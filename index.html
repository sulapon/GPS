<!doctype html><html lang="zh-Hant"><head><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"> <script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/GPS/service-worker.js')
      .then(function(reg) { console.log('âœ… Service Worker è¨»å†ŠæˆåŠŸ', reg); })
      .catch(function(err) { console.log('âŒ Service Worker è¨»å†Šå¤±æ•—', err); });
  });
}
(function () {
  const VERSION = '20241214';
  if (!location.search.includes('v=')) {
    const sep = location.search ? '&' : '?';
    location.replace(
      location.pathname +
      location.search +
      sep + 'v=' + VERSION +
      location.hash
    );
  }
})();

// ========================================
// ğŸš€ TIF æª”æ¡ˆå¿«å–ç³»çµ± - å„ªåŒ–å‰–é¢åœ–ç”Ÿæˆé€Ÿåº¦
// ========================================
let cachedTiffData = {
  github: null,      // GitHub ç·šä¸Šæª”æ¡ˆå¿«å–
  local: null,       // æœ¬åœ°ä¸Šå‚³æª”æ¡ˆå¿«å–
  url: null          // å¿«å–çš„ URL
};

// å¿«å–çš„åœ–åƒå°è±¡
let cachedImageData = {
  github: null,
  local: null
};

/**
 * ç²å–å¿«å–çš„ TIFF è³‡æ–™ (æ ¸å¿ƒå„ªåŒ–å‡½æ•¸)
 * @param {string} url - TIF æª”æ¡ˆ URL
 * @param {string} source - 'github' æˆ– 'local'  
 * @returns {Promise<{tiff, image}>}
 */
async function getCachedTiff(url, source = 'github') {
  console.log(`ğŸ” æª¢æŸ¥ TIF å¿«å– [${source}]:`, url);
  
  // å¦‚æœæœ‰å¿«å–ä¸” URL ç›¸åŒ,ç›´æ¥è¿”å›
  if (source === 'github' && cachedTiffData.github && cachedTiffData.url === url) {
    console.log('âœ… ä½¿ç”¨å¿«å–çš„ GitHub TIF è³‡æ–™ (è·³é 87MB ä¸‹è¼‰)');
    return {
      tiff: cachedTiffData.github,
      image: cachedImageData.github
    };
  }
  
  if (source === 'local' && cachedTiffData.local) {
    console.log('âœ… ä½¿ç”¨å¿«å–çš„æœ¬åœ° TIF è³‡æ–™');
    return {
      tiff: cachedTiffData.local,
      image: cachedImageData.local
    };
  }
  
  // å¦å‰‡é‡æ–°è¼‰å…¥ä¸¦å¿«å–
  console.log(`ğŸ“¥ é¦–æ¬¡è¼‰å…¥ TIF æª”æ¡ˆ,å»ºç«‹å¿«å– [${source}]...`);
  const tiff = await GeoTIFF.fromUrl(url);
  const image = await tiff.getImage();
  
  // å„²å­˜åˆ°å¿«å–
  if (source === 'github') {
    cachedTiffData.github = tiff;
    cachedImageData.github = image;
    cachedTiffData.url = url;
    console.log('ğŸ’¾ GitHub TIF å·²å¿«å–åˆ°è¨˜æ†¶é«” (ä¸‹æ¬¡ä½¿ç”¨æ™‚ç›´æ¥è®€å–)');
  } else if (source === 'local') {
    cachedTiffData.local = tiff;
    cachedImageData.local = image;
    console.log('ğŸ’¾ æœ¬åœ° TIF å·²å¿«å–åˆ°è¨˜æ†¶é«”');
  }
  
  return { tiff, image };
}

/**
 * æ¸…é™¤ TIF å¿«å–
 */
function clearTiffCache(source = 'all') {
  if (source === 'all' || source === 'github') {
    cachedTiffData.github = null;
    cachedImageData.github = null;
    cachedTiffData.url = null;
    console.log('ğŸ—‘ï¸ å·²æ¸…é™¤ GitHub TIF å¿«å–');
  }
  if (source === 'all' || source === 'local') {
    cachedTiffData.local = null;
    cachedImageData.local = null;
    console.log('ğŸ—‘ï¸ å·²æ¸…é™¤æœ¬åœ° TIF å¿«å–');
  }
}
// ========================================
// å¿«å–ç³»çµ±çµæŸ
// ========================================

let link_tx_last_unit = 'w';
function smartIncreaseSamples(baseValue) {
    const samplesInput = document.getElementById('samples');
    const currentValue = parseInt(samplesInput.value) || 0;
    if (baseValue === 100) {
        if (currentValue >= 100 && currentValue <= 900 && currentValue % 100 === 0) {
            samplesInput.value = currentValue + 100;
        } else {
            samplesInput.value = 100;
        }
    } else if (baseValue === 1000) {
        if (currentValue >= 1000 && currentValue <= 9000 && currentValue % 1000 === 0) {
            samplesInput.value = currentValue + 1000;
        } else {
            samplesInput.value = 1000;
        }
    }
}
function setMaxEffectivePoints() {
    console.log('setMaxEffectivePoints() è¢«èª¿ç”¨');
    const sLatVal = document.getElementById('sLat').value;
    const sLngVal = document.getElementById('sLng').value;
    const eLatVal = document.getElementById('eLat').value;
    const eLngVal = document.getElementById('eLng').value;
    if (!sLatVal || !sLngVal || !eLatVal || !eLngVal) {
        alert('âŒ è«‹å…ˆè¼¸å…¥Aé»å’ŒBé»åº§æ¨™');
        return;
    }
    const sLat = parseFloat(sLatVal);
    const sLng = parseFloat(sLngVal);
    const eLat = parseFloat(eLatVal);
    const eLng = parseFloat(eLngVal);
    if (isNaN(sLat) || isNaN(sLng) || isNaN(eLat) || isNaN(eLng)) {
        alert('âŒ åº§æ¨™å€¼ç„¡æ•ˆ');
        return;
    }
    const apiSelector = document.getElementById('elevationApiSelector');
    const selectedApi = apiSelector ? apiSelector.value : 'taiwan-dsm';
    let pointsPerKm;
    let apiName;
    if (selectedApi === 'taiwan-dsm') {
        pointsPerKm = 50;
        apiName = 'å…§æ”¿éƒ¨ DSM 20m';
    } else {
        pointsPerKm = 33.333333;
        apiName = 'å…¶ä»–è³‡æ–™æº';
    }
    const distance = getDistance(sLat, sLng, eLat, eLng);
    const maxEffectivePoints = Math.ceil(distance * pointsPerKm);
    document.getElementById('samples').value = maxEffectivePoints;
    const summary = document.getElementById('summary');
    summary.innerHTML = `âœ“ å·²è¨­ç½®æœ€å¤§æœ‰æ•ˆé»æ•¸ï¼š<strong>${maxEffectivePoints}</strong> é»<br>
    <span style="font-size: 12px; color: var(--muted);">è·é›¢: ${distance.toFixed(2)} km | é»å¯†åº¦: ${pointsPerKm.toFixed(2)}é»/km (${apiName})</span>`;
    summary.style.color = '#27ae60';
    summary.style.background = 'rgba(39, 174, 96, 0.1)';
    console.log('æœ€å¤§æœ‰æ•ˆé»æ•¸è¨­ç½®ç‚º:', maxEffectivePoints, '(è·é›¢:', distance.toFixed(2), 'km, é»å¯†åº¦:', pointsPerKm, 'é»/km)');
}
function swapLinkTxUnit() {
    const unitSel = document.getElementById('link_tx_power_unit');
    const input = document.getElementById('link_tx_power_input');
    const currentUnit = unitSel.value;
    const val = parseFloat(input.value);
    if (!isNaN(val) && input.value.trim() !== '') {
        const newVal = convertPower(val, link_tx_last_unit, currentUnit);
        if (!isNaN(newVal) && newVal !== Infinity && newVal !== -Infinity) {
            input.value = newVal.toFixed(3);
        }
    }
    link_tx_last_unit = currentUnit;
    calculateLinkBudget();
}
</script> <meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,minimal-ui" /><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>è¨ˆç®—å·¥å…·</title><script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.5.31/dist/jspdf.plugin.autotable.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<meta name="theme-color" content="#071026"><style> :root{ --bg-0:#050a16; --bg-1:#0b1526; --muted:#a8b3c3; --label:#85c9ff; --title:#ffe58f; --value:#5ff0d5; --accent1:#5ff0d5; --accent2:#79a8ff; --orange-border: #ffaa00; --glass: rgba(255,255,255,0.06); --shadow: 0 4px 12px rgba(0,0,0,0.40); font-size:24px; --gps-error-border: #dc3545; --rf-green-start: #36c74d; --rf-green-end: #1e8030; --rf-green-border: #1e8030; --red-clear: #dd4444; --purple-accent: #bb66ff; } *{box-sizing:border-box}
::selection {
  background-color: #5ff0d5;
  color: #000000;
}
::-moz-selection {
  background-color: #5ff0d5;
  color: #000000;
}
input::selection {
  background-color: #5ff0d5;
  color: #000000;
}
input::-moz-selection {
  background-color: #5ff0d5;
  color: #000000;
}
body{ margin:0; padding:0; background:linear-gradient(180deg,var(--bg-0),var(--bg-1)); color:#e8eef5; font-family:Inter, 'Noto Sans TC', system-ui; line-height:1.3; } header{ padding: 0 10px; background-color: var(--bg-1); border-bottom: 1px solid rgba(255,255,255,0.08); height: 0; } h1{ display: none; } main{padding:6px; max-width:880px; margin:0 auto;} .card{ background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:10px; margin-bottom:6px; box-shadow:var(--shadow); border:1px solid rgba(255,255,255,0.03); } .gps-container .card { padding: 5px 8px; } .section-title{ color:var(--title); font-size:18px; font-weight:700; margin-bottom:4px; display:block; } .rf-header { margin-bottom: 6px; } .rf-header .section-title { color: var(--title); font-size: 18px; font-weight: 700; margin-bottom: 2px; display: block; } .unit-selector-row { display: flex; align-items: center; justify-content: flex-start; gap: 8px; padding: 4px 0; margin-bottom: 2px; } .unit-selector-row .unit-label { font-size: 15px; color: var(--label); margin-bottom: 0; font-weight: 700; } .form-grid{ display:grid; grid-template-columns:1fr 1fr; gap:5px; align-items:end; } label{ color:var(--label); font-size:15px; margin-bottom:1px; display:block; } input,select{ width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15); } .input-with-clear-rf { display: flex; align-items: center; position: relative; } .input-with-clear-rf input { flex-grow: 1; padding-right: 35px; } .clear-btn-rf { position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--red-clear); font-size: 18px; cursor: pointer; padding: 0 8px; line-height: 1; font-weight: bold; opacity: 0.8; z-index: 10; height: 100%; display: flex; align-items: center; } #unit, #displayMode { border: 1px solid var(--purple-accent) !important; color: var(--purple-accent) !important; background-color: rgba(187, 102, 255, 0.08) !important; width: auto !important; max-width: 120px !important; padding: 3px 6px !important; font-size: 15px !important; flex-shrink: 0; } .gps-container input[type="number"], .gps-container input[type="text"] { padding: 3px 5px; font-size: 14px; border: 1px solid rgba(255,255,255,0.2); } .controls{ margin-top:2px; display:flex; gap:5px; } .btn{ background:linear-gradient(90deg,var(--accent1),var(--accent2)); border:0; padding:8px 12px; border-radius:6px; font-weight:700; font-size:16px; color:#022; cursor:pointer; } .btn.ghost{ border:1px solid var(--accent2); background:transparent; color:#e8eef5; } .btn.clear{ background:var(--red-clear); color:white; border-radius:6px; } #rf-content + .btn-row .btn { background: linear-gradient(90deg, var(--rf-green-start), var(--rf-green-end)); color: #022; border: none; } #rf-content + .btn-row .btn.ghost { background: transparent; border: 1px solid var(--rf-green-border); color: #e8eef5; } #rf-content + .btn-row .btn.clear { background: var(--red-clear); color: white; border: none; } .btn-row{ display:flex; flex-wrap:nowrap; justify-content:stretch; align-items:center; gap:12px; width:100%; box-sizing:border-box; } .btn-row .btn{ flex:1 1 0%; text-align:center; white-space:nowrap; min-width:0; } #liveInputs{ margin-top:3px; font-size:14px; color:var(--muted); } table{ width:100%; border-collapse:collapse; margin-top:6px; font-size:16px; } thead th{ color:var(--label); padding:3px 3px; border-bottom:1px solid rgba(255,255,255,0.06); text-align:center; } tbody td{ padding:4px 3px; border-bottom:1px solid rgba(255,255,255,0.03); text-align:center; } .name{ color:#ffd369; font-weight:700; white-space:nowrap; } th:first-child, td:first-child{ width:32%; text-align:left; } .value, .percent{ color:var(--value); font-weight:800; font-variant-numeric:tabular-nums; } .small-note{ font-size:13px; margin-top:3px; color:var(--muted); } @media (max-width:640px){ .form-grid{grid-template-columns:1fr;} } .tabs{ display:flex; margin-bottom: 6px; overflow-x: auto; border-bottom: 1px solid rgba(255,255,255,0.06); } .tab-button{ flex-shrink: 0; padding: 6px 10px; margin: 0 2px; background: transparent; border: 0; color: var(--muted); font-size: 18px; cursor: pointer; font-weight: 600; border-radius: 8px 8px 0 0; transition: all 0.2s ease; } .tab-button.active{ background: var(--glass); color: var(--title); border-bottom: 2px solid var(--accent1); } .tab-content{ display: none; padding-top: 5px; } .tab-content.active{ display: block; } .gps-container { padding: 0; } .gps-tip { color: var(--label) !important; font-size: 13px !important; margin: 0 0 2px 0 !important; } .display-mode-container { margin-top: 3px; } .gps-ig { margin-bottom: 2px !important; padding: 3px 7px !important; border: 1px solid rgba(255,255,255,0.05); border-radius: 8px; background-color: rgba(255,255,255,0.02); } .gps-loc-header { margin-bottom: 2px !important; font-weight: bold; color: var(--title); font-size: 17px; display: flex; align-items: center; justify-content: space-between; } .gps-loc-header > div { display: flex; align-items: center; gap: 5px; } #nameA, #nameB { width: 144px !important; max-width: 144px !important; font-size: 14px !important; text-align: center; flex-shrink: 0; padding: 4px 6px !important; } .gps-loc-header span { color: var(--muted); font-size: 13px; flex-shrink: 0; } .gps-cg { padding: 2px !important; margin-bottom: 2px !important; border: 1px solid rgba(255,255,255,0.05); border-radius: 6px; } .gps-cl { font-weight: bold; color: var(--label); display: block; margin-bottom: 1px; font-size: 14px !important; } .gps-ddr { display: flex; align-items: center; margin-bottom: 0 !important; } .gps-ddr input { flex-grow: 1; text-align: right; padding: 4px 8px !important; font-size: 16px !important; } .gps-ddr span { color: var(--muted); font-size: 14px !important; margin-right: 4px; flex-shrink: 0; } .gps-dmsr { display: flex; align-items: center; justify-content: space-between; gap: 4px; margin-bottom: 0 !important; } .gps-dmsr input { padding: 4px 8px !important; font-size: 16px !important; } .gps-dmsf { display: flex; align-items: center; flex: 1; min-width: 0; } .gps-dmsf input { text-align: center; margin-right: 3px; max-width: none; flex-grow: 1; min-width: 30px; } .gps-dmsf:nth-child(1) input { flex: 2; } .gps-dmsf:nth-child(2) input { flex: 1.5; } .gps-dmsf:nth-child(3) input { flex: 2.5; } .gps-dmsr span { color: var(--muted); font-size: 14px !important; margin-right: 0; flex-shrink: 0; } .gps-er { display: flex; align-items: center; justify-content: flex-start; gap: 5px; margin-top: 2px !important; padding-top: 2px !important; border-top: 1px dashed rgba(255,255,255,0.08); flex-wrap: nowrap !important; } .gps-er label { font-size: 15px !important; flex-shrink: 0; color: var(--label); width: 120px; margin-right: 8px; } .gps-er input { text-align: right; flex-grow: 1.2 !important; padding: 4px 8px !important; font-size: 16px !important; min-width: 60px !important; max-width: 100px !important; } .gps-er > .control-group { display: flex; align-items: center; flex-shrink: 0; min-width: 0; margin-left: auto !important; } .gps-er .control-group span { font-size: 14px !important; flex-shrink: 0; color: var(--muted); margin-left: 4px; } .gps-cb { background: none; border: none; color: #ff6347; font-size: 18px; cursor: pointer; padding: 0 5px; line-height: 1; font-weight: bold; opacity: 0.9; margin: 0; flex-shrink: 0; } .gps-ddr .gps-cb { margin-left: auto; } .gps-er .control-group .gps-cb { margin-left: 5px !important; } #gpsRes { margin-top: 5px !important; padding: 8px !important; border: 2px solid var(--accent2); border-radius: 8px; background-color: rgba(121, 168, 255, 0.05); font-size: 16px !important; font-weight: 500; text-align: left; color: #e8eef5; } #gpsRes p { margin: 4px 0 !important; } .gps-label-title { color: var(--title); font-weight: 700; margin-right: 5px; } .v-dist, .v-bearing, .v-pitch-value { font-weight: 900 !important; font-size: 1.1em; color: var(--value) !important; } .display-mode-container { display: flex; align-items: center; justify-content: flex-start; gap: 8px; margin-top: 3px; } #displayMode { width: auto !important; max-width: 170px; flex-shrink: 0; } .display-mode-container label { display: none; } .display-mode-text { font-weight: 700; color: var(--label); font-size: 14px; flex-shrink: 0; } .results-card-border { border: 2px solid var(--accent2) !important; border-radius: 8px !important; background-color: rgba(121, 168, 255, 0.05) !important; } .orange-border-card { border: 2px solid var(--orange-border) !important; border-radius: 8px !important; background-color: rgba(255, 170, 0, 0.05) !important; }
@keyframes blink-dots {
    0%, 20% { content: ''; }
    40% { content: '.'; }
    60% { content: '..'; }
    80%, 100% { content: '...'; }
}
.loading-dots {
    color: #ffd43b !important;
    font-weight: bold;
    display: inline-block;
}
.loading-dots::after {
    content: '';
    animation: blink-dots 1.5s steps(4, end) infinite;
}
.chart-fullscreen-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #050a16;
    z-index: 9999;
    padding: 0;
    box-sizing: border-box;
}
.chart-fullscreen-overlay.active {
    display: block;
}
.chart-fullscreen-container {
    width: 100%;
    height: 100%;
    position: relative;
    background: #050a16;
    padding: 0;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
}
.chart-fullscreen-canvas-wrapper {
    width: 100%;
    height: 100%;
    position: relative;
    display: flex;
    align-items: stretch;
    justify-content: center;
    padding: 10px 10px 10px 10px;
    box-sizing: border-box;
}
.chart-fullscreen-container canvas {
    width: 100% !important;
    height: 100% !important;
}
.chart-fullscreen-close {
    position: absolute;
    top: 10px;
    right: 15px;
    width: 32px;
    height: 32px;
    background: rgba(220, 53, 69, 0.7);
    color: rgba(255, 255, 255, 0.9);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
    padding: 0;
    line-height: 1;
    transition: all 0.2s ease;
}
.chart-fullscreen-close:hover {
    background: rgba(220, 53, 69, 0.95);
    color: rgba(255, 255, 255, 1);
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(220, 53, 69, 0.6);
}
.chart-fullscreen-close:active {
    background: rgba(220, 53, 69, 1);
    transform: scale(0.9);
}
.chart-fullscreen-screenshot {
    position: absolute;
    top: 10px;
    right: 95px;
    width: 32px;
    height: 32px;
    background: rgba(76, 175, 80, 0.85);
    color: rgba(255, 255, 255, 0.95);
    border: 2px solid rgba(129, 199, 132, 0.8);
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    padding: 0;
    line-height: 1;
    transition: all 0.2s ease;
}
.chart-fullscreen-screenshot:hover {
    background: rgba(76, 175, 80, 0.95);
    color: rgba(255, 255, 255, 1);
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(76, 175, 80, 0.6);
}
.chart-fullscreen-screenshot:active {
    background: rgba(76, 175, 80, 1);
    transform: scale(0.9);
}
.chart-fullscreen-info-toggle {
    position: absolute;
    top: 10px;
    right: 135px;
    width: 32px;
    height: 32px;
    background: rgba(13, 71, 161, 0.85);
    color: rgba(255, 255, 255, 0.95);
    border: 2px solid rgba(77, 171, 247, 0.8);
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    padding: 0;
    line-height: 1;
    transition: all 0.2s ease;
}
.chart-fullscreen-info-toggle:hover {
    background: rgba(13, 71, 161, 0.95);
    color: rgba(255, 255, 255, 1);
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(77, 171, 247, 0.6);
}
.chart-fullscreen-info-toggle:active {
    background: rgba(13, 71, 161, 1);
    transform: scale(0.9);
}
.chart-fullscreen-info-toggle.disabled {
    background: rgba(100, 100, 100, 0.85);
    border-color: rgba(150, 150, 150, 0.8);
}
.chart-fullscreen-obstruction-toggle {
    position: absolute;
    top: 10px;
    right: 175px;
    width: 32px;
    height: 32px;
    background: rgba(255, 68, 68, 0.85);
    color: rgba(255, 255, 255, 0.95);
    border: 2px solid rgba(255, 100, 100, 0.8);
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    padding: 0;
    line-height: 1;
    transition: all 0.2s ease;
}
.chart-fullscreen-obstruction-toggle:hover {
    background: rgba(255, 68, 68, 0.95);
    color: rgba(255, 255, 255, 1);
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(255, 100, 100, 0.6);
}
.chart-fullscreen-obstruction-toggle:active {
    background: rgba(255, 68, 68, 1);
    transform: scale(0.9);
}
.chart-fullscreen-obstruction-toggle.disabled {
    background: rgba(100, 100, 100, 0.85);
    border-color: rgba(150, 150, 150, 0.8);
}
.chart-fullscreen-map-toggle {
    position: absolute;
    top: 10px;
    right: 215px;
    width: 32px;
    height: 32px;
    background: rgba(79, 171, 247, 0.85);
    color: rgba(255, 255, 255, 0.95);
    border: 2px solid rgba(79, 171, 247, 0.8);
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    padding: 0;
    line-height: 1;
    transition: all 0.2s ease;
}
.chart-fullscreen-map-toggle:hover {
    background: rgba(79, 171, 247, 0.95);
    color: rgba(255, 255, 255, 1);
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(79, 171, 247, 0.6);
}
.chart-fullscreen-map-toggle:active {
    background: rgba(79, 171, 247, 1);
    transform: scale(0.9);
}
.chart-fullscreen-map-toggle.disabled {
    background: rgba(100, 100, 100, 0.85);
    border-color: rgba(150, 150, 150, 0.8);
    cursor: not-allowed;
    opacity: 0.5;
}
.chart-fullscreen-rotate-toggle {
    position: absolute;
    top: 10px;
    right: 55px;
    width: 32px;
    height: 32px;
    background: rgba(255, 152, 0, 0.85);
    color: rgba(255, 255, 255, 0.95);
    border: 2px solid rgba(255, 167, 38, 0.8);
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    padding: 0;
    line-height: 1;
    transition: all 0.2s ease;
}
.chart-fullscreen-max-obstruction {
    position: absolute;
    top: 10px;
    right: 295px;
    width: 32px;
    height: 32px;
    padding: 0;
    background: linear-gradient(135deg, #ff4444, #cc0000);
    color: rgba(255, 255, 255, 0.95);
    border: 2px solid rgba(255, 100, 100, 0.8);
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    font-weight: normal;
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    line-height: 1;
    transition: all 0.2s ease;
}
.chart-fullscreen-max-obstruction:hover {
    background: linear-gradient(135deg, #ff5555, #dd0000);
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(255, 68, 68, 0.6);
}
.chart-fullscreen-max-obstruction:active {
    background: linear-gradient(135deg, #ff3333, #bb0000);
    transform: scale(0.95);
}
.chart-fullscreen-start-obstruction {
    position: absolute;
    top: 10px;
    right: 255px;
    width: 32px;
    height: 32px;
    padding: 0;
    background: linear-gradient(135deg, #ff69b4, #ff1493);
    color: rgba(255, 255, 255, 0.95);
    border: 2px solid rgba(255, 105, 180, 0.8);
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    font-weight: normal;
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    line-height: 1;
    transition: all 0.2s ease;
}
.chart-fullscreen-start-obstruction:hover {
    background: linear-gradient(135deg, #ff7ac4, #ff2aa3);
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(255, 105, 180, 0.6);
}
.chart-fullscreen-start-obstruction:active {
    background: linear-gradient(135deg, #ff58a4, #ff0083);
    transform: scale(0.95);
}
.chart-fullscreen-end-obstruction {
    position: absolute;
    top: 10px;
    right: 335px;
    width: 32px;
    height: 32px;
    padding: 0;
    background: linear-gradient(135deg, #ff69b4, #ff1493);
    color: rgba(255, 255, 255, 0.95);
    border: 2px solid rgba(255, 105, 180, 0.8);
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    font-weight: normal;
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    line-height: 1;
    transition: all 0.2s ease;
}
.chart-fullscreen-end-obstruction:hover {
    background: linear-gradient(135deg, #ff7ac4, #ff2aa3);
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(255, 105, 180, 0.6);
}
.chart-fullscreen-end-obstruction:active {
    background: linear-gradient(135deg, #ff58a4, #ff0083);
    transform: scale(0.95);
}
.chart-fullscreen-point-control {
    position: absolute;
    top: 10px;
    left: calc(48% - 29px);
    transform: translateX(-50%);
    display: flex;
    gap: 6px;
    align-items: center;
    background: rgba(5, 10, 22, 0.7);
    border-radius: 8px;
    padding: 3px 8px;
    z-index: 10002;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}
    font-weight: bold;
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    padding: 0;
    line-height: 1;
    transition: all 0.2s ease;
}
.chart-fullscreen-rotate-toggle:hover {
    background: rgba(255, 152, 0, 0.95);
    color: rgba(255, 255, 255, 1);
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(255, 152, 0, 0.6);
}
.chart-fullscreen-rotate-toggle:active {
    background: rgba(255, 152, 0, 1);
    transform: scale(0.9);
}
.chart-zoom-btn {
    position: absolute;
    bottom: 8px;
    left: 8px;
    width: 32px;
    height: 32px;
    background: rgba(79, 168, 255, 0.6);
    border: 2px solid rgba(95, 240, 213, 0.6);
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.8);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    z-index: 10;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}
.chart-zoom-btn:hover {
    background: rgba(95, 240, 213, 0.8);
    border-color: rgba(95, 240, 213, 0.9);
    color: rgba(255, 255, 255, 1);
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(95, 240, 213, 0.4);
}
.chart-zoom-btn:active {
    transform: scale(0.95);
}
.chart-zoom-btn svg {
    width: 14px;
    height: 14px;
    opacity: 0.85;
    filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
}
</style><link rel="manifest" href="manifest.json"><meta name="theme-color" content="#0a4cff">
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/Gps-Cable-Loss-Calculator/service-worker.js');
}
</script> <style> :root{ --bg-0:#050a16; --bg-1:#0b1526; --muted:#a8b3c3; --label:#85c9ff; --title:#ffe58f; --value:#5ff0d5; --accent1:#5ff0d5; --accent2:#79a8ff; --orange-border: #ffaa00; --red-clear: #dd4444; --purple-accent: #bb66ff; --glass: rgba(255,255,255,0.06); --shadow: 0 4px 12px rgba(0,0,0,0.40); font-size:22px; } *{box-sizing:border-box} body{ margin:0; padding:0; background:linear-gradient(180deg,var(--bg-0),var(--bg-1)); color:#e8eef5; font-family:Inter, 'Noto Sans TC', system-ui; line-height:1.3; } header{ padding: 0 10px; background-color: var(--bg-1); border-bottom: 1px solid rgba(255,255,255,0.08); height: 0; } h1{ display: none; } main{padding:6px; max-width:880px; margin:0 auto;} .card{ background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:10px; margin-bottom:6px; box-shadow:var(--shadow); border:1px solid rgba(255,255,255,0.03); } .section-header-with-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; } .section-header-with-controls .section-title { margin-bottom: 0; } .section-header-with-controls .btn-group { display: flex; gap: 5px; flex-shrink: 0; } .btn{ padding: 5px 8px; border-radius: 6px; font-weight: 700; font-size: 16px; color: #022; cursor: pointer; border: none; background: linear-gradient(90deg,var(--accent1),var(--accent2)); } .section-header-with-controls .btn { padding: 3px 6px; font-size: 14px; border-radius: 4px; white-space: nowrap; } .btn-reset { border: 1px solid var(--accent2); background: transparent; color: #e8eef5; } .btn-clear { background: var(--red-clear); color: white; border: none; } .section-title{ color:var(--title); font-size:17px; font-weight:700; margin-bottom:4px; display:block; } .rf-header { margin-bottom: 6px; } .los-point-title { color: var(--title); font-size: 1.1em; font-weight: 700; margin-top: 10px; margin-bottom: 5px; border-bottom: 1px dashed rgba(255,255,255,0.08); padding-bottom: 3px; } label{ color:var(--label); font-size:17px; margin-bottom:1px; display:block; } input,select{ width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15); } .input-with-clear { display: flex; align-items: center; gap: 5px; margin-bottom: 5px; } .input-with-clear input { flex-grow: 1; width: auto; } .clear-button { background: transparent; border: none; color: var(--red-clear); font-size:22px; font-weight: bold; cursor: pointer; padding: 5px 0; line-height: 1; width: 30px; flex-shrink: 0; border-radius: 4px; transition: background-color 0.2s; } .clear-button:hover { background-color: rgba(221, 68, 68, 0.2); } #power_unit, #matching_unit, #link_tx_power_unit { border: 1px solid var(--purple-accent) !important; color: var(--purple-accent) !important; background-color: rgba(187, 102, 255, 0.08) !important; width: 100% !important; max-width: none !important; padding: 5px 8px !important; font-size: 17px !important; flex-shrink: 0; } #power_unit, #link_tx_power_unit { margin-bottom: 8px; } .input-group-border { border: 2px solid var(--orange-border) !important; border-radius: 8px !important; background-color: rgba(255, 170, 0, 0.05) !important; padding: 10px 12px; margin-bottom: 8px; margin-top: 5px; } .input-group-border > :first-child { margin-top: 0 !important; } .input-group-border .input-with-clear { margin-bottom: 8px; } .input-group-border .input-with-clear:last-child { margin-bottom: 0; } .input-group-border .los-point-title { margin-top: 8px; } .input-group-border .los-point-title:first-child { margin-top: 0 !important; margin-bottom: 5px; } .los-input-container { display: block; gap: 0; margin-bottom: 0 !important; } .los-input-container .input-item { width: 100%; flex: none; min-width: auto; box-sizing: border-box; padding-bottom: 8px; border-bottom: 1px dotted rgba(255,255,255,0.05); margin-bottom: 8px; } .los-input-container .input-item:last-child { padding-bottom: 0; border-bottom: none; margin-bottom: 0; } .results-card-border { border: 2px solid var(--accent2) !important; border-radius: 8px !important; background-color: rgba(121, 168, 255, 0.05) !important; padding: 10px 12px; margin-top: 8px !important; } .result-value { color: var(--value); font-weight: 900; font-size: 1.1em; } .result-value-small { font-size: 1em !important; } .function-selector-container { margin-bottom: 10px; padding: 6px 8px; background: rgba(255,255,255,0.02); border-radius: 10px; box-shadow: var(--shadow); border: 1px solid rgba(255,255,255,0.03); } #function_selector { border: 1px solid var(--accent1) !important; color: var(--accent1) !important; background-color: rgba(95, 240, 213, 0.08) !important; font-weight: 700; font-size: 18px; margin-top: 4px; }
</style>
<style>
html, body {
  background-color: #050a16 !important;
  color-scheme: dark;
}
select {
  background-color: #2b2b2b !important;
  color: #e8eef5 !important;
  border: 1px solid #555 !important;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
}
select option {
  background-color: #3a3a3a !important;
  color: #ffffff !important;
}
select:focus {
  outline: none;
  border-color: #888 !important;
}
select::-ms-expand {
  display: none;
}
</style>
<style>
.gps-ig {
  padding: 6px 8px !important;
  box-sizing: border-box !important;
}
.gps-ig .gps-cg,
.gps-ig .gps-er {
  margin-bottom: 4px !important;
}
.gps-ig .gps-er:last-child {
  margin-bottom: 0 !important;
}
#gps-content .gps-ig {
  width: 100% !important;
  min-width: 100% !important;
}
.gps-loc-header {
  padding-bottom: 2px !important;
}
</style>
<style>
.gps-ig,
.gps-ig.orange-border-card,
div.gps-ig,
div.gps-ig.orange-border-card,
#gps-content .gps-ig,
#gps-content .gps-ig.orange-border-card,
#gps-content div.gps-ig,
#gps-content div.gps-ig.orange-border-card {
  padding: 10px 12px !important;
  padding-top: 10px !important;
  padding-bottom: 10px !important;
  padding-left: 12px !important;
  padding-right: 12px !important;
}
</style>
</head><body><div id="splash-screen"><div class="splash-content"><img src="1.png" alt="splash"><div class="splash-text">é˜¿è‰¯è£½_1141212</div></div></div><style> #splash-screen{
  position:fixed;
  inset:0;
  background:#000;
  display:flex;
  justify-content:center;
  align-items:center;
  z-index:99999;
}
.splash-content{
  position:absolute;
  inset:0;
}
#splash-screen img{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  width:auto;
  max-width:90vw;
  max-height:90vh;
}
.splash-text{
  position:absolute;
  right:16px;
  bottom:16px;
  font-size:14px;
  color:#fff;
  font-weight:700;
  letter-spacing:1px;
  opacity:.9;
}
#gps-controls-container {
    display: block !important;
}
.tab-content:not(.active) #gps-controls-container {
    display: none !important;
}
.tab-content.active #gps-controls-container {
    display: block !important;
}
.tab-content:not(.active) #gpsCalcBtn {
    display: none !important;
    visibility: hidden !important;
}
.tab-content:not(.active) #gpsResetBtn {
    display: none !important;
    visibility: hidden !important;
}
.tab-content:not(.active) #gpsClearBtn {
    display: none !important;
    visibility: hidden !important;
}
.tab-content:not(.active) .btn-row:has(#gpsCalcBtn) {
    display: none !important;
    visibility: hidden !important;
}
.tab-content.active #gpsCalcBtn {
    display: inline-block !important;
    visibility: visible !important;
    flex: 2.5 1 0% !important;
}
.tab-content.active #gpsResetBtn {
    display: inline-block !important;
    visibility: visible !important;
    flex: 2.5 1 0% !important;
}
.tab-content.active #gpsClearBtn {
    display: inline-block !important;
    visibility: visible !important;
    flex: 2.5 1 0% !important;
}
.tab-content.active .btn-row:has(#gpsCalcBtn) {
    display: block !important;
    visibility: visible !important;
}
.tab-content.active #gpsRes {
    display: block !important;
    visibility: visible !important;
}
.tab-content:not(.active) #gpsRes {
    display: none !important;
    visibility: hidden !important;
}
</style> <script>
  setTimeout(() => {
    const splash = document.getElementById("splash-screen");
    splash.style.opacity = "0";
    splash.style.transition = "0.4s";
    setTimeout(() => splash.remove(), 400);
  }, 500);
</script> <header></header><main><div class="tabs"><button class="tab-button active" data-tab="rftool" onclick="showTab('rftool')">ğŸ“¡ RFå·¥å…·</button><button class="tab-button" data-tab="rf" onclick="showTab('rf')">ã€°ï¸ ç·šæ</button><button class="tab-button" data-tab="gps" onclick="showTab('gps')">ğŸŒ GPS</button><button class="tab-button" data-tab="elevation" onclick="showTab('elevation')">ğŸ“ˆ é«˜åº¦åœ–</button><button class="tab-button" data-tab="report" onclick="showTab('report')">ğŸ“„ å ±å‘Š</button><button class="tab-button" data-tab="compass" onclick="showTab('compass')">ğŸ§­ æŒ‡åŒ—é‡</button><button class="tab-button" data-tab="archive" onclick="showTab('archive')">ğŸ’¾ å­˜æª”</button></div><div id="rf-content" class="tab-content"><div class="rf-header"><div class="section-title">TIMES ç·šæè¨ˆç®—</div><div class="unit-selector-row"><label for="unit" class="unit-label">é•·åº¦å–®ä½ï¼š</label><select id="unit"><option value="m">å…¬å°º (m)</option><option value="ft">è‹±å°º (ft)</option></select></div></div><section class="card orange-border-card" style="margin-top: 6px;"><div class="form-grid"><div><label for="freq">é »ç‡ (MHz)</label><div class="input-with-clear-rf"><input id="freq" type="number" value="900" min="0" step="1"><button class="clear-btn-rf" onclick="clearRfInput('freq')">âœ–</button></div></div><div><label for="lenInput">é•·åº¦</label><div class="input-with-clear-rf"><input id="lenInput" type="number" value="10" min="0" step="0.01"><button class="clear-btn-rf" onclick="clearRfInput('lenInput')">âœ–</button></div></div></div><div id="liveInputs" class="small-note">è¼¸å…¥ä¸¦æŒ‰ã€Œè¨ˆç®—ã€æŸ¥çœ‹çµæœã€‚</div></section><div class="btn-row" style="margin-top: 6px; margin-bottom: 6px;"><button id="calc" class="btn" onclick="compute()">è¨ˆç®—</button><button id="reset" class="btn ghost" onclick="resetRf()">é è¨­</button><button id="clear" class="btn clear" onclick="clearRf()">æ¸…é™¤</button></div><section class="card results-card-border"><span class="section-title">è¨ˆç®—çµæœï¼ˆç”±å°åˆ°å¤§ï¼‰</span><div id="tableArea"></div></section></div><div id="gps-content" class="tab-content gps-container"><div class="card"><h2 class="section-title" style="margin-top: 0;">å…©é»GPS è·é›¢ã€æ–¹ä½è§’èˆ‡ä¿¯ä»°è§’è¨ˆç®—</h2><p class="gps-tip">è€ƒæ…®åœ°çƒæ›²ç‡èˆ‡é«˜åº¦å·® (WGS84)</p><div class="display-mode-container"><span class="display-mode-text">é¡¯ç¤ºæ ¼å¼</span><select id="displayMode" style="padding:6px;border-radius:6px;font-size:14px;"><option value="decimal">åº¦ â€” åé€²åˆ¶ (DD)</option><option value="dms">åº¦åˆ†ç§’ (DMS)</option></select></div></div><div class="gps-ig orange-border-card"><div class="gps-loc-header"> åœ°é» A <div style="display: flex; align-items: center; gap: 5px; flex: 1;"><input type="text" id="nameA" placeholder="åœ°å A" maxlength="5" style="flex: 1;"><span>(åœ°å)</span><button class="gps-cb" onclick="clearNameOnly('A')">âœ–</button><button class="btn" style="background: linear-gradient(90deg, #ff9500, #ffcc00); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:16px; color:#000; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink: 0; display: flex; align-items: center; justify-content: center; text-align: center; min-width: fit-content;" onclick="getCurrentLocation('A')" title="è®€å–ç•¶å‰GPSä½ç½®">ğŸ“</button><button class="btn" style="background: linear-gradient(90deg, #5fb3ff, #3d8eff); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:16px; color:#fff; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink: 0; display: flex; align-items: center; justify-content: center; text-align: center; min-width: fit-content;" onclick="openMapPicker('A')" title="å¾åœ°åœ–é¸æ“‡åº§æ¨™">ğŸ—ºï¸</button></div></div><div class="gps-cg"><span class="gps-cl">ç·¯åº¦ (Latitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="latA" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('latA')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="latA_deg" placeholder="åº¦" oninput="dmsToD('latA')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="latA_min" placeholder="åˆ†" oninput="dmsToD('latA')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="latA_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('latA')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('latA')">âœ–</button></div></div><div class="gps-cg"><span class="gps-cl">ç¶“åº¦ (Longitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="lonA" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('lonA')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="lonA_deg" placeholder="åº¦" oninput="dmsToD('lonA')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="lonA_min" placeholder="åˆ†" oninput="dmsToD('lonA')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="lonA_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('lonA')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('lonA')">âœ–</button></div></div><div class="gps-er"><label for="eleA">é«˜åº¦ (Elevation)</label><div style="position: relative; flex-grow: 1.2;"><input type="number" id="eleA" placeholder="è«‹è¼¸å…¥æ•¸å€¼" step="0.01"><span id="eleA-loading" style="position: absolute; top: 50%; left: 0; transform: translateY(-50%); color: #ffd43b; font-weight: bold; display: none; pointer-events: none; padding: 4px 8px;"></span></div><div class="control-group"><span>å…¬å°º (m)</span><button class="gps-cb" onclick="clearElevation('A')">âœ–</button><button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 6px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink: 0; display: flex; align-items: center; justify-content: center; text-align: center; min-width: fit-content;" onclick="getElevationFromSRTM('A')">å–å¾—é«˜åº¦</button></div></div></div><div class="gps-ig orange-border-card"><div class="gps-loc-header"> åœ°é» B <div style="display: flex; align-items: center; gap: 5px; flex: 1;"><input type="text" id="nameB" placeholder="åœ°å B" maxlength="5" style="flex: 1;"><span>(åœ°å)</span><button class="gps-cb" onclick="clearNameOnly('B')">âœ–</button><button class="btn" style="background: linear-gradient(90deg, #ff9500, #ffcc00); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:16px; color:#000; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink: 0; display: flex; align-items: center; justify-content: center; text-align: center; min-width: fit-content;" onclick="getCurrentLocation('B')" title="è®€å–ç•¶å‰GPSä½ç½®">ğŸ“</button><button class="btn" style="background: linear-gradient(90deg, #5fb3ff, #3d8eff); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:16px; color:#fff; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink: 0; display: flex; align-items: center; justify-content: center; text-align: center; min-width: fit-content;" onclick="openMapPicker('B')" title="å¾åœ°åœ–é¸æ“‡åº§æ¨™">ğŸ—ºï¸</button></div></div><div class="gps-cg"><span class="gps-cl">ç·¯åº¦ (Latitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="latB" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('latB')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="latB_deg" placeholder="åº¦" oninput="dmsToD('latB')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="latB_min" placeholder="åˆ†" oninput="dmsToD('latB')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="latB_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('latB')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('latB')">âœ–</button></div></div><div class="gps-cg"><span class="gps-cl">ç¶“åº¦ (Longitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="lonB" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('lonB')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="lonB_deg" placeholder="åº¦" oninput="dmsToD('lonB')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="lonB_min" placeholder="åˆ†" oninput="dmsToD('lonB')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="lonB_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('lonB')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('lonB')">âœ–</button></div></div><div class="gps-er"><label for="eleB">é«˜åº¦ (Elevation)</label><div style="position: relative; flex-grow: 1.2;"><input type="number" id="eleB" placeholder="è«‹è¼¸å…¥æ•¸å€¼" step="0.01"><span id="eleB-loading" style="position: absolute; top: 50%; left: 0; transform: translateY(-50%); color: #ffd43b; font-weight: bold; display: none; pointer-events: none; padding: 4px 8px;"></span></div><div class="control-group"><span>å…¬å°º (m)</span><button class="gps-cb" onclick="clearElevation('B')">âœ–</button><button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 6px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink: 0; display: flex; align-items: center; justify-content: center; text-align: center; min-width: fit-content;" onclick="getElevationFromSRTM('B')">å–å¾—é«˜åº¦</button></div></div></div><div id="gps-controls-container"><div class="btn-row" style="margin-top: 5px; margin-bottom: 5px; gap: 12px; display: flex !important; width: 100% !important; justify-content: space-between !important;"><button id="gpsCalcBtn" class="btn" style="flex: 1 1 0% !important; min-width: 0 !important; width: 25% !important; box-sizing: border-box !important;" onclick="calculate()">è¨ˆç®—</button><button id="gpsSwapBtn" class="btn" style="flex: 1 1 0% !important; min-width: 0 !important; width: 25% !important; box-sizing: border-box !important; background: linear-gradient(90deg, #bb66ff, #9945ff) !important; color: #fff !important;" onclick="swapGpsCoordinates()">äº’æ›Aâ†”B</button><button id="gpsResetBtn" class="btn ghost" style="flex: 1 1 0% !important; min-width: 0 !important; width: 25% !important; box-sizing: border-box !important;" onclick="resetGps()">é è¨­</button><button id="gpsClearBtn" class="btn clear" style="flex: 1 1 0% !important; min-width: 0 !important; width: 25% !important; box-sizing: border-box !important;" onclick="clearAllGps()">æ¸…é™¤</button></div><div id="gpsRes"> é»æ“Šã€Œè¨ˆç®—ã€ä»¥é¡¯ç¤ºçµæœ </div></div></div><header></header><div class="tab-content active" id="rftool-content"><div class="rf-header"><div class="section-title">ğŸš€ ç¶œåˆ RFå·¥å…·</div></div><div class="function-selector-container"><label for="function_selector">é¸æ“‡é¡¯ç¤ºåŠŸèƒ½æ¨¡çµ„:</label><select id="function_selector" onchange="toggleSections()"><option value="ALL">ALL - é¡¯ç¤ºæ‰€æœ‰è¨ˆç®—å™¨</option><option value="power">1. åŠŸç‡è½‰æ› (dBm / W)</option><option value="matching">2. åŒ¹é…åº¦åƒæ•¸æ›ç®—</option><option value="sensitivity">3. ç³»çµ±éˆæ•åº¦ (Sensitivity) è¨ˆç®—</option><option value="los">4. é€šè¦–æœ€å¤§è·é›¢è¨ˆç®—</option><option value="fspl">5. è‡ªç”±ç©ºé–“æè€— (FSPL)</option><option value="linkbudget">6. é€šè¨Šæ¨¡æ“¬ (Link Budget)</option></select></div><section class="card section-item" id="section-power"><div class="section-header-with-controls"><div class="section-title">1. åŠŸç‡è½‰æ› (dBm / W)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-power')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-power')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="power_unit">é¸æ“‡è¼¸å…¥å–®ä½:</label><select id="power_unit" onchange="swapAndCalculate()"><option value="w">W</option><option value="dbm">dBm</option></select><label for="power_input">è¼¸å…¥æ•¸å€¼:</label><div class="input-with-clear"><input id="power_input" oninput="calculateDbmWNew()" placeholder="è¼¸å…¥æ•¸å€¼" type="number" value="1"/><button class="clear-button" onclick="clearAndRecalculate('power_input', 'calculateDbmWNew')">Ã—</button></div></div><div class="results-card-border" id="power_output_result">æ›ç®—çµæœ:</div></section><section class="card section-item" id="section-matching"><div class="section-header-with-controls"><div class="section-title">2. åŒ¹é…åº¦åƒæ•¸æ›ç®—</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-matching')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-matching')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="matching_unit">é¸æ“‡è¼¸å…¥åƒæ•¸:</label><select id="matching_unit" onchange="swapAndConvertMatching()"><option value="rl">å›æ³¢æè€— (Return Loss, RL) [dB]</option><option value="vswr">é§æ³¢æ¯” (VSWR)</option><option value="gamma">åå°„ä¿‚æ•¸ (V, Î“)</option><option value="refl_pct">åå°„åŠŸç‡ [%]</option><option value="pass_pct">é€šéåŠŸç‡ [%]</option></select><label for="matching_input_value" style="margin-top: 8px;">è¼¸å…¥æ•¸å€¼:</label><div class="input-with-clear"><input id="matching_input_value" oninput="calculateMatching()" placeholder="ä¾‹å¦‚: 20" type="number" value="20"/><button class="clear-button" onclick="clearAndRecalculate('matching_input_value', 'calculateMatching')">Ã—</button></div></div><div class="results-card-border" id="matching_output"> å›æ³¢æè€— (RL) [dB]: <span class="result-value" id="rl_val"></span><br/> é§æ³¢æ¯” (VSWR): <span class="result-value" id="vswr_val"></span><br/> åå°„ä¿‚æ•¸ (Vï¼ŒÎ“): <span class="result-value" id="gamma_val"></span><br/> åå°„åŠŸç‡ [%]: <span class="result-value" id="refl_percent"></span><br/> é€šéåŠŸç‡ [%]: <span class="result-value" id="pass_percent"></span></div></section><section class="card section-item" id="section-sensitivity"><div class="section-header-with-controls"><div class="section-title">3. ç³»çµ±éˆæ•åº¦ (Sensitivity) è¨ˆç®—</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-sensitivity')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-sensitivity')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="sensitivity_bw">è¨Šè™Ÿé »å¯¬ (BW) [MHz]:</label><div class="input-with-clear"><input id="sensitivity_bw" oninput="calculateSensitivity()" placeholder="ä¾‹å¦‚: 1 (1MHz)" type="number" value="1"/><button class="clear-button" onclick="clearAndRecalculate('sensitivity_bw', 'calculateSensitivity')">Ã—</button></div><label for="sensitivity_nf">é›œè¨ŠæŒ‡æ•¸ (Noise Figure, NF) [dB]:</label><div class="input-with-clear"><input id="sensitivity_nf" oninput="calculateSensitivity()" placeholder="ä¾‹å¦‚: 5" type="number" value="5"/><button class="clear-button" onclick="clearAndRecalculate('sensitivity_nf', 'calculateSensitivity')">Ã—</button></div><label for="sensitivity_sn">æ‰€éœ€è¨Šé›œæ¯” (S/N) [dB]:</label><div class="input-with-clear"><input id="sensitivity_sn" oninput="calculateSensitivity()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('sensitivity_sn', 'calculateSensitivity')">Ã—</button></div></div><div class="results-card-border" id="sensitivity_output">æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity):</div></section><section class="card section-item" id="section-los"><div class="section-header-with-controls"><div class="section-title">4. é€šè¦–æœ€å¤§è·é›¢è¨ˆç®— (åœ°çƒæ›²åº¦é®è”½)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-los')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-los')">æ¸…é™¤</button></div></div><div class="input-group-border"><div class="los-point-title">A é»</div><div class="los-input-container"><div class="input-item"><label for="los_g1">å¤©ç·šæ¶è¨­é»æ°´å¹³é¢é«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_g1" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 100" type="number" value="0"/><button class="clear-button" onclick="clearAndRecalculate('los_g1', 'calculateMaxLOS')">Ã—</button></div></div><div class="input-item"><label for="los_h1">å¤©ç·šé«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_h1" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('los_h1', 'calculateMaxLOS')">Ã—</button></div></div></div><div class="los-point-title">B é»</div><div class="los-input-container"><div class="input-item"><label for="los_g2">å¤©ç·šæ¶è¨­é»æ°´å¹³é¢é«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_g2" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 150" type="number" value="0"/><button class="clear-button" onclick="clearAndRecalculate('los_g2', 'calculateMaxLOS')">Ã—</button></div></div><div class="input-item"><label for="los_h2">å¤©ç·šé«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_h2" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 20" type="number" value="20"/><button class="clear-button" onclick="clearAndRecalculate('los_h2', 'calculateMaxLOS')">Ã—</button></div></div></div></div>
<div style="margin-top:6px;">
  <button class="btn ghost" onclick="toggleRefraction()" id="refBtn" style="color: #bb66ff;">ç›®å‰ï¼šä¸å«å¤§æ°£æŠ˜å°„</button>
</div>
<div class="results-card-border" id="los_output">æœ€å¤§é€šè¦–è·é›¢:</div></section><section class="card section-item" id="section-fspl"><div class="section-header-with-controls"><div class="section-title">5. è‡ªç”±ç©ºé–“æè€— (Free Space Path Loss, FSPL)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-fspl')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-fspl')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="fspl_freq">é »ç‡ (Frequency) [MHz]:</label><div class="input-with-clear"><input id="fspl_freq" oninput="calculateFSPL()" placeholder="ä¾‹å¦‚: 2400 (2.4 GHz)" type="number" value="2400"/><button class="clear-button" onclick="clearAndRecalculate('fspl_freq', 'calculateFSPL')">Ã—</button></div><label for="fspl_dist">è·é›¢ (Distance) [km]:</label><div class="input-with-clear"><input id="fspl_dist" oninput="calculateFSPL()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('fspl_dist', 'calculateFSPL')">Ã—</button></div></div><div class="results-card-border" id="fspl_output">è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL):</div></section><section class="card section-item" id="section-linkbudget"><div class="section-header-with-controls"><div class="section-title">6. é€šè¨Šæ¨¡æ“¬ (Link Budget)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-linkbudget')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-linkbudget')">æ¸…é™¤</button></div></div><div class="input-group-border"><div class="los-point-title" style="margin-top: 0;">é€šä¿¡åƒæ•¸</div><div class="los-input-container"><div class="input-item"><label for="link_freq_mhz">é »ç‡ (Frequency) [MHz]:</label><div class="input-with-clear"><input id="link_freq_mhz" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 2400 (2.4 GHz)" type="number" value="2400"/><button class="clear-button" onclick="clearAndRecalculate('link_freq_mhz', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_dist_km">è·é›¢ (Distance) [km]:</label><div class="input-with-clear"><input id="link_dist_km" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('link_dist_km', 'calculateLinkBudget')">Ã—</button></div></div></div><div class="los-point-title">ç™¼å°„ç«¯ (Tx)</div><label for="link_tx_power_unit">ç™¼å°„åŠŸç‡è¼¸å…¥å–®ä½:</label><select id="link_tx_power_unit" onchange="swapLinkTxUnit()"><option value="w">W</option><option value="dbm">dBm</option></select><div class="los-input-container"><div class="input-item"><label for="link_tx_power_input">ç™¼å°„åŠŸç‡ (Tx Power) [W/dBm]:</label><div class="input-with-clear"><input id="link_tx_power_input" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 1 (1W)" type="number" value="1"/><button class="clear-button" onclick="clearAndRecalculate('link_tx_power_input', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_tx_gain_dbi">å¤©ç·šå¢ç›Š (Tx Gain) [dBi]:</label><div class="input-with-clear"><input id="link_tx_gain_dbi" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 3" type="number" value="3"/><button class="clear-button" onclick="clearAndRecalculate('link_tx_gain_dbi', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_tx_loss_db">ç·šæ (Tx Loss) [dB]:</label><div class="input-with-clear"><input id="link_tx_loss_db" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 3 (3 dB)" type="number" value="3"/><button class="clear-button" onclick="clearAndRecalculate('link_tx_loss_db', 'calculateLinkBudget')">Ã—</button></div></div></div><div class="los-point-title">æ¥æ”¶ç«¯ (Rx)</div><div class="los-input-container"><div class="input-item"><label for="link_rx_gain_dbi">å¤©ç·šå¢ç›Š (Rx Gain) [dBi]:</label><div class="input-with-clear"><input id="link_rx_gain_dbi" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 3" type="number" value="3"/><button class="clear-button" onclick="clearAndRecalculate('link_rx_gain_dbi', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_rx_loss_db">ç·šæ (Rx Loss) [dB]:</label><div class="input-with-clear"><input id="link_rx_loss_db" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 3 (3 dB)" type="number" value="3"/><button class="clear-button" onclick="clearAndRecalculate('link_rx_loss_db', 'calculateLinkBudget')">Ã—</button></div></div></div></div><div class="results-card-border" id="linkbudget_output">æ¥æ”¶è¨Šè™Ÿå¼·åº¦:</div></section></div><div id="elevation-content" class="tab-content">
<div class="card">
<h2 class="section-title" style="margin-top: 0;">åœ°å½¢é®è”½åˆ†æ - è·¯å¾‘é«˜åº¦åœ–</h2>
<div class="orange-border-card" style="padding: 10px 12px; margin-bottom: 15px;">
<button class="btn" style="width:100%; background:linear-gradient(90deg,#79a8ff,#5ff0d5); margin-bottom: 10px;" onclick="importFromGPS()">ğŸ“ å¾GPSåˆ†é è®€å–åº§æ¨™</button>
<div style="display:grid; grid-template-columns:2fr 2fr 1.2fr; gap:5px; align-items:end; margin-bottom:10px;">
<div><label id="labelALat" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Aé»ç·¯åº¦</label><input type="number" id="sLat" value="25.0336" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label id="labelALng" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Aé»ç¶“åº¦</label><input type="number" id="sLng" value="121.5648" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">å¤©ç·šé«˜ (m)</label><input type="number" id="antennaHeightStart" value="3" step="0.1" min="0" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label id="labelBLat" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Bé»ç·¯åº¦</label><input type="number" id="eLat" value="25.1325" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label id="labelBLng" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Bé»ç¶“åº¦</label><input type="number" id="eLng" value="121.5065" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">å¤©ç·šé«˜ (m)</label><input type="number" id="antennaHeightEnd" value="3" step="0.1" min="0" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
</div>
<div style="grid-column: span 3; display: flex; gap: 10px; align-items: flex-end; margin-bottom: 8px;">
<div style="display: flex; align-items: center; gap: 5px; flex: 1;">
<label style="color:var(--label); font-size:15px; margin-bottom:0; display:block; flex-shrink:0;">æ¡æ¨£é»æ•¸</label>
<input type="number" id="samples" value="500" min="2" max="2000" style="flex: 1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);">
</div>
<button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:6px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; height:34px; flex-shrink:0; min-width:42px;" onclick="smartIncreaseSamples(100)">100</button>
<button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:6px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; height:34px; flex-shrink:0; min-width:42px;" onclick="smartIncreaseSamples(1000)">1K</button>
<button class="btn" style="background: linear-gradient(90deg, #2f9e44, #2b8a3e); border:0; padding:5px 8px; border-radius:6px; font-weight:700; font-size:16px; color:#fff; cursor:pointer; white-space:nowrap; height:34px; flex-shrink:0;" onclick="setMaxEffectivePoints()">æ»¿æ ¼æ¡æ¨£</button>
</div>
<div style="display: flex; gap: 10px; align-items: flex-start;">
<div style="flex: 1; display: flex; flex-direction: column; gap: 3px;"><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">æœ€å°é«˜åº¦ (m)</label><div style="display: flex; gap: 3px;"><input type="number" id="minElevation" placeholder="è‡ªå‹•" oninput="updateChartYAxis()" style="flex: 1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"><button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="document.getElementById('minElevation').value=''; document.getElementById('minElevation').placeholder='è‡ªå‹•'; updateChartYAxis();">è‡ªå‹•</button></div></div>
<div style="flex: 1; display: flex; flex-direction: column; gap: 3px;"><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">æœ€å¤§é«˜åº¦ (m)</label><div style="display: flex; gap: 3px;"><input type="number" id="maxElevation" placeholder="è‡ªå‹•" oninput="updateChartYAxis()" style="flex: 1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"><button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="document.getElementById('maxElevation').value=''; document.getElementById('maxElevation').placeholder='è‡ªå‹•'; updateChartYAxis();">è‡ªå‹•</button></div></div>
</div>
<div style="display: flex; gap: 10px; align-items: flex-start; margin-top: 10px;">
<div style="flex: 1; display: flex; flex-direction: column; gap: 3px;"><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">èµ·å§‹è·é›¢ (é»)</label><div style="display: flex; gap: 3px;"><input type="number" id="minDistance" placeholder="è‡ªå‹•" oninput="updateChartXAxis()" style="flex: 1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"><button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="document.getElementById('minDistance').value=''; document.getElementById('minDistance').placeholder='è‡ªå‹•'; updateChartXAxis();">è‡ªå‹•</button></div></div>
<div style="flex: 1; display: flex; flex-direction: column; gap: 3px;"><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">çµæŸè·é›¢ (é»)</label><div style="display: flex; gap: 3px;"><input type="number" id="maxDistance" placeholder="è‡ªå‹•" oninput="updateChartXAxis()" style="flex: 1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"><button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="document.getElementById('maxDistance').value=''; document.getElementById('maxDistance').placeholder='è‡ªå‹•'; updateChartXAxis();">è‡ªå‹•</button></div></div>
</div>
</div>
<div style="margin-bottom: 12px; padding: 10px 8px; background: rgba(187, 102, 255, 0.08); border: 1px solid var(--purple-accent); border-radius: 6px;">
<label style="color: var(--label); font-size: 15px; font-weight: 700; display: block; margin-bottom: 6px;">é«˜åº¦è³‡æ–™ä¾†æºé¸æ“‡</label>
<select id="elevationApiSelector" style="width: 100%; padding: 6px 8px; font-size: 15px; color: var(--value); background: transparent; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15); cursor: pointer;" onchange="toggleLocalFileUpload()">
<option value="taiwan-dsm" selected>ğŸ‡¹ğŸ‡¼ å…§æ”¿éƒ¨ DSM 20m (å°ç£å°ˆç”¨) - é è¨­</option>
<option value="google-maps">ğŸ—ºï¸ Google Maps Elevation API</option>
<option value="open-elevation">ğŸ—» Open-Elevation SRTM (30m)</option>
<option value="openmeteo">ğŸŒ Open-Meteo API (90ç±³)</option>
<option value="astergdem">ğŸ”ï¸ ASTER GDEM v3 (30m)</option>
</select>
<span id="apiInfo" style="font-size: 12px; color: var(--muted); margin-top: 4px; display: block;"></span>
<div id="localFileUploadDiv" style="margin-top: 8px; display: block;">
<label style="color: var(--label); font-size: 14px; font-weight: 600; display: block; margin-bottom: 4px;"></label>
<div style="display: flex; gap: 6px; align-items: center; margin-bottom: 6px;">
<input type="file" id="localTifFile" accept="*/*" style="display: none;" onchange="handleLocalTifFile(event)">
<button onclick="document.getElementById('localTifFile').click()" style="flex: 1; padding: 6px 12px; font-size: 14px; color: transparent; background: transparent; border: none; border-radius: 6px; cursor: pointer; font-weight: 700; display: none;">
</button>
<button id="clearLocalTifBtn" onclick="clearLocalTifFile()" style="padding: 6px 12px; font-size: 14px; color: #fff; background: #dc3545; border: none; border-radius: 6px; cursor: pointer; font-weight: 700; display: none;">
æ¸…é™¤
</button>
</div>
<button id="useGithubTifBtn" onclick="useGithubTifFile()" style="width: 100%; padding: 6px 12px; font-size: 14px; color: transparent; background: transparent; border: none; border-radius: 6px; cursor: pointer; font-weight: 700; margin-bottom: 6px; display: none;">
</button>
<div id="currentDataSource" style="padding: 8px 10px; background: rgba(255, 170, 0, 0.15); border: 2px solid #ffaa00; border-radius: 6px; margin-bottom: 6px; display: none;">
<div style="font-size: 13px; font-weight: 700; color: #ffd43b; margin-bottom: 3px;">ğŸ“Š ç›®å‰ä½¿ç”¨ï¼š</div>
<div id="currentSourceText" style="font-size: 14px; font-weight: 600; color: #5ff0d5;">ğŸŒ GitHub ç·šä¸Šåœ–è³‡</div>
</div>
<span id="localFileInfo" style="font-size: 12px; color: var(--muted); margin-top: 4px; display: block;"></span>
</div>
</div>
<div style="margin-bottom: 12px; padding: 10px 8px; background: rgba(255, 170, 0, 0.08); border: 1px solid var(--orange-border); border-radius: 6px; display: none;" id="nodataHandlingDiv">
<label style="color: #ffd43b; font-size: 14px; font-weight: 700; display: block; margin-bottom: 6px;">ğŸ“Š ç¼ºå¤±æ•¸æ“šè™•ç†æ–¹å¼</label>
<select id="nodataHandling" style="width: 100%; padding: 6px 8px; font-size: 14px; color: var(--value); background: transparent; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15); cursor: pointer;">
<option value="interpolate" selected>ğŸ”„ æ™ºæ…§æ’å€¼ï¼ˆæ¨è–¦ï¼‰- ä½¿ç”¨é„°è¿‘æœ‰æ•ˆå€¼</option>
<option value="zero">0ï¸âƒ£ è¨­ç‚º 0 ç±³</option>
<option value="skip">â­ï¸ æ¨™è¨˜ç‚ºç„¡æ•ˆä¸¦è·³é</option>
</select>
<span style="font-size: 11px; color: var(--muted); margin-top: 4px; display: block;">ğŸ’¡ ç•¶è·¯å¾‘ç¶“éç„¡åœ–è³‡å€åŸŸï¼ˆå¦‚æ¨‚å±±é›·é”ç«™ï¼‰æ™‚ä½¿ç”¨</span>
</div>
<button class="btn" style="background:linear-gradient(90deg,var(--accent1),var(--accent2)); border:0; padding:6px 12px; border-radius:6px; font-weight:700; font-size:18px; color:#022; cursor:pointer; width:100%; margin-bottom:8px;" onclick="runAnalysis()">ğŸŒ ç”Ÿæˆè·¯å¾‘å‰–é¢</button>
<div style="display: flex; gap: 8px; margin-bottom: 8px;">
<button id="toggleGreenPointsBtn" class="btn" style="background:linear-gradient(90deg,#6c757d,#5a6268); border:0; padding:6px 12px; border-radius:6px; font-weight:700; font-size:16px; color:#fff; cursor:pointer; width:100%;" onclick="toggleGreenPoints()">ğŸ‘ï¸ é¡¯ç¤ºç¯€é»</button>
</div>
<div id="summary" style="margin:8px 0; padding:6px; text-align:center; font-weight:bold; color:#79a8ff; font-size:14px;">è«‹è¼¸å…¥åº§æ¨™ä¸¦åŸ·è¡Œ</div>
<div style="position: relative; height:300px; width:100%; margin-bottom:20px; border: 3px solid #4dabf7; border-radius: 8px; padding: 8px; background: rgba(77, 171, 247, 0.05);">
<canvas id="elevationChart"></canvas>
<button class="chart-zoom-btn" onclick="openChartFullscreen()" title="æ”¾å¤§åœ–è¡¨">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<circle cx="11" cy="11" r="8"></circle>
<path d="M21 21l-4.35-4.35"></path>
<path d="M11 8v6M8 11h6"></path>
</svg>
</button>
</div>
<div style="padding: 12px; margin-bottom: 0; background: rgba(255, 170, 0, 0.05); border-radius: 8px; border: 2px solid #ffaa00;">
<div style="display: flex; gap: 8px; align-items: center; margin-bottom: 4px; padding: 6px 0;">
<label style="color: #ffd43b; font-size: 15px; font-weight: 700; flex-shrink: 0;">ä½ç½®ï¼š</label>
<input type="number" id="selectedPointIndex" placeholder="é»æ“Šåœ–è¡¨é¸æ“‡é»" style="flex: 1; padding: 6px 8px; font-size: 16px; color: var(--value); background: transparent; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15); text-align: center;" oninput="updatePointFromInput()">
<button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:6px 16px; border-radius:4px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="decrementSelectedPoint()">â¬…</button>
<button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:6px 16px; border-radius:4px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="incrementSelectedPoint()">â¡</button>
<button class="btn" style="background: linear-gradient(90deg, #4dabf7, #339af0); border:0; padding:6px 10px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="jumpToStartPoint()">Aé»</button>
<button class="btn" style="background: linear-gradient(90deg, #ff6b6b, #e03131); border:0; padding:6px 10px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="jumpToEndPoint()">Bé»</button>
</div>
<div style="display: flex; gap: 8px; align-items: center; justify-content: center; margin-bottom: 4px; padding: 6px 0;">
<label style="color: #ffd43b; font-size: 15px; font-weight: 700; flex-shrink: 0; margin-right: 8px;">é«˜åº¦ï¼š</label>
<button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:6px 16px; border-radius:4px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="jumpToHigherPoint()" title="è·³åˆ°æ›´é«˜çš„é»">â¬†</button>
<button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:6px 16px; border-radius:4px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="jumpToLowerPoint()" title="è·³åˆ°æ›´ä½çš„é»">â¬‡</button>
<button class="btn" style="background: linear-gradient(90deg, #4dabf7, #339af0); border:0; padding:6px 12px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex:1; height:34px;" onclick="jumpToMinPoint()">æœ€ä½é»</button>
<button class="btn" style="background: linear-gradient(90deg, #ff6b6b, #e03131); border:0; padding:6px 12px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex:1; height:34px;" onclick="jumpToMaxPoint()">æœ€é«˜é»</button>
</div>
<div style="display: flex; gap: 8px; align-items: center; justify-content: center; padding: 6px 0;">
<label style="color: #ffd43b; font-size: 15px; font-weight: 700; flex-shrink: 0; margin-right: 8px;">é®è”½ï¼š</label>
<button class="btn" style="background: linear-gradient(90deg, #c92a2a, #a61e1e); border:0; padding:6px 14px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex:1; height:34px;" onclick="jumpToMaxObstruction()">ä¸»é®è”½</button>
<button class="btn" style="background: linear-gradient(90deg, #ff8fab, #ff6b8a); border:0; padding:6px 14px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex:1; height:34px;" onclick="jumpToFirstObstructionFromStart()">Aé»éšœç¤™</button>
<button class="btn" style="background: linear-gradient(90deg, #ff8fab, #ff6b8a); border:0; padding:6px 14px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex:1; height:34px;" onclick="jumpToFirstObstructionFromEnd()">Bé»éšœç¤™</button>
</div>
</div>
<div id="map-container" style="margin-top:5px; text-align:center; display:none; padding:0; border-top:none;">
<div id="map-details" style="width: 100%; box-sizing: border-box; margin: 0 0 15px 0; font-size:0.95em; color:#e8eef5; text-align:left; padding: 12px; border: 2px solid #79a8ff; border-radius: 8px; background-color: rgba(121, 168, 255, 0.05);">è«‹é»æ“Šä¸Šæ–¹åœ–è¡¨çš„é»</div>
<iframe id="map-frame" style="border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.2); border:2px solid #5ff0d5; width:100%; height:450px;" src="" allowfullscreen loading="lazy"></iframe>
</div>
<div id="route-map-container" style="margin-top:5px; text-align:center; display:none; padding:0; border-top:none;">
<div id="route-map-details" style="width: 100%; box-sizing: border-box; margin: 0 0 15px 0; font-size:0.75em; color:#e8eef5; text-align:left; padding: 10px; border: 2px solid #79a8ff; border-radius: 8px; background-color: rgba(121, 168, 255, 0.05);">
<strong><span style="color: #ffd43b;">è·¯å¾‘è³‡è¨Š</span></strong><br>
<span style="color: #4a90e2;">Aé»:</span> <span style="color: #5ff0d5;" id="route-start-info">-</span><br>
<span style="color: #ea4335;">Bé»:</span> <span style="color: #5ff0d5;" id="route-end-info">-</span><br>
<span style="color: #ffd43b;">ç›´ç·šè·é›¢:</span> <span style="color: #5ff0d5;" id="route-distance-info">-</span>
</div>
<button id="maximizeMapBtn" onclick="maximizeRouteMap()" style="background: linear-gradient(90deg, #4dabf7, #339af0); border: 0; padding: 5px 10px; border-radius: 6px; font-weight: 700; font-size: 13px; color: #fff; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: inline-flex; align-items: center; gap: 6px; margin-bottom: 3px;">
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
</svg>
ğŸ” æœ€å¤§åŒ–åœ°åœ–
</button>
<div id="route-map" style="width:100%; height:450px; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.2); border:2px solid #5ff0d5;"></div>
</div>
</div>
</div>

<!-- æŒ‡åŒ—é‡åˆ†é  -->
<div id="compass-content" class="tab-content">
  <style>
    #compass-content.active {
      display: flex !important;
      justify-content: center;
      align-items: center;
      min-height: 80vh;
      padding: 20px;
    }

    .compass-wrapper {
      text-align: center;
      max-width: 400px;
      width: 100%;
      position: relative;
    }

    .compass-fullscreen-btn {
      position: absolute;
      top: 0;
      right: 0;
      width: 44px;
      height: 44px;
      background: linear-gradient(90deg, #9b59b6, #8e44ad);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(155, 89, 182, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      z-index: 100;
    }

    .compass-fullscreen-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(155, 89, 182, 0.6);
    }

    .compass-fullscreen-btn:active {
      transform: scale(0.95);
    }

    .compass-fullscreen-btn svg {
      width: 24px;
      height: 24px;
      stroke: white;
    }

    .compass-degree-display {
      color: white;
      font-size: 56px;
      font-weight: 300;
      margin-bottom: 8px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .compass-direction-display {
      color: #4fc3f7;
      font-size: 28px;
      font-weight: 500;
      margin-bottom: 30px;
      letter-spacing: 2px;
    }

    .compass-container {
      position: relative;
      width: 300px;
      height: 300px;
      margin: 0 auto;
    }

    .compass-outer {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: linear-gradient(145deg, #2c5282, #1a365d);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5),
                  inset 0 -2px 10px rgba(0,0,0,0.3);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .compass-inner {
      width: 260px;
      height: 260px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #3a5a7a, #1e3a5f);
      position: relative;
      transition: transform 0.3s ease-out;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
    }

    .compass-rose {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
    }

    .compass-cardinal {
      position: absolute;
      font-weight: bold;
      font-size: 22px;
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .compass-north {
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      color: #ef5350;
      font-size: 26px;
    }

    .compass-east {
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
    }

    .compass-south {
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
    }

    .compass-west {
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
    }

    .compass-needle-container {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .compass-needle {
      position: absolute;
      width: 6px;
      height: 110px;
      top: 50%;
      left: 50%;
      margin-left: -3px;
      margin-top: -55px;
    }

    .compass-needle-north {
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 55px solid #ef5350;
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
    }

    .compass-needle-south {
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 55px solid #e0e0e0;
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
    }

    .compass-center-dot {
      position: absolute;
      width: 14px;
      height: 14px;
      background: #ffffff;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      z-index: 10;
    }

    .compass-degree-marks {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
    }

    .compass-mark {
      position: absolute;
      background: rgba(255,255,255,0.4);
      left: 50%;
      top: 6px;
      transform-origin: 0 124px;
    }

    .compass-mark-major {
      width: 2px;
      height: 10px;
      margin-left: -1px;
      background: rgba(255,255,255,0.6);
    }

    .compass-mark-minor {
      width: 1px;
      height: 5px;
      margin-left: -0.5px;
    }

    .compass-info-text {
      color: rgba(255,255,255,0.7);
      font-size: 13px;
      margin-top: 25px;
    }

    .compass-error-message {
      color: #ff6b6b;
      background: rgba(255,255,255,0.1);
      padding: 12px;
      border-radius: 6px;
      margin-top: 20px;
      font-size: 13px;
    }

    @keyframes compass-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .compass-calibrating {
      animation: compass-pulse 1.5s infinite;
    }

    .compass-sensor-info {
      margin-top: 30px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }

    .compass-sensor-title {
      color: #85c9ff;
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      text-align: left;
    }

    .compass-sensor-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .compass-sensor-item:last-child {
      border-bottom: none;
    }

    .compass-sensor-label {
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
    }

    .compass-sensor-value {
      color: #5ff0d5;
      font-size: 16px;
      font-weight: 500;
    }

    .compass-location-btn {
      background: linear-gradient(90deg, #ff9500, #ffcc00);
      border: 0;
      padding: 8px 16px;
      border-radius: 6px;
      font-weight: 700;
      font-size: 14px;
      color: #000;
      cursor: pointer;
      margin-bottom: 10px;
      flex: 1;
    }

    .compass-map-btn {
      background: linear-gradient(90deg, #5fb3ff, #3d8eff);
      border: 0;
      padding: 8px 16px;
      border-radius: 6px;
      font-weight: 700;
      font-size: 14px;
      color: #fff;
      cursor: pointer;
      margin-bottom: 10px;
      flex: 1;
    }

    .compass-button-row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .compass-loading {
      color: #ffd43b;
      font-style: italic;
    }
  </style>

  <div class="compass-wrapper">
    <!-- å³ä¸Šè§’å…¨è¢å¹•æŒ‰éˆ• -->
    <button class="compass-fullscreen-btn" onclick="lockScreenOrientation()" title="é–å®šå‚ç›´å…¨è¢å¹•">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
      </svg>
    </button>
    
    <div class="compass-degree-display" id="compassDegreeDisplay">0Â°</div>
    <div class="compass-direction-display" id="compassDirectionDisplay">åŒ—</div>
    
    <div class="compass-container">
      <div class="compass-outer">
        <div class="compass-inner" id="compassRoseInner">
          <div class="compass-rose">
            <div class="compass-cardinal compass-north">N</div>
            <div class="compass-cardinal compass-east">E</div>
            <div class="compass-cardinal compass-south">S</div>
            <div class="compass-cardinal compass-west">W</div>
          </div>
          
          <div class="compass-degree-marks" id="compassDegreeMarks"></div>
          
          <div class="compass-center-dot"></div>
        </div>
      </div>
      
      <div class="compass-needle-container">
        <div class="compass-needle">
          <div class="compass-needle-north"></div>
          <div class="compass-needle-south"></div>
        </div>
      </div>
    </div>
    
    <div class="compass-info-text" id="compassInfoText" style="display: none;">æ­£åœ¨æ ¡æº–æŒ‡åŒ—é‡...</div>
    <div class="compass-error-message" id="compassErrorMessage" style="display: none;"></div>

    <!-- æ–°å¢:æ„Ÿæ¸¬å™¨è³‡è¨Šé¡¯ç¤ºå€åŸŸ -->
    <div class="compass-sensor-info">
      <div class="compass-sensor-item">
        <span class="compass-sensor-label">ä¿¯ä»°è§’ / æ©«æ»¾è§’</span>
        <span class="compass-sensor-value">
          <span id="compassPitch">--Â°</span> / <span id="compassRoll">--Â°</span>
        </span>
      </div>
      
      <div class="compass-button-row">
        <button class="compass-location-btn" onclick="getCompassLocation()">ğŸ“ å–å¾—å®šä½è³‡è¨Š</button>
        <button class="compass-map-btn" onclick="openCompassMapPickerUsingGPS()">ğŸ—ºï¸ æ‰‹å‹•é¸æ“‡å®šä½</button>
      </div>
      
      <div class="compass-sensor-item">
        <span class="compass-sensor-label">ç•¶å‰åº§æ¨™</span>
        <span class="compass-sensor-value" id="compassCoordinates">
          <span class="compass-loading">å°šæœªå®šä½</span>
        </span>
      </div>
      
      <div class="compass-sensor-item">
        <span class="compass-sensor-label">åœ°å½¢ / å»ºç‰© é«˜åº¦</span>
        <span class="compass-sensor-value">
          <span id="compassElevationTerrain">--</span> / <span id="compassElevationBuilding">--</span>
        </span>
      </div>
    </div>
  </div>

  <script>
    (function() {
      const compassRoseInner = document.getElementById('compassRoseInner');
      const compassDegreeDisplay = document.getElementById('compassDegreeDisplay');
      const compassDirectionDisplay = document.getElementById('compassDirectionDisplay');
      const compassInfoText = document.getElementById('compassInfoText');
      const compassErrorMessage = document.getElementById('compassErrorMessage');
      const compassDegreeMarks = document.getElementById('compassDegreeMarks');

      // æ–°å¢ï¼šæ„Ÿæ¸¬å™¨è³‡è¨Šå…ƒç´ 
      const compassPitch = document.getElementById('compassPitch');
      const compassRoll = document.getElementById('compassRoll');

      // å„²å­˜ç•¶å‰ä½ç½®è³‡è¨Š
      let currentLat = null;
      let currentLng = null;

      // å„²å­˜ä¸Šä¸€æ¬¡çš„æ—‹è½‰è§’åº¦ï¼Œç”¨æ–¼ä¿®æ­£0/360åº¦åˆ‡æ›å•é¡Œ
      let lastRotation = 0;
      let rotationOffset = 0;

      // ç”Ÿæˆåˆ»åº¦æ¨™è¨˜
      for (let i = 0; i < 360; i += 5) {
        const mark = document.createElement('div');
        mark.className = i % 30 === 0 ? 'compass-mark compass-mark-major' : 'compass-mark compass-mark-minor';
        mark.style.transform = `translateX(-50%) rotate(${i}deg)`;
        compassDegreeMarks.appendChild(mark);
      }

      // æ–¹å‘å°ç…§è¡¨
      const directions = [
        { name: 'åŒ—', range: [0, 22.5] },
        { name: 'æ±åŒ—', range: [22.5, 67.5] },
        { name: 'æ±', range: [67.5, 112.5] },
        { name: 'æ±å—', range: [112.5, 157.5] },
        { name: 'å—', range: [157.5, 202.5] },
        { name: 'è¥¿å—', range: [202.5, 247.5] },
        { name: 'è¥¿', range: [247.5, 292.5] },
        { name: 'è¥¿åŒ—', range: [292.5, 337.5] },
        { name: 'åŒ—', range: [337.5, 360] }
      ];

      function getDirection(degree) {
        for (let dir of directions) {
          if (degree >= dir.range[0] && degree < dir.range[1]) {
            return dir.name;
          }
        }
        return 'åŒ—';
      }

      function handleOrientation(event) {
        let heading = event.alpha;
        
        if (event.webkitCompassHeading) {
          heading = event.webkitCompassHeading;
        } else if (event.alpha) {
          heading = 360 - event.alpha;
        }

        if (heading !== null) {
          const roundedHeading = Math.round(heading);
          
          // ä¿®æ­£0/360åº¦åˆ‡æ›å•é¡Œï¼šè¨ˆç®—æœ€çŸ­æ—‹è½‰è·¯å¾‘
          let targetRotation = -heading;
          let diff = targetRotation - lastRotation;
          
          // å°‡å·®å€¼æ¨™æº–åŒ–åˆ° -180 åˆ° 180 ä¹‹é–“
          while (diff > 180) diff -= 360;
          while (diff < -180) diff += 360;
          
          // ç´¯åŠ æ—‹è½‰åç§»é‡
          rotationOffset += diff;
          lastRotation = targetRotation;
          
          // ä½¿ç”¨ç´¯ç©çš„æ—‹è½‰å€¼ï¼Œé¿å…è·³è½‰
          compassRoseInner.style.transform = `rotate(${rotationOffset}deg)`;
          compassDegreeDisplay.textContent = `${roundedHeading}Â°`;
          compassDirectionDisplay.textContent = getDirection(roundedHeading);
          
          // ç§»é™¤ã€ŒæŒ‡åŒ—é‡å·²å°±ç·’ã€æ–‡å­—é¡¯ç¤º
          if (compassInfoText.classList.contains('compass-calibrating')) {
            compassInfoText.classList.remove('compass-calibrating');
            compassInfoText.style.display = 'none';
          }
        }

        // æ–°å¢ï¼šæ›´æ–°ä¿¯ä»°è§’å’Œæ©«æ»¾è§’
        if (event.beta !== null && event.beta !== undefined) {
          const pitch = Math.round(event.beta);
          compassPitch.textContent = `${pitch}Â°`;
        }

        if (event.gamma !== null && event.gamma !== undefined) {
          const roll = Math.round(event.gamma);
          compassRoll.textContent = `${roll}Â°`;
        }
      }

      // æª¢æŸ¥è¨­å‚™æ–¹å‘æ”¯æ´
      if (window.DeviceOrientationEvent) {
        // iOS 13+ éœ€è¦è«‹æ±‚æ¬Šé™
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          DeviceOrientationEvent.requestPermission()
            .then(permissionState => {
              if (permissionState === 'granted') {
                window.addEventListener('deviceorientation', handleOrientation);
                compassInfoText.classList.add('compass-calibrating');
              } else {
                compassErrorMessage.textContent = 'éœ€è¦è£ç½®æ–¹å‘æ¬Šé™æ‰èƒ½ä½¿ç”¨æŒ‡åŒ—é‡';
                compassErrorMessage.style.display = 'block';
                compassInfoText.style.display = 'none';
              }
            })
            .catch(error => {
              compassErrorMessage.textContent = 'ç„¡æ³•è«‹æ±‚è£ç½®æ–¹å‘æ¬Šé™';
              compassErrorMessage.style.display = 'block';
              compassInfoText.style.display = 'none';
            });
        } else {
          // é iOS 13+ è¨­å‚™
          window.addEventListener('deviceorientation', handleOrientation);
          compassInfoText.classList.add('compass-calibrating');
        }
      } else {
        compassErrorMessage.textContent = 'æ‚¨çš„è¨­å‚™ä¸æ”¯æ´æŒ‡åŒ—é‡åŠŸèƒ½';
        compassErrorMessage.style.display = 'block';
        compassInfoText.style.display = 'none';
      }

      // å°‡å‡½æ•¸æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
      window.getCompassLocation = getCompassLocation;
      window.currentCompassLat = null;
      window.currentCompassLng = null;
    })();

    // æ–°å¢ï¼šå–å¾—ç•¶å‰ä½ç½®çš„å‡½æ•¸
    async function getCompassLocation() {
      const coordsElement = document.getElementById('compassCoordinates');
      const elevTerrainElement = document.getElementById('compassElevationTerrain');
      const elevBuildingElement = document.getElementById('compassElevationBuilding');

      coordsElement.innerHTML = '<span class="compass-loading">å®šä½ä¸­...</span>';

      if (!navigator.geolocation) {
        coordsElement.innerHTML = '<span style="color: #ff6b6b;">ä¸æ”¯æ´å®šä½</span>';
        return;
      }

      try {
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          });
        });

        const lat = position.coords.latitude;
        const lng = position.coords.longitude;

        // å„²å­˜åº§æ¨™
        window.currentCompassLat = lat;
        window.currentCompassLng = lng;

        // é¡¯ç¤ºåº§æ¨™ï¼ˆå–®è¡Œæ ¼å¼ï¼šç·¯åº¦,ç¶“åº¦ï¼‰
        coordsElement.textContent = `${lat.toFixed(6)}Â°, ${lng.toFixed(6)}Â°`;

        // å–å¾—åœ°å½¢é«˜åº¦ (Google Maps)
        elevTerrainElement.innerHTML = '<span class="compass-loading">è®€å–ä¸­...</span>';
        try {
          const terrainElev = await getElevationFromGoogleMapsForCompass(lat, lng);
          elevTerrainElement.textContent = `${Math.round(terrainElev)}m`;
        } catch (error) {
          console.error('Google Maps elevation error:', error);
          elevTerrainElement.innerHTML = '<span style="color: #ff6b6b;">å¤±æ•—</span>';
        }

        // å–å¾—å»ºç‰©é«˜åº¦ (å…§æ”¿éƒ¨ DSMï¼Œåƒ…é™å°ç£ç¯„åœ)
        if (lat >= 21.5 && lat <= 25.5 && lng >= 119.5 && lng <= 122.5) {
          elevBuildingElement.innerHTML = '<span class="compass-loading">è®€å–ä¸­...</span>';
          try {
            const buildingElev = await getElevationFromDSMForCompass(lat, lng);
            elevBuildingElement.textContent = `${Math.round(buildingElev)}m`;
          } catch (error) {
            console.error('DSM elevation error:', error);
            elevBuildingElement.innerHTML = '<span style="color: #ff6b6b;">å¤±æ•—</span>';
          }
        } else {
          elevBuildingElement.innerHTML = '<span style="color: #a8b3c3;">è¶…å‡ºç¯„åœ</span>';
        }

      } catch (error) {
        console.error('Geolocation error:', error);
        coordsElement.innerHTML = '<span style="color: #ff6b6b;">å®šä½å¤±æ•—</span>';
        
        if (error.code === 1) {
          coordsElement.innerHTML = '<span style="color: #ff6b6b;">éœ€è¦ä½ç½®æ¬Šé™</span>';
        } else if (error.code === 2) {
          coordsElement.innerHTML = '<span style="color: #ff6b6b;">å®šä½ä¸å¯ç”¨</span>';
        } else if (error.code === 3) {
          coordsElement.innerHTML = '<span style="color: #ff6b6b;">å®šä½é€¾æ™‚</span>';
        }
      }
    }

    // æ–°å¢ï¼šç‚ºæŒ‡åŒ—é‡é é¢å°ˆç”¨çš„ Google Maps é«˜åº¦æŸ¥è©¢å‡½æ•¸
    async function getElevationFromGoogleMapsForCompass(lat, lng) {
      const GOOGLE_API_KEY = 'AIzaSyBwd_GtAZq2eW6KgRRkro__aG7h5ZECJwo';
      
      if (!window.google || !window.google.maps) {
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=geometry`;
          script.async = true;
          script.defer = true;
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
      }

      const elevator = new google.maps.ElevationService();
      const result = await new Promise((resolve, reject) => {
        elevator.getElevationForLocations({
          locations: [{ lat: lat, lng: lng }]
        }, (results, status) => {
          if (status === 'OK' && results && results.length > 0) {
            resolve(results[0].elevation);
          } else {
            reject(new Error(`Google Maps API ç‹€æ…‹: ${status}`));
          }
        });
      });

      return result;
    }

    // æ–°å¢ï¼šç‚ºæŒ‡åŒ—é‡é é¢å°ˆç”¨çš„å…§æ”¿éƒ¨ DSM é«˜åº¦æŸ¥è©¢å‡½æ•¸
    async function getElevationFromDSMForCompass(lat, lng) {
      if (!window.GeoTIFF) {
        await loadGeoTIFFLibrary();
      }

      const cogFilename = 'taiwan_dsm_wgs84_cog.tif';
      let tiff = null;

      try {
        tiff = await GeoTIFF.fromUrl(cogFilename);
      } catch (err) {
        const githubUrl = 'https://sulapon.github.io/GPS/taiwan_dsm_wgs84_cog.tif';
        tiff = await GeoTIFF.fromUrl(githubUrl);
      }

      const image = await tiff.getImage();
      const bbox = image.getBoundingBox();
      const width = image.getWidth();
      const height = image.getHeight();

      const pixelX = Math.floor((lng - bbox[0]) / (bbox[2] - bbox[0]) * width);
      const pixelY = Math.floor((bbox[3] - lat) / (bbox[3] - bbox[1]) * height);

      if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
        const rasters = await image.readRasters({
          window: [pixelX, pixelY, pixelX + 1, pixelY + 1]
        });
        
        const elevation = rasters[0][0];
        
        if (elevation === null || elevation === undefined || isNaN(elevation)) {
          throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
        }
        
        return elevation;
      } else {
        throw new Error('åº§æ¨™è¶…å‡º DSM è³‡æ–™ç¯„åœ');
      }
    }

    // æ–°å¢ï¼šç‚ºæŒ‡åŒ—é‡é é¢èª¿ç”¨GPSåˆ†é çš„åœ°åœ–é¸æ“‡å™¨
    function openCompassMapPickerUsingGPS() {
      console.log('openCompassMapPickerUsingGPS() è¢«èª¿ç”¨ - ä½¿ç”¨GPSåˆ†é çš„åœ°åœ–åŠŸèƒ½');
      
      const coordsElement = document.getElementById('compassCoordinates');
      const currentCoords = coordsElement.textContent.trim();
      
      // å˜—è©¦å¾ç¾æœ‰åº§æ¨™è§£æï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨å°åŒ—101é è¨­å€¼
      let currentLat = 25.0336;
      let currentLon = 121.5648;
      
      if (currentCoords && !currentCoords.includes('å°šæœªå®šä½') && !currentCoords.includes('å¤±æ•—')) {
        const coordMatch = currentCoords.match(/([\d.]+)Â°,\s*([\d.]+)Â°/);
        if (coordMatch) {
          currentLat = parseFloat(coordMatch[1]);
          currentLon = parseFloat(coordMatch[2]);
        }
      }
      
      // æš«å­˜ç•¶å‰åº§æ¨™åˆ°è‡¨æ™‚è®Šé‡ï¼Œä¾›GPSåœ°åœ–ä½¿ç”¨
      window.tempCompassLat = currentLat;
      window.tempCompassLng = currentLon;
      
      // èª¿ç”¨GPSåˆ†é çš„åœ°åœ–é¸æ“‡å™¨å‡½æ•¸ï¼Œå‚³å…¥'COMPASS'ä½œç‚ºç‰¹æ®Šæ¨™è¨˜
      openMapPicker('COMPASS');
    }

    // æ–°å¢ï¼šæ¥æ”¶GPSåœ°åœ–é¸æ“‡å™¨å›å‚³çš„åº§æ¨™ï¼ˆå°ˆç‚ºæŒ‡åŒ—é‡è¨­è¨ˆï¼‰
    window.receiveCompassMapCoordinates = async function(lat, lng, searchedName) {
      console.log('receiveCompassMapCoordinates() è¢«èª¿ç”¨: ç·¯åº¦=' + lat + ', ç¶“åº¦=' + lng);
      
      const coordsElement = document.getElementById('compassCoordinates');
      const elevTerrainElement = document.getElementById('compassElevationTerrain');
      const elevBuildingElement = document.getElementById('compassElevationBuilding');
      
      // æ›´æ–°åº§æ¨™é¡¯ç¤º
      coordsElement.textContent = `${lat.toFixed(6)}Â°, ${lng.toFixed(6)}Â°`;
      
      // å–å¾—åœ°å½¢é«˜åº¦ (Google Maps)
      elevTerrainElement.innerHTML = '<span class="compass-loading">è®€å–ä¸­...</span>';
      try {
        const terrainElev = await getElevationFromGoogleMapsForCompass(lat, lng);
        elevTerrainElement.textContent = `${Math.round(terrainElev)}m`;
      } catch (error) {
        console.error('Google Maps elevation error:', error);
        elevTerrainElement.innerHTML = '<span style="color: #ff6b6b;">å¤±æ•—</span>';
      }
      
      // å–å¾—å»ºç‰©é«˜åº¦ (å…§æ”¿éƒ¨ DSM) - æ‰‹å‹•é¸æ“‡å®šä½æ™‚ä¹Ÿæœƒæ›´æ–°
      if (lat >= 21.5 && lat <= 25.5 && lng >= 119.5 && lng <= 122.5) {
        elevBuildingElement.innerHTML = '<span class="compass-loading">è®€å–ä¸­...</span>';
        try {
          const buildingElev = await getElevationFromDSMForCompass(lat, lng);
          elevBuildingElement.textContent = `${Math.round(buildingElev)}m`;
        } catch (error) {
          console.error('DSM elevation error:', error);
          elevBuildingElement.innerHTML = '<span style="color: #ff6b6b;">å¤±æ•—</span>';
        }
      } else {
        elevBuildingElement.innerHTML = '<span style="color: #a8b3c3;">è¶…å‡ºç¯„åœ</span>';
      }
    };
    
    // æ–°å¢ï¼šé–å®šè¢å¹•æ–¹å‘ç‚ºå‚ç›´ä¸¦é€²å…¥çœŸæ­£çš„å…¨è¢å¹•ï¼ˆåƒè€ƒé«˜åº¦åœ–å¯¦ç¾ï¼‰
    let isCompassFullscreen = false;
    let originalCompassStyles = {};
    let compassExitBtn = null;
    
    async function lockScreenOrientation() {
      const compassContent = document.getElementById('compass-content');
      const fullscreenBtn = document.querySelector('.compass-fullscreen-btn');
      
      if (!compassContent) {
        console.error('æ‰¾ä¸åˆ°æŒ‡åŒ—é‡å®¹å™¨');
        return;
      }
      
      if (!isCompassFullscreen) {
        try {
          // é€²å…¥å…¨è¢å¹•
          if (compassContent.requestFullscreen) {
            await compassContent.requestFullscreen();
          } else if (compassContent.webkitRequestFullscreen) {
            await compassContent.webkitRequestFullscreen();
          } else if (compassContent.mozRequestFullScreen) {
            await compassContent.mozRequestFullScreen();
          } else if (compassContent.msRequestFullscreen) {
            await compassContent.msRequestFullscreen();
          }
          
          // éš±è—å…¨è¢å¹•æŒ‰éˆ•
          if (fullscreenBtn) {
            fullscreenBtn.style.display = 'none';
          }
          
          // ä¿å­˜åŸå§‹æ¨£å¼
          originalCompassStyles = {
            background: compassContent.style.background,
            padding: compassContent.style.padding,
            display: compassContent.style.display,
            minHeight: compassContent.style.minHeight
          };
          
          // è¨­ç½®å…¨è¢å¹•æ¨£å¼
          compassContent.style.background = '#050a16';
          compassContent.style.padding = '0';
          compassContent.style.display = 'flex';
          compassContent.style.justifyContent = 'center';
          compassContent.style.alignItems = 'center';
          compassContent.style.minHeight = '100vh';
          
          // å‰µå»ºé€€å‡ºæŒ‰éˆ•
          compassExitBtn = document.createElement('button');
          compassExitBtn.innerHTML = 'âœ•';
          compassExitBtn.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(220, 38, 38, 0.95);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            z-index: 999999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
          `;
          compassExitBtn.onclick = exitCompassFullscreen;
          compassContent.appendChild(compassExitBtn);
          
          isCompassFullscreen = true;
          
          // ç­‰å¾…ä¸€å°æ®µæ™‚é–“ç¢ºä¿å…¨è¢å¹•å·²å•Ÿå‹•
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // é–å®šè¢å¹•æ–¹å‘ç‚ºå‚ç›´
          if (screen.orientation && screen.orientation.lock) {
            try {
              await screen.orientation.lock('portrait');
              console.log('âœ… å·²é–å®šç‚ºå‚ç›´å…¨è¢å¹•æ¨¡å¼');
              showTemporaryMessage('âœ… å·²é–å®šç‚ºå‚ç›´å…¨è¢å¹•æ¨¡å¼');
            } catch (err) {
              console.error('é–å®šè¢å¹•æ–¹å‘å¤±æ•—:', err);
              showTemporaryMessage('âš ï¸ å·²é€²å…¥å…¨è¢å¹•');
            }
          } else {
            showTemporaryMessage('âœ… å·²é€²å…¥å…¨è¢å¹•');
          }
          
        } catch (error) {
          console.error('é€²å…¥å…¨è¢å¹•å¤±æ•—:', error);
          alert('âŒ ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼\nè«‹ç¢ºèªå·²æˆäºˆç¶²é å…¨è¢å¹•æ¬Šé™');
        }
      }
    }
    
    function exitCompassFullscreen() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
    
    // ç›£è½å…¨è¢å¹•è®ŠåŒ–äº‹ä»¶
    document.addEventListener('fullscreenchange', handleCompassFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleCompassFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleCompassFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleCompassFullscreenChange);
    
    function handleCompassFullscreenChange() {
      const compassContent = document.getElementById('compass-content');
      const fullscreenBtn = document.querySelector('.compass-fullscreen-btn');
      
      if (!compassContent) return;
      
      const isFullscreen = !!(document.fullscreenElement || 
                             document.webkitFullscreenElement || 
                             document.mozFullScreenElement || 
                             document.msFullscreenElement);
      
      if (!isFullscreen && isCompassFullscreen) {
        // æ¢å¾©é¡¯ç¤ºå…¨è¢å¹•æŒ‰éˆ•
        if (fullscreenBtn) {
          fullscreenBtn.style.display = 'flex';
        }
        
        // æ¢å¾©åŸå§‹æ¨£å¼
        if (originalCompassStyles) {
          compassContent.style.background = originalCompassStyles.background;
          compassContent.style.padding = originalCompassStyles.padding;
          compassContent.style.display = originalCompassStyles.display;
          compassContent.style.minHeight = originalCompassStyles.minHeight;
        }
        
        // ç§»é™¤é€€å‡ºæŒ‰éˆ•
        if (compassExitBtn && compassExitBtn.parentNode) {
          compassExitBtn.parentNode.removeChild(compassExitBtn);
          compassExitBtn = null;
        }
        
        isCompassFullscreen = false;
        
        // è§£é–è¢å¹•æ–¹å‘
        if (screen.orientation && screen.orientation.unlock) {
          try {
            screen.orientation.unlock();
          } catch (err) {
            console.log('è§£é–è¢å¹•æ–¹å‘:', err);
          }
        }
      }
    }
    
    // é¡¯ç¤ºè‡¨æ™‚è¨Šæ¯ï¼ˆä¸ç ´å£å…¨è¢å¹•é«”é©—ï¼‰
    function showTemporaryMessage(message) {
      const msgDiv = document.createElement('div');
      msgDiv.textContent = message;
      msgDiv.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      `;
      document.body.appendChild(msgDiv);
      
      // 3ç§’å¾Œè‡ªå‹•ç§»é™¤
      setTimeout(() => {
        msgDiv.style.opacity = '0';
        msgDiv.style.transition = 'opacity 0.5s';
        setTimeout(() => msgDiv.remove(), 500);
      }, 3000);
    }
  </script>

</div>

<!-- å ±å‘ŠåŒ¯å‡ºåˆ†é  -->
<div id="report-content" class="tab-content">
  <div class="card">
    <h2 class="section-title" style="margin-top: 0;">ğŸ“„ å ±å‘ŠåŒ¯å‡º</h2>
    
    <!-- å ±å‘Šè¨­å®š -->
    <div style="background: rgba(95, 240, 213, 0.05); border: 2px solid var(--accent1); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
      <h3 style="color: var(--accent1); font-size: 16px; margin: 0 0 12px 0; font-weight: 700;">âš™ï¸ å ±å‘Šè¨­å®š</h3>
      
      <div style="margin-bottom: 10px;">
        <label style="color: var(--label); font-size: 14px; display: block; margin-bottom: 5px; font-weight: 600;">å ±å‘Šæ¨™é¡Œ</label>
        <input type="text" id="report_title" value="ç„¡ç·šé›»é€šè¨Šè·¯å¾‘åˆ†æå ±å‘Š" 
               style="width: 100%; padding: 8px; font-size: 15px; color: var(--value); background: rgba(255,255,255,0.05); border-radius: 6px; border: 1px solid rgba(255,255,255,0.2);">
      </div>
      
      <div style="margin-bottom: 10px;">
        <label style="color: var(--label); font-size: 14px; display: block; margin-bottom: 5px; font-weight: 600;">å°ˆæ¡ˆåç¨± (é¸å¡«)</label>
        <input type="text" id="report_project" placeholder="ä¾‹å¦‚ï¼šå°åŒ—-æ–°ç«¹ UHF éˆè·¯è©•ä¼°" 
               style="width: 100%; padding: 8px; font-size: 15px; color: var(--value); background: rgba(255,255,255,0.05); border-radius: 6px; border: 1px solid rgba(255,255,255,0.2);">
      </div>
      
      <div>
        <label style="color: var(--label); font-size: 14px; display: block; margin-bottom: 5px; font-weight: 600;">è£½ä½œè€… (é¸å¡«)</label>
        <input type="text" id="report_author" placeholder="æ‚¨çš„å§“åæˆ–å–®ä½" 
               style="width: 100%; padding: 8px; font-size: 15px; color: var(--value); background: rgba(255,255,255,0.05); border-radius: 6px; border: 1px solid rgba(255,255,255,0.2);">
      </div>
    </div>
    
    <!-- åŒ¯å‡ºæŒ‰éˆ• -->
    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
      <button onclick="generateReportPDF()" 
              style="flex: 1; min-width: 200px; background: linear-gradient(90deg, #ffd43b, #ffa94d); border: 0; padding: 12px 20px; border-radius: 8px; font-weight: 700; font-size: 18px; color: #000; cursor: pointer; box-shadow: 0 4px 12px rgba(255, 164, 77, 0.3); transition: all 0.3s;">
        ğŸš€ ç”Ÿæˆ PDF å ±å‘Š
      </button>
    </div>
    
    <!-- å ±å‘Šè³‡æ–™ä¾†æºèªªæ˜ -->
    <div style="background: rgba(95, 240, 213, 0.05); border: 2px solid var(--accent1); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
      <h3 style="color: var(--accent1); font-size: 16px; margin: 0 0 8px 0; font-weight: 700;">ğŸ“‹ å ±å‘Šè³‡æ–™ä¾†æºèªªæ˜</h3>
      
      <div style="margin-bottom: 8px; padding: 8px 12px; background: rgba(255, 212, 59, 0.1); border-radius: 4px; font-size: 14px; color: #ffd43b; line-height: 1.5;">
        ğŸ’¡ æç¤ºï¼šå»ºè­°åœ¨ç”Ÿæˆå ±å‘Šå‰ç¢ºèªå„åˆ†é è³‡æ–™å·²æ­£ç¢ºå¡«å¯«
      </div>
      
      <div style="font-size: 14px; color: #a8b3c3; line-height: 1.8;">
        <div style="margin-bottom: 4px;">
          <span style="color: #ffd43b;">â—</span> <span style="color: #e8eef5; font-weight: 600;">RFå·¥å…·</span>ï¼šLink Budget è¨ˆç®—çµæœ
        </div>
        
        <div style="margin-bottom: 4px;">
          <span style="color: #ffd43b;">â—</span> <span style="color: #e8eef5; font-weight: 600;">GPS</span>ï¼šA/B å…©é»åº§æ¨™ã€æµ·æ‹”ã€å¤©ç·šé«˜åº¦ã€æ–¹ä½è§’/ä¿¯ä»°è§’
        </div>
        
        <div style="margin-bottom: 0;">
          <span style="color: #ffd43b;">â—</span> <span style="color: #e8eef5; font-weight: 600;">é«˜åº¦åœ–</span>ï¼šè·¯å¾‘å‰–é¢åœ–ã€é®è”½åˆ†æã€è²æ¶…çˆ¾å€
        </div>
      </div>
    </div>
    
    <!-- ç‹€æ…‹è¨Šæ¯ -->
    <div id="export_status" style="margin-top: 15px; padding: 10px; border-radius: 6px; display: none; font-size: 14px; font-weight: 600;"></div>
  </div>
</div>

<script>
// ========================================
// ğŸ“„ PDF å ±å‘ŠåŒ¯å‡ºåŠŸèƒ½
// ========================================

/**
 * é è¦½å ±å‘Šå…§å®¹
 */

/**
 * ç”Ÿæˆ PDF å ±å‘Š
 */
/**
 * ç”Ÿæˆ PDF å ±å‘Š - å–®é A4ç‰ˆæœ¬
 * ä¸Šæ–¹ï¼šå‰–é¢åœ–
 * ä¸‹æ–¹ï¼šå·¦(Aé»+Aâ†’Bè§’åº¦)ã€ä¸­(RFè¨ˆç®—)ã€å³(Bé»+Bâ†’Aè§’åº¦)
 */
async function generateReportPDF() {
  const exportRF = true;
  const exportGPS = true;
  const exportElevation = true;
  
  // æª¢æŸ¥æ˜¯å¦éœ€è¦å‰–é¢åœ–ä½†æœªé–‹å•Ÿå…¨ç•«é¢æ¨¡å¼
  if (exportElevation) {
    const overlay = document.getElementById('chartFullscreenOverlay');
    const isFullscreen = overlay && overlay.classList.contains('active');
    
    if (!isFullscreen) {
      // ç§»é™¤ç¢ºèªå°è©±æ¡†ï¼Œç›´æ¥é–‹å•Ÿå…¨è¢å¹•
      if (typeof openChartFullscreen === 'function') {
        try {
          openChartFullscreen();
          
          // è¨­å®šæ¨™è¨˜ï¼šè¡¨ç¤ºæ­£åœ¨ç”Ÿæˆå ±å‘Š
          window.isGeneratingReport = true;
          
          showExportStatus('ğŸ”„ æ­£åœ¨é–‹å•Ÿå…¨ç•«é¢æ¨¡å¼...è«‹è¨­å®šå¥½åœ–è¡¨å¾Œé»æ“Šã€Œç¢ºèªæˆªåœ–ã€æŒ‰éˆ•', 'loading');
          await new Promise(resolve => setTimeout(resolve, 800));
          
          const overlayCheck = document.getElementById('chartFullscreenOverlay');
          if (!overlayCheck || !overlayCheck.classList.contains('active')) {
            alert('âš ï¸ å…¨ç•«é¢æ¨¡å¼é–‹å•Ÿç•°å¸¸ï¼Œå°‡ä½¿ç”¨ä¸€èˆ¬åœ–è¡¨ã€‚');
            window.isGeneratingReport = false;
          } else {
            // é¡¯ç¤ºã€Œç¢ºèªæˆªåœ–ã€æŒ‰éˆ•
            showReportConfirmButton();
            // ç­‰å¾…ç”¨æˆ¶é»æ“Šç¢ºèªæŒ‰éˆ•
            return;  // ä¸­æ–·åŸ·è¡Œï¼Œç­‰å¾…ç”¨æˆ¶ç¢ºèª
          }
        } catch (error) {
          console.error('é–‹å•Ÿå…¨ç•«é¢å¤±æ•—:', error);
          alert('âŒ è‡ªå‹•é–‹å•Ÿå¤±æ•—\n\nè«‹æ‰‹å‹•æ“ä½œï¼š\n1. é»æ“Šå‰–é¢åœ–å³ä¸Šè§’çš„å…¨è¢å¹•æŒ‰éˆ• ğŸ“º\n2. å†æ¬¡é»æ“Šã€Œç”Ÿæˆ PDF å ±å‘Šã€');
          window.isGeneratingReport = false;
          return;
        }
      } else {
        alert('âŒ æ‰¾ä¸åˆ°å…¨ç•«é¢åŠŸèƒ½');
        return;
      }
    }
  }
  
  // ç¹¼çºŒç”Ÿæˆå ±å‘Šçš„é‚è¼¯
  await continueGenerateReport();
}

// æ–°å¢å‡½æ•¸ï¼šé¡¯ç¤ºç¢ºèªæˆªåœ–æŒ‰éˆ•
function showReportConfirmButton() {
  const overlay = document.getElementById('chartFullscreenOverlay');
  if (!overlay) return;
  
  // æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰æŒ‰éˆ•
  let confirmBtn = overlay.querySelector('#reportConfirmButton');
  if (confirmBtn) {
    confirmBtn.style.display = 'block';
    return;
  }
  
  // å‰µå»ºç¢ºèªæŒ‰éˆ•
  confirmBtn = document.createElement('button');
  confirmBtn.id = 'reportConfirmButton';
  confirmBtn.innerHTML = 'âœ… ç¢ºèªæˆªåœ–ç”Ÿæˆå ±å‘Š';
  confirmBtn.style.cssText = `
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 10005;
    background: linear-gradient(90deg, #36c74d, #28a745);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
  `;
  
  confirmBtn.onmouseover = function() {
    this.style.background = 'linear-gradient(90deg, #28a745, #1e7e34)';
    this.style.transform = 'scale(1.05)';
  };
  
  confirmBtn.onmouseout = function() {
    this.style.background = 'linear-gradient(90deg, #36c74d, #28a745)';
    this.style.transform = 'scale(1)';
  };
  
  confirmBtn.onclick = async function() {
    this.style.display = 'none';
    await continueGenerateReport();
  };
  
  overlay.appendChild(confirmBtn);
}

// æ–°å¢å‡½æ•¸ï¼šç¹¼çºŒç”Ÿæˆå ±å‘Šï¼ˆå¾æˆªåœ–é–‹å§‹ï¼‰
async function continueGenerateReport() {
  const exportRF = true;
  const exportGPS = true;
  const exportElevation = true;
  
  showExportStatus('ğŸ“ æ­£åœ¨ç”Ÿæˆå–®é å ±å‘Š...', 'loading');
  
  try {
    const { jsPDF } = window.jspdf;
    const title = document.getElementById('report_title').value || 'ç„¡ç·šé›»é€šè¨Šè·¯å¾‘åˆ†æå ±å‘Š';
    const project = document.getElementById('report_project').value;
    const author = document.getElementById('report_author').value;
    const date = new Date().toLocaleString('zh-TW', {
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit'
    });
    
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pdfWidth = 210;
    const pdfHeight = 297;
    const margin = 10;
    
    // é»‘è‰²èƒŒæ™¯
    pdf.setFillColor(11, 21, 38);
    pdf.rect(0, 0, pdfWidth, pdfHeight, 'F');
    
    let yPos = margin;
    
    // === 1. å ±å‘Šæ¨™é¡Œ ===
    const titleDiv = document.createElement('div');
    titleDiv.style.cssText = `
      background: #0b1526;
      padding: 15px;
      text-align: center;
      font-family: 'Microsoft JhengHei', sans-serif;
      width: ${(pdfWidth - 2 * margin) * 3.7795}px;
    `;
    titleDiv.innerHTML = `
      <div style="font-size: 20px; color: #5ff0d5; font-weight: bold; margin-bottom: 8px;">
        ${title}
      </div>
      ${project ? `<div style="font-size: 14px; color: #ffe58f; margin-bottom: 6px;">${project}</div>` : ''}
      <div style="font-size: 11px; color: #a8b3c3;">
        ${date}${author ? ' | ' + author : ''}
      </div>
    `;
    document.body.appendChild(titleDiv);
    
    const titleCanvas = await html2canvas(titleDiv, {
      backgroundColor: '#0b1526',
      scale: 1.5  // é™ä½è§£æåº¦ä»¥æ¸›å°æª”æ¡ˆå¤§å°
    });
    document.body.removeChild(titleDiv);
    
    const titleImgData = titleCanvas.toDataURL('image/png');
    const titleHeight = 25;
    pdf.addImage(titleImgData, 'PNG', margin, yPos, pdfWidth - 2 * margin, titleHeight);
    yPos += titleHeight + 5;
    
    // === 2. å‰–é¢åœ–å€åŸŸ ===
    if (exportElevation) {
      try {
        const overlay = document.getElementById('chartFullscreenOverlay');
        let chartImgData = null;
        
        if (overlay && overlay.classList.contains('active') && typeof fullscreenChartInstance !== 'undefined' && fullscreenChartInstance) {
          showExportStatus('ğŸ“¸ æ­£åœ¨æ“·å–å…¨ç•«é¢å‰–é¢åœ–...', 'loading');
          
          const controlsToHide = [
            overlay.querySelector('.chart-fullscreen-close'),
            overlay.querySelector('.chart-fullscreen-screenshot'),
            overlay.querySelector('.chart-fullscreen-rotate-toggle'),
            overlay.querySelector('.chart-fullscreen-info-toggle'),
            overlay.querySelector('.chart-fullscreen-obstruction-toggle'),
            overlay.querySelector('.chart-fullscreen-map-toggle'),
            overlay.querySelector('.chart-fullscreen-end-obstruction'),
            overlay.querySelector('.chart-fullscreen-max-obstruction'),
            overlay.querySelector('.chart-fullscreen-start-obstruction'),
            overlay.querySelector('.chart-fullscreen-point-control')
          ];
          
          const originalDisplayStates = controlsToHide.map(el => {
            if (el) {
              const display = el.style.display;
              el.style.display = 'none';
              return display;
            }
            return null;
          });
          
          await new Promise(resolve => setTimeout(resolve, 150));
          
          const canvas = await html2canvas(overlay, {
            backgroundColor: '#0b1526',
            scale: 1.5,  // é™ä½è§£æåº¦ä»¥æ¸›å°æª”æ¡ˆå¤§å°
            logging: false,
            useCORS: true
          });
          
          controlsToHide.forEach((el, index) => {
            if (el) el.style.display = originalDisplayStates[index] || '';
          });
          
          chartImgData = canvas.toDataURL('image/jpeg', 0.85);  // ä½¿ç”¨ JPEG æ ¼å¼ï¼Œå£“ç¸®å“è³ª 85%
          
        } else {
          const elevationChart = document.getElementById('elevationChart');
          if (elevationChart) {
            chartImgData = elevationChart.toDataURL('image/jpeg', 0.85);  // ä½¿ç”¨ JPEG æ ¼å¼
          }
        }
        
        if (chartImgData) {
          const chartHeight = 130;
          pdf.addImage(chartImgData, 'JPEG', margin, yPos, pdfWidth - 2 * margin, chartHeight);
          yPos += chartHeight + 5;
        }
        
      } catch (e) {
        console.error('åœ–è¡¨æ“·å–å¤±æ•—:', e);
        yPos += 5;
      }
    }
    
    // === 3. ä¸‰å€‹è³‡æ–™å€å¡Š (å·¦-ä¸­-å³) ===
    // è¨ˆç®—æ–¹ä½è§’å’Œä¿¯ä»°è§’
    function calculateAngles(lat1, lng1, alt1, lat2, lng2, alt2) {
      const toRad = deg => deg * Math.PI / 180;
      const toDeg = rad => rad * 180 / Math.PI;
      
      const Ï†1 = toRad(lat1);
      const Ï†2 = toRad(lat2);
      const Î”Î» = toRad(lng2 - lng1);
      
      // æ–¹ä½è§’ Aâ†’B
      const y = Math.sin(Î”Î») * Math.cos(Ï†2);
      const x = Math.cos(Ï†1) * Math.sin(Ï†2) - Math.sin(Ï†1) * Math.cos(Ï†2) * Math.cos(Î”Î»);
      let azimuthAtoB = toDeg(Math.atan2(y, x));
      azimuthAtoB = (azimuthAtoB + 360) % 360;
      
      // åæ–¹ä½è§’ Bâ†’A
      let azimuthBtoA = (azimuthAtoB + 180) % 360;
      
      // è·é›¢
      const R = 6371;
      const a = Math.sin((Ï†2 - Ï†1) / 2) ** 2 + 
                Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î» / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const distance = R * c;
      
      // ä¿¯ä»°è§’
      const heightDiff = alt2 - alt1;
      const distanceMeters = distance * 1000;
      const elevationAtoB = toDeg(Math.atan(heightDiff / distanceMeters));
      const elevationBtoA = -elevationAtoB;
      
      return { azimuthAtoB, azimuthBtoA, elevationAtoB, elevationBtoA, distance };
    }
    
    // è®€å–GPSè³‡æ–™
    const latA = parseFloat(document.getElementById('latA').value);
    const lonA = parseFloat(document.getElementById('lonA').value);
    const eleA = parseFloat(document.getElementById('eleA').value || 0);
    const nameA = document.getElementById('nameA').value || 'Aé»';
    
    const latB = parseFloat(document.getElementById('latB').value);
    const lonB = parseFloat(document.getElementById('lonB').value);
    const eleB = parseFloat(document.getElementById('eleB').value || 0);
    const nameB = document.getElementById('nameB').value || 'Bé»';
    
    // è¨ˆç®—è§’åº¦
    let angles = null;
    if (!isNaN(latA) && !isNaN(lonA) && !isNaN(latB) && !isNaN(lonB)) {
      angles = calculateAngles(latA, lonA, eleA, latB, lonB, eleB);
    }
    
    // è®€å–RFè³‡æ–™
    const freq = document.getElementById('link_freq_mhz').value;
    const dist = document.getElementById('link_dist_km').value;
    const linkBudgetOutput = document.getElementById('linkbudget_output');
    const rssiText = linkBudgetOutput ? linkBudgetOutput.textContent : '';
    
    // å‰µå»ºä¸‰å€‹å€å¡Šå®¹å™¨
    const threeBlocksDiv = document.createElement('div');
    threeBlocksDiv.style.cssText = `
      display: flex;
      gap: 8px;
      width: ${(pdfWidth - 2 * margin) * 3.7795}px;
      font-family: 'Microsoft JhengHei', sans-serif;
    `;
    
    // === å·¦å´å€å¡Š:Aé» + Aâ†’Bè§’åº¦ + ç™¼å°„ç«¯RFåƒæ•¸ ===
    const leftBlock = document.createElement('div');
    leftBlock.style.cssText = `
      flex: 1;
      background: rgba(20, 30, 50, 1);
      border: 2px solid #ff9500;
      border-radius: 8px;
      padding: 12px;
    `;
    
    let leftContent = `
      <div style="font-size: 15px; color: #ff9500; text-align: center; margin-bottom: 10px; font-weight: bold;">
        ğŸ“ ${nameA}
      </div>
    `;
    
    if (!isNaN(latA) && !isNaN(lonA)) {
      leftContent += `
        <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 5px;">
          åœ°å: <span style="color: #5ff0d5;">${nameA}</span>
        </div>
        <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 5px;">
          åº§æ¨™: <span style="color: #5ff0d5;">${latA.toFixed(6)}Â°N, ${lonA.toFixed(6)}Â°E</span>
        </div>
        <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 5px;">
          é«˜åº¦: <span style="color: #5ff0d5;">${eleA.toFixed(1)} m</span>
        </div>
      `;
    }
    
    // è®€å–å¤©ç·šé«˜åº¦
    const antennaHeightA = document.getElementById('antennaHeightStart').value;
    if (antennaHeightA) {
      leftContent += `
        <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 8px;">
          å¤©ç·šé«˜: <span style="color: #5ff0d5;">${antennaHeightA} m</span>
        </div>
      `;
    }
    
    if (angles) {
      leftContent += `
        <div style="background: rgba(95,240,213,0.1); padding: 8px; border-radius: 4px; margin-top: 8px;">
          <div style="font-size: 12px; color: #5ff0d5; margin-bottom: 6px; font-weight: bold;">${nameA} â†’ ${nameB} æ–¹å‘</div>
          <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 4px;">
            æ–¹ä½è§’: <span style="color: #5ff0d5;">${angles.azimuthAtoB.toFixed(1)}Â°</span>
          </div>
          <div style="font-size: 11px; color: #a8b3c3;">
            ä¿¯ä»°è§’: <span style="color: #5ff0d5;">${angles.elevationAtoB >= 0 ? '+' : ''}${angles.elevationAtoB.toFixed(2)}Â°</span>
          </div>
        </div>
      `;
    }
    
    // è®€å–ç™¼å°„ç«¯RFåƒæ•¸
    const txPower = document.getElementById('link_tx_power_input').value;
    const txPowerUnit = document.getElementById('link_tx_power_unit').value.toUpperCase();
    const txGain = document.getElementById('link_tx_gain_dbi').value;
    const txLoss = document.getElementById('link_tx_loss_db').value;
    
    if (txPower || txGain || txLoss) {
      leftContent += `
        <div style="background: rgba(77,171,247,0.1); padding: 8px; border-radius: 4px; margin-top: 8px;">
          <div style="font-size: 12px; color: #4dabf7; margin-bottom: 6px; font-weight: bold;">ç™¼å°„ç«¯ (Tx)</div>
      `;
      
      if (txPower) {
        leftContent += `
          <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 4px;">
            ç™¼å°„åŠŸç‡: <span style="color: #5ff0d5;">${txPower} ${txPowerUnit}</span>
          </div>
        `;
      }
      
      if (txGain) {
        leftContent += `
          <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 4px;">
            å¤©ç·šå¢ç›Š: <span style="color: #5ff0d5;">${txGain} dBi</span>
          </div>
        `;
      }
      
      if (txLoss) {
        leftContent += `
          <div style="font-size: 11px; color: #a8b3c3;">
            ç·šæ: <span style="color: #5ff0d5;">${txLoss} dB</span>
          </div>
        `;
      }
      
      leftContent += `</div>`;
    }
    
    leftBlock.innerHTML = leftContent;
    
    // === ä¸­é–“å€å¡Šï¼šRFè¨ˆç®— ===
    const centerBlock = document.createElement('div');
    centerBlock.style.cssText = `
      flex: 1;
      background: rgba(20, 30, 50, 1);
      border: 2px solid #5ff0d5;
      border-radius: 8px;
      padding: 12px;
    `;
    
    let centerContent = `
      <div style="font-size: 15px; color: #5ff0d5; text-align: center; margin-bottom: 10px; font-weight: bold;">
        ğŸ“¡ RFéˆè·¯è¨ˆç®—
      </div>
    `;
    
    if (freq) {
      centerContent += `
        <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 5px;">
          é »ç‡: <span style="color: #5ff0d5;">${freq} MHz</span>
        </div>
      `;
    }
    
    // è®€å–å‰–é¢åœ–è·é›¢æ•¸æ“šï¼ˆä½¿ç”¨ window.currentPathDataï¼‰
    let profileDistance = null;
    if (typeof window.currentPathData !== 'undefined' && window.currentPathData && window.currentPathData.length > 0) {
      const lastPoint = window.currentPathData[window.currentPathData.length - 1];
      if (lastPoint && lastPoint.dist !== undefined) {
        profileDistance = parseFloat(lastPoint.dist);
      }
    }
    
    // å„ªå…ˆä½¿ç”¨å‰–é¢åœ–è·é›¢ï¼Œå¦å‰‡ä½¿ç”¨RFå·¥å…·çš„è·é›¢
    const displayDistance = profileDistance !== null ? profileDistance.toFixed(2) : dist;
    
    if (displayDistance) {
      centerContent += `
        <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 8px;">
          è·é›¢: <span style="color: #5ff0d5;">${displayDistance} km</span>
        </div>
      `;
    }
    
    // è§£ææ¥æ”¶è¨Šè™Ÿå¼·åº¦
    const rssiMatch = rssiText.match(/æ¥æ”¶è¨Šè™Ÿå¼·åº¦:\s*([-+]?\d+\.?\d*)\s*dBm/);
    if (rssiMatch) {
      centerContent += `
        <div style="background: rgba(95,240,213,0.15); border: 1px solid #5ff0d5; border-radius: 4px; padding: 10px; text-align: center; margin-bottom: 8px;">
          <div style="font-size: 10px; color: #a8b3c3; margin-bottom: 3px;">ç„¡é®è”½ä¸‹æ¥æ”¶è¨Šè™Ÿå¼·åº¦</div>
          <div style="font-size: 16px; color: #5ff0d5; font-weight: bold;">${rssiMatch[1]} dBm</div>
        </div>
      `;
    }
    
    // åˆ¤æ–·è·¯å¾‘æ˜¯å¦æœ‰é®è”½
    if (elevationData && elevationData.length > 0 && chartInstance && chartInstance.data.datasets[1]) {
      const losLineData = chartInstance.data.datasets[1].data;
      let hasObstruction = false;
      
      // æª¢æŸ¥æ˜¯å¦æœ‰ä»»ä½•é®è”½é»
      for (let i = 1; i < elevationData.length - 1; i++) {
        const terrainHeight = elevationData[i];
        const losHeight = losLineData[i];
        const clearance = losHeight - terrainHeight;
        if (clearance < 0) {
          hasObstruction = true;
          break;
        }
      }
      
      // é¡¯ç¤ºé®è”½åˆ¤æ–·
      if (hasObstruction) {
        centerContent += `
          <div style="background: rgba(255,107,107,0.15); border: 1px solid #ff6b6b; border-radius: 4px; padding: 12px; margin-top: 2px; text-align: center;">
            <div style="font-size: 20px; color: #ff6b6b; font-weight: bold;">âš ï¸ æœ‰é®è”½</div>
          </div>
        `;
      } else {
        centerContent += `
          <div style="background: rgba(95,240,213,0.1); border: 1px solid #5ff0d5; border-radius: 4px; padding: 12px; margin-top: 2px; text-align: center;">
            <div style="font-size: 20px; color: #5ff0d5; font-weight: bold;">âœ“ ç„¡é®è”½</div>
          </div>
        `;
      }
    }
    
    centerBlock.innerHTML = centerContent;
    
    // === å³å´å€å¡Šï¼šBé» + Bâ†’Aè§’åº¦ + æ¥æ”¶ç«¯RFåƒæ•¸ ===
    const rightBlock = document.createElement('div');
    rightBlock.style.cssText = `
      flex: 1;
      background: rgba(20, 30, 50, 1);
      border: 2px solid #ff9500;
      border-radius: 8px;
      padding: 12px;
    `;
    
    let rightContent = `
      <div style="font-size: 15px; color: #ff9500; text-align: center; margin-bottom: 10px; font-weight: bold;">
        ğŸ“ ${nameB}
      </div>
    `;
    
    if (!isNaN(latB) && !isNaN(lonB)) {
      rightContent += `
        <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 5px;">
          åœ°å: <span style="color: #5ff0d5;">${nameB}</span>
        </div>
        <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 5px;">
          åº§æ¨™: <span style="color: #5ff0d5;">${latB.toFixed(6)}Â°N, ${lonB.toFixed(6)}Â°E</span>
        </div>
        <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 5px;">
          é«˜åº¦: <span style="color: #5ff0d5;">${eleB.toFixed(1)} m</span>
        </div>
      `;
    }
    
    // è®€å–å¤©ç·šé«˜åº¦
    const antennaHeightB = document.getElementById('antennaHeightEnd').value;
    if (antennaHeightB) {
      rightContent += `
        <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 8px;">
          å¤©ç·šé«˜: <span style="color: #5ff0d5;">${antennaHeightB} m</span>
        </div>
      `;
    }
    
    if (angles) {
      rightContent += `
        <div style="background: rgba(95,240,213,0.1); padding: 8px; border-radius: 4px; margin-top: 8px;">
          <div style="font-size: 12px; color: #5ff0d5; margin-bottom: 6px; font-weight: bold;">${nameB} â†’ ${nameA} æ–¹å‘</div>
          <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 4px;">
            æ–¹ä½è§’: <span style="color: #5ff0d5;">${angles.azimuthBtoA.toFixed(1)}Â°</span>
          </div>
          <div style="font-size: 11px; color: #a8b3c3;">
            ä¿¯ä»°è§’: <span style="color: #5ff0d5;">${angles.elevationBtoA >= 0 ? '+' : ''}${angles.elevationBtoA.toFixed(2)}Â°</span>
          </div>
        </div>
      `;
    }
    
    // è®€å–æ¥æ”¶ç«¯RFåƒæ•¸
    const rxGain = document.getElementById('link_rx_gain_dbi').value;
    const rxLoss = document.getElementById('link_rx_loss_db').value;
    
    if (rxGain || rxLoss) {
      rightContent += `
        <div style="background: rgba(77,171,247,0.1); padding: 8px; border-radius: 4px; margin-top: 8px;">
          <div style="font-size: 12px; color: #4dabf7; margin-bottom: 6px; font-weight: bold;">æ¥æ”¶ç«¯ (Rx)</div>
      `;
      
      if (rxGain) {
        rightContent += `
          <div style="font-size: 11px; color: #a8b3c3; margin-bottom: 4px;">
            å¤©ç·šå¢ç›Š: <span style="color: #5ff0d5;">${rxGain} dBi</span>
          </div>
        `;
      }
      
      if (rxLoss) {
        rightContent += `
          <div style="font-size: 11px; color: #a8b3c3;">
            ç·šæ: <span style="color: #5ff0d5;">${rxLoss} dB</span>
          </div>
        `;
      }
      
      rightContent += `</div>`;
    }
    
    rightBlock.innerHTML = rightContent;
    
    // çµ„åˆä¸‰å€‹å€å¡Š
    threeBlocksDiv.appendChild(leftBlock);
    threeBlocksDiv.appendChild(centerBlock);
    threeBlocksDiv.appendChild(rightBlock);
    
    // æ¸²æŸ“åˆ°PDF
    document.body.appendChild(threeBlocksDiv);
    
    const blocksCanvas = await html2canvas(threeBlocksDiv, {
      backgroundColor: null,
      scale: 1.5  // é™ä½è§£æåº¦ä»¥æ¸›å°æª”æ¡ˆå¤§å°
    });
    
    document.body.removeChild(threeBlocksDiv);
    
    const blocksImgData = blocksCanvas.toDataURL('image/png');
    const blocksHeight = 80;
    pdf.addImage(blocksImgData, 'PNG', margin, yPos, pdfWidth - 2 * margin, blocksHeight);
    
    // å„²å­˜PDF
    const fileName = `RFåˆ†æå ±å‘Š_${new Date().getTime()}.pdf`;
    pdf.save(fileName);
    showExportStatus('âœ… å–®é PDFå ±å‘Šå·²æˆåŠŸä¸‹è¼‰ï¼', 'success');
    
    // ğŸ¯ è‡ªå‹•é—œé–‰å‰–é¢åœ–å…¨å±
    const overlay = document.getElementById('chartFullscreenOverlay');
    if (overlay && overlay.classList.contains('active')) {
      console.log('ğŸ“‹ PDFç”Ÿæˆå®Œæˆï¼Œè‡ªå‹•é—œé–‰å…¨å±æ¨¡å¼...');
      setTimeout(() => {
        closeChartFullscreen();
        console.log('âœ… å…¨å±æ¨¡å¼å·²è‡ªå‹•é—œé–‰');
      }, 500);  // å»¶é² 0.5 ç§’å¾Œé—œé–‰ï¼Œè®“ä½¿ç”¨è€…çœ‹åˆ°æˆåŠŸè¨Šæ¯
    }
    
  } catch (error) {
    console.error('PDF ç”ŸæˆéŒ¯èª¤:', error);
    showExportStatus('âŒ PDF ç”Ÿæˆå¤±æ•—ï¼š' + error.message, 'error');
  }
}

function showExportStatus(message, type) {
  const status = document.getElementById('export_status');
  status.textContent = message;
  status.style.display = 'block';
  
  // è¨­å®šæ¨£å¼
  if (type === 'success') {
    status.style.background = 'rgba(39, 174, 96, 0.2)';
    status.style.color = '#27ae60';
    status.style.border = '1px solid #27ae60';
  } else if (type === 'error') {
    status.style.background = 'rgba(220, 53, 69, 0.2)';
    status.style.color = '#dc3545';
    status.style.border = '1px solid #dc3545';
  } else if (type === 'warning') {
    status.style.background = 'rgba(255, 193, 7, 0.2)';
    status.style.color = '#ffc107';
    status.style.border = '1px solid #ffc107';
  } else {
    status.style.background = 'rgba(255, 212, 59, 0.2)';
    status.style.color = '#ffd43b';
    status.style.border = '1px solid #ffd43b';
  }
  
  // æˆåŠŸæˆ–éŒ¯èª¤è¨Šæ¯ 3 ç§’å¾Œè‡ªå‹•æ¶ˆå¤±
  if (type === 'success' || type === 'error') {
    setTimeout(() => {
      status.style.display = 'none';
    }, 3000);
  }
}
</script>

<div id="archive-content" class="tab-content">
  <section class="card">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
      <h3 class="section-title" style="margin:0">ğŸ’¾ åƒæ•¸ä¿å­˜ / å‚™ä»½</h3>
      <div style="display:flex; gap:8px;">
        <button class="btn ghost" onclick="lsExport()" style="padding:5.6px 11.2px; font-size:16px; white-space:nowrap; flex-shrink:0;">åŒ¯å‡º</button>
        <button class="btn ghost" onclick="document.getElementById('ls_import').click()" style="padding:5.6px 11.2px; font-size:16px; white-space:nowrap; flex-shrink:0;">è®€å–</button>
        <input id="ls_import" type="file" accept="application/json" style="display:none" onchange="lsImport(event)">
      </div>
    </div>
    <div style="display:flex;gap:8px; margin-bottom:12px; align-items:center; flex-wrap:nowrap;">
      <div id="ls_name_container" style="flex:1;min-width:150px; position:relative; display:flex; align-items:center; justify-content:space-between; padding:8px 12px; font-size:16px; background:transparent; border-radius:6px; border:1px solid #ffffff;">
        <input id="ls_save_name" placeholder="è‡ªè¨‚åç¨±" style="border:none; background:transparent; outline:none; color:#ffffff; font-size:16px; padding:0; flex:1; min-width:60px;" oninput="updateNamePreview()">
        <span id="ls_name_suffix" style="color:rgba(255,255,255,0.5); font-size:16px; white-space:nowrap; margin-left:8px;"></span>
      </div>
    </div>
    <div style="display:flex; gap:8px; margin-bottom:12px; flex-wrap:nowrap;">
      <button class="btn" onclick="loadGpsNamesToArchive()" style="flex:1; padding:5.6px 11.2px; font-size:16px; white-space:nowrap; background: linear-gradient(90deg, #bb66ff, #9945ff); color: #fff;" title="å¾GPSåˆ†é è®€å–åœ°å">ğŸŒâ†”ï¸</button>
      <button id="los_toggle_btn" class="btn" onclick="toggleLosStatus()" style="flex:1; padding:5.6px 11.2px; font-size:16px; white-space:nowrap; background: linear-gradient(90deg, #95a5a6, #7f8c8d); color: #fff;" title="åˆ‡æ›ç‹€æ…‹ï¼šæœªæŒ‡å®š/è¦–è·/éè¦–è·">N/A</button>
      <button class="btn" onclick="lsSave()" style="flex:1; padding:5.6px 11.2px; font-size:16px; white-space:nowrap;" title="ä¿å­˜åƒæ•¸">ğŸ’¾</button>
    </div>
    <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px; flex-wrap:nowrap;">
      <label style="color:var(--label); font-size:15px; font-weight:600; white-space:nowrap;">ğŸ” æœå°‹ï¼š</label>
      <div style="flex:1; position:relative;">
        <input id="archive_search" type="text" placeholder="è¼¸å…¥å­˜æª”åç¨±..." oninput="lsLoadTable()" style="width:100%; padding:6px 30px 6px 10px; font-size:15px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);">
        <button onclick="clearArchiveSearch()" style="position:absolute; right:6px; top:50%; transform:translateY(-50%); background:none; border:none; color:rgba(255,255,255,0.4); cursor:pointer; font-size:18px; padding:0 4px; line-height:1;" title="æ¸…é™¤æœå°‹">Ã—</button>
      </div>
    </div>
    <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px; flex-wrap:nowrap;">
      <label style="color:var(--label); font-size:15px; font-weight:600; white-space:nowrap;">æ’åˆ—æ–¹å¼ï¼š</label>
      <select id="sort_order" onchange="lsLoadTable()" style="flex:1; padding:6px 10px; font-size:15px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);">
        <option value="time-new">æª”æ¡ˆ æ–° â®• èˆŠ</option>
        <option value="time-old">æª”æ¡ˆ èˆŠ â®• æ–°</option>
        <option value="name-az">åç¨± A â®• Z</option>
        <option value="name-za">åç¨± Z â®• A</option>
      </select>
    </div>
    <div style="overflow-x:auto;">
      <table style="width:100%; table-layout:fixed;">
        <thead>
          <tr>
            <th style="text-align:left; padding:8px 8px 8px 4px; width:75%;">åç¨±</th>
            <th style="text-align:center; padding:4px 2px; width:25%;">æ“ä½œ</th>
          </tr>
        </thead>
        <tbody id="ls_table"></tbody>
      </table>
    </div>
  </section>
</div>
</main>
<script>
const sectionIds = {
    'power': 'section-power',
    'matching': 'section-matching',
    'sensitivity': 'section-sensitivity',
    'los': 'section-los',
    'fspl': 'section-fspl',
    'linkbudget': 'section-linkbudget'
};
const defaultValues = {
    'section-power': {
        'power_input': '1',
        'power_unit': 'w',
    },
    'section-matching': {
        'matching_input_value': '20',
        'matching_unit': 'rl',
    },
    'section-sensitivity': {
        'sensitivity_bw': '1',
        'sensitivity_nf': '5',
        'sensitivity_sn': '10',
    },
    'section-los': {
        'los_g1': '0',
        'los_h1': '10',
        'los_g2': '0',
        'los_h2': '20',
    },
    'section-fspl': {
        'fspl_freq': '2400',
        'fspl_dist': '10',
    },
    'section-linkbudget': {
        'link_tx_power_input': '1',
        'link_tx_power_unit': 'w',
        'link_tx_loss_db': '3',
        'link_tx_gain_dbi': '20',
        'link_dist_km': '10',
        'link_freq_mhz': '2400',
        'link_rx_gain_dbi': '20',
        'link_rx_loss_db': '2',
    }
};
const calculationFunctions = {
    'section-power': 'calculateDbmWNew',
    'section-matching': 'calculateMatching',
    'section-sensitivity': 'calculateSensitivity',
    'section-los': 'calculateMaxLOS',
    'section-fspl': 'calculateFSPL',
    'section-linkbudget': 'calculateLinkBudget',
};
function getSectionControls(sectionId) {
    const sectionEl = document.getElementById(sectionId);
    if (!sectionEl) return [];
    const inputGroup = sectionEl.querySelector('.input-group-border');
    if (!inputGroup) return [];
    return Array.from(inputGroup.querySelectorAll('input, select')).filter(el => el.id);
}
function resetSection(sectionId) {
    const defaults = defaultValues[sectionId];
    if (defaults) {
        for (const id in defaults) {
            const element = document.getElementById(id);
            if (element) {
                element.value = defaults[id];
                if(element.tagName === 'INPUT') element.value = defaults[id];
            }
        }
    }
    const calcFunc = calculationFunctions[sectionId];
    if (calcFunc && typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}
function clearSection(sectionId) {
    const controls = getSectionControls(sectionId);
    const defaults = defaultValues[sectionId] || {};
    controls.forEach(element => {
        const id = element.id;
        if (element.tagName === 'INPUT') {
            element.value = '';
        } else if (element.tagName === 'SELECT') {
            if (defaults[id]) {
                element.value = defaults[id];
            } else {
                element.selectedIndex = 0;
            }
        }
    });
    const calcFunc = calculationFunctions[sectionId];
    if (calcFunc && typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}
function toggleSections() {
    const selector = document.getElementById('function_selector');
    const selectedValue = selector.value;
    const allSections = document.querySelectorAll('.section-item');
    allSections.forEach(section => {
        const sectionKey = Object.keys(sectionIds).find(key => sectionIds[key] === section.id);
        if (selectedValue === 'ALL') {
            section.style.display = 'block';
        } else if (sectionKey === selectedValue) {
            section.style.display = 'block';
        } else {
            section.style.display = 'none';
        }
    });
    if (selectedValue === 'ALL' || selectedValue === 'power') calculateDbmWNew();
    if (selectedValue === 'ALL' || selectedValue === 'matching') calculateMatching();
    if (selectedValue === 'ALL' || selectedValue === 'sensitivity') calculateSensitivity();
    if (selectedValue === 'ALL' || selectedValue === 'los') calculateMaxLOS();
    if (selectedValue === 'ALL' || selectedValue === 'fspl') calculateFSPL();
    if (selectedValue === 'ALL' || selectedValue === 'linkbudget') calculateLinkBudget();
}
function clearAndRecalculate(inputId, calcFunc) {
    const inputElement = document.getElementById(inputId);
    if (inputElement) {
        inputElement.value = '';
    }
    if (typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}
function convertPower(value, fromUnit, toUnit) {
    if (fromUnit === toUnit) return value;
    if (fromUnit === 'w' && toUnit === 'dbm') {
        return 10 * Math.log10(value * 1000);
    } else if (fromUnit === 'dbm' && toUnit === 'w') {
        return Math.pow(10, (value / 10) - 3);
    }
    return NaN;
}
let power_conv_last_unit = 'w';
function calculateDbmWNew() {
    const input = document.getElementById('power_input');
    const unit = document.getElementById('power_unit').value;
    const output = document.getElementById('power_output_result');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    const input_value = parseFloat(input.value);
    if (isNaN(input_value) || input.value.trim() === '') {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">è«‹è¼¸å…¥æ•¸å€¼</span>`;
        return;
    }
    if (unit === 'w' && input_value < 0) {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">åŠŸç‡ (W) å¿…é ˆ â‰¥ 0</span>`;
        return;
    }
    let result_value, result_unit;
    if (unit === 'w') {
        result_value = convertPower(input_value, 'w', 'dbm');
        result_unit = 'dBm';
        if (result_value === -Infinity) {
            output.innerHTML = `æ›ç®—çµæœ: <span class="result-value">-âˆ</span> <span style="color:${unit_color};">${result_unit}</span>`;
            return;
        }
    } else {
        result_value = convertPower(input_value, 'dbm', 'w');
        result_unit = 'W';
        if (result_value < 0) result_value = 0;
    }
    if (isNaN(result_value)) {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">è¼¸å…¥ç„¡æ•ˆ</span>`;
        return;
    } else {
        output.innerHTML = `æ›ç®—çµæœ: <span class="result-value">${result_value.toFixed(3)}</span> <span style="color:${unit_color};">${result_unit}</span>`;
    }
    power_conv_last_unit = unit;
}
function swapAndCalculate() {
    const input = document.getElementById('power_input');
    const current_unit = document.getElementById('power_unit').value;
    const input_value = parseFloat(input.value);
    if (!isNaN(input_value) && input.value.trim() !== '') {
        const new_value = convertPower(input_value, power_conv_last_unit, current_unit);
        if (!isNaN(new_value)) {
            if (current_unit === 'dbm' && new_value === -Infinity) {
            } else {
                input.value = new_value.toFixed(3);
            }
        } else {
        }
    }
    calculateDbmWNew();
}
let last_matching_unit = 'rl';
function getGammaFromValue(value, type) {
    if (type === 'rl') {
        if (value < 0) throw new Error("RL å¿…é ˆ â‰¥ 0 dB");
        return Math.pow(10, -value / 20);
    } else if (type === 'vswr') {
        if (value < 1) throw new Error("VSWR å¿…é ˆ â‰¥ 1");
        return (value - 1) / (value + 1);
    } else if (type === 'gamma') {
        if (value < 0 || value > 1) throw new Error("Î“ å¿…é ˆä»‹æ–¼ 0 åˆ° 1 ä¹‹é–“");
        return value;
    } else if (type === 'refl_pct') {
        if (value < 0 || value > 100) throw new Error("åå°„åŠŸç‡å¿…é ˆä»‹æ–¼ 0 åˆ° 100 ä¹‹é–“");
        return Math.sqrt(value / 100);
    } else if (type === 'pass_pct') {
        if (value < 0 || value > 100) throw new Error("é€šéåŠŸç‡å¿…é ˆä»‹æ–¼ 0 åˆ° 100 ä¹‹é–“");
        return Math.sqrt(1 - (value / 100));
    }
    return NaN;
}
function getValueFromGamma(gamma, type) {
    if (isNaN(gamma) || gamma === Infinity) return NaN;
    if (type === 'rl') {
        if (gamma === 0) return Infinity;
        return -20 * Math.log10(Math.abs(gamma));
    } else if (type === 'vswr') {
        if (gamma === 1) return Infinity;
        return (1 + Math.abs(gamma)) / (1 - Math.abs(gamma));
    } else if (type === 'gamma') {
        return Math.abs(gamma);
    } else if (type === 'refl_pct') {
        return Math.abs(gamma)**2 * 100;
    } else if (type === 'pass_pct') {
        return (1 - Math.abs(gamma)**2) * 100;
    }
    return NaN;
}
function swapAndConvertMatching() {
    const current_unit = document.getElementById('matching_unit').value;
    const input_element = document.getElementById('matching_input_value');
    const input_value = parseFloat(input_element.value);
    if (!isNaN(input_value) && input_element.value.trim() !== '') {
        let gamma_abs;
        try {
            gamma_abs = getGammaFromValue(input_value, last_matching_unit);
            if (!isNaN(gamma_abs)) {
                const new_value = getValueFromGamma(gamma_abs, current_unit);
                if (!isNaN(new_value) && new_value !== Infinity) {
                    const precision = (current_unit === 'rl' || current_unit === 'refl_pct' || current_unit === 'pass_pct') ? 2 : 4;
                    input_element.value = new_value.toFixed(precision);
                } else if (new_value === Infinity) {
                    input_element.value = '1';
                } else {
                    input_element.value = '';
                }
            } else {
                input_element.value = '';
            }
        } catch (error) {
             input_element.value = '';
        }
    }
    calculateMatching();
    last_matching_unit = current_unit;
}
function calculateMatching() {
    const input_type = document.getElementById('matching_unit').value;
    const input_element = document.getElementById('matching_input_value');
    const input_value = parseFloat(input_element.value);
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    const output_elements = {
        rl: document.getElementById('rl_val'),
        vswr: document.getElementById('vswr_val'),
        gamma: document.getElementById('gamma_val'),
        refl_pct: document.getElementById('refl_percent'),
        pass_pct: document.getElementById('pass_percent')
    };
    const empty_output = `<span style="color:${redColor};font-size:17px;">è«‹è¼¸å…¥æ•¸å€¼</span>`;
    Object.values(output_elements).forEach(el => el.innerHTML = '');
    if (isNaN(input_value) || input_element.value.trim() === '') {
        output_elements.rl.innerHTML = empty_output;
        return;
    }
    let gamma_abs;
    try {
        gamma_abs = getGammaFromValue(input_value, input_type);
    } catch (error) {
        output_elements.rl.innerHTML = `<span style="color:${redColor};font-size:17px;">${error.message}</span>`;
        return;
    }
    const rl_val = getValueFromGamma(gamma_abs, 'rl');
    const vswr_val = getValueFromGamma(gamma_abs, 'vswr');
    const gamma_val = getValueFromGamma(gamma_abs, 'gamma');
    const refl_pct = getValueFromGamma(gamma_abs, 'refl_pct');
    const pass_pct = getValueFromGamma(gamma_abs, 'pass_pct');
    const formatOutput = (value, unit, precision=2) => {
        if (value === Infinity) return `<span class="result-value">âˆ</span> <span style="color:${unit_color};">${unit}</span>`;
        if (isNaN(value)) return `<span style="color:${redColor};font-size:17px;">è¨ˆç®—éŒ¯èª¤</span>`;
        return `<span class="result-value">${value.toFixed(precision)}</span> <span style="color:${unit_color};">${unit}</span>`;
    }
    output_elements.rl.innerHTML = formatOutput(rl_val, 'dB');
    output_elements.vswr.innerText = vswr_val === Infinity ? 'âˆ' : vswr_val.toFixed(3);
    output_elements.gamma.innerText = gamma_val.toFixed(4);
    output_elements.refl_pct.innerHTML = formatOutput(refl_pct, '%');
    output_elements.pass_pct.innerHTML = formatOutput(pass_pct, '%');
    last_matching_unit = input_type;
}
const BOLTZMANN_K_J = 1.380649e-23;
const T_KELVIN = 290;
function calculateSensitivity() {
    const bw_mhz = parseFloat(document.getElementById('sensitivity_bw').value);
    const nf_db = parseFloat(document.getElementById('sensitivity_nf').value);
    const sn_db = parseFloat(document.getElementById('sensitivity_sn').value);
    const output = document.getElementById('sensitivity_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    if (isNaN(bw_mhz) || isNaN(nf_db) || isNaN(sn_db) || bw_mhz <= 0 || nf_db < 0) {
        output.innerHTML = `æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity): <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å€¼ (BW > 0, NF â‰¥ 0)</span>`;
        return;
    }
    const noise_floor_dbm = -114 + (10 * Math.log10(bw_mhz)) + nf_db;
    const sensitivity_dbm = noise_floor_dbm + sn_db;
    output.innerHTML = `
        æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity): <span class="result-value">${sensitivity_dbm.toFixed(2)}</span> <span style="color:${unit_color};">dBm</span><br>
        <span class="result-value-small">ç†±é›œè¨Šåœ°æ¿ (Noise Floor) Pn: ${noise_floor_dbm.toFixed(2)} dBm</span>
    `;
}
const K_FACTOR = 4 / 3;
const R_EARTH_KM = 6371;
function calculateMaxLOS() {
    const g1 = parseFloat(document.getElementById('los_g1').value) || 0;
    const h1 = parseFloat(document.getElementById('los_h1').value) || 0;
    const g2 = parseFloat(document.getElementById('los_g2').value) || 0;
    const h2 = parseFloat(document.getElementById('los_h2').value) || 0;
    const output = document.getElementById('los_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    if (h1 < 0 || h2 < 0) {
        output.innerHTML = `æœ€å¤§é€šè¦–è·é›¢: <span style="color:${redColor};">å¤©ç·šé«˜åº¦å¿…é ˆ â‰¥ 0</span>`;
        return;
    }
    const a1 = g1 + h1;
    const a2 = g2 + h2;
    if (a1 <= 0 || a2 <= 0) {
        output.innerHTML = `æœ€å¤§é€šè¦–è·é›¢: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (å¤©ç·šçµ•å°é«˜åº¦ > 0) æ•¸å€¼</span>`;
        return;
    }
    const R_eff = K_FACTOR * R_EARTH_KM;
    const d1_km = Math.sqrt(2 * R_eff * a1 / 1000);
    const d2_km = Math.sqrt(2 * R_eff * a2 / 1000);
    const max_los_km = d1_km + d2_km;
    output.innerHTML = `
        æœ€å¤§é€šè¦–è·é›¢: <span class="result-value">${max_los_km.toFixed(2)}</span> <span style="color:${unit_color};">km</span><br>
        <span class="result-value-small">Aé»è¦–è·: ${d1_km.toFixed(2)} km; Bé»è¦–è·: ${d2_km.toFixed(2)} km</span>
    `;
}
function calculateFSPL() {
    const freq_mhz = parseFloat(document.getElementById('fspl_freq').value);
    const dist_km = parseFloat(document.getElementById('fspl_dist').value);
    const output = document.getElementById('fspl_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    if (isNaN(freq_mhz) || isNaN(dist_km) || freq_mhz <= 0 || dist_km <= 0) {
        output.innerHTML = `è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL): <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (é »ç‡ > 0, è·é›¢ > 0) æ•¸å€¼</span>`;
        return;
    }
    const fspl_db = 32.44 + (20 * Math.log10(freq_mhz)) + (20 * Math.log10(dist_km));
    output.innerHTML = `è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL): <span class="result-value">${fspl_db.toFixed(2)}</span> <span style="color:${unit_color};">dB</span>`;
}
function calculateLinkBudget() {
    const freq_mhz = parseFloat(document.getElementById('link_freq_mhz').value);
    const dist_km = parseFloat(document.getElementById('link_dist_km').value);
    const tx_power_input = parseFloat(document.getElementById('link_tx_power_input').value);
    const tx_power_unit = document.getElementById('link_tx_power_unit').value;
    const tx_loss_db = parseFloat(document.getElementById('link_tx_loss_db').value) || 0;
    const tx_gain_dbi = parseFloat(document.getElementById('link_tx_gain_dbi').value) || 0;
    const rx_gain_dbi = parseFloat(document.getElementById('link_rx_gain_dbi').value) || 0;
    const rx_loss_db = parseFloat(document.getElementById('link_rx_loss_db').value) || 0;
    const output = document.getElementById('linkbudget_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    if (isNaN(freq_mhz) || isNaN(dist_km) || freq_mhz <= 0 || dist_km <= 0) {
        output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (é »ç‡ > 0, è·é›¢ > 0) æ•¸å€¼</span>`;
        return;
    }
    if (isNaN(tx_power_input) || (tx_power_unit === 'w' && tx_power_input < 0)) {
         output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ç™¼å°„åŠŸç‡</span>`;
         return;
    }
    const tx_power_dbm = convertPower(tx_power_input, tx_power_unit, 'dbm');
    if (isNaN(tx_power_dbm)) {
         output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">ç™¼å°„åŠŸç‡ (W) å¿…é ˆ > 0</span>`;
         return;
    }
    const fspl_db = 32.44 + (20 * Math.log10(freq_mhz)) + (20 * Math.log10(dist_km));
    const rx_power_dbm = tx_power_dbm - tx_loss_db + tx_gain_dbi - fspl_db + rx_gain_dbi - rx_loss_db;
    output.innerHTML = `
        æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span class="result-value">${rx_power_dbm.toFixed(2)}</span> <span style="color:${unit_color};">dBm</span><br>
        <span style="font-size:14px;color:var(--muted);">
            è·¯å¾‘æè€— (Path Loss): ${fspl_db.toFixed(2)} dB (FSPL) + ${(tx_loss_db + rx_loss_db).toFixed(2)} dB (ç·šæ) = ${(fspl_db + tx_loss_db + rx_loss_db).toFixed(2)} dB<br>
            ç™¼å°„ EIRP: ${(tx_power_dbm - tx_loss_db + tx_gain_dbi).toFixed(2)} dBm
        </span>
    `;
}
document.addEventListener('DOMContentLoaded', () => {
    window.elevationPointAName = 'Aé»';
    window.elevationPointBName = 'Bé»';
    toggleSections();
    console.log('âœ… å…¨å±€è®Šé‡å·²åˆå§‹åŒ–');
    console.log('window.elevationPointAName:', window.elevationPointAName);
    console.log('window.elevationPointBName:', window.elevationPointBName);
});
</script>  <script>
  function showTab(tabId) {
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
    const clickedButton = document.querySelector(`.tab-button[data-tab="${tabId}"]`);
    if(clickedButton) clickedButton.classList.add('active');
    const tabContent = document.getElementById(tabId + '-content');
    if(tabContent) tabContent.classList.add('active');
    if (tabId === 'rf') {
      compute();
    } else if (tabId === 'gps') {
      calculate();
    }
  }
  const cables = [
    { name: "LMR-600", a: 0.07555, b: 0.00026 },
    { name: "TCOM-600", a: 0.080075, b: 0.000256 },
    { name: "LMR-600-UF", a: 0.09066, b: 0.000312 },
    { name: "LMR-400", a: 0.12229, b: 0.00026 },
    { name: "LMR-400-UF", a: 0.146748, b: 0.000312 },
    { name: "M17/RG214", a: 0.21, b: 0.00126 },
    { name: "M17/RG142", a: 0.368, b: 0.0012 },
    { name: "LSSB-RG214", a: 0.191365, b: 0.001895 },
    { name: "LSSB-RG58", a: 0.444971, b: 0.003370 }
  ];
  let lastUnit = 'm';
  const FT_PER_METER = 3.28084;
  function calcAttenPer100ft(f,a,b){
    return a * Math.sqrt(f) + b * f;
  }
  function ftFromLength(len,unit){
    return unit === "ft" ? len : len * FT_PER_METER;
  }
  function convertLength() {
      const lenInput = document.getElementById("lenInput");
      let len = parseFloat(lenInput.value);
      const newUnit = document.getElementById("unit").value;
      if (isNaN(len) || len === 0) {
          lastUnit = newUnit;
          compute();
          return;
      }
      if (lastUnit === 'm' && newUnit === 'ft') {
          len *= FT_PER_METER;
      } else if (lastUnit === 'ft' && newUnit === 'm') {
          len /= FT_PER_METER;
      }
      lenInput.value = len.toFixed(2);
      lastUnit = newUnit;
      compute();
  }
  function powerPassPercent(db){
    return Math.pow(10, -db / 10) * 100;
  }
  function compute(){
    const f = parseFloat(document.getElementById("freq").value) || 0;
    const len = parseFloat(document.getElementById("lenInput").value) || 0;
    const unit = document.getElementById("unit").value || "m";
    const ftLen = ftFromLength(len, unit);
    const mLen = unit === "m" ? len : len / FT_PER_METER;
    let alternateDisplay;
    if (unit === "m") {
        alternateDisplay = `(${ftLen.toFixed(2)} ft)`;
    } else {
        alternateDisplay = `(${mLen.toFixed(2)} m)`;
    }
    document.getElementById("liveInputs").innerText =
      `${f} MHz â€¢ ${len.toFixed(2)} ${unit} ${alternateDisplay}`;
    lastUnit = unit;
    const results = cables.map(c=>{
      const per100 = calcAttenPer100ft(f, c.a, c.b);
      const total = per100 * (ftLen / 100);
      const pass = powerPassPercent(total);
      const loss = 100 - pass;
      return {
        name: c.name,
        total: Number(total.toFixed(6)),
        pass: pass,
        loss: loss
      };
    });
    results.sort((x,y)=> x.total - y.total);
    let html =
      "<table><thead><tr>" +
      "<th>ç·šæ</th>" +
      "<th>è¡°æ¸› (dB)</th>" +
      "<th>é€šéåŠŸç‡ (%)</th>" +
      "<th>è¡°æ¸›åŠŸç‡ (%)</th>" +
      "</tr></thead><tbody>";
    results.forEach(r=>{
      html += `
        <tr>
          <td class="name">${r.name}</td>
          <td class="value">${r.total.toFixed(3)}</td>
          <td class="percent">${r.pass.toFixed(1)}</td>
          <td class="percent">${r.loss.toFixed(1)}</td>
        </tr>`;
    });
    html += "</tbody></table>";
    document.getElementById("tableArea").innerHTML = html;
  }
  function clearRfInput(id) {
    document.getElementById(id).value = '';
    compute();
  }
  function resetRf(){
    document.getElementById("freq").value = 900;
    document.getElementById("lenInput").value = 10;
    document.getElementById("unit").value = "m";
    lastUnit = 'm';
    compute();
  }
  function clearRf(){
    document.getElementById("freq").value = "";
    document.getElementById("lenInput").value = "";
    document.getElementById("unit").value = "m";
    compute();
  }
  const R_KM = 6371;
  const tRad = a => a * (Math.PI / 180);
  const tDeg = r => r * (180 / Math.PI);
  const dToDMS = (id) => {
    const ddInput = document.getElementById(id);
    const dd = parseFloat(ddInput.value);
    if (isNaN(dd) || ddInput.value.trim() === '') {
        ['deg', 'min', 'sec'].forEach(s => document.getElementById(id + '_' + s).value = '');
        return;
    }
    const absDD = Math.abs(dd);
    const deg = Math.floor(absDD);
    let minFloat = (absDD - deg) * 60;
    const min = Math.floor(minFloat);
    let sec = (minFloat - min) * 60;
    sec = Number(sec.toFixed(2));
    let finalMin = min;
    let finalSec = sec;
    let finalDeg = deg;
    if (finalSec >= 60) {
      finalMin += Math.floor(finalSec / 60);
      finalSec = finalSec % 60;
      finalSec = Number(finalSec.toFixed(2));
    }
    if (finalMin >= 60) {
      finalDeg += Math.floor(finalMin / 60);
      finalMin = finalMin % 60;
    }
    document.getElementById(id + '_deg').value = (dd < 0 ? -finalDeg : finalDeg);
    document.getElementById(id + '_min').value = finalMin;
    document.getElementById(id + '_sec').value = finalSec.toFixed(2);
  };
  const dmsToD = (id) => {
    const d = parseFloat(document.getElementById(id + '_deg').value);
    const m = parseFloat(document.getElementById(id + '_min').value) || 0;
    const s = parseFloat(document.getElementById(id + '_sec').value) || 0;
    if (isNaN(d) && !m && !s) { document.getElementById(id).value = ''; return; }
    const sign = (d < 0) ? -1 : 1;
    const dd = sign * (Math.abs(d) + Math.abs(m) / 60 + Math.abs(s) / 3600);
    if (!isNaN(dd)) {
      document.getElementById(id).value = dd.toFixed(6);
    } else {
      document.getElementById(id).value = '';
    }
  };
  const clearCoord = (idPrefix) => {
    document.getElementById(idPrefix).value = '';
    ['deg', 'min', 'sec'].forEach(s => document.getElementById(idPrefix + '_' + s).value = '');
    calculate();
  };
  const clearElevation = (suffix) => {
    document.getElementById('ele' + suffix).value = '';
    calculate();
  };
  const clearNameOnly = (suffix) => {
    document.getElementById('name' + suffix).value = '';
  };
  const clearAllCoord = (suffix) => {
    const latPrefix = 'lat' + suffix;
    const lonPrefix = 'lon' + suffix;
    document.getElementById('name' + suffix).value = '';
    document.getElementById(latPrefix).value = '';
    ['deg', 'min', 'sec'].forEach(s => document.getElementById(latPrefix + '_' + s).value = '');
    document.getElementById(lonPrefix).value = '';
    ['deg', 'min', 'sec'].forEach(s => document.getElementById(lonPrefix + '_' + s).value = '');
    document.getElementById('ele' + suffix).value = '';
    calculate();
  };
  const resetGps = () => {
    document.getElementById('latA').value = '24.164547';
    document.getElementById('lonA').value = '120.641258';
    document.getElementById('eleA').value = '50';
    document.getElementById('nameA').value = 'åŒ—ä¸ƒè·¯';
    document.getElementById('latB').value = '23.877521';
    document.getElementById('lonB').value = '120.360578';
    document.getElementById('eleB').value = '2000';
    document.getElementById('nameB').value = 'ç«ç‡’å';
    const mode = document.getElementById('displayMode').value;
    if (mode === 'dms') {
        dToDMS('latA'); dToDMS('lonA'); dToDMS('latB'); dToDMS('lonB');
    }
    calculate();
  };
  const swapGpsCoordinates = () => {
    const tempNameA = document.getElementById('nameA').value;
    const tempLatA = document.getElementById('latA').value;
    const tempLonA = document.getElementById('lonA').value;
    const tempEleA = document.getElementById('eleA').value;
    const tempNameB = document.getElementById('nameB').value;
    const tempLatB = document.getElementById('latB').value;
    const tempLonB = document.getElementById('lonB').value;
    const tempEleB = document.getElementById('eleB').value;
    document.getElementById('nameA').value = tempNameB;
    document.getElementById('nameB').value = tempNameA;
    document.getElementById('latA').value = tempLatB;
    document.getElementById('lonA').value = tempLonB;
    document.getElementById('eleA').value = tempEleB;
    document.getElementById('latB').value = tempLatA;
    document.getElementById('lonB').value = tempLonA;
    document.getElementById('eleB').value = tempEleA;
    const mode = document.getElementById('displayMode').value;
    if (mode === 'dms') {
        dToDMS('latA');
        dToDMS('lonA');
        dToDMS('latB');
        dToDMS('lonB');
    }
    console.log('å·²äº¤æ› A å’Œ B çš„åº§æ¨™è³‡æ–™');
  };
  const clearAllGps = () => {
    clearAllCoord('A');
    clearAllCoord('B');
    document.getElementById('gpsRes').innerHTML = "é»æ“Šã€Œè¨ˆç®—ã€ä»¥é¡¯ç¤ºçµæœ";
    document.getElementById('gpsRes').classList.remove('gps-error');
  };
  const hDist = (lat1, lon1, lat2, lon2) => {
    const [rLat1, rLat2, dLat, dLon] = [tRad(lat1), tRad(lat2), tRad(lat2 - lat1), tRad(lon2 - lon1)];
    const a = Math.sin(dLat / 2)**2 + Math.cos(rLat1) * Math.cos(rLat2) * Math.sin(dLon / 2)**2;
    return R_KM * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  };
  const straightDist = (hD, eleA, eleB) => {
    const dH = (eleB - eleA) / 1000;
    return Math.sqrt(hD * hD + dH * dH);
  };
  const getBearing = (lat1, lon1, lat2, lon2) => {
    const [rL1, rL2, dLon] = [tRad(lat1), tRad(lat2), tRad(lon2 - lon1)];
    const y = Math.sin(dLon) * Math.cos(rL2);
    const x = Math.cos(rL1) * Math.sin(rL2) - Math.sin(rL1) * Math.cos(rL2) * Math.cos(dLon);
    return (tDeg(Math.atan2(y, x)) + 360) % 360;
  };
  const getPitch = (distKm, eleA, eleB) => {
    if (distKm === 0) return { pitchAB: 0, pitchBA: 0 };
    const [hA, hB] = [eleA / 1000, eleB / 1000];
    const offset = distKm**2 / (2 * R_KM);
    const H_AB = (hB - hA) - offset;
    const pitchAB = tDeg(Math.atan2(H_AB, distKm));
    const H_BA = (hA - hB) - offset;
    const pitchBA = tDeg(Math.atan2(H_BA, distKm));
    return { pitchAB, pitchBA };
  };
function showLoadingWithDots(elementId, message, eleInput = null) {
    if (eleInput) {
        const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
        const loadingSpan = document.getElementById(loadingId);
        if (loadingSpan) {
            loadingSpan.innerHTML = `${message}<span class="loading-dots"></span>`;
            loadingSpan.style.display = 'inline';
            eleInput.style.opacity = '0.5';
        }
    } else {
        const element = document.getElementById(elementId);
        element.innerHTML = `<span style="color: #ffd43b; font-weight: bold;">${message}<span class="loading-dots"></span></span>`;
        element.style.color = '#ffd43b';
        element.style.background = 'rgba(255, 215, 0, 0.1)';
    }
}
function getCurrentLocation(location) {
    console.log('getCurrentLocation() è¢«èª¿ç”¨ï¼Œåœ°é»:', location);
    if (!navigator.geolocation) {
        alert('âŒ æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´åœ°ç†å®šä½åŠŸèƒ½');
        return;
    }
    const latId = location === 'A' ? 'latA' : 'latB';
    const lonId = location === 'A' ? 'lonA' : 'lonB';
    const nameId = location === 'A' ? 'nameA' : 'nameB';
    const eleId = location === 'A' ? 'eleA' : 'eleB';
    const latInput = document.getElementById(latId);
    const lonInput = document.getElementById(lonId);
    const nameInput = document.getElementById(nameId);
    const eleInput = document.getElementById(eleId);
    const originalLatValue = latInput.value;
    const originalLonValue = lonInput.value;
    const originalNameValue = nameInput.value;
    const originalEleValue = eleInput.value;
    latInput.value = 'å®šä½ä¸­...';
    lonInput.value = 'å®šä½ä¸­...';
    nameInput.value = 'å–å¾—ä¸­...';
    eleInput.value = 'å–å¾—ä¸­...';
    latInput.disabled = true;
    lonInput.disabled = true;
    nameInput.disabled = true;
    eleInput.disabled = true;
    navigator.geolocation.getCurrentPosition(
        function(position) {
            const latitude = position.coords.latitude;
            const longitude = position.coords.longitude;
            latInput.value = latitude.toFixed(6);
            lonInput.value = longitude.toFixed(6);
            latInput.disabled = false;
            lonInput.disabled = false;
            nameInput.disabled = false;
            eleInput.disabled = false;
            updateDMSFromDecimal(latId);
            updateDMSFromDecimal(lonId);
            console.log('åœ°é» ' + location + ' åº§æ¨™å·²æ›´æ–°: ç·¯åº¦=' + latitude + ', ç¶“åº¦=' + longitude);
            getLocationNameAndShowDialog(latitude, longitude, location, nameId, eleId);
        },
        function(error) {
            latInput.value = originalLatValue;
            lonInput.value = originalLonValue;
            nameInput.value = originalNameValue;
            eleInput.value = originalEleValue;
            latInput.disabled = false;
            lonInput.disabled = false;
            nameInput.disabled = false;
            eleInput.disabled = false;
            let errorMessage = 'âŒ ç„¡æ³•ç²å–ä½ç½®: ';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage += 'ä½¿ç”¨è€…æ‹’çµ•äº†åœ°ç†å®šä½è«‹æ±‚';
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMessage += 'ä½ç½®è³‡è¨Šä¸å¯ç”¨';
                    break;
                case error.TIMEOUT:
                    errorMessage += 'è«‹æ±‚è¶…æ™‚';
                    break;
                default:
                    errorMessage += 'æœªçŸ¥éŒ¯èª¤';
                    break;
            }
            alert(errorMessage);
            console.error('åœ°ç†å®šä½éŒ¯èª¤:', error);
        },
        {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
        }
    );
}
function openMapPicker(location) {
    console.log('openMapPicker() è¢«èª¿ç”¨ï¼Œåœ°é»:', location);
    
    // è™•ç†æŒ‡åŒ—é‡çš„ç‰¹æ®Šæƒ…æ³
    let currentLat, currentLon;
    if (location === 'COMPASS') {
        currentLat = window.tempCompassLat || 25.0336;
        currentLon = window.tempCompassLng || 121.5648;
        console.log('ä½¿ç”¨æŒ‡åŒ—é‡è‡¨æ™‚åº§æ¨™:', currentLat, currentLon);
    } else {
        const latId = location === 'A' ? 'latA' : 'latB';
        const lonId = location === 'A' ? 'lonA' : 'lonB';
        currentLat = document.getElementById(latId).value || 25.0336;
        currentLon = document.getElementById(lonId).value || 121.5648;
    }
    
    var mapPickerHTML = '<!DOCTYPE html><html><head><meta charset="utf-8">';
    mapPickerHTML += '<meta name="viewport" content="width=device-width, initial-scale=1">';
    mapPickerHTML += '<title>é¸æ“‡åœ°é» ' + (location === 'COMPASS' ? 'æŒ‡åŒ—é‡ä½ç½®' : location) + ' çš„åº§æ¨™</title>';
    mapPickerHTML += '<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />';
    mapPickerHTML += '<style>* { margin: 0; padding: 0; box-sizing: border-box; }';
    mapPickerHTML += 'body { font-family: Arial, sans-serif; overflow: hidden; }';
    mapPickerHTML += '#map { width: 100vw; height: calc(100vh - 130px); position: absolute; top: 130px; }';
    mapPickerHTML += '#info-bar { position: fixed; top: 0; left: 0; right: 0; height: 60px;';
    mapPickerHTML += 'background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: white;';
    mapPickerHTML += 'display: flex; align-items: center; justify-content: space-between;';
    mapPickerHTML += 'padding: 0 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 1000; }';
    mapPickerHTML += '#search-bar { position: fixed; top: 60px; left: 0; right: 0; height: 70px;';
    mapPickerHTML += 'background: #f8f9fa; display: flex; flex-direction: column; gap: 6px;';
    mapPickerHTML += 'padding: 8px 12px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 1000; }';
    mapPickerHTML += '.search-row { display: flex; gap: 8px; align-items: center; }';
    mapPickerHTML += '#search-input { flex: 1; padding: 8px 12px; border: 2px solid #ddd;';
    mapPickerHTML += 'border-radius: 6px; font-size: 14px; min-width: 0; }';
    mapPickerHTML += '.search-btn { background: linear-gradient(90deg, #ff9500, #ffcc00);';
    mapPickerHTML += 'border: none; padding: 8px 12px; border-radius: 6px; font-weight: bold;';
    mapPickerHTML += 'color: #000; cursor: pointer; font-size: 13px; white-space: nowrap; flex-shrink: 0; }';
    mapPickerHTML += '.layer-btn { background: linear-gradient(90deg, #9b59b6, #8e44ad);';
    mapPickerHTML += 'border: none; padding: 8px 12px; border-radius: 6px; font-weight: bold;';
    mapPickerHTML += 'color: #fff; cursor: pointer; font-size: 13px; white-space: nowrap; flex-shrink: 0; }';
    mapPickerHTML += '#coords { font-size: 12px; font-weight: bold; color: #5ff0d5; }';
    mapPickerHTML += '.btn { background: linear-gradient(90deg, #79a8ff, #5ff0d5); border: none;';
    mapPickerHTML += 'padding: 10px 16px; border-radius: 6px; font-weight: bold; color: #022;';
    mapPickerHTML += 'cursor: pointer; font-size: 14px; }';
    mapPickerHTML += '#instruction { position: fixed; top: 140px; left: 50%; transform: translateX(-50%);';
    mapPickerHTML += 'background: rgba(255, 255, 255, 0.95); padding: 8px 16px; border-radius: 8px;';
    mapPickerHTML += 'box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 1000; font-size: 12px;';
    mapPickerHTML += 'color: #333; font-weight: bold; max-width: 90%; text-align: center; }';
    mapPickerHTML += '#results-panel { position: fixed; top: 140px; right: 10px; width: 320px; max-width: calc(100vw - 20px);';
    mapPickerHTML += 'height: auto; max-height: calc(100vh - 160px); background: white; border-radius: 8px;';
    mapPickerHTML += 'box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 1001; display: none;';
    mapPickerHTML += 'flex-direction: column; }';
    mapPickerHTML += '#results-list { flex: 1; overflow-y: scroll; overflow-x: hidden; -webkit-overflow-scrolling: touch;';
    mapPickerHTML += 'min-height: 100px; max-height: calc(100vh - 220px); padding-bottom: 80px; }';
    mapPickerHTML += '.results-header { padding: 12px 15px; background: linear-gradient(90deg, #ff9500, #ffcc00);';
    mapPickerHTML += 'color: #000; font-weight: bold; font-size: 14px; display: flex;';
    mapPickerHTML += 'justify-content: space-between; align-items: center; border-radius: 8px 8px 0 0;';
    mapPickerHTML += 'flex-shrink: 0; }';
    mapPickerHTML += '.close-results { background: none; border: none; font-size: 20px; cursor: pointer;';
    mapPickerHTML += 'color: #000; padding: 0; width: 24px; height: 24px; }';
    mapPickerHTML += '.result-item { padding: 12px 15px; border-bottom: 1px solid #eee;';
    mapPickerHTML += 'cursor: pointer; transition: background 0.2s; touch-action: manipulation; }';
    mapPickerHTML += '.result-item:hover { background: #f0f8ff; }';
    mapPickerHTML += '.result-item:active { background: #d0e8ff; }';
    mapPickerHTML += '.result-item:last-child { border-bottom: none; padding-bottom: 20px; }';
    mapPickerHTML += '.result-name { font-weight: bold; color: #333; margin-bottom: 4px; font-size: 14px; }';
    mapPickerHTML += '.result-address { font-size: 12px; color: #666; line-height: 1.4; }';
    mapPickerHTML += '.no-results { padding: 20px; text-align: center; color: #999; margin-bottom: 60px; }';
    mapPickerHTML += '.leaflet-control-attribution { font-size: 10px; }</style></head><body>';
    mapPickerHTML += '<div id="info-bar"><div style="flex: 1; min-width: 0;">';
    mapPickerHTML += '<div style="font-size: 15px; font-weight: bold; margin-bottom: 2px;">' + (location === 'COMPASS' ? 'æŒ‡åŒ—é‡ä½ç½®' : 'åœ°é» ' + location) + '</div>';
    mapPickerHTML += '<div id="coords">ç·¯åº¦: -- | ç¶“åº¦: --</div>';
    mapPickerHTML += '<div id="elevation" style="color: #ffd43b; font-size: 12px; margin-top: 2px;">é«˜åº¦: -- m</div></div>';
    mapPickerHTML += '<button class="btn" onclick="confirmSelection()">âœ“ ç¢ºèª</button></div>';
    mapPickerHTML += '<div id="search-bar">';
    mapPickerHTML += '<div class="search-row">';
    mapPickerHTML += '<input type="text" id="search-input" placeholder="è¼¸å…¥åœ°å€æˆ–åœ°åï¼ˆä¾‹å¦‚ï¼šç«è»Šç«™ã€101ï¼‰">';
    mapPickerHTML += '<button class="search-btn" onclick="searchLocation()">ğŸ”</button></div>';
    mapPickerHTML += '<div class="search-row">';
    mapPickerHTML += '<button class="layer-btn" onclick="toggleLayer()" id="layer-toggle" style="flex: 1;">ğŸ—ºï¸ è¡—é“åœ–</button></div></div>';
    mapPickerHTML += '<div id="instruction">ğŸ‘† é»æ“Šåœ°åœ–æˆ–æœå°‹åœ°å€</div>';
    mapPickerHTML += '<div id="results-panel">';
    mapPickerHTML += '<div class="results-header">æœå°‹çµæœ <button class="close-results" onclick="closeResults()">Ã—</button></div>';
    mapPickerHTML += '<div id="results-list"></div></div>';
    mapPickerHTML += '<div id="map"></div>';
    mapPickerHTML += '<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"><\/script>';
    mapPickerHTML += '<script>';
    mapPickerHTML += 'var map, marker, currentLayer; var selectedLat = ' + currentLat + ', selectedLng = ' + currentLon + ', selectedName = null, selectedElevation = null;';
    mapPickerHTML += 'var center = [' + currentLat + ', ' + currentLon + '];';
    mapPickerHTML += 'map = L.map("map").setView(center, 15);';
    mapPickerHTML += 'document.getElementById("coords").innerHTML = "ç·¯åº¦: " + selectedLat.toFixed(6) + " | ç¶“åº¦: " + selectedLng.toFixed(6);';
    mapPickerHTML += 'fetchElevation(selectedLat, selectedLng);';
    mapPickerHTML += 'marker = L.marker([selectedLat, selectedLng]).addTo(map);';
    mapPickerHTML += 'document.getElementById("instruction").style.display = "none";';
    mapPickerHTML += 'var streetLayer = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {';
    mapPickerHTML += 'attribution: "Â© OpenStreetMap", maxZoom: 19 });';
    mapPickerHTML += 'var satelliteLayer = L.tileLayer("http://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", {';
    mapPickerHTML += 'attribution: "Â© Google Maps", maxZoom: 20, subdomains: ["0", "1", "2", "3"] });';
    mapPickerHTML += 'var earthLayer = L.tileLayer("http://mt{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}", {';
    mapPickerHTML += 'attribution: "Â© Google Earth", maxZoom: 20, subdomains: ["0", "1", "2", "3"] });';
    mapPickerHTML += 'var hybridLayer = L.layerGroup([';
    mapPickerHTML += 'L.tileLayer("http://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", {';
    mapPickerHTML += 'attribution: "Â© Google Maps", maxZoom: 20, subdomains: ["0", "1", "2", "3"] }),';
    mapPickerHTML += 'L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {';
    mapPickerHTML += 'opacity: 0.3, maxZoom: 19 })';
    mapPickerHTML += ']);';
    mapPickerHTML += 'var nlscLayer = L.tileLayer("https://wmts.nlsc.gov.tw/wmts/PHOTO2/default/GoogleMapsCompatible/{z}/{y}/{x}", {';
    mapPickerHTML += 'attribution: "Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ", maxZoom: 19 });';
    mapPickerHTML += 'currentLayer = "street"; streetLayer.addTo(map);';
    mapPickerHTML += 'function toggleLayer() {';
    mapPickerHTML += 'var btn = document.getElementById("layer-toggle");';
    mapPickerHTML += 'if (currentLayer === "street") {';
    mapPickerHTML += 'map.removeLayer(streetLayer); satelliteLayer.addTo(map);';
    mapPickerHTML += 'currentLayer = "satellite"; btn.innerHTML = "ğŸ›°ï¸ è¡›æ˜Ÿåœ–";';
    mapPickerHTML += '} else if (currentLayer === "satellite") {';
    mapPickerHTML += 'map.removeLayer(satelliteLayer); earthLayer.addTo(map);';
    mapPickerHTML += 'currentLayer = "earth"; btn.innerHTML = "ğŸŒ åœ°å½¢åœ–";';
    mapPickerHTML += '} else if (currentLayer === "earth") {';
    mapPickerHTML += 'map.removeLayer(earthLayer); hybridLayer.addTo(map);';
    mapPickerHTML += 'currentLayer = "hybrid"; btn.innerHTML = "ğŸ”€ æ··åˆåœ–";';
    mapPickerHTML += '} else if (currentLayer === "hybrid") {';
    mapPickerHTML += 'map.removeLayer(hybridLayer); nlscLayer.addTo(map);';
    mapPickerHTML += 'currentLayer = "nlsc"; btn.innerHTML = "ğŸ›©ï¸ èˆªç…§åœ–";';
    mapPickerHTML += '} else {';
    mapPickerHTML += 'map.removeLayer(nlscLayer); streetLayer.addTo(map);';
    mapPickerHTML += 'currentLayer = "street"; btn.innerHTML = "ğŸ—ºï¸ è¡—é“åœ–";';
    mapPickerHTML += '} }';
    mapPickerHTML += 'map.on("click", function(e) {';
    mapPickerHTML += 'selectedLat = e.latlng.lat; selectedLng = e.latlng.lng; selectedName = null; selectedElevation = null;';
    mapPickerHTML += 'document.getElementById("coords").innerHTML = "ç·¯åº¦: " + selectedLat.toFixed(6) + " | ç¶“åº¦: " + selectedLng.toFixed(6);';
    mapPickerHTML += 'document.getElementById("elevation").innerHTML = "é«˜åº¦: <span style=\\"color:#ffd43b;\\">æŸ¥è©¢ä¸­...</span>";';
    mapPickerHTML += 'fetchElevation(selectedLat, selectedLng);';
    mapPickerHTML += 'if (marker) { map.removeLayer(marker); }';
    mapPickerHTML += 'marker = L.marker([selectedLat, selectedLng]).addTo(map);';
    mapPickerHTML += 'document.getElementById("instruction").style.display = "none"; });';
    mapPickerHTML += 'function searchLocation() {';
    mapPickerHTML += 'var query = document.getElementById("search-input").value.trim();';
    mapPickerHTML += 'if (!query) { alert("è«‹è¼¸å…¥åœ°å€æˆ–åœ°å"); return; }';
    mapPickerHTML += 'document.getElementById("instruction").style.display = "none";';
    mapPickerHTML += 'document.getElementById("results-list").innerHTML = "<div class=\\"no-results\\">ğŸ” æ™ºèƒ½æœå°‹ä¸­...<br><small>æ­£åœ¨ä½¿ç”¨å¤šå€‹è³‡æ–™ä¾†æº</small></div>";';
    mapPickerHTML += 'document.getElementById("results-panel").style.display = "flex";';
    mapPickerHTML += 'var allResults = [];';
    mapPickerHTML += 'var searchPromises = [];';
    mapPickerHTML += 'var isCommonPlace = /ç«è»Šç«™|è»Šç«™|æ©Ÿå ´|æ¸¯å£|ç¢¼é ­|é†«é™¢|å¤§å­¸|å…¬åœ’|å¤œå¸‚|è€è¡—/i.test(query);';
    mapPickerHTML += 'var limitPerQuery = isCommonPlace ? 10 : 5;';
    mapPickerHTML += 'var isTaiwanAddress = /[ç¸£å¸‚å€é„‰é®æ‘é‡Œè·¯è¡—æ®µå··å¼„è™Ÿ]/i.test(query);';
    mapPickerHTML += 'function cleanAddress(addr) {';
    mapPickerHTML += '  return addr.replace(/ç¬¬?\\d+é„°/g, "").replace(/[\\s]+/g, " ").trim();';
    mapPickerHTML += '}';
    mapPickerHTML += 'function generateAddressVariations(addr) {';
    mapPickerHTML += '  var variations = [addr];';
    mapPickerHTML += '  var cleaned = cleanAddress(addr);';
    mapPickerHTML += '  if (cleaned !== addr) variations.push(cleaned);';
    mapPickerHTML += '  var withoutHao = addr.replace(/è™Ÿ$/g, "");';
    mapPickerHTML += '  if (withoutHao !== addr) {';
    mapPickerHTML += '    variations.push(withoutHao);';
    mapPickerHTML += '    variations.push(cleanAddress(withoutHao));';
    mapPickerHTML += '  }';
    mapPickerHTML += '  var withHao = addr.match(/\\d+$/) ? addr + "è™Ÿ" : addr;';
    mapPickerHTML += '  if (withHao !== addr) {';
    mapPickerHTML += '    variations.push(withHao);';
    mapPickerHTML += '    variations.push(cleanAddress(withHao));';
    mapPickerHTML += '  }';
    mapPickerHTML += '  var normalized1 = addr.replace(/å°/g, "è‡º");';
    mapPickerHTML += '  var normalized2 = addr.replace(/è‡º/g, "å°");';
    mapPickerHTML += '  if (normalized1 !== addr) {';
    mapPickerHTML += '    variations.push(normalized1);';
    mapPickerHTML += '    variations.push(normalized1.replace(/è™Ÿ$/g, ""));';
    mapPickerHTML += '  }';
    mapPickerHTML += '  if (normalized2 !== addr) {';
    mapPickerHTML += '    variations.push(normalized2);';
    mapPickerHTML += '    variations.push(normalized2.replace(/è™Ÿ$/g, ""));';
    mapPickerHTML += '  }';
    mapPickerHTML += '  var cityMatch = addr.match(/^(.+?[ç¸£å¸‚])(.+)$/);';
    mapPickerHTML += '  if (cityMatch) {';
    mapPickerHTML += '    var remainder = cityMatch[2].trim();';
    mapPickerHTML += '    variations.push(remainder);';
    mapPickerHTML += '    variations.push(remainder.replace(/è™Ÿ$/g, ""));';
    mapPickerHTML += '    var districtMatch = cityMatch[2].match(/^(.+?[å€é„‰é®å¸‚])(.+)$/);';
    mapPickerHTML += '    if (districtMatch) {';
    mapPickerHTML += '      var street = districtMatch[2].trim();';
    mapPickerHTML += '      variations.push(cityMatch[1] + " " + districtMatch[1] + " " + street);';
    mapPickerHTML += '      variations.push(districtMatch[1] + " " + street);';
    mapPickerHTML += '      variations.push(street);';
    mapPickerHTML += '      variations.push(street.replace(/è™Ÿ$/g, ""));';
    mapPickerHTML += '      var streetOnly = districtMatch[2].match(/^([^0-9]+)/);';
    mapPickerHTML += '      if (streetOnly) {';
    mapPickerHTML += '        variations.push(streetOnly[1].trim());';
    mapPickerHTML += '        variations.push(streetOnly[1].trim().replace(/è™Ÿ$/g, ""));';
    mapPickerHTML += '      }';
    mapPickerHTML += '    }';
    mapPickerHTML += '  }';
    mapPickerHTML += '  var noNumbers = addr.replace(/\\d+è™Ÿ?/g, "").replace(/ç¬¬?\\d+é„°/g, "").trim();';
    mapPickerHTML += '  if (noNumbers !== addr && noNumbers.length > 3) variations.push(noNumbers);';
    mapPickerHTML += '  return [...new Set(variations)];';
    mapPickerHTML += '}';
    mapPickerHTML += 'var taiwanQueries = [];';
    mapPickerHTML += 'if (isTaiwanAddress) {';
    mapPickerHTML += '  taiwanQueries = generateAddressVariations(query);';
    mapPickerHTML += '  console.log("åœ°å€è®Šé«”:", taiwanQueries);';
    mapPickerHTML += '} else {';
    mapPickerHTML += '  taiwanQueries = [query + ", å°ç£", query + ", Taiwan", query];';
    mapPickerHTML += '}';
    mapPickerHTML += 'taiwanQueries.slice(0, 3).forEach(function(searchQuery) {';
    mapPickerHTML += 'searchPromises.push(';
    mapPickerHTML += 'fetch("https://nominatim.openstreetmap.org/search?format=json&q=" + encodeURIComponent(searchQuery) + "&countrycodes=tw&limit=" + limitPerQuery + "&addressdetails=1&accept-language=zh-TW")';
    mapPickerHTML += '.then(r => r.json()).then(data => data.map(item => ({...item, source: "OSM"})))';
    mapPickerHTML += '.catch(e => [])';
    mapPickerHTML += '); });';
    mapPickerHTML += 'searchPromises.push(';
    mapPickerHTML += 'fetch("https://photon.komoot.io/api/?q=" + encodeURIComponent(query + " taiwan") + "&limit=" + (limitPerQuery * 2) + "&lang=zh")';
    mapPickerHTML += '.then(r => r.json()).then(data => {';
    mapPickerHTML += 'if (data.features) {';
    mapPickerHTML += 'return data.features.map(f => ({';
    mapPickerHTML += 'lat: f.geometry.coordinates[1],';
    mapPickerHTML += 'lon: f.geometry.coordinates[0],';
    mapPickerHTML += 'display_name: f.properties.name + (f.properties.city ? ", " + f.properties.city : "") + (f.properties.country ? ", " + f.properties.country : ""),';
    mapPickerHTML += 'type: f.properties.type || "place",';
    mapPickerHTML += 'source: "Photon"';
    mapPickerHTML += '})); }';
    mapPickerHTML += 'return []; }).catch(e => [])';
    mapPickerHTML += ');';
    mapPickerHTML += 'searchPromises.push(';
    mapPickerHTML += 'fetch("https://api.locationiq.com/v1/autocomplete.php?key=pk.0f147952a41c555a5b70614039fd148b&q=" + encodeURIComponent(query) + "&countrycodes=tw&limit=" + limitPerQuery + "&format=json&accept-language=zh")';
    mapPickerHTML += '.then(r => r.json()).then(data => data.map(item => ({...item, source: "LocationIQ"})))';
    mapPickerHTML += '.catch(e => [])';
    mapPickerHTML += ');';
    mapPickerHTML += 'if (isTaiwanAddress) {';
    mapPickerHTML += '  var addressVariations = generateAddressVariations(query);';
    mapPickerHTML += '  addressVariations.slice(0, 5).forEach(function(addr) {';
    mapPickerHTML += '    searchPromises.push(';
    mapPickerHTML += '      fetch("https://nominatim.openstreetmap.org/search?format=json&q=" + encodeURIComponent(addr) + "&countrycodes=tw&limit=8&addressdetails=1&accept-language=zh-TW")';
    mapPickerHTML += '      .then(r => r.json()).then(data => data.map(item => ({...item, source: "OSM-Address", searchVariant: addr})))';
    mapPickerHTML += '      .catch(e => [])';
    mapPickerHTML += '    );';
    mapPickerHTML += '  });';
    mapPickerHTML += '  var mainAddr = cleanAddress(query);';
    mapPickerHTML += '  searchPromises.push(';
    mapPickerHTML += '    fetch("https://nominatim.openstreetmap.org/search?format=json&street=" + encodeURIComponent(mainAddr) + "&country=taiwan&limit=10&addressdetails=1")';
    mapPickerHTML += '    .then(r => r.json()).then(data => data.map(item => ({...item, source: "OSM-Street"})))';
    mapPickerHTML += '    .catch(e => [])';
    mapPickerHTML += '  );';
    mapPickerHTML += '  var geocodeQueries = [query, mainAddr, query.replace(/å°/g, "è‡º"), query.replace(/è‡º/g, "å°")];';
    mapPickerHTML += '  geocodeQueries.slice(0, 2).forEach(function(geoQuery) {';
    mapPickerHTML += '    searchPromises.push(';
    mapPickerHTML += '      fetch("https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates?f=json&outFields=*&maxLocations=5&address=" + encodeURIComponent(geoQuery) + "&countryCode=TWN")';
    mapPickerHTML += '      .then(r => r.json()).then(data => {';
    mapPickerHTML += '        if (data.candidates && data.candidates.length > 0) {';
    mapPickerHTML += '          return data.candidates.map(c => ({';
    mapPickerHTML += '            lat: c.location.y,';
    mapPickerHTML += '            lon: c.location.x,';
    mapPickerHTML += '            display_name: c.address || geoQuery,';
    mapPickerHTML += '            type: "address",';
    mapPickerHTML += '            source: "ArcGIS",';
    mapPickerHTML += '            score: c.score || 0';
    mapPickerHTML += '          }));';
    mapPickerHTML += '        }';
    mapPickerHTML += '        return [];';
    mapPickerHTML += '      }).catch(e => [])';
    mapPickerHTML += '    );';
    mapPickerHTML += '  });';
    mapPickerHTML += '  searchPromises.push(';
    mapPickerHTML += '    fetch("https://api.nlsc.gov.tw/other/TownVillagePointQuery/" + encodeURIComponent(mainAddr) + "/4326/JSON")';
    mapPickerHTML += '    .then(r => r.json()).then(data => {';
    mapPickerHTML += '      if (data && Array.isArray(data) && data.length > 0) {';
    mapPickerHTML += '        return data.map(item => ({';
    mapPickerHTML += '          lat: parseFloat(item.y || item.Y),';
    mapPickerHTML += '          lon: parseFloat(item.x || item.X),';
    mapPickerHTML += '          display_name: query,';
    mapPickerHTML += '          type: "address",';
    mapPickerHTML += '          source: "NLSC-TW"';
    mapPickerHTML += '        }));';
    mapPickerHTML += '      }';
    mapPickerHTML += '      return [];';
    mapPickerHTML += '    }).catch(e => [])';
    mapPickerHTML += '  );';
    mapPickerHTML += '}';
    mapPickerHTML += 'Promise.all(searchPromises).then(function(results) {';
    mapPickerHTML += 'results.forEach(function(data) {';
    mapPickerHTML += 'if (data && Array.isArray(data)) {';
    mapPickerHTML += 'data.forEach(function(item) {';
    mapPickerHTML += 'if (!item.lat || !item.lon) return;';
    mapPickerHTML += 'var itemLat = parseFloat(item.lat);';
    mapPickerHTML += 'var itemLon = parseFloat(item.lon);';
    mapPickerHTML += 'if (isNaN(itemLat) || isNaN(itemLon)) return;';
    mapPickerHTML += 'var isDuplicate = allResults.some(function(existing) {';
    mapPickerHTML += 'return Math.abs(existing.lat - itemLat) < 0.0005 && Math.abs(existing.lon - itemLon) < 0.0005; });';
    mapPickerHTML += 'if (!isDuplicate) {';
    mapPickerHTML += 'allResults.push({';
    mapPickerHTML += 'lat: itemLat,';
    mapPickerHTML += 'lon: itemLon,';
    mapPickerHTML += 'display_name: item.display_name || item.name || "æœªçŸ¥åœ°é»",';
    mapPickerHTML += 'type: item.type || item.osm_type || "place",';
    mapPickerHTML += 'source: item.source || "Unknown"';
    mapPickerHTML += '}); }';
    mapPickerHTML += '}); }});';
    mapPickerHTML += 'allResults.sort(function(a, b) {';
    mapPickerHTML += 'var aScore = 0, bScore = 0;';
    mapPickerHTML += 'var queryLower = query.toLowerCase().trim();';
    mapPickerHTML += 'var aName = (a.name || a.display_name.split(",")[0]).toLowerCase().trim();';
    mapPickerHTML += 'var bName = (b.name || b.display_name.split(",")[0]).toLowerCase().trim();';
    mapPickerHTML += 'var aFullName = a.display_name.toLowerCase().trim();';
    mapPickerHTML += 'var bFullName = b.display_name.toLowerCase().trim();';
    mapPickerHTML += 'if (isTaiwanAddress) {';
    mapPickerHTML += '  if (a.source === "ArcGIS" && a.score > 90) aScore += 3500;';
    mapPickerHTML += '  if (b.source === "ArcGIS" && b.score > 90) bScore += 3500;';
    mapPickerHTML += '  if (a.source === "ArcGIS") aScore += 3000;';
    mapPickerHTML += '  if (b.source === "ArcGIS") bScore += 3000;';
    mapPickerHTML += '  if (a.source === "NLSC-TW") aScore += 2800;';
    mapPickerHTML += '  if (b.source === "NLSC-TW") bScore += 2800;';
    mapPickerHTML += '  if ((a.type === "house" || a.type === "building" || a.type === "address") && aFullName.includes(queryLower)) aScore += 2000;';
    mapPickerHTML += '  if ((b.type === "house" || b.type === "building" || b.type === "address") && bFullName.includes(queryLower)) bScore += 2000;';
    mapPickerHTML += '  if (a.source === "OSM-Street") aScore += 1800;';
    mapPickerHTML += '  if (b.source === "OSM-Street") bScore += 1800;';
    mapPickerHTML += '  if (a.source === "OSM-Address") aScore += 1500;';
    mapPickerHTML += '  if (b.source === "OSM-Address") bScore += 1500;';
    mapPickerHTML += '  if (a.searchVariant && a.searchVariant.length < query.length) aScore += 500;';
    mapPickerHTML += '  if (b.searchVariant && b.searchVariant.length < query.length) bScore += 500;';
    mapPickerHTML += '}';
    mapPickerHTML += 'if (aName === queryLower || aFullName === queryLower) aScore += 1000;';
    mapPickerHTML += 'if (bName === queryLower || bFullName === queryLower) bScore += 1000;';
    mapPickerHTML += 'if (aName.indexOf(queryLower) === 0 && aName.length - queryLower.length <= 5) aScore += 800;';
    mapPickerHTML += 'if (bName.indexOf(queryLower) === 0 && bName.length - queryLower.length <= 5) bScore += 800;';
    mapPickerHTML += 'if (aName.indexOf(queryLower) === 0) aScore += 500;';
    mapPickerHTML += 'if (bName.indexOf(queryLower) === 0) bScore += 500;';
    mapPickerHTML += 'if (aFullName.indexOf(queryLower) === 0) aScore += 300;';
    mapPickerHTML += 'if (bFullName.indexOf(queryLower) === 0) bScore += 300;';
    mapPickerHTML += 'var aWords = aName.split(/[\\s,()ï¼ˆï¼‰]+/);';
    mapPickerHTML += 'var bWords = bName.split(/[\\s,()ï¼ˆï¼‰]+/);';
    mapPickerHTML += 'for (var i = 0; i < aWords.length; i++) { if (aWords[i] === queryLower) { aScore += 700; break; } }';
    mapPickerHTML += 'for (var i = 0; i < bWords.length; i++) { if (bWords[i] === queryLower) { bScore += 700; break; } }';
    mapPickerHTML += 'if (aName.includes(queryLower)) aScore += 200;';
    mapPickerHTML += 'if (bName.includes(queryLower)) bScore += 200;';
    mapPickerHTML += 'if (aFullName.includes(queryLower)) aScore += 100;';
    mapPickerHTML += 'if (bFullName.includes(queryLower)) bScore += 100;';
    mapPickerHTML += 'if (a.type === "station" || a.type === "railway" || a.type === "railway_station") aScore += 50;';
    mapPickerHTML += 'if (b.type === "station" || b.type === "railway" || b.type === "railway_station") bScore += 50;';
    mapPickerHTML += 'if (a.type === "building" || a.type === "amenity" || a.type === "house" || a.type === "address") aScore += 30;';
    mapPickerHTML += 'if (b.type === "building" || b.type === "amenity" || b.type === "house" || b.type === "address") bScore += 30;';
    mapPickerHTML += 'if (a.type === "city" || a.type === "town" || a.type === "village") aScore += 10;';
    mapPickerHTML += 'if (b.type === "city" || b.type === "town" || b.type === "village") bScore += 10;';
    mapPickerHTML += 'if (aScore === bScore) {';
    mapPickerHTML += 'if (a.source === "OSM" && b.source !== "OSM") aScore += 5;';
    mapPickerHTML += 'if (b.source === "OSM" && a.source !== "OSM") bScore += 5;';
    mapPickerHTML += 'if (aName.length < bName.length) aScore += 3;';
    mapPickerHTML += 'if (bName.length < aName.length) bScore += 3;';
    mapPickerHTML += '}';
    mapPickerHTML += 'return bScore - aScore; });';
    mapPickerHTML += 'if (allResults.length === 0) {';
    mapPickerHTML += 'document.getElementById("results-list").innerHTML = ';
    mapPickerHTML += '"<div class=\\"no-results\\">æ‰¾ä¸åˆ° \\"" + query + "\\"<br><br>ğŸ’¡ æœå°‹å»ºè­°ï¼š<br>â€¢ å®Œæ•´åœ°å€æ ¼å¼ï¼š<br>ã€€å°åŒ—å¸‚ä¿¡ç¾©å€å¸‚åºœè·¯1è™Ÿ<br>â€¢ çœç•¥é„°è™Ÿå¾Œå†è©¦ï¼š<br>ã€€ç§»é™¤ã€Œç¬¬Xé„°ã€ç­‰æ–‡å­—<br>â€¢ åªè¼¸å…¥ä¸»è¦é“è·¯ï¼š<br>ã€€å¸‚åºœè·¯<br>â€¢ è©¦è©¦å°/è‡ºçš„ä¸åŒå¯«æ³•<br>â€¢ æˆ–ç›´æ¥åœ¨åœ°åœ–ä¸Šé»æ“Šä½ç½®</div>";';
    mapPickerHTML += 'return; }';
    mapPickerHTML += 'var html = "";';
    mapPickerHTML += 'var maxDisplay = isCommonPlace ? 20 : 15;';
    mapPickerHTML += 'var displayCount = Math.min(allResults.length, maxDisplay);';
    mapPickerHTML += 'for (var i = 0; i < displayCount; i++) {';
    mapPickerHTML += 'var item = allResults[i];';
    mapPickerHTML += 'var name = item.display_name.split(",")[0];';
    mapPickerHTML += 'var address = item.display_name;';
    mapPickerHTML += 'var typeLabel = "";';
    mapPickerHTML += 'if (item.type === "city") typeLabel = " ğŸ™ï¸";';
    mapPickerHTML += 'else if (item.type === "town") typeLabel = " ğŸ˜ï¸";';
    mapPickerHTML += 'else if (item.type === "village") typeLabel = " ğŸ¡";';
    mapPickerHTML += 'else if (item.type === "building") typeLabel = " ğŸ¢";';
    mapPickerHTML += 'else if (item.type === "amenity") typeLabel = " ğŸ“";';
    mapPickerHTML += 'var sourceBadge = "<small style=\\"color:#999;font-size:10px;\\"> [" + item.source + "]</small>";';
    mapPickerHTML += 'html += "<div class=\\"result-item\\" onclick=\\"selectResult(" + item.lat + "," + item.lon + ",\\047" + name.replace(/"/g, "&quot;").replace(/\'/g, "\\047") + "\\047)\\">";';
    mapPickerHTML += 'html += "<div class=\\"result-name\\">" + name + typeLabel + sourceBadge + "</div>";';
    mapPickerHTML += 'html += "<div class=\\"result-address\\">" + address + "</div></div>"; }';
    mapPickerHTML += 'if (allResults.length > displayCount) {';
    mapPickerHTML += 'html += "<div class=\\"no-results\\" style=\\"background:#f0f8ff;color:#333;padding:10px;\\">é¡¯ç¤ºå‰ " + displayCount + " å€‹çµæœï¼ˆå…±æ‰¾åˆ° " + allResults.length + " å€‹ï¼‰</div>"; }';
    mapPickerHTML += 'document.getElementById("results-list").innerHTML = html;';
    mapPickerHTML += '}).catch(function(e) {';
    mapPickerHTML += 'document.getElementById("results-list").innerHTML = "<div class=\\"no-results\\">âŒ æœå°‹å¤±æ•—<br><br>" + e.message + "</div>";';
    mapPickerHTML += '}); }';
    mapPickerHTML += 'function selectResult(lat, lng, name) {';
    mapPickerHTML += 'map.setView([lat, lng], 16);';
    mapPickerHTML += 'selectedLat = lat; selectedLng = lng; selectedName = name; selectedElevation = null;';
    mapPickerHTML += 'document.getElementById("coords").innerHTML = "ç·¯åº¦: " + lat.toFixed(6) + " | ç¶“åº¦: " + lng.toFixed(6);';
    mapPickerHTML += 'document.getElementById("elevation").innerHTML = "é«˜åº¦: <span style=\\"color:#ffd43b;\\">æŸ¥è©¢ä¸­...</span>";';
    mapPickerHTML += 'fetchElevation(lat, lng);';
    mapPickerHTML += 'if (marker) { map.removeLayer(marker); }';
    mapPickerHTML += 'marker = L.marker([lat, lng]).addTo(map).bindPopup(name).openPopup();';
    mapPickerHTML += 'closeResults(); }';
    mapPickerHTML += 'function closeResults() {';
    mapPickerHTML += 'document.getElementById("results-panel").style.display = "none"; }';
    mapPickerHTML += 'document.getElementById("search-input").addEventListener("keypress", function(e) {';
    mapPickerHTML += 'if (e.key === "Enter") { searchLocation(); } });';
    mapPickerHTML += 'async function fetchElevation(lat, lng) {';
    mapPickerHTML += '  var elevDiv = document.getElementById("elevation");';
    mapPickerHTML += '  if (lat < 21.5 || lat > 25.5 || lng < 119.5 || lng > 122.5) {';
    mapPickerHTML += '    elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#ff6b6b;\\">è¶…å‡ºç¯„åœ</span> <span style=\\"font-size:10px; color:#aaa;\\">(åƒ…æ”¯æ´å°ç£åœ°å€)</span>";';
    mapPickerHTML += '    return;';
    mapPickerHTML += '  }';
    mapPickerHTML += '  try {';
    mapPickerHTML += '    if (!window.GeoTIFF) {';
    mapPickerHTML += '      elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#ffd43b;\\">è¼‰å…¥ä¸­...</span>";';
    mapPickerHTML += '      var script = document.createElement("script");';
    mapPickerHTML += '      script.src = "https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.min.js";';
    mapPickerHTML += '      document.head.appendChild(script);';
    mapPickerHTML += '      await new Promise(function(resolve, reject) {';
    mapPickerHTML += '        script.onload = resolve;';
    mapPickerHTML += '        script.onerror = reject;';
    mapPickerHTML += '      });';
    mapPickerHTML += '    }';
    mapPickerHTML += '    elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#ffd43b;\\">æŸ¥è©¢ä¸­...</span>";';
    mapPickerHTML += '    var tiff = null;';
    mapPickerHTML += '    var cogFilename = "taiwan_dsm_wgs84_cog.tif";';
    mapPickerHTML += '    try {';
    mapPickerHTML += '      tiff = await GeoTIFF.fromUrl(cogFilename);';
    mapPickerHTML += '    } catch (err) {';
    mapPickerHTML += '      var githubUrl = "https://sulapon.github.io/GPS/taiwan_dsm_wgs84_cog.tif";';
    mapPickerHTML += '      tiff = await GeoTIFF.fromUrl(githubUrl);';
    mapPickerHTML += '    }';
    mapPickerHTML += '    var image = await tiff.getImage();';
    mapPickerHTML += '    var bbox = image.getBoundingBox();';
    mapPickerHTML += '    var width = image.getWidth();';
    mapPickerHTML += '    var height = image.getHeight();';
    mapPickerHTML += '    var pixelX = Math.floor((lng - bbox[0]) / (bbox[2] - bbox[0]) * width);';
    mapPickerHTML += '    var pixelY = Math.floor((bbox[3] - lat) / (bbox[3] - bbox[1]) * height);';
    mapPickerHTML += '    if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {';
    mapPickerHTML += '      var rasters = await image.readRasters({ window: [pixelX, pixelY, pixelX + 1, pixelY + 1] });';
    mapPickerHTML += '      var elevation = rasters[0][0];';
    mapPickerHTML += '      if (elevation === null || elevation === undefined || isNaN(elevation)) {';
    mapPickerHTML += '        throw new Error("è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨");';
    mapPickerHTML += '      }';
    mapPickerHTML += '      selectedElevation = Math.round(parseFloat(elevation));';
    mapPickerHTML += '      elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#5ff0d5; font-weight:bold;\\">" + selectedElevation + " m</span> <span style=\\"font-size:10px; color:#aaa;\\">(å…§æ”¿éƒ¨ DSM 20m)</span>";';
    mapPickerHTML += '    } else {';
    mapPickerHTML += '      throw new Error("åº§æ¨™è¶…å‡º DSM è³‡æ–™ç¯„åœ");';
    mapPickerHTML += '    }';
    mapPickerHTML += '  } catch (error) {';
    mapPickerHTML += '    console.error("å–å¾—é«˜åº¦å¤±æ•—:", error);';
    mapPickerHTML += '    selectedElevation = null;';
    mapPickerHTML += '    elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#ff6b6b;\\">ç„¡æ³•å–å¾—</span> <span style=\\"font-size:10px; color:#aaa;\\">(è«‹ç¢ºèªç¶²è·¯é€£ç·š)</span>";';
    mapPickerHTML += '  }';
    mapPickerHTML += '}';
    mapPickerHTML += 'function confirmSelection() {';
    mapPickerHTML += 'if (selectedLat === null || selectedLng === null) {';
    mapPickerHTML += 'alert("âŒ è«‹å…ˆé»æ“Šåœ°åœ–æˆ–æœå°‹ä½ç½®"); return; }';
    mapPickerHTML += 'if (window.opener && !window.opener.closed) {';
    mapPickerHTML += 'window.opener.receiveMapCoordinates("' + location + '", selectedLat, selectedLng, selectedName);';
    mapPickerHTML += 'window.close(); } else { alert("âŒ ç„¡æ³•èˆ‡ä¸»è¦–çª—é€šè¨Š"); } }';
    mapPickerHTML += '<\/script></body></html>';
    var width = Math.min(900, window.screen.width - 50);
    var height = Math.min(700, window.screen.height - 50);
    var left = (window.screen.width - width) / 2;
    var top = (window.screen.height - height) / 2;
    var mapPickerWindow = window.open('', 'mapPicker',
        'width=' + width + ',height=' + height + ',left=' + left + ',top=' + top + ',toolbar=no,location=no,menubar=no');
    if (mapPickerWindow) {
        mapPickerWindow.document.write(mapPickerHTML);
        mapPickerWindow.document.close();
    } else {
        alert('âŒ ç„¡æ³•æ‰“é–‹åœ°åœ–è¦–çª—ï¼Œè«‹å…è¨±å½ˆå‡ºè¦–çª—');
    }
}
function receiveMapCoordinates(location, lat, lng, searchedName) {
    console.log('receiveMapCoordinates() è¢«èª¿ç”¨: åœ°é»=' + location + ', ç·¯åº¦=' + lat + ', ç¶“åº¦=' + lng + ', æœå°‹åœ°å=' + searchedName);
    
    // ç‰¹æ®Šè™•ç†ï¼šå¦‚æœæ˜¯æŒ‡åŒ—é‡èª¿ç”¨
    if (location === 'COMPASS') {
        console.log('æª¢æ¸¬åˆ°æŒ‡åŒ—é‡èª¿ç”¨ï¼Œè½‰ç™¼è‡³ receiveCompassMapCoordinates');
        if (window.receiveCompassMapCoordinates) {
            window.receiveCompassMapCoordinates(lat, lng, searchedName);
        }
        return;
    }
    
    // åŸæœ‰çš„GPSåˆ†é è™•ç†é‚è¼¯
    const latId = location === 'A' ? 'latA' : 'latB';
    const lonId = location === 'A' ? 'lonA' : 'lonB';
    const nameId = location === 'A' ? 'nameA' : 'nameB';
    const eleId = location === 'A' ? 'eleA' : 'eleB';
    document.getElementById(latId).value = lat.toFixed(6);
    document.getElementById(lonId).value = lng.toFixed(6);
    updateDMSFromDecimal(latId);
    updateDMSFromDecimal(lonId);
    console.log('åœ°é» ' + location + ' åº§æ¨™å·²å¾åœ°åœ–æ›´æ–°');
    if (searchedName && searchedName.trim() !== '') {
        let locationName = searchedName.trim();
        if (locationName.length > 5) {
            locationName = locationName.substring(0, 5);
        }
        document.getElementById(nameId).value = locationName;
        console.log('ä½¿ç”¨æœå°‹åœ°å:', locationName);
        showLocationUpdateDialog(location, lat, lng, locationName, eleId);
        setTimeout(() => {
            getElevationAutomatic(lat, lng, location, eleId);
        }, 100);
    } else {
        getLocationNameAndShowDialog(lat, lng, location, nameId, eleId);
    }
}
async function getLocationNameAndShowDialog(lat, lng, location, nameId, eleId) {
    const nameInput = document.getElementById(nameId);
    showLocationUpdateDialog(location, lat, lng, 'å–å¾—ä¸­...', eleId);
    try {
        console.log('é–‹å§‹åå‘åœ°ç†ç·¨ç¢¼: ', lat, lng);
        const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=zh-TW`
        );
        if (!response.ok) {
            throw new Error('åå‘åœ°ç†ç·¨ç¢¼è«‹æ±‚å¤±æ•—');
        }
        const data = await response.json();
        console.log('åå‘åœ°ç†ç·¨ç¢¼çµæœ:', data);
        if (data && data.address) {
            let locationName = '';
            if (data.name && data.name.trim() !== '' &&
                !data.name.match(/^[0-9\-]+$/) &&
                data.name.length <= 20) {
                locationName = data.name;
                console.log('ä½¿ç”¨åœ°é»åç¨±(name):', locationName);
            }
            else if (data.address.building &&
                     data.address.building.trim() !== '' &&
                     !data.address.building.match(/^(yes|house|residential|commercial|retail|apartments|office)$/i)) {
                locationName = data.address.building;
                console.log('ä½¿ç”¨å»ºç¯‰ç‰©åç¨±:', locationName);
            }
            else if (data.address.amenity) {
                locationName = data.address.amenity;
                console.log('ä½¿ç”¨è¨­æ–½åç¨±:', locationName);
            }
            else if (data.address.road) {
                locationName = data.address.road;
                console.log('ä½¿ç”¨é“è·¯åç¨±:', locationName);
            }
            else if (data.address.village || data.address.hamlet || data.address.suburb) {
                locationName = data.address.village || data.address.hamlet || data.address.suburb;
                console.log('ä½¿ç”¨æ‘é‡Œåç¨±:', locationName);
            }
            else if (data.address.town || data.address.city_district) {
                locationName = data.address.town || data.address.city_district;
                console.log('ä½¿ç”¨é„‰é®å¸‚å€:', locationName);
            }
            else if (data.address.city || data.address.county || data.address.state) {
                locationName = data.address.city || data.address.county || data.address.state;
                console.log('ä½¿ç”¨ç¸£å¸‚åç¨±:', locationName);
            }
            else if (data.display_name) {
                const parts = data.display_name.split(',');
                locationName = parts[0].trim();
                console.log('ä½¿ç”¨é¡¯ç¤ºåç¨±:', locationName);
            }
            if (locationName.length > 5) {
                locationName = locationName.substring(0, 5);
            }
            if (locationName) {
                nameInput.value = locationName;
                console.log('åœ°åå·²æ›´æ–°:', locationName);
                updateDialogLocationName(locationName);
            } else {
                throw new Error('ç„¡æ³•å–å¾—åœ°å');
            }
        } else {
            throw new Error('åå‘åœ°ç†ç·¨ç¢¼ç„¡çµæœ');
        }
    } catch (error) {
        console.error('å–å¾—åœ°åå¤±æ•—:', error);
        const simpleName = `é»${location}`;
        nameInput.value = simpleName;
        updateDialogLocationName(`é»${location} (æœªå–å¾—åœ°å)`);
    }
    setTimeout(() => {
        getElevationAutomatic(lat, lng, location, eleId);
    }, 100);
}
function updateDialogLocationName(locationName) {
    if (currentUpdateDialog) {
        const dialog = currentUpdateDialog;
        const innerHTML = dialog.innerHTML;
        const updatedHTML = innerHTML.replace(
            /åœ°å: <span style="color: #fbbf24;">.*?<\/span>/,
            `åœ°å: <span style="color: #fbbf24;">${locationName}</span>`
        );
        dialog.innerHTML = updatedHTML;
    }
}
function updateDMSFromDecimal(coordId) {
    const decimalInput = document.getElementById(coordId);
    const decimalValue = parseFloat(decimalInput.value);
    if (isNaN(decimalValue)) return;
    const isNegative = decimalValue < 0;
    const absValue = Math.abs(decimalValue);
    const degrees = Math.floor(absValue);
    const minutesDecimal = (absValue - degrees) * 60;
    const minutes = Math.floor(minutesDecimal);
    const seconds = (minutesDecimal - minutes) * 60;
    const degInput = document.getElementById(coordId + '_deg');
    const minInput = document.getElementById(coordId + '_min');
    const secInput = document.getElementById(coordId + '_sec');
    if (degInput) degInput.value = isNegative ? -degrees : degrees;
    if (minInput) minInput.value = minutes;
    if (secInput) secInput.value = seconds.toFixed(2);
}
async function getElevationFromSRTM(location) {
    console.log('getElevationFromSRTM() è¢«èª¿ç”¨ï¼Œåœ°é»:', location);
    const latId = location === 'A' ? 'latA' : 'latB';
    const lonId = location === 'A' ? 'lonA' : 'lonB';
    const eleId = location === 'A' ? 'eleA' : 'eleB';
    const latVal = document.getElementById(latId).value;
    const lonVal = document.getElementById(lonId).value;
    if (!latVal || !lonVal) {
        alert(`âŒ è«‹å…ˆè¼¸å…¥åœ°é»${location}çš„åº§æ¨™`);
        return;
    }
    const lat = parseFloat(latVal);
    const lon = parseFloat(lonVal);
    if (isNaN(lat) || isNaN(lon)) {
        alert(`âŒ åœ°é»${location}çš„åº§æ¨™ç„¡æ•ˆ`);
        return;
    }
    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
        alert(`âŒ åº§æ¨™è¶…å‡ºæœ‰æ•ˆç¯„åœ\nç·¯åº¦: -90 ~ 90\nç¶“åº¦: -180 ~ 180`);
        return;
    }
    if (lat < 21.5 || lat > 25.5 || lon < 119.5 || lon > 122.5) {
        alert(`âš ï¸ è­¦å‘Šï¼šåº§æ¨™è¶…å‡ºå°ç£ç¯„åœ\nå…§æ”¿éƒ¨ DSM åƒ…æ¶µè“‹å°ç£åœ°å€\n\nå°‡å˜—è©¦ä½¿ç”¨ Google Maps API ä½œç‚ºå‚™ç”¨è³‡æ–™æº`);
        await getElevationFromGoogleMaps(location);
        return;
    }
    const eleInput = document.getElementById(eleId);
    const originalValue = eleInput.value;
    eleInput.disabled = true;
    const gpsRes = document.getElementById('gpsRes');
    const originalContent = gpsRes.innerHTML;
    const originalColor = gpsRes.style.color;
    const originalBg = gpsRes.style.background;
    showLoadingWithDots('gpsRes', 'è®€å–ä¸­', eleInput);
    try {
        console.log(`ä½¿ç”¨å…§æ”¿éƒ¨ DSM 20m å–å¾—é«˜åº¦ï¼Œåº§æ¨™: ${lat}, ${lon}`);
        if (!window.GeoTIFF) {
            gpsRes.innerHTML = '<span style="color: #ffd43b;">æ­£åœ¨è¼‰å…¥ GeoTIFF å‡½å¼åº«<span class="loading-dots"></span></span>';
            await loadGeoTIFFLibrary();
        }
        gpsRes.innerHTML = '<span style="color: #ffd43b;">æ­£åœ¨é€£æ¥å…§æ”¿éƒ¨ DSM è³‡æ–™<span class="loading-dots"></span></span>';
        const cogFilename = 'taiwan_dsm_wgs84_cog.tif';
        let tiff = null;
        try {
            tiff = await GeoTIFF.fromUrl(cogFilename);
            console.log('æˆåŠŸè¼‰å…¥ COG æª”æ¡ˆ:', cogFilename);
        } catch (err) {
            console.error('å¾ç›¸å°è·¯å¾‘è¼‰å…¥å¤±æ•—ï¼Œå˜—è©¦ GitHub Pages:', err);
            const githubUrl = 'https://sulapon.github.io/GPS/taiwan_dsm_wgs84_cog.tif';
            try {
                tiff = await GeoTIFF.fromUrl(githubUrl);
                console.log('æˆåŠŸå¾ GitHub Pages è¼‰å…¥:', githubUrl);
            } catch (err2) {
                throw new Error(`ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆ: ${err2.message}`);
            }
        }
        if (!tiff) {
            throw new Error('ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆ');
        }
        gpsRes.innerHTML = '<span style="color: #ffd43b;">æ­£åœ¨å–å¾—é«˜åº¦è³‡æ–™<span class="loading-dots"></span></span>';
        const image = await tiff.getImage();
        const bbox = image.getBoundingBox();
        const width = image.getWidth();
        const height = image.getHeight();
        const pixelX = Math.floor((lon - bbox[0]) / (bbox[2] - bbox[0]) * width);
        const pixelY = Math.floor((bbox[3] - lat) / (bbox[3] - bbox[1]) * height);
        if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
            const rasters = await image.readRasters({
                window: [pixelX, pixelY, pixelX + 1, pixelY + 1]
            });
            const elevation = rasters[0][0];
            if (elevation === null || elevation === undefined || isNaN(elevation)) {
                throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
            }
            eleInput.value = Math.round(parseFloat(elevation));
            console.log(`åœ°é»${location}é«˜åº¦å·²æ›´æ–°: ${elevation}m`);
            calculate();
            const currentResult = gpsRes.innerHTML;
            const successMsg = `<span style="color: #ffd43b; font-weight: bold;">âœ“ åœ°é»${location}é«˜åº¦å·²å¾å…§æ”¿éƒ¨ DSM 20m æ›´æ–°ï¼š<strong>${Math.round(parseFloat(elevation))} m</strong></span><br><br>${currentResult}`;
            gpsRes.innerHTML = successMsg;
            const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
            const loadingSpan = document.getElementById(loadingId);
            if (loadingSpan) {
                loadingSpan.style.display = 'none';
                eleInput.style.opacity = '1';
            }
            setTimeout(() => {
                gpsRes.innerHTML = currentResult;
            }, 3000);
        } else {
            throw new Error('åº§æ¨™è¶…å‡º DSM è³‡æ–™ç¯„åœ');
        }
    } catch (err) {
        console.error('å–å¾—é«˜åº¦å¤±æ•—:', err);
        eleInput.value = originalValue;
        let errorHTML = 'âŒ å…§æ”¿éƒ¨ DSM å–å¾—é«˜åº¦å¤±æ•—<br><span style="color: #ffd43b; font-weight: bold;">è©²åŠŸèƒ½éœ€é€£ç¶²</span>';
        if (err.message.includes('COG')) {
            errorHTML += '<br><small>ç„¡æ³•è¼‰å…¥ DSM æª”æ¡ˆï¼Œè«‹ç¢ºèªç¶²è·¯é€£ç·š</small>';
        } else if (err.message.includes('ä¸å¯ç”¨') || err.message.includes('ç¯„åœ')) {
            errorHTML += '<br><small>è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šæš«ä¸å¯ç”¨</small>';
        } else {
            errorHTML += '<br><small>' + err.message + '</small>';
        }
        errorHTML += '<br><br><span style="font-size: 12px; color: #5ff0d5;">æç¤ºï¼šè‹¥åº§æ¨™ä¸åœ¨å°ç£ç¯„åœï¼Œç³»çµ±æœƒè‡ªå‹•ä½¿ç”¨ Google Maps å‚™ç”¨</span>';
        gpsRes.innerHTML = errorHTML;
        gpsRes.style.color = '#e8eef5';
        gpsRes.style.background = 'rgba(220, 53, 69, 0.15)';
        gpsRes.style.border = '1px solid #dc3545';
        gpsRes.style.borderRadius = '8px';
        gpsRes.style.padding = '8px';
    } finally {
        eleInput.disabled = false;
        const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
        const loadingSpan = document.getElementById(loadingId);
        if (loadingSpan) {
            loadingSpan.style.display = 'none';
            eleInput.style.opacity = '1';
        }
        gpsRes.innerHTML = originalContent;
        gpsRes.style.color = originalColor;
        gpsRes.style.background = originalBg;
    }
}
async function getElevationFromGoogleMaps(location) {
    console.log('getElevationFromGoogleMaps() è¢«èª¿ç”¨ï¼ˆå‚™ç”¨ï¼‰ï¼Œåœ°é»:', location);
    const latId = location === 'A' ? 'latA' : 'latB';
    const lonId = location === 'A' ? 'lonA' : 'lonB';
    const eleId = location === 'A' ? 'eleA' : 'eleB';
    const latVal = document.getElementById(latId).value;
    const lonVal = document.getElementById(lonId).value;
    const lat = parseFloat(latVal);
    const lon = parseFloat(lonVal);
    const eleInput = document.getElementById(eleId);
    const originalValue = eleInput.value;
    eleInput.disabled = true;
    const gpsRes = document.getElementById('gpsRes');
    showLoadingWithDots('gpsRes', 'ä½¿ç”¨ Google Maps å‚™ç”¨', eleInput);
    const GOOGLE_API_KEY = 'AIzaSyBwd_GtAZq2eW6KgRRkro__aG7h5ZECJwo';
    try {
        console.log(`èª¿ç”¨ Google Maps Elevation API (å‚™ç”¨)ï¼Œåº§æ¨™: ${lat}, ${lon}`);
        if (!window.google || !window.google.maps) {
            gpsRes.innerHTML = '<span style="color: #ffd43b;">æ­£åœ¨è¼‰å…¥ Google Maps API<span class="loading-dots"></span></span>';
            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=geometry`;
                script.async = true;
                script.defer = true;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        gpsRes.innerHTML = '<span style="color: #ffd43b;">æ­£åœ¨å–å¾—é«˜åº¦è³‡æ–™ (Google Maps)<span class="loading-dots"></span></span>';
        const elevator = new google.maps.ElevationService();
        const result = await new Promise((resolve, reject) => {
            elevator.getElevationForLocations({
                locations: [{lat: lat, lng: lon}]
            }, (results, status) => {
                if (status === 'OK' && results && results.length > 0) {
                    resolve(results[0]);
                } else {
                    reject(new Error(`Google Maps API ç‹€æ…‹: ${status}`));
                }
            });
        });
        const elevation = result.elevation;
        console.log('Google Maps API éŸ¿æ‡‰:', result);
        if (elevation === null || elevation === undefined) {
            throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
        }
        eleInput.value = Math.round(parseFloat(elevation));
        console.log(`åœ°é»${location}é«˜åº¦å·²æ›´æ–° (Google Maps): ${elevation}m`);
        calculate();
        const currentResult = gpsRes.innerHTML;
        const successMsg = `<span style="color: #ffd43b; font-weight: bold;">âœ“ åœ°é»${location}é«˜åº¦å·²å¾ Google Maps æ›´æ–°ï¼š<strong>${Math.round(parseFloat(elevation))} m</strong></span><br><br>${currentResult}`;
        gpsRes.innerHTML = successMsg;
        const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
        const loadingSpan = document.getElementById(loadingId);
        if (loadingSpan) {
            loadingSpan.style.display = 'none';
            eleInput.style.opacity = '1';
        }
        setTimeout(() => {
            gpsRes.innerHTML = currentResult;
        }, 3000);
    } catch (err) {
        console.error('Google Maps å–å¾—é«˜åº¦å¤±æ•—:', err);
        eleInput.value = originalValue;
        let errorHTML = 'âŒ Google Maps å–å¾—é«˜åº¦å¤±æ•—<br><span style="color: #ffd43b; font-weight: bold;">è©²åŠŸèƒ½éœ€é€£ç¶²</span>';
        if (err.message.includes('API')) {
            errorHTML += '<br><small>API é€£ç·šå•é¡Œï¼Œè«‹æª¢æŸ¥ç¶²è·¯</small>';
        } else if (err.message.includes('ä¸å¯ç”¨')) {
            errorHTML += '<br><small>è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šæš«ä¸å¯ç”¨</small>';
        } else {
            errorHTML += '<br><small>' + err.message + '</small>';
        }
        gpsRes.innerHTML = errorHTML;
        gpsRes.style.color = '#e8eef5';
        gpsRes.style.background = 'rgba(220, 53, 69, 0.15)';
        gpsRes.style.border = '1px solid #dc3545';
        gpsRes.style.borderRadius = '8px';
        gpsRes.style.padding = '8px';
    } finally {
        eleInput.disabled = false;
        const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
        const loadingSpan = document.getElementById(loadingId);
        if (loadingSpan) {
            loadingSpan.style.display = 'none';
            eleInput.style.opacity = '1';
        }
    }
}
let currentUpdateDialog = null;
function showLocationUpdateDialog(location, lat, lng, locationName, eleId) {
    if (currentUpdateDialog && currentUpdateDialog.parentNode) {
        currentUpdateDialog.parentNode.removeChild(currentUpdateDialog);
    }
    const dialog = document.createElement('div');
    dialog.id = 'location-update-dialog';
    dialog.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(40, 44, 52, 0.98);
        border: 2px solid #5ff0d5;
        border-radius: 12px;
        padding: 24px;
        min-width: 320px;
        max-width: 90vw;
        z-index: 999999;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
        color: #ffffff;
        font-size: 15px;
        line-height: 1.6;
    `;
    dialog.innerHTML = `
        <div style="font-size: 18px; font-weight: bold; color: #5ff0d5; margin-bottom: 16px; text-align: center;">
            sulapon.github.io é¡¯ç¤º
        </div>
        <div style="margin-bottom: 12px;">
            <span style="color: #4ade80;">âœ“</span> åœ°é» ${location} å·²æ›´æ–°
        </div>
        <div style="margin-bottom: 8px;">
            åº§æ¨™: <span style="color: #60a5fa;">${lat.toFixed(6)}, ${lng.toFixed(6)}</span>
        </div>
        <div style="margin-bottom: 12px;">
            åœ°å: <span style="color: #fbbf24;">${locationName}</span>
        </div>
        <div id="elevation-status-${eleId}" style="color: #94a3b8;">
            æ­£åœ¨å–å¾—é«˜åº¦...
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <button onclick="closeLocationUpdateDialog()" style="background: linear-gradient(90deg, #fbbf24, #f59e0b); color: #000; border: none; padding: 10px 32px; border-radius: 6px; font-weight: bold; font-size: 16px; cursor: pointer;">
                ç¢ºå®š
            </button>
        </div>
    `;
    document.body.appendChild(dialog);
    currentUpdateDialog = dialog;
    dialog.dataset.eleId = eleId;
}
function updateDialogElevationStatus(eleId, status, success = true) {
    const statusDiv = document.getElementById(`elevation-status-${eleId}`);
    if (statusDiv) {
        if (success) {
            statusDiv.innerHTML = `<span style="color: #4ade80;">âœ“</span> ${status}`;
            statusDiv.style.color = '#4ade80';
        } else {
            statusDiv.innerHTML = `<span style="color: #ef4444;">âœ—</span> ${status}`;
            statusDiv.style.color = '#ef4444';
        }
    }
}
function closeLocationUpdateDialog() {
    if (currentUpdateDialog && currentUpdateDialog.parentNode) {
        currentUpdateDialog.parentNode.removeChild(currentUpdateDialog);
        currentUpdateDialog = null;
    }
}
async function getElevationAutomatic(lat, lon, location, eleId) {
    console.log(`getElevationAutomatic() è¢«èª¿ç”¨ï¼Œåº§æ¨™: ${lat}, ${lon}, åœ°é»: ${location}`);
    const eleInput = document.getElementById(eleId);
    const originalValue = eleInput.value;
    const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
    const loadingSpan = document.getElementById(loadingId);
    if (loadingSpan) {
        loadingSpan.innerHTML = 'è®€å–ä¸­<span class="loading-dots"></span>';
        loadingSpan.style.display = 'inline';
        eleInput.style.opacity = '0.5';
    }
    const isInTaiwan = (lat >= 21.5 && lat <= 25.5 && lon >= 119.5 && lon <= 122.5);
    if (!isInTaiwan) {
        console.log('åº§æ¨™ä¸åœ¨å°ç£ç¯„åœï¼Œä½¿ç”¨ Google Maps API');
        await getElevationAutomaticGoogleMaps(lat, lon, location, eleId);
        return;
    }
    try {
        console.log(`ä½¿ç”¨å…§æ”¿éƒ¨ DSM 20m å–å¾—é«˜åº¦ï¼Œåº§æ¨™: ${lat}, ${lon}`);
        updateDialogElevationStatus(eleId, 'æ­£åœ¨é€£æ¥å…§æ”¿éƒ¨ DSM...', true);
        if (!window.GeoTIFF) {
            updateDialogElevationStatus(eleId, 'è¼‰å…¥ GeoTIFF å‡½å¼åº«...', true);
            await loadGeoTIFFLibrary();
        }
        updateDialogElevationStatus(eleId, 'é€£æ¥ DSM è³‡æ–™æª”æ¡ˆ...', true);
        const cogFilename = 'taiwan_dsm_wgs84_cog.tif';
        let tiff = null;
        try {
            tiff = await GeoTIFF.fromUrl(cogFilename);
            console.log('æˆåŠŸè¼‰å…¥ COG æª”æ¡ˆ:', cogFilename);
        } catch (err) {
            console.error('å¾ç›¸å°è·¯å¾‘è¼‰å…¥å¤±æ•—ï¼Œå˜—è©¦ GitHub Pages:', err);
            const githubUrl = 'https://sulapon.github.io/GPS/taiwan_dsm_wgs84_cog.tif';
            try {
                tiff = await GeoTIFF.fromUrl(githubUrl);
                console.log('æˆåŠŸå¾ GitHub Pages è¼‰å…¥:', githubUrl);
            } catch (err2) {
                throw new Error(`ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆ: ${err2.message}`);
            }
        }
        if (!tiff) {
            throw new Error('ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆ');
        }
        updateDialogElevationStatus(eleId, 'æ­£åœ¨è§£æé«˜åº¦è³‡æ–™...', true);
        const image = await tiff.getImage();
        const bbox = image.getBoundingBox();
        const width = image.getWidth();
        const height = image.getHeight();
        const pixelX = Math.floor((lon - bbox[0]) / (bbox[2] - bbox[0]) * width);
        const pixelY = Math.floor((bbox[3] - lat) / (bbox[3] - bbox[1]) * height);
        if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
            const rasters = await image.readRasters({
                window: [pixelX, pixelY, pixelX + 1, pixelY + 1]
            });
            const elevation = rasters[0][0];
            if (elevation === null || elevation === undefined || isNaN(elevation)) {
                throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
            }
            const elevationRounded = Math.round(parseFloat(elevation));
            eleInput.value = elevationRounded;
            updateDialogElevationStatus(eleId, `é«˜åº¦: ${elevationRounded} å…¬å°º (å…§æ”¿éƒ¨ DSM 20m)`, true);
            console.log(`åœ°é»${location}é«˜åº¦å·²è‡ªå‹•æ›´æ–°: ${elevation}m`);
        } else {
            throw new Error('åº§æ¨™è¶…å‡º DSM è³‡æ–™ç¯„åœ');
        }
    } catch (err) {
        console.error('å…§æ”¿éƒ¨ DSM å–å¾—é«˜åº¦å¤±æ•—:', err);
        console.log('å˜—è©¦ä½¿ç”¨ Google Maps API å‚™ç”¨');
        updateDialogElevationStatus(eleId, 'åˆ‡æ›è‡³ Google Maps å‚™ç”¨...', true);
        await getElevationAutomaticGoogleMaps(lat, lon, location, eleId);
    } finally {
        if (loadingSpan) {
            loadingSpan.style.display = 'none';
            eleInput.style.opacity = '1';
        }
    }
}
async function getElevationAutomaticGoogleMaps(lat, lon, location, eleId) {
    console.log(`getElevationAutomaticGoogleMaps() è¢«èª¿ç”¨ï¼Œåº§æ¨™: ${lat}, ${lon}, åœ°é»: ${location}`);
    const eleInput = document.getElementById(eleId);
    const originalValue = eleInput.value;
    const GOOGLE_API_KEY = 'AIzaSyBwd_GtAZq2eW6KgRRkro__aG7h5ZECJwo';
    try {
        console.log(`èª¿ç”¨ Google Maps Elevation APIï¼Œåº§æ¨™: ${lat}, ${lon}`);
        updateDialogElevationStatus(eleId, 'æ­£åœ¨é€£æ¥ Google Maps...', true);
        if (!window.google || !window.google.maps) {
            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=geometry`;
                script.async = true;
                script.defer = true;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        updateDialogElevationStatus(eleId, 'æ­£åœ¨è§£æé«˜åº¦è³‡æ–™...', true);
        const elevator = new google.maps.ElevationService();
        const result = await new Promise((resolve, reject) => {
            elevator.getElevationForLocations({
                locations: [{lat: lat, lng: lon}]
            }, (results, status) => {
                if (status === 'OK' && results && results.length > 0) {
                    resolve(results[0]);
                } else {
                    reject(new Error(`Google Maps API ç‹€æ…‹: ${status}`));
                }
            });
        });
        console.log('Google Maps Elevation API éŸ¿æ‡‰:', result);
        const elevation = result.elevation;
        if (elevation === null || elevation === undefined) {
            throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
        }
        const elevationRounded = Math.round(parseFloat(elevation));
        eleInput.value = elevationRounded;
        updateDialogElevationStatus(eleId, `é«˜åº¦: ${elevationRounded} å…¬å°º (Google Maps)`, true);
        console.log(`åœ°é»${location}é«˜åº¦å·²è‡ªå‹•æ›´æ–°: ${elevation}m`);
    } catch (err) {
        console.error('è‡ªå‹•å–å¾—é«˜åº¦å¤±æ•—:', err);
        updateDialogElevationStatus(eleId, 'é«˜åº¦å–å¾—å¤±æ•—', false);
        if (!originalValue || originalValue === 'å–å¾—ä¸­...') {
            eleInput.value = '';
        }
    }
}
function calculate() {
    const mode = document.getElementById('displayMode').value;
    if (mode === 'dms') {
        ['latA','lonA','latB','lonB'].forEach(id => { try{ dmsToD(id); }catch(e){} });
    }
    const [latA, lonA, latB, lonB, eleA, eleB] =
        ['latA', 'lonA', 'latB', 'lonB', 'eleA', 'eleB'].map(id => parseFloat(document.getElementById(id).value || 0));
    const [nameA, nameB] =
        ['nameA', 'nameB'].map(id => document.getElementById(id).value || (id === 'nameA' ? 'A' : 'B'));
    const resDiv = document.getElementById('gpsRes');
    if (isNaN(latA) || isNaN(lonA) || isNaN(latB) || isNaN(lonB)) {
        resDiv.innerHTML = "âŒ **è«‹è¼¸å…¥æœ‰æ•ˆçš„ GPS åº§æ¨™æ•¸å­—**";
        resDiv.classList.add('gps-error');
        return;
    }
    resDiv.classList.remove('gps-error');
    const hD = hDist(latA, lonA, latB, lonB);
    const sD = straightDist(hD, eleA, eleB);
    const bAB = getBearing(latA, lonA, latB, lonB);
    const bBA = getBearing(latB, lonB, latA, lonA);
    const pitch = getPitch(hD, eleA, eleB);
    const fDist = sD < 1
        ? `<strong class="v-dist">${(sD * 1000).toFixed(2)}</strong> å…¬å°º`
        : `<strong class="v-dist">${sD.toFixed(2)}</strong> å…¬é‡Œ`;
    resDiv.innerHTML = `
        <p><span class="gps-label-title">âœ… å…©é»é–“çš„ç›´ç·šè·é›¢(å«é«˜åº¦å·®)</span>ï¼š${fDist}</p>
        <hr>
        <p><span class="gps-label-title">ğŸ§­ å¾ ${nameA} åˆ° ${nameB} çš„æ–¹ä½è§’</span>ï¼š<strong class="v-bearing">${bAB.toFixed(2)}Â°</strong></p>
        <p><span class="gps-label-title">â†©ï¸ å¾ ${nameB} åˆ° ${nameA} çš„æ–¹ä½è§’</span>ï¼š<strong class="v-bearing">${bBA.toFixed(2)}Â°</strong></p>
        <hr style="border: 0; border-top: 1px dashed rgba(255,255,255,0.06); margin: 3px 0;">
        <p><span class="gps-label-title">â« ${nameA} å° ${nameB} çš„ä¿¯ä»°è§’</span>ï¼š<strong class="v-pitch-value">${pitch.pitchAB.toFixed(2)}Â°</strong></p>
        <p><span class="gps-label-title">â¬ ${nameB} å° ${nameA} çš„ä¿¯ä»°è§’</span>ï¼š<strong class="v-pitch-value">${pitch.pitchBA.toFixed(2)}Â°</strong></p>
    `;
  }
    const displayModeSelect = document.getElementById('displayMode');
    function updateDisplayMode(mode){
      if(!mode) mode = displayModeSelect ? displayModeSelect.value : 'decimal';
      const ids = ['latA','lonA','latB','lonB'];
      if(mode === 'dms'){
        document.querySelectorAll('.gps-dmsr').forEach(el => el.style.display = 'flex');
        document.querySelectorAll('.gps-ddr').forEach(el => el.style.display = 'none');
        ids.forEach(id => {
            try{ dToDMS(id); }catch(e){}
        });
      } else {
        document.querySelectorAll('.gps-dmsr').forEach(el => el.style.display = 'none');
        document.querySelectorAll('.gps-ddr').forEach(el => el.style.display = 'flex');
        ids.forEach(id => {
            const ddInput = document.getElementById(id);
            if (ddInput.value.trim() === '') {
                try{ dmsToD(id); }catch(e){}
            }
        });
      }
      calculate();
    }
    if(displayModeSelect){
      displayModeSelect.addEventListener('change', e => updateDisplayMode(e.target.value));
    }
  document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('unit').addEventListener('change', convertLength);
    if (document.getElementById('rf-content').classList.contains('active')) {
      compute();
    }
    resetGps();
    try { updateDisplayMode(document.getElementById('displayMode').value || 'decimal'); } catch(e){}
  });
</script> <script>
const sectionIds = {
    'power': 'section-power',
    'matching': 'section-matching',
    'sensitivity': 'section-sensitivity',
    'los': 'section-los',
    'fspl': 'section-fspl',
    'linkbudget': 'section-linkbudget'
};
const defaultValues = {
    'section-power': {
        'power_input': '1',
        'power_unit': 'w',
    },
    'section-matching': {
        'matching_input_value': '20',
        'matching_unit': 'rl',
    },
    'section-sensitivity': {
        'sensitivity_bw': '1',
        'sensitivity_nf': '5',
        'sensitivity_sn': '10',
    },
    'section-los': {
        'los_g1': '0',
        'los_h1': '10',
        'los_g2': '0',
        'los_h2': '20',
    },
    'section-fspl': {
        'fspl_freq': '2400',
        'fspl_dist': '10',
    },
    'section-linkbudget': {
        'link_tx_power_input': '1',
        'link_tx_power_unit': 'w',
        'link_tx_loss_db': '3',
        'link_tx_gain_dbi': '20',
        'link_dist_km': '10',
        'link_freq_mhz': '2400',
        'link_rx_gain_dbi': '20',
        'link_rx_loss_db': '2',
    }
};
const calculationFunctions = {
    'section-power': 'calculateDbmWNew',
    'section-matching': 'calculateMatching',
    'section-sensitivity': 'calculateSensitivity',
    'section-los': 'calculateMaxLOS',
    'section-fspl': 'calculateFSPL',
    'section-linkbudget': 'calculateLinkBudget',
};
function getSectionControls(sectionId) {
    const sectionEl = document.getElementById(sectionId);
    if (!sectionEl) return [];
    const inputGroup = sectionEl.querySelector('.input-group-border');
    if (!inputGroup) return [];
    return Array.from(inputGroup.querySelectorAll('input, select')).filter(el => el.id);
}
function resetSection(sectionId) {
    const defaults = defaultValues[sectionId];
    if (defaults) {
        for (const id in defaults) {
            const element = document.getElementById(id);
            if (element) {
                element.value = defaults[id];
                if(element.tagName === 'INPUT') element.value = defaults[id];
            }
        }
    }
    const calcFunc = calculationFunctions[sectionId];
    if (calcFunc && typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}
function clearSection(sectionId) {
    const controls = getSectionControls(sectionId);
    const defaults = defaultValues[sectionId] || {};
    controls.forEach(element => {
        const id = element.id;
        if (element.tagName === 'INPUT') {
            element.value = '';
        } else if (element.tagName === 'SELECT') {
            if (defaults[id]) {
                element.value = defaults[id];
            } else {
                element.selectedIndex = 0;
            }
        }
    });
    const calcFunc = calculationFunctions[sectionId];
    if (calcFunc && typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}
function toggleSections() {
    const selector = document.getElementById('function_selector');
    const selectedValue = selector.value;
    const allSections = document.querySelectorAll('.section-item');
    allSections.forEach(section => {
        const sectionKey = Object.keys(sectionIds).find(key => sectionIds[key] === section.id);
        if (selectedValue === 'ALL') {
            section.style.display = 'block';
        } else if (sectionKey === selectedValue) {
            section.style.display = 'block';
        } else {
            section.style.display = 'none';
        }
    });
    if (selectedValue === 'ALL' || selectedValue === 'power') calculateDbmWNew();
    if (selectedValue === 'ALL' || selectedValue === 'matching') calculateMatching();
    if (selectedValue === 'ALL' || selectedValue === 'sensitivity') calculateSensitivity();
    if (selectedValue === 'ALL' || selectedValue === 'los') calculateMaxLOS();
    if (selectedValue === 'ALL' || selectedValue === 'fspl') calculateFSPL();
    if (selectedValue === 'ALL' || selectedValue === 'linkbudget') calculateLinkBudget();
}
function clearAndRecalculate(inputId, calcFunc) {
    const inputElement = document.getElementById(inputId);
    if (inputElement) {
        inputElement.value = '';
    }
    if (typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}
function convertPower(value, fromUnit, toUnit) {
    if (fromUnit === toUnit) return value;
    if (fromUnit === 'w' && toUnit === 'dbm') {
        return 10 * Math.log10(value * 1000);
    } else if (fromUnit === 'dbm' && toUnit === 'w') {
        return Math.pow(10, (value / 10) - 3);
    }
    return NaN;
}
let power_conv_last_unit = 'w';
function calculateDbmWNew() {
    const input = document.getElementById('power_input');
    const unit = document.getElementById('power_unit').value;
    const output = document.getElementById('power_output_result');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    const input_value = parseFloat(input.value);
    if (isNaN(input_value) || input.value.trim() === '') {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">è«‹è¼¸å…¥æ•¸å€¼</span>`;
        return;
    }
    if (unit === 'w' && input_value < 0) {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">åŠŸç‡ (W) å¿…é ˆ â‰¥ 0</span>`;
        return;
    }
    let result_value, result_unit;
    if (unit === 'w') {
        result_value = convertPower(input_value, 'w', 'dbm');
        result_unit = 'dBm';
        if (result_value === -Infinity) {
            output.innerHTML = `æ›ç®—çµæœ: <span class="result-value">-âˆ</span> <span style="color:${unit_color};">${result_unit}</span>`;
            return;
        }
    } else {
        result_value = convertPower(input_value, 'dbm', 'w');
        result_unit = 'W';
        if (result_value < 0) result_value = 0;
    }
    if (isNaN(result_value)) {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">è¼¸å…¥ç„¡æ•ˆ</span>`;
        return;
    } else {
        output.innerHTML = `æ›ç®—çµæœ: <span class="result-value">${result_value.toFixed(3)}</span> <span style="color:${unit_color};">${result_unit}</span>`;
    }
    power_conv_last_unit = unit;
}
function swapAndCalculate() {
    const input = document.getElementById('power_input');
    const current_unit = document.getElementById('power_unit').value;
    const input_value = parseFloat(input.value);
    if (!isNaN(input_value) && input.value.trim() !== '') {
        const new_value = convertPower(input_value, power_conv_last_unit, current_unit);
        if (!isNaN(new_value)) {
            if (current_unit === 'dbm' && new_value === -Infinity) {
            } else {
                input.value = new_value.toFixed(3);
            }
        } else {
        }
    }
    calculateDbmWNew();
}
let last_matching_unit = 'rl';
function getGammaFromValue(value, type) {
    if (type === 'rl') {
        if (value < 0) throw new Error("RL å¿…é ˆ â‰¥ 0 dB");
        return Math.pow(10, -value / 20);
    } else if (type === 'vswr') {
        if (value < 1) throw new Error("VSWR å¿…é ˆ â‰¥ 1");
        return (value - 1) / (value + 1);
    } else if (type === 'gamma') {
        if (value < 0 || value > 1) throw new Error("Î“ å¿…é ˆä»‹æ–¼ 0 åˆ° 1 ä¹‹é–“");
        return value;
    } else if (type === 'refl_pct') {
        if (value < 0 || value > 100) throw new Error("åå°„åŠŸç‡å¿…é ˆä»‹æ–¼ 0 åˆ° 100 ä¹‹é–“");
        return Math.sqrt(value / 100);
    } else if (type === 'pass_pct') {
        if (value < 0 || value > 100) throw new Error("é€šéåŠŸç‡å¿…é ˆä»‹æ–¼ 0 åˆ° 100 ä¹‹é–“");
        return Math.sqrt(1 - (value / 100));
    }
    return NaN;
}
function getValueFromGamma(gamma, type) {
    if (isNaN(gamma) || gamma === Infinity) return NaN;
    if (type === 'rl') {
        if (gamma === 0) return Infinity;
        return -20 * Math.log10(Math.abs(gamma));
    } else if (type === 'vswr') {
        if (gamma === 1) return Infinity;
        return (1 + Math.abs(gamma)) / (1 - Math.abs(gamma));
    } else if (type === 'gamma') {
        return Math.abs(gamma);
    } else if (type === 'refl_pct') {
        return Math.abs(gamma)**2 * 100;
    } else if (type === 'pass_pct') {
        return (1 - Math.abs(gamma)**2) * 100;
    }
    return NaN;
}
function swapAndConvertMatching() {
    const current_unit = document.getElementById('matching_unit').value;
    const input_element = document.getElementById('matching_input_value');
    const input_value = parseFloat(input_element.value);
    if (!isNaN(input_value) && input_element.value.trim() !== '') {
        let gamma_abs;
        try {
            gamma_abs = getGammaFromValue(input_value, last_matching_unit);
            if (!isNaN(gamma_abs)) {
                const new_value = getValueFromGamma(gamma_abs, current_unit);
                if (!isNaN(new_value) && new_value !== Infinity) {
                    const precision = (current_unit === 'rl' || current_unit === 'refl_pct' || current_unit === 'pass_pct') ? 2 : 4;
                    input_element.value = new_value.toFixed(precision);
                } else if (new_value === Infinity) {
                    input_element.value = '1';
                } else {
                    input_element.value = '';
                }
            } else {
                input_element.value = '';
            }
        } catch (error) {
             input_element.value = '';
        }
    }
    calculateMatching();
    last_matching_unit = current_unit;
}
function calculateMatching() {
    const input_type = document.getElementById('matching_unit').value;
    const input_element = document.getElementById('matching_input_value');
    const input_value = parseFloat(input_element.value);
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    const output_elements = {
        rl: document.getElementById('rl_val'),
        vswr: document.getElementById('vswr_val'),
        gamma: document.getElementById('gamma_val'),
        refl_pct: document.getElementById('refl_percent'),
        pass_pct: document.getElementById('pass_percent')
    };
    const empty_output = `<span style="color:${redColor};font-size:17px;">è«‹è¼¸å…¥æ•¸å€¼</span>`;
    Object.values(output_elements).forEach(el => el.innerHTML = '');
    if (isNaN(input_value) || input_element.value.trim() === '') {
        output_elements.rl.innerHTML = empty_output;
        return;
    }
    let gamma_abs;
    try {
        gamma_abs = getGammaFromValue(input_value, input_type);
    } catch (error) {
        output_elements.rl.innerHTML = `<span style="color:${redColor};font-size:17px;">${error.message}</span>`;
        return;
    }
    const rl_val = getValueFromGamma(gamma_abs, 'rl');
    const vswr_val = getValueFromGamma(gamma_abs, 'vswr');
    const gamma_val = getValueFromGamma(gamma_abs, 'gamma');
    const refl_pct = getValueFromGamma(gamma_abs, 'refl_pct');
    const pass_pct = getValueFromGamma(gamma_abs, 'pass_pct');
    const formatOutput = (value, unit, precision=2) => {
        if (value === Infinity) return `<span class="result-value">âˆ</span> <span style="color:${unit_color};">${unit}</span>`;
        if (isNaN(value)) return `<span style="color:${redColor};font-size:17px;">è¨ˆç®—éŒ¯èª¤</span>`;
        return `<span class="result-value">${value.toFixed(precision)}</span> <span style="color:${unit_color};">${unit}</span>`;
    }
    output_elements.rl.innerHTML = formatOutput(rl_val, 'dB');
    output_elements.vswr.innerText = vswr_val === Infinity ? 'âˆ' : vswr_val.toFixed(3);
    output_elements.gamma.innerText = gamma_val.toFixed(4);
    output_elements.refl_pct.innerHTML = formatOutput(refl_pct, '%');
    output_elements.pass_pct.innerHTML = formatOutput(pass_pct, '%');
    last_matching_unit = input_type;
}
const BOLTZMANN_K_J = 1.380649e-23;
const T_KELVIN = 290;
function calculateSensitivity() {
    const bw_mhz = parseFloat(document.getElementById('sensitivity_bw').value);
    const nf_db = parseFloat(document.getElementById('sensitivity_nf').value);
    const sn_db = parseFloat(document.getElementById('sensitivity_sn').value);
    const output = document.getElementById('sensitivity_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    if (isNaN(bw_mhz) || isNaN(nf_db) || isNaN(sn_db) || bw_mhz <= 0 || nf_db < 0) {
        output.innerHTML = `æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity): <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å€¼ (BW > 0, NF â‰¥ 0)</span>`;
        return;
    }
    const noise_floor_dbm = -114 + (10 * Math.log10(bw_mhz)) + nf_db;
    const sensitivity_dbm = noise_floor_dbm + sn_db;
    output.innerHTML = `
        æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity): <span class="result-value">${sensitivity_dbm.toFixed(2)}</span> <span style="color:${unit_color};">dBm</span><br>
        <span class="result-value-small">ç†±é›œè¨Šåœ°æ¿ (Noise Floor) Pn: ${noise_floor_dbm.toFixed(2)} dBm</span>
    `;
}
const K_FACTOR = 4 / 3;
const R_EARTH_KM = 6371;
function calculateMaxLOS() {
    const g1 = parseFloat(document.getElementById('los_g1').value) || 0;
    const h1 = parseFloat(document.getElementById('los_h1').value) || 0;
    const g2 = parseFloat(document.getElementById('los_g2').value) || 0;
    const h2 = parseFloat(document.getElementById('los_h2').value) || 0;
    const output = document.getElementById('los_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    if (h1 < 0 || h2 < 0) {
        output.innerHTML = `æœ€å¤§é€šè¦–è·é›¢: <span style="color:${redColor};">å¤©ç·šé«˜åº¦å¿…é ˆ â‰¥ 0</span>`;
        return;
    }
    const a1 = g1 + h1;
    const a2 = g2 + h2;
    if (a1 <= 0 || a2 <= 0) {
        output.innerHTML = `æœ€å¤§é€šè¦–è·é›¢: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (å¤©ç·šçµ•å°é«˜åº¦ > 0) æ•¸å€¼</span>`;
        return;
    }
    const R_eff = K_FACTOR * R_EARTH_KM;
    const d1_km = Math.sqrt(2 * R_eff * a1 / 1000);
    const d2_km = Math.sqrt(2 * R_eff * a2 / 1000);
    const max_los_km = d1_km + d2_km;
    output.innerHTML = `
        æœ€å¤§é€šè¦–è·é›¢: <span class="result-value">${max_los_km.toFixed(2)}</span> <span style="color:${unit_color};">km</span><br>
        <span class="result-value-small">Aé»è¦–è·: ${d1_km.toFixed(2)} km; Bé»è¦–è·: ${d2_km.toFixed(2)} km</span>
    `;
}
function calculateFSPL() {
    const freq_mhz = parseFloat(document.getElementById('fspl_freq').value);
    const dist_km = parseFloat(document.getElementById('fspl_dist').value);
    const output = document.getElementById('fspl_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    if (isNaN(freq_mhz) || isNaN(dist_km) || freq_mhz <= 0 || dist_km <= 0) {
        output.innerHTML = `è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL): <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (é »ç‡ > 0, è·é›¢ > 0) æ•¸å€¼</span>`;
        return;
    }
    const fspl_db = 32.44 + (20 * Math.log10(freq_mhz)) + (20 * Math.log10(dist_km));
    output.innerHTML = `è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL): <span class="result-value">${fspl_db.toFixed(2)}</span> <span style="color:${unit_color};">dB</span>`;
}
function calculateLinkBudget() {
    const freq_mhz = parseFloat(document.getElementById('link_freq_mhz').value);
    const dist_km = parseFloat(document.getElementById('link_dist_km').value);
    const tx_power_input = parseFloat(document.getElementById('link_tx_power_input').value);
    const tx_power_unit = document.getElementById('link_tx_power_unit').value;
    const tx_loss_db = parseFloat(document.getElementById('link_tx_loss_db').value) || 0;
    const tx_gain_dbi = parseFloat(document.getElementById('link_tx_gain_dbi').value) || 0;
    const rx_gain_dbi = parseFloat(document.getElementById('link_rx_gain_dbi').value) || 0;
    const rx_loss_db = parseFloat(document.getElementById('link_rx_loss_db').value) || 0;
    const output = document.getElementById('linkbudget_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;
    if (isNaN(freq_mhz) || isNaN(dist_km) || freq_mhz <= 0 || dist_km <= 0) {
        output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (é »ç‡ > 0, è·é›¢ > 0) æ•¸å€¼</span>`;
        return;
    }
    if (isNaN(tx_power_input) || (tx_power_unit === 'w' && tx_power_input < 0)) {
         output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ç™¼å°„åŠŸç‡</span>`;
         return;
    }
    const tx_power_dbm = convertPower(tx_power_input, tx_power_unit, 'dbm');
    if (isNaN(tx_power_dbm)) {
         output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">ç™¼å°„åŠŸç‡ (W) å¿…é ˆ > 0</span>`;
         return;
    }
    const fspl_db = 32.44 + (20 * Math.log10(freq_mhz)) + (20 * Math.log10(dist_km));
    const rx_power_dbm = tx_power_dbm - tx_loss_db + tx_gain_dbi - fspl_db + rx_gain_dbi - rx_loss_db;
    output.innerHTML = `
        æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span class="result-value">${rx_power_dbm.toFixed(2)}</span> <span style="color:${unit_color};">dBm</span><br>
        <span style="font-size:14px;color:var(--muted);">
            è·¯å¾‘æè€— (Path Loss): ${fspl_db.toFixed(2)} dB (FSPL) + ${(tx_loss_db + rx_loss_db).toFixed(2)} dB (ç·šæ) = ${(fspl_db + tx_loss_db + rx_loss_db).toFixed(2)} dB<br>
            ç™¼å°„ EIRP: ${(tx_power_dbm - tx_loss_db + tx_gain_dbi).toFixed(2)} dBm
        </span>
    `;
}
document.addEventListener('DOMContentLoaded', () => {
    toggleSections();
});
</script>
<script>
let chartInstance = null;
let pathData = [];
let localTifFileData = null;  // æœ¬åœ°TIFæª”æ¡ˆè³‡æ–™
function importFromGPS() {
    console.log('importFromGPS() è¢«èª¿ç”¨');
    const latA = document.getElementById('latA').value;
    const lonA = document.getElementById('lonA').value;
    const latADeg = document.getElementById('latA_deg').value;
    const latAMin = document.getElementById('latA_min').value;
    const latASec = document.getElementById('latA_sec').value;
    const lonADeg = document.getElementById('lonA_deg').value;
    const lonAMin = document.getElementById('lonA_min').value;
    const lonASec = document.getElementById('lonA_sec').value;
    const latB = document.getElementById('latB').value;
    const lonB = document.getElementById('lonB').value;
    const latBDeg = document.getElementById('latB_deg').value;
    const latBMin = document.getElementById('latB_min').value;
    const latBSec = document.getElementById('latB_sec').value;
    const lonBDeg = document.getElementById('lonB_deg').value;
    const lonBMin = document.getElementById('lonB_min').value;
    const lonBSec = document.getElementById('lonB_sec').value;
    const nameA = document.getElementById('nameA').value || '';
    const nameB = document.getElementById('nameB').value || '';
    let startLat = latA ? parseFloat(latA) : (latADeg || latAMin || latASec) ? dmsToDecimal(latADeg, latAMin, latASec) : null;
    let startLon = lonA ? parseFloat(lonA) : (lonADeg || lonAMin || lonASec) ? dmsToDecimal(lonADeg, lonAMin, lonASec) : null;
    let endLat = latB ? parseFloat(latB) : (latBDeg || latBMin || latBSec) ? dmsToDecimal(latBDeg, latBMin, latBSec) : null;
    let endLon = lonB ? parseFloat(lonB) : (lonBDeg || lonBMin || lonBSec) ? dmsToDecimal(lonBDeg, lonBMin, lonBSec) : null;
    console.log('è®€å–åˆ°çš„åº§æ¨™:', {startLat, startLon, endLat, endLon});
    console.log('è®€å–åˆ°çš„åœ°å:', {nameA, nameB});
    if (!startLat || !startLon || !endLat || !endLon) {
        alert('âŒ GPS åˆ†é çš„åœ°é» A æˆ– B åº§æ¨™æœªå®Œæ•´å¡«å¯«ï¼Œè«‹å…ˆåœ¨ GPS åˆ†é è¼¸å…¥åº§æ¨™');
        return;
    }
    document.getElementById('sLat').value = startLat.toFixed(6);
    document.getElementById('sLng').value = startLon.toFixed(6);
    document.getElementById('eLat').value = endLat.toFixed(6);
    document.getElementById('eLng').value = endLon.toFixed(6);
    updateElevationLabelsWithPlaceNames(startLat, startLon, endLat, endLon, nameA, nameB);
    const summary = document.getElementById('summary');
    summary.innerText = `âœ“ å·²å¾ GPS åˆ†é è®€å–åº§æ¨™å®Œæˆï¼Aé»: (${startLat.toFixed(6)}, ${startLon.toFixed(6)}), Bé»: (${endLat.toFixed(6)}, ${endLon.toFixed(6)})`;
    summary.style.color = '#27ae60';
    summary.style.background = 'rgba(39, 174, 96, 0.1)';
    console.log('åº§æ¨™å·²å¡«å…¥é«˜åº¦åœ–åˆ†é ');
}
async function getPlaceNameFromCoords(lat, lon) {
    try {
        const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`,
            {
                headers: {
                    'User-Agent': 'GPS Calculator App'
                }
            }
        );
        if (!response.ok) {
            throw new Error('APIè«‹æ±‚å¤±æ•—');
        }
        const data = await response.json();
        if (data.address) {
            const addr = data.address;
            return addr.road || addr.village || addr.town || addr.city ||
                   addr.suburb || addr.neighbourhood || addr.hamlet ||
                   addr.county || addr.state || 'æœªçŸ¥åœ°é»';
        }
        return 'æœªçŸ¥åœ°é»';
    } catch (error) {
        console.error('ç²å–åœ°åå¤±æ•—:', error);
        return 'æœªçŸ¥åœ°é»';
    }
}
async function updateElevationLabelsWithPlaceNames(latA, lonA, latB, lonB, nameA, nameB) {
    const labelALat = document.getElementById('labelALat');
    const labelALng = document.getElementById('labelALng');
    const labelBLat = document.getElementById('labelBLat');
    const labelBLng = document.getElementById('labelBLng');
    let placeNameA = nameA;
    let placeNameB = nameB;
    if (!placeNameA || placeNameA.trim() === '') {
        if (labelALat) labelALat.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
        if (labelALng) labelALng.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
        placeNameA = await getPlaceNameFromCoords(latA, lonA);
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
    if (!placeNameB || placeNameB.trim() === '') {
        if (labelBLat) labelBLat.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
        if (labelBLng) labelBLng.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
        placeNameB = await getPlaceNameFromCoords(latB, lonB);
    }
    if (labelALat) labelALat.innerHTML = `<span style="color: var(--title); font-weight: 700;">${placeNameA}</span> ç·¯åº¦`;
    if (labelALng) labelALng.innerHTML = `<span style="color: var(--title); font-weight: 700;">${placeNameA}</span> ç¶“åº¦`;
    if (labelBLat) labelBLat.innerHTML = `<span style="color: var(--title); font-weight: 700;">${placeNameB}</span> ç·¯åº¦`;
    if (labelBLng) labelBLng.innerHTML = `<span style="color: var(--title); font-weight: 700;">${placeNameB}</span> ç¶“åº¦`;
    window.elevationPointAName = placeNameA;
    window.elevationPointBName = placeNameB;
    console.log('âœ… åœ°åå·²æˆåŠŸæ›´æ–°ï¼Œè—è‰²æ¡†æœƒé¡¯ç¤º:', {placeNameA, placeNameB});
    console.log('window.elevationPointAName:', window.elevationPointAName);
    console.log('window.elevationPointBName:', window.elevationPointBName);
}
function dmsToDecimal(degrees, minutes, seconds) {
    const d = parseFloat(degrees) || 0;
    const m = parseFloat(minutes) || 0;
    const s = parseFloat(seconds) || 0;
    return d + m/60 + s/3600;
}
function getDistance(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

/**
 * è¨ˆç®—åŒ…å«å¤©ç·šé«˜åº¦çš„3Dè·¯å¾‘ç¸½é•·åº¦ (è€ƒæ…®åœ°çƒæ›²åº¦)
 * @param {number} lat1 - Aé»ç·¯åº¦
 * @param {number} lon1 - Aé»ç¶“åº¦
 * @param {number} lat2 - Bé»ç·¯åº¦
 * @param {number} lon2 - Bé»ç¶“åº¦
 * @param {number} antennaHeight1 - Aé»å¤©ç·šé«˜åº¦ (å…¬å°º)
 * @param {number} antennaHeight2 - Bé»å¤©ç·šé«˜åº¦ (å…¬å°º)
 * @returns {number} 3Dç›´ç·šè·é›¢ (å…¬é‡Œ)
 */
function getDistance3D(lat1, lon1, lat2, lon2, antennaHeight1 = 0, antennaHeight2 = 0) {
    const R = 6371; // åœ°çƒåŠå¾‘ (å…¬é‡Œ)
    
    // å°‡ç¶“ç·¯åº¦è½‰æ›ç‚ºå¼§åº¦
    const lat1Rad = lat1 * Math.PI / 180;
    const lon1Rad = lon1 * Math.PI / 180;
    const lat2Rad = lat2 * Math.PI / 180;
    const lon2Rad = lon2 * Math.PI / 180;
    
    // è¨ˆç®—å…©é»å¾åœ°å¿ƒçš„è·é›¢ (åœ°çƒåŠå¾‘ + å¤©ç·šé«˜åº¦)
    const r1 = R + antennaHeight1 / 1000; // è½‰æ›å…¬å°ºç‚ºå…¬é‡Œ
    const r2 = R + antennaHeight2 / 1000;
    
    // å°‡çƒé¢åº§æ¨™è½‰æ›ç‚º3Dç›´è§’åº§æ¨™ç³» (åœ°å¿ƒç‚ºåŸé»)
    const x1 = r1 * Math.cos(lat1Rad) * Math.cos(lon1Rad);
    const y1 = r1 * Math.cos(lat1Rad) * Math.sin(lon1Rad);
    const z1 = r1 * Math.sin(lat1Rad);
    
    const x2 = r2 * Math.cos(lat2Rad) * Math.cos(lon2Rad);
    const y2 = r2 * Math.cos(lat2Rad) * Math.sin(lon2Rad);
    const z2 = r2 * Math.sin(lat2Rad);
    
    // è¨ˆç®—3Dç©ºé–“ä¸­çš„ç›´ç·šè·é›¢ (å¼¦é•·)
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dz = z2 - z1;
    const distance3D = Math.sqrt(dx * dx + dy * dy + dz * dz);
    
    return distance3D;
}
document.addEventListener('DOMContentLoaded', function() {
    const apiSelector = document.getElementById('elevationApiSelector');
    if (apiSelector) {
        apiSelector.addEventListener('change', function() {
            updateApiInfo();
        });
    }
});
function updateApiInfo() {
    const apiSelector = document.getElementById('elevationApiSelector');
    const apiInfo = document.getElementById('apiInfo');
    apiInfo.textContent = '';
}
async function runAnalysis() {
    console.log('runAnalysis() è¢«èª¿ç”¨');
    const apiSelector = document.getElementById('elevationApiSelector');
    const selectedApi = apiSelector ? apiSelector.value : 'open-elevation';
    console.log('é¸ä¸­çš„API:', selectedApi);
    if (selectedApi === 'google-maps') {
        await runAnalysisWithGoogleMaps();
    } else if (selectedApi === 'taiwan-dsm') {
        await runAnalysisWithTaiwanDSM();
    } else {
        await runAnalysisWithOpenElevation();
    }
}
async function runAnalysisWithOpenElevation() {
    console.log('runAnalysisWithOpenElevation() è¢«èª¿ç”¨');
    const sLat = parseFloat(document.getElementById('sLat').value);
    const sLng = parseFloat(document.getElementById('sLng').value);
    const eLat = parseFloat(document.getElementById('eLat').value);
    const eLng = parseFloat(document.getElementById('eLng').value);
    const numPoints = parseInt(document.getElementById('samples').value);
    console.log('è¼¸å…¥å€¼:', {sLat, sLng, eLat, eLng, numPoints});
    if (isNaN(sLat) || isNaN(sLng) || isNaN(eLat) || isNaN(eLng)) {
        summary.innerText = 'âŒ è«‹è¼¸å…¥æ‰€æœ‰åº§æ¨™æ•¸å€¼';
        console.error('åº§æ¨™è¼¸å…¥ç„¡æ•ˆ');
        return;
    }
    const totalDist = getDistance(sLat, sLng, eLat, eLng);
    console.log('ç¸½è·é›¢:', totalDist);
    summary.innerHTML = `<span style="color: #ffd43b; font-weight: bold; font-size: 14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (åˆ†æä¸­<span class="loading-dots"></span>)</span>`;
    pathData = [];
    const locations = [];
    for (let i = 0; i < numPoints; i++) {
        const f = i / (numPoints - 1);
        const lat = sLat + (eLat - sLat) * f;
        const lng = sLng + (eLng - sLng) * f;
        locations.push({ latitude: lat, longitude: lng });
        pathData.push({ dist: (totalDist * f).toFixed(3), lat: lat.toFixed(6), lng: lng.toFixed(6) });
    }
    window.currentPathData = pathData;
    console.log('å–æ¨£é»æ•¸:', locations.length);
    try {
        console.log('é–‹å§‹èª¿ç”¨ Open-Elevation API...');
        const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations })
        });
        if (!response.ok) {
            throw new Error(`API è¿”å›ç‹€æ…‹ ${response.status}`);
        }
        const result = await response.json();
        console.log('API éŸ¿æ‡‰:', result);
        const elevations = result.results.map(r => r.elevation);
        console.log('é«˜åº¦æ•¸æ“š:', elevations);
        summary.innerText = `è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km`;
        renderChart(elevations);
    } catch (err) {
        console.error('API éŒ¯èª¤:', err);
        summary.innerHTML = 'âŒ è³‡æ–™ç²å–å¤±æ•—<br><span style="color: #ffd43b; font-weight: bold;">ğŸŒ è©²åŠŸèƒ½éœ€é€£ç¶²</span><br>' + err.message;
    }
}
async function runAnalysisWithGoogleMaps() {
    console.log('runAnalysisWithGoogleMaps() è¢«èª¿ç”¨');
    const GOOGLE_API_KEY = 'AIzaSyBwd_GtAZq2eW6KgRRkro__aG7h5ZECJwo';
    const summary = document.getElementById('summary');
    const sLat = parseFloat(document.getElementById('sLat').value);
    const sLng = parseFloat(document.getElementById('sLng').value);
    const eLat = parseFloat(document.getElementById('eLat').value);
    const eLng = parseFloat(document.getElementById('eLng').value);
    const numPoints = parseInt(document.getElementById('samples').value);
    console.log('è¼¸å…¥å€¼:', {sLat, sLng, eLat, eLng, numPoints});
    if (isNaN(sLat) || isNaN(sLng) || isNaN(eLat) || isNaN(eLng)) {
        summary.innerText = 'âŒ è«‹è¼¸å…¥æ‰€æœ‰åº§æ¨™æ•¸å€¼';
        console.error('åº§æ¨™è¼¸å…¥ç„¡æ•ˆ');
        return;
    }
    const totalDist = getDistance(sLat, sLng, eLat, eLng);
    console.log('ç¸½è·é›¢:', totalDist);
    summary.innerHTML = `<span style="color: #ffd43b; font-weight: bold; font-size: 14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (è¼‰å…¥ Google Maps API<span class="loading-dots"></span>)</span>`;
    pathData = [];
    const locations = [];
    for (let i = 0; i < numPoints; i++) {
        const f = i / (numPoints - 1);
        const lat = sLat + (eLat - sLat) * f;
        const lng = sLng + (eLng - sLng) * f;
        locations.push({ lat: lat, lng: lng });
        pathData.push({ dist: (totalDist * f).toFixed(3), lat: lat.toFixed(6), lng: lng.toFixed(6) });
    }
    window.currentPathData = pathData;
    console.log('å–æ¨£é»æ•¸:', locations.length);
    try {
        if (!window.google || !window.google.maps) {
            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=geometry`;
                script.async = true;
                script.defer = true;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        summary.innerHTML = `<span style="color: #ffd43b; font-weight: bold; font-size: 14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (ä½¿ç”¨ Google Maps API åˆ†æä¸­<span class="loading-dots"></span>)</span>`;
        console.log('é–‹å§‹èª¿ç”¨ Google Maps Elevation API...');
        const elevator = new google.maps.ElevationService();
        const elevations = [];
        const batchSize = 512;
        const totalBatches = Math.ceil(locations.length / batchSize);
        for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
            const start = batchIndex * batchSize;
            const end = Math.min(start + batchSize, locations.length);
            const batch = locations.slice(start, end);
            summary.innerHTML = `<span style="color: #ffd43b; font-weight: bold; font-size: 14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (æ‰¹æ¬¡ ${batchIndex + 1}/${totalBatches}<span class="loading-dots"></span>)</span>`;
            const result = await new Promise((resolve, reject) => {
                elevator.getElevationForLocations({
                    locations: batch
                }, (results, status) => {
                    if (status === 'OK') {
                        resolve(results);
                    } else {
                        reject(new Error(`Google Maps API ç‹€æ…‹: ${status}`));
                    }
                });
            });
            console.log(`æ‰¹æ¬¡ ${batchIndex + 1}/${totalBatches} å®Œæˆï¼Œå–å¾— ${result.length} å€‹é«˜åº¦é»`);
            const batchElevations = result.map(r => r.elevation);
            elevations.push(...batchElevations);
            if (batchIndex < totalBatches - 1) {
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        }
        console.log('Google Maps é«˜åº¦æ•¸æ“šç¸½æ•¸:', elevations.length);
        
        // è®€å–å¤©ç·šé«˜åº¦
        const antennaHeightStart = parseFloat(document.getElementById('antennaHeightStart').value) || 0;
        const antennaHeightEnd = parseFloat(document.getElementById('antennaHeightEnd').value) || 0;
        
        // è¨ˆç®—åŒ…å«å¤©ç·šé«˜åº¦çš„3Dç¸½è·é›¢
        const totalDist3D = getDistance3D(sLat, sLng, eLat, eLng, antennaHeightStart, antennaHeightEnd);
        const heightDiff = antennaHeightEnd - antennaHeightStart;
        
        let statusMessage = `<span style="color: #27ae60; font-weight: bold; font-size: 14px;">âœ“ è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (Google Maps API)</span>`;
        
        // å¦‚æœæœ‰è¨­å®šå¤©ç·šé«˜åº¦,é¡¯ç¤º3Dè·é›¢
        if (antennaHeightStart > 0 || antennaHeightEnd > 0) {
            statusMessage += `<br><span style="color: #5ff0d5; font-size: 13px;">ğŸ“¡ å«å¤©ç·šé«˜åº¦ 3D è·é›¢: ${totalDist3D.toFixed(3)} km</span>`;
            statusMessage += `<br><span style="color: #85c9ff; font-size: 12px;">   (Aé»å¤©ç·š: ${antennaHeightStart}m, Bé»å¤©ç·š: ${antennaHeightEnd}m, é«˜åº¦å·®: ${heightDiff >= 0 ? '+' : ''}${heightDiff}m)</span>`;
        }
        
        summary.innerHTML = statusMessage;
        renderChart(elevations);
    } catch (err) {
        console.error('Google Maps API éŒ¯èª¤:', err);
        summary.innerHTML = `âŒ Google Maps API è³‡æ–™ç²å–å¤±æ•—<br><span style="color: #ffd43b; font-weight: bold;">ğŸŒ è©²åŠŸèƒ½éœ€é€£ç¶²ä¸”éœ€æœ‰æ•ˆçš„ API é‡‘é‘°</span><br>${err.message}`;
    }
}
async function runAnalysisWithTaiwanDSM() {
    console.log('runAnalysisWithTaiwanDSM() è¢«èª¿ç”¨');
    const summary = document.getElementById('summary');
    const sLat = parseFloat(document.getElementById('sLat').value);
    const sLng = parseFloat(document.getElementById('sLng').value);
    const eLat = parseFloat(document.getElementById('eLat').value);
    const eLng = parseFloat(document.getElementById('eLng').value);
    const numPoints = parseInt(document.getElementById('samples').value);
    console.log('è¼¸å…¥å€¼:', {sLat, sLng, eLat, eLng, numPoints});
    if (isNaN(sLat) || isNaN(sLng) || isNaN(eLat) || isNaN(eLng)) {
        summary.innerText = 'âŒ è«‹è¼¸å…¥æ‰€æœ‰åº§æ¨™æ•¸å€¼';
        console.error('åº§æ¨™è¼¸å…¥ç„¡æ•ˆ');
        return;
    }
    if (sLat < 21.5 || sLat > 25.5 || sLng < 119.5 || sLng > 122.5 ||
        eLat < 21.5 || eLat > 25.5 || eLng < 119.5 || eLng > 122.5) {
        summary.innerHTML = 'âš ï¸ è­¦å‘Šï¼šåº§æ¨™è¶…å‡ºå°ç£ç¯„åœ<br>å…§æ”¿éƒ¨ DSM åƒ…æ¶µè“‹å°ç£åœ°å€';
    }
    const totalDist = getDistance(sLat, sLng, eLat, eLng);
    console.log('ç¸½è·é›¢:', totalDist);
    summary.innerHTML = `<span style="color: #ffd43b; font-weight: bold; font-size: 14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (ä½¿ç”¨å…§æ”¿éƒ¨ DSM 20m åˆ†æä¸­<span class="loading-dots"></span>)</span>`;
    pathData = [];
    const locations = [];
    for (let i = 0; i < numPoints; i++) {
        const f = i / (numPoints - 1);
        const lat = sLat + (eLat - sLat) * f;
        const lng = sLng + (eLng - sLng) * f;
        locations.push({ lat: lat, lng: lng });
        pathData.push({ dist: (totalDist * f).toFixed(3), lat: lat.toFixed(6), lng: lng.toFixed(6) });
    }
    window.currentPathData = pathData;
    console.log('å–æ¨£é»æ•¸:', locations.length);
    try {
        console.log('é–‹å§‹å¾ Taiwan DSM COG è®€å–é«˜åº¦æ•¸æ“š...');
        if (!window.GeoTIFF) {
            summary.innerHTML = `<span style="color: #ffd43b; font-weight: bold; font-size: 14px;">è¼‰å…¥ GeoTIFF å‡½å¼åº«<span class="loading-dots"></span></span>`;
            await loadGeoTIFFLibrary();
        }
        summary.innerHTML = `<span style="color: #ffd43b; font-weight: bold; font-size: 14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (é€£æ¥ COG æª”æ¡ˆ<span class="loading-dots"></span>)</span>`;
        const cogFilename = 'taiwan_dsm_wgs84_cog.tif';
        console.log('å˜—è©¦è¼‰å…¥ COG æª”æ¡ˆ:', cogFilename);
        let tiff = null;
        let image = null;
        
        // ğŸš€ å„ªåŒ–: ä½¿ç”¨å¿«å–ç³»çµ±
        if (localTifFileData && localTifFileData.tiff && localTifFileData.image) {
            console.log('âœ… ä½¿ç”¨æœ¬åœ° TIF æª”æ¡ˆ:', localTifFileData.fileName);
            summary.innerHTML = `<span style="color: #ffd43b; font-weight: bold; font-size: 14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (ä½¿ç”¨æœ¬åœ°æª”æ¡ˆ: ${localTifFileData.fileName}<span class="loading-dots"></span>)</span>`;
            
            // ä½¿ç”¨å¿«å–çš„æœ¬åœ°æª”æ¡ˆ
            const cached = await getCachedTiff(null, 'local');
            if (!cached.tiff) {
                // é¦–æ¬¡ä½¿ç”¨,å»ºç«‹å¿«å–
                cachedTiffData.local = localTifFileData.tiff;
                cachedImageData.local = localTifFileData.image;
                tiff = localTifFileData.tiff;
                image = localTifFileData.image;
            } else {
                tiff = cached.tiff;
                image = cached.image;
            }
        } else {
            // ğŸš€ å„ªåŒ–: ä½¿ç”¨å¿«å–çš„ GitHub æª”æ¡ˆ (ä¿æŒåŸæœ¬å„ªå…ˆé †åº: å…ˆåŒè³‡æ–™å¤¾,å¾Œ GitHub Pages)
            try {
                // å„ªå…ˆå˜—è©¦åŒè³‡æ–™å¤¾çš„æª”æ¡ˆ
                const cached = await getCachedTiff(cogFilename, 'github');
                tiff = cached.tiff;
                image = cached.image;
                console.log('æˆåŠŸå¾å¿«å–æˆ–åŒè³‡æ–™å¤¾è¼‰å…¥:', cogFilename);
            } catch (err) {
                console.error('å¾ç›¸å°è·¯å¾‘è¼‰å…¥å¤±æ•—ï¼Œå˜—è©¦ GitHub Pages:', err);
                // å¤±æ•—æ‰å˜—è©¦ GitHub Pages
                const githubUrl = 'https://sulapon.github.io/GPS/taiwan_dsm_wgs84_cog.tif';
                try {
                    const cached = await getCachedTiff(githubUrl, 'github');
                    tiff = cached.tiff;
                    image = cached.image;
                    console.log('æˆåŠŸå¾ GitHub Pages è¼‰å…¥:', githubUrl);
                } catch (err2) {
                    console.error('å¾ GitHub Pages è¼‰å…¥å¤±æ•—:', err2);
                    throw new Error(`ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆã€‚è«‹ç¢ºèª:\n1. æª”æ¡ˆ "${cogFilename}" å·²ä¸Šå‚³åˆ°æ­£ç¢ºä½ç½®\n2. GitHub Pages å·²å•Ÿç”¨\n3. æª”æ¡ˆåç¨±æ­£ç¢ºï¼ˆtaiwan_dsm_wgs84_cog.tifï¼‰\n\néŒ¯èª¤: ${err2.message}`);
                }
            }
            
            if (!tiff || !image) {
                throw new Error('ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆ');
            }
            
            summary.innerHTML = `<span style="color: #ffd43b; font-weight: bold; font-size: 14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (è®€å–å½±åƒè³‡è¨Š<span class="loading-dots"></span>)</span>`;
        }
        const bbox = image.getBoundingBox();
        const width = image.getWidth();
        const height = image.getHeight();
        console.log('COG æª”æ¡ˆè³‡è¨Š:', { bbox, width, height });
        summary.innerHTML = `<span style="color: #ffd43b; font-weight: bold; font-size: 14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (è®€å–é«˜åº¦æ•¸æ“š<span class="loading-dots"></span>)</span>`;
        const nodataHandling = document.getElementById('nodataHandling')?.value || 'interpolate';
        console.log('ç¼ºå¤±æ•¸æ“šè™•ç†æ–¹å¼:', nodataHandling);
        const elevations = [];
        let invalidDataCount = 0;
        const batchSize = 100;  // ğŸš€ å„ªåŒ–: å¢åŠ æ‰¹æ¬¡å¤§å°ä»¥æé«˜æ•ˆç‡
        for (let batchStart = 0; batchStart < locations.length; batchStart += batchSize) {
            const batchEnd = Math.min(batchStart + batchSize, locations.length);
            const batch = locations.slice(batchStart, batchEnd);
            for (let i = 0; i < batch.length; i++) {
                const loc = batch[i];
                const globalIndex = batchStart + i;
                const pixelX = Math.floor((loc.lng - bbox[0]) / (bbox[2] - bbox[0]) * width);
                const pixelY = Math.floor((bbox[3] - loc.lat) / (bbox[3] - bbox[1]) * height);
                if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
                    try {
                        const rasters = await image.readRasters({
                            window: [pixelX, pixelY, pixelX + 1, pixelY + 1]
                        });
                        const elevation = rasters[0][0];
                        let validElevation = 0;
                        let isInvalidData = false;
                        if (elevation !== null && elevation !== undefined && !isNaN(elevation) && isFinite(elevation)) {
                            const commonNoDataValues = [-32768, -9999, -99999, -12345, 32767, 65535, -3.4028235e+38];
                            const isNoData = commonNoDataValues.some(noData => Math.abs(elevation - noData) < 0.01);
                            if (!isNoData && elevation >= -500 && elevation <= 4000) {
                                validElevation = elevation;
                            } else {
                                isInvalidData = true;
                                invalidDataCount++;
                                if (nodataHandling === 'interpolate') {
                                    if (elevations.length > 0) {
                                        validElevation = elevations[elevations.length - 1];
                                        console.warn(`åº§æ¨™ ${globalIndex} é«˜åº¦ç•°å¸¸ (${elevation.toFixed(2)}m)ï¼Œä½¿ç”¨å‰å€¼æ’å€¼: ${validElevation.toFixed(2)}m`);
                                    } else {
                                        validElevation = 0;
                                        console.warn(`åº§æ¨™ ${globalIndex} é«˜åº¦ç•°å¸¸ (${elevation.toFixed(2)}m)ï¼Œä½¿ç”¨é è¨­å€¼ 0`);
                                    }
                                } else if (nodataHandling === 'zero') {
                                    validElevation = 0;
                                    console.warn(`åº§æ¨™ ${globalIndex} é«˜åº¦ç•°å¸¸ (${elevation.toFixed(2)}m)ï¼Œè¨­ç‚º 0`);
                                } else if (nodataHandling === 'skip') {
                                    validElevation = null;
                                    console.warn(`åº§æ¨™ ${globalIndex} é«˜åº¦ç•°å¸¸ (${elevation.toFixed(2)}m)ï¼Œæ¨™è¨˜ç‚ºç„¡æ•ˆ`);
                                }
                            }
                        } else {
                            isInvalidData = true;
                            invalidDataCount++;
                            if (nodataHandling === 'interpolate') {
                                if (elevations.length > 0) {
                                    validElevation = elevations[elevations.length - 1];
                                }
                                console.warn(`åº§æ¨™ ${globalIndex} é«˜åº¦ç„¡æ•ˆ (${elevation})ï¼Œä½¿ç”¨${elevations.length > 0 ? 'å‰å€¼' : 'é è¨­å€¼'}: ${validElevation}m`);
                            } else if (nodataHandling === 'zero') {
                                validElevation = 0;
                                console.warn(`åº§æ¨™ ${globalIndex} é«˜åº¦ç„¡æ•ˆ (${elevation})ï¼Œè¨­ç‚º 0`);
                            } else if (nodataHandling === 'skip') {
                                validElevation = null;
                                console.warn(`åº§æ¨™ ${globalIndex} é«˜åº¦ç„¡æ•ˆ (${elevation})ï¼Œæ¨™è¨˜ç‚ºç„¡æ•ˆ`);
                            }
                        }
                        elevations.push(validElevation);
                    } catch (readErr) {
                        console.warn(`è®€å–åº§æ¨™ ${globalIndex} å¤±æ•—:`, readErr);
                        invalidDataCount++;
                        let fallbackValue = 0;
                        if (nodataHandling === 'interpolate' && elevations.length > 0) {
                            fallbackValue = elevations[elevations.length - 1];
                        } else if (nodataHandling === 'skip') {
                            fallbackValue = null;
                        }
                        elevations.push(fallbackValue);
                    }
                } else {
                    console.warn(`åº§æ¨™ ${globalIndex} è¶…å‡º COG ç¯„åœ:`, loc, 'åƒç´ åº§æ¨™:', {pixelX, pixelY});
                    invalidDataCount++;
                    let fallbackValue = 0;
                    if (nodataHandling === 'interpolate' && elevations.length > 0) {
                        fallbackValue = elevations[elevations.length - 1];
                    } else if (nodataHandling === 'skip') {
                        fallbackValue = null;
                    }
                    elevations.push(fallbackValue);
                }
            }
            const progress = Math.round((batchEnd) / locations.length * 100);
            summary.innerHTML = `<span style="color: #ffd43b; font-weight: bold; font-size: 14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (è™•ç†ä¸­ ${progress}%<span class="loading-dots"></span>)</span>`;
        }
        console.log('Taiwan DSM é«˜åº¦æ•¸æ“šç¸½æ•¸:', elevations.length);
        console.log('ç„¡æ•ˆæ•¸æ“šé»æ•¸é‡:', invalidDataCount);
        
        // è®€å–å¤©ç·šé«˜åº¦
        const antennaHeightStart = parseFloat(document.getElementById('antennaHeightStart').value) || 0;
        const antennaHeightEnd = parseFloat(document.getElementById('antennaHeightEnd').value) || 0;
        
        // è¨ˆç®—åŒ…å«å¤©ç·šé«˜åº¦çš„3Dç¸½è·é›¢
        const totalDist3D = getDistance3D(sLat, sLng, eLat, eLng, antennaHeightStart, antennaHeightEnd);
        const heightDiff = antennaHeightEnd - antennaHeightStart;
        
        let statusMessage = `<span style="color: #27ae60; font-weight: bold; font-size: 14px;">âœ“ è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (å…§æ”¿éƒ¨ DSM 20m)</span>`;
        
        // å¦‚æœæœ‰è¨­å®šå¤©ç·šé«˜åº¦,é¡¯ç¤º3Dè·é›¢
        if (antennaHeightStart > 0 || antennaHeightEnd > 0) {
            statusMessage += `<br><span style="color: #5ff0d5; font-size: 13px;">ğŸ“¡ å«å¤©ç·šé«˜åº¦ 3D è·é›¢: ${totalDist3D.toFixed(3)} km</span>`;
            statusMessage += `<br><span style="color: #85c9ff; font-size: 12px;">   (Aé»å¤©ç·š: ${antennaHeightStart}m, Bé»å¤©ç·š: ${antennaHeightEnd}m, é«˜åº¦å·®: ${heightDiff >= 0 ? '+' : ''}${heightDiff}m)</span>`;
        }
        
        if (invalidDataCount > 0) {
            const invalidPercent = ((invalidDataCount / elevations.length) * 100).toFixed(1);
            statusMessage += `<br><span style="color: #ffd43b; font-size: 12px;">âš ï¸ æª¢æ¸¬åˆ° ${invalidDataCount} å€‹ç„¡æ•ˆæ•¸æ“šé» (${invalidPercent}%) - å·²ä½¿ç”¨ã€Œ${
                nodataHandling === 'interpolate' ? 'æ™ºæ…§æ’å€¼' :
                nodataHandling === 'zero' ? 'è¨­ç‚º0ç±³' :
                'æ¨™è¨˜ç„¡æ•ˆ'
            }ã€è™•ç†</span>`;
        }
        summary.innerHTML = statusMessage;
        renderChart(elevations);
    } catch (err) {
        console.error('Taiwan DSM éŒ¯èª¤:', err);
        let errorMsg = `âŒ å…§æ”¿éƒ¨ DSM è³‡æ–™ç²å–å¤±æ•—<br><br>`;
        if (err.message.includes('Invalid byte order') || err.message.includes('GitHub Pages')) {
            errorMsg += `<div style="text-align: left; padding: 10px; background: rgba(255,170,0,0.1); border-radius: 6px; margin: 10px 0;">
                <strong style="color: #ffd43b;">ğŸ“‹ è¨­å®š GitHub Pages æ­¥é©Ÿ:</strong><br>
                1ï¸âƒ£ é–‹å•Ÿ <a href="https://github.com/sulapon/GPS/settings/pages" target="_blank" style="color: #5ff0d5;">GitHub å°ˆæ¡ˆè¨­å®š</a><br>
                2ï¸âƒ£ åœ¨ Pages é¸é …ä¸­é¸æ“‡ "main" åˆ†æ”¯<br>
                3ï¸âƒ£ ç­‰å¾… 1-2 åˆ†é˜éƒ¨ç½²å®Œæˆ<br>
                4ï¸âƒ£ é‡æ–°åŸ·è¡Œåˆ†æ<br><br>
                <span style="color: #a8b3c3; font-size: 12px;">æˆ–ä½¿ç”¨å…¶ä»–è³‡æ–™æºå¦‚ Google Maps API</span>
            </div>`;
        } else {
            errorMsg += `<span style="color: #ffd43b; font-weight: bold;">ğŸŒ è«‹ç¢ºèª:</span><br>
                â€¢ ç¶²è·¯é€£ç·šæ­£å¸¸<br>
                â€¢ GitHub Pages å·²å•Ÿç”¨<br>
                â€¢ COG æª”æ¡ˆå¯æ­£å¸¸è¨ªå•<br><br>
                <span style="font-size: 12px; color: #a8b3c3;">éŒ¯èª¤è©³æƒ…: ${err.message}</span>`;
        }
        summary.innerHTML = errorMsg;
    }
}
async function loadGeoTIFFLibrary() {
    return new Promise((resolve, reject) => {
        if (window.GeoTIFF) {
            resolve();
            return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js';
        script.async = true;
        script.onload = () => {
            console.log('GeoTIFF å‡½å¼åº«è¼‰å…¥æˆåŠŸ');
            resolve();
        };
        script.onerror = () => {
            reject(new Error('ç„¡æ³•è¼‰å…¥ GeoTIFF å‡½å¼åº«'));
        };
        document.head.appendChild(script);
    });
}
function renderChart(elevations) {
    console.log('renderChart() è¢«èª¿ç”¨ï¼Œé«˜åº¦æ•¸æ“šé•·åº¦:', elevations.length);
    const labelALat = document.getElementById('labelALat');
    const labelBLat = document.getElementById('labelBLat');
    if (labelALat && labelALat.innerHTML) {
        const matchA = labelALat.innerHTML.match(/<span[^>]*>([^<]+)<\/span>/);
        if (matchA && matchA[1]) {
            window.elevationPointAName = matchA[1].trim();
            console.log('å¾æ¨™ç±¤Aæå–åœ°å:', window.elevationPointAName);
        }
    }
    if (labelBLat && labelBLat.innerHTML) {
        const matchB = labelBLat.innerHTML.match(/<span[^>]*>([^<]+)<\/span>/);
        if (matchB && matchB[1]) {
            window.elevationPointBName = matchB[1].trim();
            console.log('å¾æ¨™ç±¤Bæå–åœ°å:', window.elevationPointBName);
        }
    }
    if (!window.elevationPointAName) {
        window.elevationPointAName = 'Aé»';
    }
    if (!window.elevationPointBName) {
        window.elevationPointBName = 'Bé»';
    }
    console.log('renderChart è¨­ç½®çš„åœ°å - Aé»:', window.elevationPointAName, 'Bé»:', window.elevationPointBName);
    const antennaHeightStart = parseFloat(document.getElementById('antennaHeightStart').value) || 0;
    const antennaHeightEnd = parseFloat(document.getElementById('antennaHeightEnd').value) || 0;
    const adjustedElevations = elevations.map((elev, i) => {
        if (i === 0) {
            return elev + antennaHeightStart;
        } else if (i === elevations.length - 1) {
            return elev + antennaHeightEnd;
        }
        return elev;
    });
    elevationData = adjustedElevations;
    console.log('å·²ä¿å­˜elevationæ•¸æ“šï¼ˆå«å¤©ç·šé«˜åº¦ï¼‰');
    console.log('å¤©ç·šé«˜åº¦ - Aé»:', antennaHeightStart, 'Bé»:', antennaHeightEnd);
    const ctx = document.getElementById('elevationChart');
    if (!ctx) {
        console.error('æ‰¾ä¸åˆ° elevationChart canvas');
        return;
    }
    const pointColors = adjustedElevations.map((_, i) => '#28a745');
    const losLine = adjustedElevations.map((_, i) =>
        adjustedElevations[0] + (adjustedElevations[adjustedElevations.length-1] - adjustedElevations[0]) * (i / (adjustedElevations.length-1))
    );
    const R = 6371000;
    const sLat = parseFloat(document.getElementById('sLat').value);
    const sLng = parseFloat(document.getElementById('sLng').value);
    const eLat = parseFloat(document.getElementById('eLat').value);
    const eLng = parseFloat(document.getElementById('eLng').value);
    const totalDist = getDistance(sLat, sLng, eLat, eLng);
    const totalDistM = totalDist * 1000;
    
    // ğŸ¯ åŒæ­¥æ›´æ–°RFå·¥å…·çš„Link Budgetè·é›¢ (ä½¿ç”¨åŒ…å«å¤©ç·šé«˜åº¦çš„3Dè·é›¢)
    const linkDistInput = document.getElementById('link_dist_km');
    if (linkDistInput) {
        // è¨ˆç®—åŒ…å«å¤©ç·šé«˜åº¦çš„3Dè·é›¢
        const totalDist3D = getDistance3D(sLat, sLng, eLat, eLng, antennaHeightStart, antennaHeightEnd);
        
        // ä½¿ç”¨3Dè·é›¢æ›´æ–°Link Budget
        linkDistInput.value = totalDist3D.toFixed(3);
        
        // è§¸ç™¼Link Budgeté‡æ–°è¨ˆç®—
        if (typeof calculateLinkBudget === 'function') {
            calculateLinkBudget();
        }
        
        console.log('å·²åŒæ­¥æ›´æ–°Link Budgetè·é›¢:', totalDist3D.toFixed(3), 'km (å«å¤©ç·šé«˜åº¦)');
    }
    const losLineWithCurvature = adjustedElevations.map((_, i) => {
        const f = i / (adjustedElevations.length - 1);
        const distFromStart = totalDistM * f;
        const straightLineHeight = adjustedElevations[0] + (adjustedElevations[adjustedElevations.length-1] - adjustedElevations[0]) * f;
        const d1 = distFromStart;
        const d2 = totalDistM - distFromStart;
        const earthDrop = (d1 * d2) / (2 * R);
        return straightLineHeight - earthDrop;
    });
    
    // è¨ˆç®—è²æ¶…çˆ¾åŠå¾‘æ‰€éœ€çš„æ³¢é•·
    const freqMHz = parseFloat(document.getElementById('link_freq_mhz')?.value) || 2400;
    const freqHz = freqMHz * 1e6; // è½‰æ›ç‚º Hz
    const c = 299792458; // å…‰é€Ÿ m/s
    const lambda = c / freqHz; // æ³¢é•·
    if (chartInstance) {
        chartInstance.destroy();
    }
    if (typeof window.labelAOffset === 'undefined') {
        window.labelAOffset = { x: 0, y: -40 };
    }
    if (typeof window.labelBOffset === 'undefined') {
        window.labelBOffset = { x: 0, y: -40 };
    }
    if (typeof window.draggingLabel === 'undefined') {
        window.draggingLabel = null;
        window.dragStartX = 0;
        window.dragStartY = 0;
        window.dragStartOffsetX = 0;
        window.dragStartOffsetY = 0;
    }
    if (typeof window.labelTextVertical === 'undefined') {
        window.labelTextVertical = {
            A: false,
            B: false
        };
    }
    const pointLabelPlugin = {
        id: 'pointLabelPlugin',
        afterDatasetsDraw: (chart) => {
            const ctx = chart.ctx;
            const xAxis = chart.scales.x;
            const yAxis = chart.scales.y;
            const chartArea = chart.chartArea;
            const nameA = window.elevationPointAName || 'Aé»';
            const nameB = window.elevationPointBName || 'Bé»';
            const datasetIndex = 0;
            const dataset = chart.data.datasets[datasetIndex];
            if (dataset.data.length > 0) {
                const xA = xAxis.getPixelForValue(0);
                const yA = yAxis.getPixelForValue(dataset.data[0]);
                ctx.save();
                ctx.font = 'bold 14px Inter, sans-serif';
                const textWidthA = ctx.measureText(nameA).width;
                const paddingA = 8;
                const boxWidthA = textWidthA + paddingA * 2;
                const boxHeightA = 24;
                let labelXA = xA + window.labelAOffset.x;
                let labelYA = yA + window.labelAOffset.y;
                const halfBoxWidth = boxWidthA / 2;
                if (labelXA - halfBoxWidth < chartArea.left) {
                    labelXA = chartArea.left + halfBoxWidth + 2;
                }
                if (labelXA + halfBoxWidth > chartArea.right) {
                    labelXA = chartArea.right - halfBoxWidth - 2;
                }
                const halfBoxHeight = boxHeightA / 2;
                if (labelYA - halfBoxHeight < chartArea.top) {
                    labelYA = chartArea.top + halfBoxHeight + 2;
                }
                if (labelYA + halfBoxHeight > chartArea.bottom) {
                    labelYA = chartArea.bottom - halfBoxHeight - 2;
                }
                const boxY = labelYA - halfBoxHeight;
                const boxX = labelXA - halfBoxWidth;
                window.labelABounds = {
                    x: boxX,
                    y: boxY,
                    width: boxWidthA,
                    height: boxHeightA,
                    centerX: labelXA,
                    centerY: labelYA
                };
                if (window.draggingLabel === 'A') {
                    ctx.fillStyle = 'rgba(255, 229, 143, 1)';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 2;
                } else {
                    ctx.fillStyle = 'rgba(255, 229, 143, 0.95)';
                }
                ctx.beginPath();
                ctx.roundRect(boxX, boxY, boxWidthA, boxHeightA, 5);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 200, 100, 1)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#022';
                if (window.labelTextVertical.A) {
                    ctx.save();
                    const chars = nameA.split('');
                    const charHeight = boxHeightA / (chars.length + 1);
                    chars.forEach((char, i) => {
                        ctx.fillText(char, labelXA, boxY + charHeight * (i + 1));
                    });
                    ctx.restore();
                } else {
                    ctx.fillText(nameA, labelXA, boxY + boxHeightA / 2);
                }
                ctx.fillStyle = 'rgba(0, 34, 34, 0.3)';
                ctx.beginPath();
                ctx.arc(boxX + 6, boxY + boxHeightA / 2, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(boxX + boxWidthA - 6, boxY + boxHeightA / 2, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            if (dataset.data.length > 0) {
                const lastIndex = dataset.data.length - 1;
                const xB = xAxis.getPixelForValue(lastIndex);
                const yB = yAxis.getPixelForValue(dataset.data[lastIndex]);
                ctx.save();
                ctx.font = 'bold 14px Inter, sans-serif';
                const textWidthB = ctx.measureText(nameB).width;
                const paddingB = 8;
                const boxWidthB = textWidthB + paddingB * 2;
                const boxHeightB = 24;
                let labelXB = xB + window.labelBOffset.x;
                let labelYB = yB + window.labelBOffset.y;
                const halfBoxWidth = boxWidthB / 2;
                if (labelXB - halfBoxWidth < chartArea.left) {
                    labelXB = chartArea.left + halfBoxWidth + 2;
                }
                if (labelXB + halfBoxWidth > chartArea.right) {
                    labelXB = chartArea.right - halfBoxWidth - 2;
                }
                const halfBoxHeight = boxHeightB / 2;
                if (labelYB - halfBoxHeight < chartArea.top) {
                    labelYB = chartArea.top + halfBoxHeight + 2;
                }
                if (labelYB + halfBoxHeight > chartArea.bottom) {
                    labelYB = chartArea.bottom - halfBoxHeight - 2;
                }
                const boxY = labelYB - halfBoxHeight;
                const boxX = labelXB - halfBoxWidth;
                window.labelBBounds = {
                    x: boxX,
                    y: boxY,
                    width: boxWidthB,
                    height: boxHeightB,
                    centerX: labelXB,
                    centerY: labelYB
                };
                if (window.draggingLabel === 'B') {
                    ctx.fillStyle = 'rgba(255, 229, 143, 1)';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 2;
                } else {
                    ctx.fillStyle = 'rgba(255, 229, 143, 0.95)';
                }
                ctx.beginPath();
                ctx.roundRect(boxX, boxY, boxWidthB, boxHeightB, 5);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 200, 100, 1)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#022';
                if (window.labelTextVertical.B) {
                    ctx.save();
                    const chars = nameB.split('');
                    const charHeight = boxHeightB / (chars.length + 1);
                    chars.forEach((char, i) => {
                        ctx.fillText(char, labelXB, boxY + charHeight * (i + 1));
                    });
                    ctx.restore();
                } else {
                    ctx.fillText(nameB, labelXB, boxY + boxHeightB / 2);
                }
                ctx.fillStyle = 'rgba(0, 34, 34, 0.3)';
                ctx.beginPath();
                ctx.arc(boxX + 6, boxY + boxHeightB / 2, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(boxX + boxWidthB - 6, boxY + boxHeightB / 2, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
    };
    const totalDistancePlugin = {
        id: 'totalDistance',
        afterDraw(chart) {
            const ctx = chart.ctx;
            const xAxis = chart.scales.x;
            const yAxis = chart.scales.y;
            const totalDist = pathData[pathData.length - 1].dist;
            ctx.save();
            ctx.font = '12px Arial';
            ctx.fillStyle = '#ffd43b';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            const text = `ç¸½è·é›¢: ${parseFloat(totalDist).toFixed(2)} km`;
            const x = xAxis.right + 2;  // å¾ -5 æ”¹ç‚º +2ï¼ˆå³ç§»ç´„7åƒç´ ï¼‰
            const y = yAxis.bottom + 28;  // å¾35æ”¹ç‚º28ï¼ˆä¸Šç§»7åƒç´ ï¼‰
            ctx.fillStyle = '#ffe58f';
            ctx.fillText(text, x, y);
            ctx.restore();
        }
    };
    // é »ç‡é¡¯ç¤ºæ’ä»¶
    const frequencyDisplayPlugin = {
        id: 'frequencyDisplay',
        afterDraw(chart) {
            // æª¢æŸ¥è²æ¶…çˆ¾å€æ˜¯å¦é¡¯ç¤ºï¼ˆindex 2 æ˜¯è²æ¶…çˆ¾å€ä¸Šç•Œï¼‰
            const fresnelMeta = chart.getDatasetMeta(2);
            
            // å¦‚æœè²æ¶…çˆ¾å€éš±è—(hidden=true)æˆ–æœªå®šç¾©æ™‚é è¨­ç‚ºtrueï¼Œå‰‡ä¸é¡¯ç¤ºé »ç‡
            const isHidden = fresnelMeta.hidden !== false;  // é è¨­è¦–ç‚ºéš±è—
            if (isHidden) return;
            
            const ctx = chart.ctx;
            const xAxis = chart.scales.x;
            const yAxis = chart.scales.y;
            
            // å–å¾—ç•¶å‰é »ç‡
            const freqMHz = parseFloat(document.getElementById('link_freq_mhz')?.value) || 2400;
            
            ctx.save();
            ctx.font = '12px Arial';  // èˆ‡ç¸½è·é›¢ç›¸åŒçš„å­—é«”
            ctx.fillStyle = '#ffe58f';  // èˆ‡ç¸½è·é›¢ç›¸åŒçš„é¡è‰²
            ctx.textAlign = 'right';  // æ”¹ç‚ºå³å°é½Š
            ctx.textBaseline = 'top';
            
            const text = `é »ç‡: ${freqMHz} MHz`;
            const x = xAxis.right + 2;  // å¾ -5 æ”¹ç‚º +2ï¼ˆå³ç§»ç´„7åƒç´ ï¼Œèˆ‡ç¸½è·é›¢å°é½Šï¼‰
            const y = yAxis.bottom + 43;  // å¾50æ”¹ç‚º43ï¼ˆä¸Šç§»7åƒç´ ï¼‰
            
            ctx.fillText(text, x, y);
            ctx.restore();
        }
    };
    window.currentSelectedPointIndex = -1;
    const pointRadiusArray = adjustedElevations.map((_, i) => 3);
    const pointHoverRadiusArray = adjustedElevations.map((_, i) => 8);
    const pointColorArray = adjustedElevations.map((_, i) => '#28a745');
    chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: pathData.map(p => Math.round(parseFloat(p.dist)).toString()),
            datasets: [
                {
                    label: 'åœ°å½¢æµ·æ‹” (m)',
                    data: adjustedElevations,
                    borderColor: '#28a745',
                    backgroundColor: 'rgba(40, 167, 69, 0.2)',
                    fill: true,
                    tension: 0.4,
                    pointRadius: pointRadiusArray,
                    pointHoverRadius: pointHoverRadiusArray,
                    pointBackgroundColor: pointColorArray,
                    pointBorderWidth: 0,
                    order: 2,
                    cubicInterpolationMode: 'monotone'
                },
                {
                    label: 'è¦–è·é€£ç·š (è€ƒæ…®åœ°çƒæ›²åº¦)',
                    data: losLineWithCurvature,
                    borderColor: '#dc3545',
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0,
                    order: 3,
                    tension: 0.4,
                    cubicInterpolationMode: 'monotone'
                },
                {
                    label: 'è²æ¶…çˆ¾å€ (60%)',
                    data: losLineWithCurvature.map((losVal, i) => {
                        // åœ¨èµ·é»å’Œçµ‚é»ï¼Œè²æ¶…çˆ¾å€åŠå¾‘æ‡‰è©²ç‚º 0
                        if (i === 0 || i === adjustedElevations.length - 1) {
                            return losVal;
                        }
                        
                        const f = i / (adjustedElevations.length - 1);
                        const distFromStartKm = totalDist * f;  // km
                        const d1 = distFromStartKm;  // km
                        const d2 = totalDist - distFromStartKm;  // km
                        
                        // é¡å¤–æª¢æŸ¥ï¼šå¦‚æœè·é›¢ç«¯é»å¤ªè¿‘ï¼ˆ< 0.1 kmï¼‰ï¼Œä¹Ÿè¿”å›è¦–è·ç·šå€¼
                        if (d1 < 0.1 || d2 < 0.1) {
                            return losVal;
                        }
                        
                        // ä½¿ç”¨å·¥ç¨‹å…¬å¼è¨ˆç®—ç¬¬ä¸€è²æ¶…çˆ¾å€åŠå¾‘ (ç±³)
                        // râ‚ = 17.3 Ã— âˆš(d1 Ã— d2 / (f Ã— D))
                        const freqGHz = freqMHz / 1000;  // è½‰æ›ç‚º GHz
                        const D = totalDist;  // ç¸½è·é›¢ km
                        const fresnelRadius = 17.3 * Math.sqrt((d1 * d2) / (freqGHz * D));
                        
                        return losVal + fresnelRadius * 0.6;
                    }),
                    borderColor: 'rgba(255, 193, 7, 0.6)',
                    borderDash: [3, 3],
                    fill: false,
                    pointRadius: 0,
                    order: 4,
                    tension: 0.4,
                    cubicInterpolationMode: 'monotone',
                    hidden: true  // é è¨­éš±è—
                },
                {
                    label: 'è²æ¶…çˆ¾å€ä¸‹ç•Œ',
                    data: losLineWithCurvature.map((losVal, i) => {
                        // åœ¨èµ·é»å’Œçµ‚é»ï¼Œè²æ¶…çˆ¾å€åŠå¾‘æ‡‰è©²ç‚º 0
                        if (i === 0 || i === adjustedElevations.length - 1) {
                            return losVal;
                        }
                        
                        const f = i / (adjustedElevations.length - 1);
                        const distFromStartKm = totalDist * f;  // km
                        const d1 = distFromStartKm;  // km
                        const d2 = totalDist - distFromStartKm;  // km
                        
                        // é¡å¤–æª¢æŸ¥ï¼šå¦‚æœè·é›¢ç«¯é»å¤ªè¿‘ï¼ˆ< 0.1 kmï¼‰ï¼Œä¹Ÿè¿”å›è¦–è·ç·šå€¼
                        if (d1 < 0.1 || d2 < 0.1) {
                            return losVal;
                        }
                        
                        const freqGHz = freqMHz / 1000;
                        const D = totalDist;
                        const fresnelRadius = 17.3 * Math.sqrt((d1 * d2) / (freqGHz * D));
                        
                        return losVal - fresnelRadius * 0.6;
                    }),
                    borderColor: 'rgba(255, 193, 7, 0.6)',
                    borderDash: [3, 3],
                    fill: false,
                    pointRadius: 0,
                    order: 4,
                    tension: 0.4,
                    cubicInterpolationMode: 'monotone',
                    hidden: true  // é è¨­éš±è—
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: {
                    left: 10,
                    right: 20,
                    top: 5,
                    bottom: 5
                }
            },
            onClick: (event, elements) => {
                selectedPointsInCurrentHeight.clear();
                console.log('é»æ“Šåœ–è¡¨ï¼Œelements:', elements);
                if (elements.length > 0) {
                    const idx = elements[0].index;
                    console.log('é¸ä¸­ç´¢å¼•:', idx);
                    for (let i = 0; i < pointColorArray.length; i++) {
                        if (i === idx) {
                            pointColorArray[i] = '#ffd43b';
                            pointRadiusArray[i] = 6;
                            pointHoverRadiusArray[i] = 10;
                        } else {
                            pointColorArray[i] = '#28a745';
                            if (typeof greenPointsVisible !== 'undefined' && !greenPointsVisible) {
                                pointRadiusArray[i] = 0;
                                pointHoverRadiusArray[i] = 0;
                            } else {
                                pointRadiusArray[i] = 3;
                                pointHoverRadiusArray[i] = 8;
                            }
                        }
                    }
                    window.currentSelectedPointIndex = idx;
                    chartInstance.data.datasets[0].pointBackgroundColor = pointColorArray;
                    chartInstance.data.datasets[0].pointRadius = pointRadiusArray;
                    chartInstance.data.datasets[0].pointHoverRadius = pointHoverRadiusArray;
                    chartInstance.update();
                    showMap(idx, elevations[idx]);
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: (ctx) => `é«˜åº¦: ${ctx.parsed.y} m | è·é›¢: ${pathData[ctx.dataIndex].dist} km`
                    }
                },
                legend: {
                    labels: {
                        color: '#e8eef5',
                        font: { size: 14 },
                        boxWidth: 15,
                        boxHeight: 15,
                        padding: 10,
                        usePointStyle: false,
                        filter: function(legendItem, chartData) {
                            // éš±è—ã€Œè²æ¶…çˆ¾å€ä¸‹ç•Œã€åœ–ä¾‹é …ç›®
                            return legendItem.text !== 'è²æ¶…çˆ¾å€ä¸‹ç•Œ';
                        }
                    },
                    display: true,
                    position: 'top',
                    align: 'center',
                    onClick: function(e, legendItem, legend) {
                        const index = legendItem.datasetIndex;
                        const chart = legend.chart;
                        const meta = chart.getDatasetMeta(index);
                        
                        // å¦‚æœé»æ“Šçš„æ˜¯è²æ¶…çˆ¾å€ï¼ŒåŒæ™‚åˆ‡æ›ä¸Šç•Œå’Œä¸‹ç•Œ
                        if (legendItem.text === 'è²æ¶…çˆ¾å€ (60%)') {
                            const upperMeta = chart.getDatasetMeta(index);
                            const lowerMeta = chart.getDatasetMeta(index + 1);
                            
                            // ç°¡åŒ–é‚è¼¯ï¼šç›´æ¥åˆ‡æ›å¸ƒæ—å€¼
                            const newState = !upperMeta.hidden;
                            upperMeta.hidden = newState;
                            lowerMeta.hidden = newState;
                        } else {
                            // ç°¡åŒ–é‚è¼¯ï¼šç›´æ¥åˆ‡æ›å¸ƒæ—å€¼
                            meta.hidden = !meta.hidden;
                        }
                        
                        chart.update();
                    }
                }
            },
            scales: {
                x: {
                    ticks: { color: '#e8eef5', font: { size: 12 }, maxRotation: 0, minRotation: 0 },
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    title: { display: true, text: 'è·é›¢ (km)', color: '#e8eef5' },
                    min: isNaN(parseFloat(document.getElementById('minDistance').value)) ? undefined : parseFloat(document.getElementById('minDistance').value),
                    max: isNaN(parseFloat(document.getElementById('maxDistance').value)) ? undefined : parseFloat(document.getElementById('maxDistance').value)
                },
                y: {
                    ticks: { color: '#e8eef5', font: { size: 12 } },
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    title: { display: true, text: 'é«˜åº¦ (m)', color: '#e8eef5' },
                    min: isNaN(parseFloat(document.getElementById('minElevation').value)) ? undefined : parseFloat(document.getElementById('minElevation').value),
                    max: isNaN(parseFloat(document.getElementById('maxElevation').value)) ? undefined : parseFloat(document.getElementById('maxElevation').value)
                }
            }
        },
        plugins: [pointLabelPlugin, totalDistancePlugin, frequencyDisplayPlugin]
    });
    const canvas = document.getElementById('elevationChart');
    function isPointInLabel(x, y, labelBounds) {
        if (!labelBounds) return false;
        return x >= labelBounds.x &&
               x <= labelBounds.x + labelBounds.width &&
               y >= labelBounds.y &&
               y <= labelBounds.y + labelBounds.height;
    }
    function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }
    canvas.addEventListener('mousedown', function(e) {
        const pos = getMousePos(canvas, e);
        window.clickStartTime = Date.now();
        window.clickStartPos = { x: pos.x, y: pos.y };
        if (isPointInLabel(pos.x, pos.y, window.labelABounds)) {
            window.draggingLabel = 'A';
            window.dragStartX = pos.x;
            window.dragStartY = pos.y;
            window.dragStartOffsetX = window.labelAOffset.x;
            window.dragStartOffsetY = window.labelAOffset.y;
            canvas.style.cursor = 'grabbing';
            e.preventDefault();
        } else if (isPointInLabel(pos.x, pos.y, window.labelBBounds)) {
            window.draggingLabel = 'B';
            window.dragStartX = pos.x;
            window.dragStartY = pos.y;
            window.dragStartOffsetX = window.labelBOffset.x;
            window.dragStartOffsetY = window.labelBOffset.y;
            canvas.style.cursor = 'grabbing';
            e.preventDefault();
        }
    });
    canvas.addEventListener('mousemove', function(e) {
        const pos = getMousePos(canvas, e);
        if (window.draggingLabel) {
            const deltaX = pos.x - window.dragStartX;
            const deltaY = pos.y - window.dragStartY;
            if (window.draggingLabel === 'A') {
                window.labelAOffset.x = window.dragStartOffsetX + deltaX;
                window.labelAOffset.y = window.dragStartOffsetY + deltaY;
            } else if (window.draggingLabel === 'B') {
                window.labelBOffset.x = window.dragStartOffsetX + deltaX;
                window.labelBOffset.y = window.dragStartOffsetY + deltaY;
            }
            chartInstance.update('none');
            e.preventDefault();
        } else {
            if (isPointInLabel(pos.x, pos.y, window.labelABounds) ||
                isPointInLabel(pos.x, pos.y, window.labelBBounds)) {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'default';
            }
        }
    });
    canvas.addEventListener('mouseup', function(e) {
        const pos = getMousePos(canvas, e);
        const clickDuration = Date.now() - (window.clickStartTime || 0);
        const moveDistance = window.clickStartPos ?
            Math.sqrt(Math.pow(pos.x - window.clickStartPos.x, 2) + Math.pow(pos.y - window.clickStartPos.y, 2)) : 0;
        const isClick = clickDuration < 300 && moveDistance < 5;
        if (window.draggingLabel && isClick) {
            const label = window.draggingLabel;
            window.labelTextVertical[label] = !window.labelTextVertical[label];
            console.log(`åˆ‡æ›${label}æ¨™ç±¤æ–‡å­—æ–¹å‘ï¼š${window.labelTextVertical[label] ? 'å‚ç›´' : 'æ©«å‘'}`);
        }
        if (window.draggingLabel) {
            window.draggingLabel = null;
            canvas.style.cursor = 'default';
            chartInstance.update();
        }
    });
    canvas.addEventListener('mouseleave', function(e) {
        if (window.draggingLabel) {
            window.draggingLabel = null;
            canvas.style.cursor = 'default';
            chartInstance.update();
        }
    });
    canvas.addEventListener('touchstart', function(e) {
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            const pos = getMousePos(canvas, touch);
            if (isPointInLabel(pos.x, pos.y, window.labelABounds)) {
                window.draggingLabel = 'A';
                window.dragStartX = pos.x;
                window.dragStartY = pos.y;
                window.dragStartOffsetX = window.labelAOffset.x;
                window.dragStartOffsetY = window.labelAOffset.y;
                e.preventDefault();
            } else if (isPointInLabel(pos.x, pos.y, window.labelBBounds)) {
                window.draggingLabel = 'B';
                window.dragStartX = pos.x;
                window.dragStartY = pos.y;
                window.dragStartOffsetX = window.labelBOffset.x;
                window.dragStartOffsetY = window.labelBOffset.y;
                e.preventDefault();
            }
        }
    });
    canvas.addEventListener('touchmove', function(e) {
        if (window.draggingLabel && e.touches.length === 1) {
            const touch = e.touches[0];
            const pos = getMousePos(canvas, touch);
            const deltaX = pos.x - window.dragStartX;
            const deltaY = pos.y - window.dragStartY;
            if (window.draggingLabel === 'A') {
                window.labelAOffset.x = window.dragStartOffsetX + deltaX;
                window.labelAOffset.y = window.dragStartOffsetY + deltaY;
            } else if (window.draggingLabel === 'B') {
                window.labelBOffset.x = window.dragStartOffsetX + deltaX;
                window.labelBOffset.y = window.dragStartOffsetY + deltaY;
            }
            chartInstance.update('none');
            e.preventDefault();
        }
    });
    canvas.addEventListener('touchend', function(e) {
        if (window.draggingLabel) {
            window.draggingLabel = null;
            chartInstance.update();
        }
    });
    console.log('åœ–è¡¨å·²ç¹ªè£½');
    const selectedPointInput = document.getElementById('selectedPointIndex');
    let currentSelectedIndex = 0;
    if (selectedPointInput && selectedPointInput.value) {
        currentSelectedIndex = parseInt(selectedPointInput.value) - 1;
        if (currentSelectedIndex < 0 || currentSelectedIndex >= adjustedElevations.length) {
            currentSelectedIndex = 0;
        }
    } else if (isFirstProfileGeneration) {
        if (selectedPointInput) {
            selectedPointInput.value = 1;
        }
        currentSelectedIndex = 0;
    }
    console.log('å½“å‰é€‰å®šç´¢å¼•:', currentSelectedIndex);
    showMap(currentSelectedIndex, adjustedElevations[currentSelectedIndex]);
    if (isFirstProfileGeneration) {
        isFirstProfileGeneration = false;
    }
    showRouteMap();
}
let greenPointsVisible = false;
function toggleGreenPoints() {
    if (!chartInstance || !chartInstance.data.datasets[0]) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    const btn = document.getElementById('toggleGreenPointsBtn');
    const pointRadiusArray = chartInstance.data.datasets[0].pointRadius;
    const pointHoverRadiusArray = chartInstance.data.datasets[0].pointHoverRadius;
    const currentSelectedIndex = window.currentSelectedPointIndex || -1;
    greenPointsVisible = !greenPointsVisible;
    if (greenPointsVisible) {
        btn.innerHTML = 'ğŸ‘ï¸ éš±è—ç¯€é»';
        btn.style.background = 'linear-gradient(90deg,#28a745,#20c997)';
        for (let i = 0; i < pointRadiusArray.length; i++) {
            if (i === currentSelectedIndex) {
                pointRadiusArray[i] = 6;
                pointHoverRadiusArray[i] = 10;
            } else {
                pointRadiusArray[i] = 3;
                pointHoverRadiusArray[i] = 8;
            }
        }
    } else {
        btn.innerHTML = 'ğŸ‘ï¸ é¡¯ç¤ºç¯€é»';
        btn.style.background = 'linear-gradient(90deg,#6c757d,#5a6268)';
        for (let i = 0; i < pointRadiusArray.length; i++) {
            if (i === currentSelectedIndex) {
                pointRadiusArray[i] = 6;
                pointHoverRadiusArray[i] = 10;
            } else {
                pointRadiusArray[i] = 0;
                pointHoverRadiusArray[i] = 0;
            }
        }
    }
    chartInstance.data.datasets[0].pointRadius = pointRadiusArray;
    chartInstance.data.datasets[0].pointHoverRadius = pointHoverRadiusArray;
    chartInstance.update();
    console.log('ç¯€é»é¡¯ç¤ºç‹€æ…‹å·²åˆ‡æ›:', greenPointsVisible ? 'é¡¯ç¤º' : 'éš±è—');
}
function updateChartYAxis() {
    console.log('updateChartYAxis() è¢«èª¿ç”¨');
    const minValue = parseFloat(document.getElementById('minElevation').value);
    const maxValue = parseFloat(document.getElementById('maxElevation').value);
    if (chartInstance) {
        chartInstance.options.scales.y.min = isNaN(minValue) ? undefined : minValue;
        chartInstance.options.scales.y.max = isNaN(maxValue) ? undefined : maxValue;
        chartInstance.update();
        console.log('ä¸»åœ–è¡¨Yè»¸å·²æ›´æ–° - min:', minValue, 'max:', maxValue);
    }
    if (fullscreenChartInstance) {
        fullscreenChartInstance.options.scales.y.min = isNaN(minValue) ? undefined : minValue;
        fullscreenChartInstance.options.scales.y.max = isNaN(maxValue) ? undefined : maxValue;
        fullscreenChartInstance.update();
        console.log('å…¨è¢å¹•åœ–è¡¨Yè»¸å·²æ›´æ–° - min:', minValue, 'max:', maxValue);
    }
}
function updateChartXAxis() {
    console.log('updateChartXAxis() è¢«èª¿ç”¨');
    const minValue = parseFloat(document.getElementById('minDistance').value);
    const maxValue = parseFloat(document.getElementById('maxDistance').value);
    if (chartInstance) {
        chartInstance.options.scales.x.min = isNaN(minValue) ? undefined : minValue;
        chartInstance.options.scales.x.max = isNaN(maxValue) ? undefined : maxValue;
        chartInstance.update();
        console.log('ä¸»åœ–è¡¨Xè»¸å·²æ›´æ–° - min:', minValue, 'max:', maxValue);
    }
    if (fullscreenChartInstance) {
        fullscreenChartInstance.options.scales.x.min = isNaN(minValue) ? undefined : minValue;
        fullscreenChartInstance.options.scales.x.max = isNaN(maxValue) ? undefined : maxValue;
        fullscreenChartInstance.update();
        console.log('å…¨è¢å¹•åœ–è¡¨Xè»¸å·²æ›´æ–° - min:', minValue, 'max:', maxValue);
    }
}
let fullscreenChartInstance = null;
let fullscreenLabelAOffset = { x: 0, y: -30 };
let fullscreenLabelBOffset = { x: 0, y: -30 };
let fullscreenDraggingLabel = null;
let fullscreenIgnoreNextClick = false;
let tooltipDraggingFullscreen = false;
let tooltipOffsetX = 0;
let tooltipOffsetY = -100;

// å¼·åˆ¶ç¶å®štooltipæ‹–æ›³åŠŸèƒ½çš„å‡½æ•¸
function makeTooltipDraggable(tooltipEl) {
    console.log('ç¶å®štooltipæ‹–æ›³åŠŸèƒ½');
    
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let startOffsetX = 0;
    let startOffsetY = 0;
    
    // æ»‘é¼ æŒ‰ä¸‹
    tooltipEl.addEventListener('mousedown', function(e) {
        console.log('Tooltip mousedown è§¸ç™¼');
        isDragging = true;
        tooltipDraggingFullscreen = true;
        
        startX = e.clientX;
        startY = e.clientY;
        startOffsetX = tooltipOffsetX;
        startOffsetY = tooltipOffsetY;
        
        tooltipEl.style.transition = 'none';
        tooltipEl.style.border = '2px solid #ffd43b';
        tooltipEl.style.cursor = 'grabbing';
        
        e.preventDefault();
        e.stopPropagation();
    });
    
    // æ»‘é¼ ç§»å‹•ï¼ˆå…¨å±€ç›£è½ï¼‰
    document.addEventListener('mousemove', function(e) {
        if (!isDragging) return;
        
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        tooltipOffsetX = startOffsetX + deltaX;
        tooltipOffsetY = startOffsetY + deltaY;
        
        // ç›´æ¥æ›´æ–°ä½ç½®
        if (window.currentSelectedPointIndex !== undefined && fullscreenChartInstance) {
            const canvas = document.getElementById('elevationChartFullscreen');
            if (canvas) {
                const xScale = fullscreenChartInstance.scales.x;
                const yScale = fullscreenChartInstance.scales.y;
                const dataset = fullscreenChartInstance.data.datasets.find(d =>
                    d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
                );
                
                if (dataset && dataset.data[window.currentSelectedPointIndex] !== undefined) {
                    const pixelX = xScale.getPixelForValue(window.currentSelectedPointIndex);
                    const pixelY = yScale.getPixelForValue(dataset.data[window.currentSelectedPointIndex]);
                    const rect = canvas.getBoundingClientRect();
                    
                    tooltipEl.style.left = (rect.left + pixelX + tooltipOffsetX) + 'px';
                    tooltipEl.style.top = (rect.top + pixelY + tooltipOffsetY) + 'px';
                }
            }
        }
        
        e.preventDefault();
    });
    
    // æ»‘é¼ æ”¾é–‹ï¼ˆå…¨å±€ç›£è½ï¼‰
    document.addEventListener('mouseup', function() {
        if (!isDragging) return;
        
        console.log('Tooltip mouseup è§¸ç™¼');
        isDragging = false;
        tooltipDraggingFullscreen = false;
        
        tooltipEl.style.transition = 'all .1s ease';
        tooltipEl.style.border = '2px solid #4dabf7';
        tooltipEl.style.cursor = 'move';
        
        // ğŸ¯ ä¿å­˜ tooltip åç§»é‡
        if (window.lastFullscreenState) {
            window.lastFullscreenState.tooltipOffsetX = tooltipOffsetX;
            window.lastFullscreenState.tooltipOffsetY = tooltipOffsetY;
        }
    });
    
    // è§¸æ§æ”¯æ´
    tooltipEl.addEventListener('touchstart', function(e) {
        console.log('Tooltip touchstart è§¸ç™¼');
        isDragging = true;
        tooltipDraggingFullscreen = true;
        
        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
        startOffsetX = tooltipOffsetX;
        startOffsetY = tooltipOffsetY;
        
        tooltipEl.style.transition = 'none';
        tooltipEl.style.border = '2px solid #ffd43b';
        
        e.preventDefault();
        e.stopPropagation();
    });
    
    document.addEventListener('touchmove', function(e) {
        if (!isDragging || e.touches.length !== 1) return;
        
        const touch = e.touches[0];
        const deltaX = touch.clientX - startX;
        const deltaY = touch.clientY - startY;
        
        tooltipOffsetX = startOffsetX + deltaX;
        tooltipOffsetY = startOffsetY + deltaY;
        
        // ç›´æ¥æ›´æ–°ä½ç½®
        if (window.currentSelectedPointIndex !== undefined && fullscreenChartInstance) {
            const canvas = document.getElementById('elevationChartFullscreen');
            if (canvas) {
                const xScale = fullscreenChartInstance.scales.x;
                const yScale = fullscreenChartInstance.scales.y;
                const dataset = fullscreenChartInstance.data.datasets.find(d =>
                    d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
                );
                
                if (dataset && dataset.data[window.currentSelectedPointIndex] !== undefined) {
                    const pixelX = xScale.getPixelForValue(window.currentSelectedPointIndex);
                    const pixelY = yScale.getPixelForValue(dataset.data[window.currentSelectedPointIndex]);
                    const rect = canvas.getBoundingClientRect();
                    
                    tooltipEl.style.left = (rect.left + pixelX + tooltipOffsetX) + 'px';
                    tooltipEl.style.top = (rect.top + pixelY + tooltipOffsetY) + 'px';
                }
            }
        }
        
        e.preventDefault();
    }, { passive: false });
    
    document.addEventListener('touchend', function() {
        if (!isDragging) return;
        
        console.log('Tooltip touchend è§¸ç™¼');
        isDragging = false;
        tooltipDraggingFullscreen = false;
        
        tooltipEl.style.transition = 'all .1s ease';
        tooltipEl.style.border = '2px solid #4dabf7';
        
        // ğŸ¯ ä¿å­˜ tooltip åç§»é‡
        if (window.lastFullscreenState) {
            window.lastFullscreenState.tooltipOffsetX = tooltipOffsetX;
            window.lastFullscreenState.tooltipOffsetY = tooltipOffsetY;
        }
    });
}
function openChartFullscreen() {
    // ğŸ¯ è¨˜éŒ„é€²å…¥å…¨å±å‰çš„ç‹€æ…‹
    const fullscreenState = {
        infoVisible: fullscreenInfoVisible,
        obstructionEnabled: obstructionColorEnabled,
        selectedPointIndex: window.currentSelectedPointIndex,
        tooltipOffsetX: tooltipOffsetX,
        tooltipOffsetY: tooltipOffsetY,
        labelAOffset: fullscreenLabelAOffset ? {...fullscreenLabelAOffset} : { x: 0, y: -30 },
        labelBOffset: fullscreenLabelBOffset ? {...fullscreenLabelBOffset} : { x: 0, y: -30 }
    };
    // ä¿å­˜åˆ°å…¨å±€è®Šæ•¸
    window.lastFullscreenState = fullscreenState;
    console.log('ğŸ’¾ å·²ä¿å­˜å…¨å±ç‹€æ…‹:', fullscreenState);
    
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
        || (window.innerWidth <= 768 && window.innerHeight <= 768)
        || ('ontouchstart' in window);
    fullscreenInfoVisible = true;
    obstructionColorEnabled = false;
    if (!chartInstance || !chartInstance.data) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    const overlay = document.getElementById('chartFullscreenOverlay');
    overlay.classList.add('active');
    document.body.style.overflow = 'hidden';
    fullscreenLabelAOffset = { x: 0, y: -30 };
    fullscreenLabelBOffset = { x: 0, y: -30 };
    const elem = overlay;
    const enterFullscreen = () => {
        if (elem.requestFullscreen) {
            return elem.requestFullscreen({ navigationUI: "hide" });
        } else if (elem.webkitRequestFullscreen) {
            return elem.webkitRequestFullscreen();
        } else if (elem.mozRequestFullScreen) {
            return elem.mozRequestFullScreen();
        } else if (elem.msRequestFullscreen) {
            return elem.msRequestFullscreen();
        }
        return Promise.reject(new Error('ä¸æ”¯æ´å…¨è¢å¹•'));
    };
    enterFullscreen().then(() => {
        console.log('å·²é€²å…¥å…¨è¢å¹•æ¨¡å¼');
        setTimeout(() => {
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').then(() => {
                    console.log('å·²é–å®šæ©«å‘é¡¯ç¤º');
                }).catch(err => {
                    console.log('ç„¡æ³•é–å®šæ©«å‘:', err);
                    if (screen.lockOrientation) {
                        screen.lockOrientation('landscape');
                    } else if (screen.mozLockOrientation) {
                        screen.mozLockOrientation('landscape');
                    } else if (screen.msLockOrientation) {
                        screen.msLockOrientation('landscape');
                    }
                });
            }
        }, 300);
    }).catch(err => {
        console.log('ç„¡æ³•é€²å…¥å…¨è¢å¹•:', err);
    });
    setTimeout(() => {
        const ctx = document.getElementById('elevationChartFullscreen');
        if (fullscreenChartInstance) {
            fullscreenChartInstance.destroy();
        }
        const originalData = chartInstance.data;
        const originalOptions = chartInstance.options;
        const fullscreenLabelPlugin = {
            id: 'fullscreenLabelPlugin',
            beforeDraw: (chart) => {
                const ctx = chart.ctx;
                ctx.save();
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, chart.width, chart.height);
                ctx.restore();
            },
            afterDatasetsDraw: (chart) => {
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;
                const chartArea = chart.chartArea;
                const nameA = window.elevationPointAName || 'Aé»';
                const nameB = window.elevationPointBName || 'Bé»';
                const datasetIndex = 0;
                const dataset = chart.data.datasets[datasetIndex];
                if (dataset.data.length > 0) {
                    const xA = xAxis.getPixelForValue(0);
                    const yA = yAxis.getPixelForValue(dataset.data[0]);
                    ctx.save();
                    ctx.font = 'bold 13px Inter, sans-serif';
                    const textWidthA = ctx.measureText(nameA).width;
                    const paddingA = 6;
                    const boxWidthA = textWidthA + paddingA * 2;
                    const boxHeightA = 22;
                    let labelXA = xA + fullscreenLabelAOffset.x;
                    let labelYA = yA + fullscreenLabelAOffset.y;
                    const halfBoxWidth = boxWidthA / 2;
                    if (labelXA - halfBoxWidth < chartArea.left) {
                        labelXA = chartArea.left + halfBoxWidth + 2;
                    }
                    if (labelXA + halfBoxWidth > chartArea.right) {
                        labelXA = chartArea.right - halfBoxWidth - 2;
                    }
                    const halfBoxHeight = boxHeightA / 2;
                    if (labelYA - halfBoxHeight < chartArea.top) {
                        labelYA = chartArea.top + halfBoxHeight + 2;
                    }
                    if (labelYA + halfBoxHeight > chartArea.bottom) {
                        labelYA = chartArea.bottom - halfBoxHeight - 2;
                    }
                    const boxY = labelYA - halfBoxHeight;
                    const boxX = labelXA - halfBoxWidth;
                    window.fullscreenLabelABounds = {
                        x: boxX, y: boxY,
                        width: boxWidthA, height: boxHeightA,
                        centerX: labelXA, centerY: labelYA
                    };
                    if (fullscreenDraggingLabel === 'A') {
                        ctx.fillStyle = 'rgba(255, 229, 143, 1)';
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                        ctx.shadowBlur = 10;
                    } else {
                        ctx.fillStyle = 'rgba(255, 229, 143, 0.95)';
                    }
                    ctx.beginPath();
                    ctx.roundRect(boxX, boxY, boxWidthA, boxHeightA, 5);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 200, 100, 1)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#022';
                    ctx.fillText(nameA, labelXA, boxY + boxHeightA / 2);
                    ctx.fillStyle = 'rgba(0, 34, 34, 0.3)';
                    ctx.beginPath();
                    ctx.arc(boxX + 6, boxY + boxHeightA / 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(boxX + boxWidthA - 6, boxY + boxHeightA / 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                if (dataset.data.length > 0) {
                    const lastIndex = dataset.data.length - 1;
                    const xB = xAxis.getPixelForValue(lastIndex);
                    const yB = yAxis.getPixelForValue(dataset.data[lastIndex]);
                    ctx.save();
                    ctx.font = 'bold 13px Inter, sans-serif';
                    const textWidthB = ctx.measureText(nameB).width;
                    const paddingB = 6;
                    const boxWidthB = textWidthB + paddingB * 2;
                    const boxHeightB = 22;
                    let labelXB = xB + fullscreenLabelBOffset.x;
                    let labelYB = yB + fullscreenLabelBOffset.y;
                    const halfBoxWidth = boxWidthB / 2;
                    if (labelXB - halfBoxWidth < chartArea.left) {
                        labelXB = chartArea.left + halfBoxWidth + 2;
                    }
                    if (labelXB + halfBoxWidth > chartArea.right) {
                        labelXB = chartArea.right - halfBoxWidth - 2;
                    }
                    const halfBoxHeight = boxHeightB / 2;
                    if (labelYB - halfBoxHeight < chartArea.top) {
                        labelYB = chartArea.top + halfBoxHeight + 2;
                    }
                    if (labelYB + halfBoxHeight > chartArea.bottom) {
                        labelYB = chartArea.bottom - halfBoxHeight - 2;
                    }
                    const boxY = labelYB - halfBoxHeight;
                    const boxX = labelXB - halfBoxWidth;
                    window.fullscreenLabelBBounds = {
                        x: boxX, y: boxY,
                        width: boxWidthB, height: boxHeightB,
                        centerX: labelXB, centerY: labelYB
                    };
                    if (fullscreenDraggingLabel === 'B') {
                        ctx.fillStyle = 'rgba(255, 229, 143, 1)';
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                        ctx.shadowBlur = 10;
                    } else {
                        ctx.fillStyle = 'rgba(255, 229, 143, 0.95)';
                    }
                    ctx.beginPath();
                    ctx.roundRect(boxX, boxY, boxWidthB, boxHeightB, 5);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 200, 100, 1)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#022';
                    ctx.fillText(nameB, labelXB, boxY + boxHeightB / 2);
                    ctx.fillStyle = 'rgba(0, 34, 34, 0.3)';
                    ctx.beginPath();
                    ctx.arc(boxX + 6, boxY + boxHeightB / 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(boxX + boxWidthB - 6, boxY + boxHeightB / 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        };
        const fullscreenTotalDistancePlugin = {
            id: 'fullscreenTotalDistance',
            afterDraw(chart) {
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;
                if (!window.currentPathData || window.currentPathData.length === 0) return;
                const pathData = window.currentPathData;
                const totalDist = pathData[pathData.length - 1].dist;
                
                // é¡¯ç¤ºç¸½è·é›¢ï¼ˆå³ä¸‹ï¼‰
                ctx.save();
                ctx.font = '13px Arial';
                ctx.fillStyle = '#ffd43b';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'top';
                const text = `ç¸½è·é›¢: ${parseFloat(totalDist).toFixed(2)} km`;
                const x = xAxis.right - 1;  // å¾ -8 æ”¹ç‚º -1ï¼ˆå³ç§»ç´„7åƒç´ ï¼‰
                const y = yAxis.bottom + 30;  // å¾38æ”¹ç‚º30ï¼ˆä¸Šç§»8åƒç´ ï¼‰
                ctx.fillStyle = '#ffe58f';
                ctx.fillText(text, x, y);
                ctx.restore();
                
                // é¡¯ç¤ºé »ç‡ï¼ˆå³ä¸‹ï¼Œç¸½è·é›¢ä¸‹æ–¹ï¼‰- åªåœ¨è²æ¶…çˆ¾å€é¡¯ç¤ºæ™‚æ‰é¡¯ç¤º
                // æª¢æŸ¥è²æ¶…çˆ¾å€æ˜¯å¦é¡¯ç¤ºï¼ˆindex 2 æ˜¯è²æ¶…çˆ¾å€ä¸Šç•Œï¼‰
                const fresnelMeta = chart.getDatasetMeta(2);
                
                // å¦‚æœè²æ¶…çˆ¾å€éš±è—(hidden=true)æˆ–æœªå®šç¾©æ™‚é è¨­ç‚ºtrueï¼Œå‰‡ä¸é¡¯ç¤ºé »ç‡
                const isHidden = fresnelMeta.hidden !== false;  // é è¨­è¦–ç‚ºéš±è—
                if (!isHidden) {
                    const freqMHz = parseFloat(document.getElementById('link_freq_mhz')?.value) || 2400;
                    ctx.save();
                    ctx.font = '13px Arial';  // èˆ‡ç¸½è·é›¢ç›¸åŒçš„å­—é«”
                    ctx.fillStyle = '#ffe58f';  // èˆ‡ç¸½è·é›¢ç›¸åŒçš„é¡è‰²
                    ctx.textAlign = 'right';  // æ”¹ç‚ºå³å°é½Š
                    ctx.textBaseline = 'top';
                    const freqText = `é »ç‡: ${freqMHz} MHz`;
                    const freqX = xAxis.right - 1;  // å¾ -8 æ”¹ç‚º -1ï¼ˆå³ç§»ç´„7åƒç´ ï¼Œèˆ‡ç¸½è·é›¢å°é½Šï¼‰
                    const freqY = yAxis.bottom + 45;  // å¾53æ”¹ç‚º45ï¼ˆä¸Šç§»8åƒç´ ï¼‰
                    ctx.fillText(freqText, freqX, freqY);
                    ctx.restore();
                }
            }
        };
        fullscreenChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: originalData.labels,
                datasets: originalData.datasets.map((dataset, index) => {
                    const dataLength = dataset.data.length;
                    const pointBgColor = Array.isArray(dataset.pointBackgroundColor)
                        ? dataset.pointBackgroundColor.slice()
                        : new Array(dataLength).fill(dataset.pointBackgroundColor || 'transparent');
                    const pointBColor = Array.isArray(dataset.pointBorderColor)
                        ? dataset.pointBorderColor.slice()
                        : new Array(dataLength).fill(dataset.pointBorderColor || 'transparent');
                    const pointR = Array.isArray(dataset.pointRadius)
                        ? dataset.pointRadius.slice()
                        : new Array(dataLength).fill(dataset.pointRadius || 0);
                    const pointHR = Array.isArray(dataset.pointHoverRadius)
                        ? dataset.pointHoverRadius.slice()
                        : new Array(dataLength).fill(dataset.pointHoverRadius || 6);
                    
                    // ç‚ºå…¨è¢å¹•æ¨¡å¼ç°¡åŒ–æ¨™ç±¤æ–‡å­—
                    let displayLabel = dataset.label;
                    if (dataset.label === 'åœ°å½¢æµ·æ‹” (m)') {
                        displayLabel = 'æµ·æ‹”';
                    } else if (dataset.label === 'è¦–è·é€£ç·š (è€ƒæ…®åœ°çƒæ›²åº¦)') {
                        displayLabel = 'è¦–è· (å«åœ°çƒæ›²åº¦)';
                    } else if (dataset.label === 'è²æ¶…çˆ¾å€ (60%)') {
                        displayLabel = 'è²æ¶…çˆ¾60%å€';
                    }
                    
                    // æ±ºå®š hidden ç‹€æ…‹ï¼šå„ªå…ˆä½¿ç”¨ä¿å­˜çš„ç‹€æ…‹ï¼Œå¦å‰‡ä½¿ç”¨åŸå§‹åœ–è¡¨çš„ç‹€æ…‹
                    let hiddenState = dataset.hidden;
                    if (window.lastFullscreenState && window.lastFullscreenState.datasetHiddenStates) {
                        if (window.lastFullscreenState.datasetHiddenStates.hasOwnProperty(index)) {
                            hiddenState = window.lastFullscreenState.datasetHiddenStates[index];
                        }
                    }
                    
                    return {
                        label: displayLabel,
                        data: dataset.data,
                        borderColor: dataset.borderColor,
                        backgroundColor: dataset.backgroundColor,
                        tension: dataset.tension || 0.4,
                        fill: dataset.fill,
                        borderWidth: dataset.borderWidth || 2,
                        pointRadius: pointR,
                        pointBackgroundColor: pointBgColor,
                        pointBorderColor: pointBColor,
                        pointHoverRadius: pointHR,
                        pointHoverBackgroundColor: dataset.pointHoverBackgroundColor,
                        pointHoverBorderColor: dataset.pointHoverBorderColor,
                        pointHoverBorderWidth: dataset.pointHoverBorderWidth || 2,
                        borderDash: dataset.borderDash,
                        order: dataset.order,
                        hidden: hiddenState  // ä½¿ç”¨æ±ºå®šå¾Œçš„ hidden ç‹€æ…‹
                    };
                })
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                },
                layout: {
                    padding: {
                        left: 10,
                        right: 20,
                        top: 5,
                        bottom: 5
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            color: '#e8eef5',
                            font: { size: 12 },
                            padding: 5,
                            boxWidth: 15,
                            boxHeight: 15,
                            filter: function(legendItem, chartData) {
                                // éš±è—ã€Œè²æ¶…çˆ¾å€ä¸‹ç•Œã€åœ–ä¾‹é …ç›®
                                return legendItem.text !== 'è²æ¶…çˆ¾å€ä¸‹ç•Œ';
                            }
                        },
                        align: 'start',
                        onClick: function(e, legendItem, legend) {
                            const index = legendItem.datasetIndex;
                            const chart = legend.chart;
                            const meta = chart.getDatasetMeta(index);
                            
                            // å¦‚æœé»æ“Šçš„æ˜¯è²æ¶…çˆ¾å€ï¼ŒåŒæ™‚åˆ‡æ›ä¸Šç•Œå’Œä¸‹ç•Œ
                            if (legendItem.text === 'è²æ¶…çˆ¾60%å€') {
                                const upperMeta = chart.getDatasetMeta(index);
                                const lowerMeta = chart.getDatasetMeta(index + 1);
                                
                                // ç°¡åŒ–é‚è¼¯ï¼šç›´æ¥åˆ‡æ›å¸ƒæ—å€¼
                                const newState = !upperMeta.hidden;
                                upperMeta.hidden = newState;
                                lowerMeta.hidden = newState;
                            } else {
                                // ç°¡åŒ–é‚è¼¯ï¼šç›´æ¥åˆ‡æ›å¸ƒæ—å€¼
                                meta.hidden = !meta.hidden;
                            }
                            
                            chart.update();
                        }
                    },
                    tooltip: {
                        enabled: false,
                        position: 'nearest',
                        mode: 'index',
                        intersect: false,
                        external: function(context) {
                            if (typeof fullscreenInfoVisible !== 'undefined' && !fullscreenInfoVisible) {
                                return;
                            }
                            const fullscreenContainer = document.getElementById('chartFullscreenOverlay');
                            let tooltipEl = fullscreenContainer ? fullscreenContainer.querySelector('#chartjs-tooltip-fullscreen') : null;
                            if (!tooltipEl) {
                                tooltipEl = document.createElement('div');
                                tooltipEl.id = 'chartjs-tooltip-fullscreen';
                                tooltipEl.style.background = 'rgba(13, 71, 161, 0.35)';
                                tooltipEl.style.borderRadius = '8px';
                                tooltipEl.style.color = 'white';
                                tooltipEl.style.opacity = '0';
                                tooltipEl.style.pointerEvents = 'auto';
                                tooltipEl.style.position = 'fixed';
                                tooltipEl.style.transform = 'translate(-50%, -120%)';
                                tooltipEl.style.transition = 'all .1s ease';
                                tooltipEl.style.padding = '10px 12px';
                                tooltipEl.style.border = '2px solid #4dabf7';
                                tooltipEl.style.fontSize = '13px';
                                tooltipEl.style.lineHeight = '1.5';
                                tooltipEl.style.zIndex = '10002';
                                tooltipEl.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                                tooltipEl.style.whiteSpace = 'nowrap';
                                tooltipEl.style.cursor = 'move';
                                if (fullscreenContainer) {
                                    fullscreenContainer.appendChild(tooltipEl);
                                    makeTooltipDraggable(tooltipEl);
                                }
                            }
                            const tooltipModel = context.tooltip;
                            if (tooltipModel.opacity === 0) {
                                tooltipEl.style.opacity = '0';
                                return;
                            }
                            if (tooltipModel.body && tooltipModel.dataPoints && tooltipModel.dataPoints.length > 0) {
                                const index = tooltipModel.dataPoints[0].dataIndex;
                                const dataset = tooltipModel.dataPoints[0].dataset;
                                const dataValue = dataset.data[index];
                                const totalPoints = dataset.data.length;
                                const sLat = parseFloat(document.getElementById('sLat').value);
                                const sLng = parseFloat(document.getElementById('sLng').value);
                                const eLat = parseFloat(document.getElementById('eLat').value);
                                const eLng = parseFloat(document.getElementById('eLng').value);
                                const totalDistance = getDistance(sLat, sLng, eLat, eLng);
                                const distanceFromStart = (index / (totalPoints - 1)) * totalDistance;
                                const distanceFromEnd = totalDistance - distanceFromStart;
                                const fraction = index / (totalPoints - 1);
                                const currentLat = sLat + (eLat - sLat) * fraction;
                                const currentLng = sLng + (eLng - sLng) * fraction;
                                const startName = window.elevationPointAName || 'Aé»';
                                const endName = window.elevationPointBName || 'Bé»';
                                let clearanceValue = 0;
                                let clearanceText = '';
                                const losDataset = context.chart.data.datasets.find(d => d.label && (d.label.includes('è¦–è·é€£ç·š') || d.label.includes('è¦–è·')));
                                if (losDataset && losDataset.data[index] !== undefined) {
                                    const losHeight = losDataset.data[index];
                                    clearanceValue = losHeight - dataValue;
                                    if (clearanceValue > 0) {
                                        clearanceText = `+${clearanceValue.toFixed(2)} m`;
                                    } else if (clearanceValue < 0) {
                                        clearanceText = `${clearanceValue.toFixed(2)} m`;
                                    } else {
                                        clearanceText = '0.00 m';
                                    }
                                }
                                const clearanceColor = clearanceValue >= 0 ? '#4caf50' : '#ff4444';
                                const innerHTML = `
                                    <div class="tooltip-drag-handle" style="position: absolute; top: 2px; right: 2px; width: 24px; height: 24px; cursor: move; display: flex; align-items: center; justify-content: center; opacity: 0.7; font-size: 16px; user-select: none;" title="æ‹–æ›³ç§»å‹•">â ¿</div>
                                    <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">ä½ç½®è³‡è¨Š: ${index + 1}</div>
                                    <div>è·é›¢${startName}: ${distanceFromStart.toFixed(3)} km</div>
                                    <div>è·é›¢${endName}: ${distanceFromEnd.toFixed(3)} km</div>
                                    <div>æµ·æ‹”é«˜åº¦: ${dataValue.toFixed(0)} m</div>
                                    <div>åº§æ¨™: ${currentLat.toFixed(6)}, ${currentLng.toFixed(6)}</div>
                                    <div style="color: ${clearanceColor}; font-weight: bold;">é®è”½: ${clearanceText}</div>
                                `;
                                tooltipEl.innerHTML = innerHTML;
                            }
                            const position = context.chart.canvas.getBoundingClientRect();
                            let tooltipX = position.left + tooltipModel.caretX;
                            let tooltipY = position.top + tooltipModel.caretY;
                            tooltipEl.style.opacity = '0';
                            tooltipEl.style.left = tooltipX + 'px';
                            tooltipEl.style.top = tooltipY + 'px';
                            tooltipEl.style.transform = 'translate(-50%, -120%)';
                            const tooltipRect = tooltipEl.getBoundingClientRect();
                            const tooltipWidth = tooltipRect.width;
                            const tooltipHeight = tooltipRect.height;
                            const viewportWidth = window.innerWidth;
                            const viewportHeight = window.innerHeight;
                            let transformX = '-50%';
                            let transformY = '-120%';
                            const spaceAbove = tooltipY;
                            const spaceBelow = viewportHeight - tooltipY;
                            if (spaceAbove < tooltipHeight + 30) {
                                if (spaceBelow > tooltipHeight + 30) {
                                    transformY = '20%';
                                } else {
                                    if (spaceAbove > spaceBelow) {
                                        transformY = '-50%';
                                        tooltipY = Math.min(tooltipY, spaceAbove - tooltipHeight/2);
                                    } else {
                                        transformY = '-50%';
                                        tooltipY = Math.max(tooltipY, tooltipHeight/2);
                                    }
                                }
                            }
                            const spaceLeft = tooltipX;
                            const spaceRight = viewportWidth - tooltipX;
                            if (tooltipX - tooltipWidth / 2 < 20) {
                                transformX = '0%';
                                tooltipX = Math.max(20, tooltipX);
                            } else if (tooltipX + tooltipWidth / 2 > viewportWidth - 20) {
                                transformX = '-100%';
                                tooltipX = Math.min(viewportWidth - 20, tooltipX);
                            }
                            if (tooltipManualPosition) {
                                tooltipEl.style.left = tooltipManualPosition.x + 'px';
                                tooltipEl.style.top = tooltipManualPosition.y + 'px';
                                tooltipEl.style.transform = 'translate(-50%, -50%)';
                                tooltipEl.style.opacity = '1';
                            } else {
                                tooltipEl.style.transform = `translate(${transformX}, ${transformY})`;
                                tooltipEl.style.left = tooltipX + 'px';
                                tooltipEl.style.top = tooltipY + 'px';
                                tooltipEl.style.opacity = '1';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        ticks: {
                            color: '#a8b3c3',
                            font: { size: 11 },
                            padding: 5
                        },
                        grid: { color: 'rgba(255,255,255,0.1)' },
                        title: {
                            display: true,
                            text: 'é«˜åº¦ (m)',
                            color: '#85c9ff',
                            font: { size: 13 },
                            padding: { bottom: 5 }
                        },
                        min: isNaN(parseFloat(document.getElementById('minElevation').value)) ? undefined : parseFloat(document.getElementById('minElevation').value),
                        max: isNaN(parseFloat(document.getElementById('maxElevation').value)) ? undefined : parseFloat(document.getElementById('maxElevation').value)
                    },
                    x: {
                        ticks: {
                            color: '#a8b3c3',
                            font: { size: 11 },
                            maxRotation: 0,
                            minRotation: 0,
                            autoSkip: true,
                            maxTicksLimit: 15
                        },
                        grid: { color: 'rgba(255,255,255,0.1)' },
                        title: {
                            display: true,
                            text: 'è·é›¢ (km)',
                            color: '#85c9ff',
                            font: { size: 13 },
                            padding: { top: 5 }
                        },
                        min: isNaN(parseFloat(document.getElementById('minDistance').value)) ? undefined : parseFloat(document.getElementById('minDistance').value),
                        max: isNaN(parseFloat(document.getElementById('maxDistance').value)) ? undefined : parseFloat(document.getElementById('maxDistance').value)
                    }
                },
                onClick: (event, elements, chart) => {
                    console.log('=== å…¨è¢å¹•åœ–è¡¨é»æ“Šäº‹ä»¶é–‹å§‹ ===');
                    
                    // ========== å„ªå…ˆåº¦1: æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°è—è‰²è¨Šæ¯æ¡† ==========
                    const fullscreenContainer = document.getElementById('chartFullscreenOverlay');
                    const tooltipEl = fullscreenContainer ? fullscreenContainer.querySelector('#chartjs-tooltip-fullscreen') : null;
                    if (tooltipEl && event.native) {
                        const target = event.native.target || event.native.srcElement;
                        if (tooltipEl.contains(target) || tooltipEl === target) {
                            console.log('âœ“ é»æ“Šåˆ°è—è‰²è¨Šæ¯æ¡†ï¼Œä¸æ›´æ–°å°é»ƒé»ï¼Œå•Ÿå‹•æ‹–æ›³');
                            return;
                        }
                    }
                    
                    // ========== å„ªå…ˆåº¦2: æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°åœ°åæ¨™ç±¤ ==========
                    if (event.native) {
                        const canvas = chart.canvas;
                        const rect = canvas.getBoundingClientRect();
                        const clickX = event.native.clientX - rect.left;
                        const clickY = event.native.clientY - rect.top;
                        
                        console.log('é»æ“Šåº§æ¨™:', clickX, clickY);
                        console.log('Aæ¨™ç±¤ç¯„åœ:', window.fullscreenLabelABounds);
                        console.log('Bæ¨™ç±¤ç¯„åœ:', window.fullscreenLabelBBounds);
                        
                        // æª¢æŸ¥é»æ˜¯å¦åœ¨æ¨™ç±¤å…§
                        const checkPointInLabel = (x, y, bounds) => {
                            if (!bounds) return false;
                            const inBounds = x >= bounds.x && x <= bounds.x + bounds.width &&
                                           y >= bounds.y && y <= bounds.y + bounds.height;
                            return inBounds;
                        };
                        
                        if (checkPointInLabel(clickX, clickY, window.fullscreenLabelABounds)) {
                            console.log('âœ“ é»æ“Šåˆ°Aé»åœ°åæ¨™ç±¤ï¼Œä¸æ›´æ–°å°é»ƒé»ï¼Œå•Ÿå‹•æ‹–æ›³');
                            return;
                        }
                        
                        if (checkPointInLabel(clickX, clickY, window.fullscreenLabelBBounds)) {
                            console.log('âœ“ é»æ“Šåˆ°Bé»åœ°åæ¨™ç±¤ï¼Œä¸æ›´æ–°å°é»ƒé»ï¼Œå•Ÿå‹•æ‹–æ›³');
                            return;
                        }
                    }
                    
                    console.log('â†’ æœªé»æ“Šæ¨™ç±¤æˆ–è¨Šæ¯æ¡†ï¼Œç¹¼çºŒæ›´æ–°å°é»ƒé»');
                    
                    // ========== å„ªå…ˆåº¦3: æ­£å¸¸æ›´æ–°å°é»ƒé»ä½ç½® ==========
                    const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                    let idx = -1;
                    if (elements.length > 0) {
                        idx = elements[0].index;
                    } else {
                        const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                        if (dataX !== null && dataX !== undefined) {
                            const labels = chart.data.labels;
                            let minDist = Infinity;
                            let closestIdx = 0;
                            for (let i = 0; i < labels.length; i++) {
                                const dist = Math.abs(i - dataX);
                                if (dist < minDist) {
                                    minDist = dist;
                                    closestIdx = i;
                                }
                            }
                            if (minDist < 2) {
                                idx = closestIdx;
                            }
                        }
                    }
                    if (idx >= 0) {
                        console.log('å…¨è¢å¹•é¸ä¸­ç´¢å¼•:', idx);
                        if (typeof fullscreenInfoVisible === 'undefined' || !fullscreenInfoVisible) {
                            console.log('è³‡è¨Šæ¡†å·²é—œé–‰ï¼Œä¸æ›´æ–°é»ƒé»');
                            return;
                        }
                        window.currentSelectedPointIndex = idx;
                        const fullscreenPointInput = document.getElementById('fullscreenPointInput');
                        if (fullscreenPointInput) {
                            fullscreenPointInput.value = idx + 1;
                            fullscreenPointInput.style.display = 'none';
                            fullscreenPointInput.offsetHeight;
                            fullscreenPointInput.style.display = '';
                        }
                        if (typeof chartInstance !== 'undefined' && chartInstance) {
                            const mainDataset = chartInstance.data.datasets[0];
                            if (mainDataset && typeof pointColorArray !== 'undefined') {
                                for (let i = 0; i < pointColorArray.length; i++) {
                                    if (i === idx) {
                                        pointColorArray[i] = '#ffd43b';
                                        pointRadiusArray[i] = 6;
                                        pointHoverRadiusArray[i] = 10;
                                    } else {
                                        pointColorArray[i] = '#28a745';
                                        if (typeof greenPointsVisible !== 'undefined' && !greenPointsVisible) {
                                            pointRadiusArray[i] = 0;
                                            pointHoverRadiusArray[i] = 0;
                                        } else {
                                            pointRadiusArray[i] = 3;
                                            pointHoverRadiusArray[i] = 8;
                                        }
                                    }
                                }
                                mainDataset.pointBackgroundColor = pointColorArray.slice();
                                mainDataset.pointRadius = pointRadiusArray.slice();
                                mainDataset.pointHoverRadius = pointHoverRadiusArray.slice();
                                chartInstance.update('none');
                            }
                        }
                        const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
                            d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
                        );
                        if (fullscreenDataset && fullscreenDataset.data) {
                            const fullscreenPointColors = new Array(fullscreenDataset.data.length);
                            const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
                            const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
                            const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);
                            for (let i = 0; i < fullscreenDataset.data.length; i++) {
                                if (i === idx) {
                                    fullscreenPointColors[i] = '#ffd43b';
                                    fullscreenPointRadius[i] = 8;
                                    fullscreenPointHoverRadius[i] = 12;
                                    fullscreenPointBorderColor[i] = '#fff';
                                } else {
                                    fullscreenPointColors[i] = 'transparent';
                                    fullscreenPointRadius[i] = 0;
                                    fullscreenPointHoverRadius[i] = 6;
                                    fullscreenPointBorderColor[i] = 'transparent';
                                }
                            }
                            fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
                            fullscreenDataset.pointRadius = fullscreenPointRadius;
                            fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
                            fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
                            fullscreenDataset.pointBorderWidth = 2;
                            console.log('æ›´æ–°å…¨è¢å¹•åœ–è¡¨é»ƒé»ï¼Œç´¢å¼•:', idx, 'é¡è‰²:', fullscreenPointColors[idx]);
                            fullscreenChartInstance.update('none');
                            
                            // ğŸ¯ æ›´æ–°ä¿å­˜çš„ç‹€æ…‹
                            if (window.lastFullscreenState) {
                                window.lastFullscreenState.selectedPointIndex = idx;
                            }
                        }
                        const selectedPointInput = document.getElementById('selectedPointIndex');
                        if (selectedPointInput) {
                            selectedPointInput.value = idx + 1;
                        }
                        if (typeof elevations !== 'undefined' && elevations[idx] !== undefined) {
                            showMap(idx, elevations[idx]);
                        }
                    } else {
                        if (fullscreenChartInstance.tooltip) {
                            fullscreenChartInstance.tooltip.setActiveElements([], {x: 0, y: 0});
                            fullscreenChartInstance.update('none');
                        }
                    }
                },
                onHover: (event, elements, chart) => {
                    if (preventHoverUpdate) {
                        console.log('æŒ‰éˆ•æ“ä½œé€²è¡Œä¸­ï¼Œç¦æ­¢æ‹–æ›³æ›´æ–°');
                        return;
                    }
                    if (typeof fullscreenInfoVisible === 'undefined' || !fullscreenInfoVisible) {
                        return;
                    }
                    let idx = -1;
                    if (elements.length > 0) {
                        idx = elements[0].index;
                    }
                    if (idx >= 0 && idx !== window.currentSelectedPointIndex) {
                        window.currentSelectedPointIndex = idx;
                        const fullscreenPointInput = document.getElementById('fullscreenPointInput');
                        if (fullscreenPointInput) {
                            fullscreenPointInput.value = idx + 1;
                            fullscreenPointInput.style.display = 'none';
                            fullscreenPointInput.offsetHeight;
                            fullscreenPointInput.style.display = '';
                        }
                        const selectedPointInput = document.getElementById('selectedPointIndex');
                        if (selectedPointInput) {
                            selectedPointInput.value = idx + 1;
                        }
                        const fullscreenDataset = chart.data.datasets.find(d =>
                            d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
                        );
                        if (fullscreenDataset && fullscreenDataset.data) {
                            const fullscreenPointColors = new Array(fullscreenDataset.data.length);
                            const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
                            const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
                            const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);
                            for (let i = 0; i < fullscreenDataset.data.length; i++) {
                                if (i === idx) {
                                    fullscreenPointColors[i] = '#ffd43b';
                                    fullscreenPointRadius[i] = 8;
                                    fullscreenPointHoverRadius[i] = 12;
                                    fullscreenPointBorderColor[i] = '#fff';
                                } else {
                                    fullscreenPointColors[i] = 'transparent';
                                    fullscreenPointRadius[i] = 0;
                                    fullscreenPointHoverRadius[i] = 6;
                                    fullscreenPointBorderColor[i] = 'transparent';
                                }
                            }
                            fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
                            fullscreenDataset.pointRadius = fullscreenPointRadius;
                            fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
                            fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
                            fullscreenDataset.pointBorderWidth = 2;
                            chart.update('none');
                        }
                        const canvas = document.getElementById('elevationChartFullscreen');
                        const fullscreenContainer = document.getElementById('chartFullscreenOverlay');
                        if (canvas && fullscreenContainer && fullscreenChartInstance) {
                            const xScale = fullscreenChartInstance.scales.x;
                            const yScale = fullscreenChartInstance.scales.y;
                            const dataset = fullscreenChartInstance.data.datasets.find(d =>
                                d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
                            );
                            if (dataset && dataset.data[idx] !== undefined) {
                                const pixelX = xScale.getPixelForValue(idx);
                                const pixelY = yScale.getPixelForValue(dataset.data[idx]);
                                let tooltipEl = fullscreenContainer.querySelector('#chartjs-tooltip-fullscreen');
                                if (!tooltipEl) {
                                    tooltipEl = document.createElement('div');
                                    tooltipEl.id = 'chartjs-tooltip-fullscreen';
                                    tooltipEl.style.background = 'rgba(13, 71, 161, 0.35)';
                                    tooltipEl.style.borderRadius = '8px';
                                    tooltipEl.style.color = 'white';
                                    tooltipEl.style.opacity = '0';
                                    tooltipEl.style.pointerEvents = 'auto';
                                    tooltipEl.style.position = 'fixed';
                                    tooltipEl.style.transform = 'translate(-50%, -120%)';
                                    tooltipEl.style.transition = 'all .1s ease';
                                    tooltipEl.style.padding = '10px 12px';
                                    tooltipEl.style.border = '2px solid #4dabf7';
                                    tooltipEl.style.fontSize = '13px';
                                    tooltipEl.style.lineHeight = '1.5';
                                    tooltipEl.style.zIndex = '10002';
                                    tooltipEl.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                                    tooltipEl.style.whiteSpace = 'nowrap';
                                    tooltipEl.style.cursor = 'move';
                                    fullscreenContainer.appendChild(tooltipEl);
                                    makeTooltipDraggable(tooltipEl);
                                }
                                const dataValue = dataset.data[idx];
                                const totalPoints = dataset.data.length;
                                const sLat = parseFloat(document.getElementById('sLat').value);
                                const sLng = parseFloat(document.getElementById('sLng').value);
                                const eLat = parseFloat(document.getElementById('eLat').value);
                                const eLng = parseFloat(document.getElementById('eLng').value);
                                const totalDistance = getDistance(sLat, sLng, eLat, eLng);
                                const distanceFromStart = (idx / (totalPoints - 1)) * totalDistance;
                                const distanceFromEnd = totalDistance - distanceFromStart;
                                const fraction = idx / (totalPoints - 1);
                                const currentLat = sLat + (eLat - sLat) * fraction;
                                const currentLng = sLng + (eLng - sLng) * fraction;
                                const startName = window.elevationPointAName || 'Aé»';
                                const endName = window.elevationPointBName || 'Bé»';
                                let clearanceValue = 0;
                                let clearanceText = '';
                                const losDataset = fullscreenChartInstance.data.datasets.find(d => d.label && (d.label.includes('è¦–è·é€£ç·š') || d.label.includes('è¦–è·')));
                                if (losDataset && losDataset.data[idx] !== undefined) {
                                    const losHeight = losDataset.data[idx];
                                    clearanceValue = losHeight - dataValue;
                                    if (clearanceValue > 0) {
                                        clearanceText = `+${clearanceValue.toFixed(2)} m`;
                                    } else if (clearanceValue < 0) {
                                        clearanceText = `${clearanceValue.toFixed(2)} m`;
                                    } else {
                                        clearanceText = '0.00 m';
                                    }
                                }
                                const clearanceColor = clearanceValue >= 0 ? '#4caf50' : '#ff4444';
                                const innerHTML = `
                                    <div class="tooltip-drag-handle" style="position: absolute; top: 2px; right: 2px; width: 24px; height: 24px; cursor: move; display: flex; align-items: center; justify-content: center; opacity: 0.7; font-size: 16px; user-select: none;" title="æ‹–æ›³ç§»å‹•">â ¿</div>
                                    <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">ä½ç½®è³‡è¨Š: ${idx + 1}</div>
                                    <div>è·é›¢${startName}: ${distanceFromStart.toFixed(3)} km</div>
                                    <div>è·é›¢${endName}: ${distanceFromEnd.toFixed(3)} km</div>
                                    <div>æµ·æ‹”é«˜åº¦: ${dataValue.toFixed(0)} m</div>
                                    <div>åº§æ¨™: ${currentLat.toFixed(6)}, ${currentLng.toFixed(6)}</div>
                                    <div style="color: ${clearanceColor}; font-weight: bold;">é®è”½: ${clearanceText}</div>
                                `;
                                tooltipEl.innerHTML = innerHTML;
                                const rect = canvas.getBoundingClientRect();
                                let tooltipX = rect.left + pixelX;
                                let tooltipY = rect.top + pixelY;
                                tooltipEl.style.left = tooltipX + 'px';
                                tooltipEl.style.top = tooltipY + 'px';
                                tooltipEl.style.opacity = '0';
                                tooltipEl.style.display = 'block';
                                const tooltipRect = tooltipEl.getBoundingClientRect();
                                const tooltipWidth = tooltipRect.width;
                                const tooltipHeight = tooltipRect.height;
                                const viewportWidth = window.innerWidth;
                                const viewportHeight = window.innerHeight;
                                let transformX = '-50%';
                                let transformY = '-120%';
                                const spaceAbove = tooltipY;
                                const spaceBelow = viewportHeight - tooltipY;
                                if (spaceAbove < tooltipHeight + 30) {
                                    if (spaceBelow > tooltipHeight + 30) {
                                        transformY = '20%';
                                    } else {
                                        transformY = '-50%';
                                        tooltipY = spaceAbove > spaceBelow
                                            ? Math.min(tooltipY, spaceAbove - tooltipHeight/2)
                                            : Math.max(tooltipY, tooltipHeight/2);
                                    }
                                }
                                const spaceLeft = tooltipX;
                                const spaceRight = viewportWidth - tooltipX;
                                if (spaceLeft < tooltipWidth/2 + 10) {
                                    transformX = '10%';
                                    tooltipX = Math.max(tooltipX, tooltipWidth/2 + 10);
                                } else if (spaceRight < tooltipWidth/2 + 10) {
                                    transformX = '-110%';
                                    tooltipX = Math.min(tooltipX, viewportWidth - tooltipWidth/2 - 10);
                                }
                                tooltipEl.style.left = tooltipX + 'px';
                                tooltipEl.style.top = tooltipY + 'px';
                                tooltipEl.style.transform = `translate(${transformX}, ${transformY})`;
                                tooltipEl.style.opacity = '1';
                                
                                // ğŸ¯ æ›´æ–°ä¿å­˜çš„ç‹€æ…‹
                                if (window.lastFullscreenState) {
                                    window.lastFullscreenState.selectedPointIndex = idx;
                                }
                            }
                        }
                    }
                }
            },
            plugins: [fullscreenLabelPlugin, fullscreenTotalDistancePlugin]
        });
        if (typeof window.currentSelectedPointIndex !== 'undefined' && window.currentSelectedPointIndex !== null && window.currentSelectedPointIndex >= 0) {
            const selectedIdx = window.currentSelectedPointIndex;
            const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
                d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
            );
            if (fullscreenDataset && fullscreenDataset.data) {
                const fullscreenPointColors = new Array(fullscreenDataset.data.length);
                const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
                const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
                const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);
                for (let i = 0; i < fullscreenDataset.data.length; i++) {
                    if (i === selectedIdx) {
                        fullscreenPointColors[i] = '#ffd43b';
                        fullscreenPointRadius[i] = 8;
                        fullscreenPointHoverRadius[i] = 12;
                        fullscreenPointBorderColor[i] = '#fff';
                    } else {
                        fullscreenPointColors[i] = 'transparent';
                        fullscreenPointRadius[i] = 0;
                        fullscreenPointHoverRadius[i] = 6;
                        fullscreenPointBorderColor[i] = 'transparent';
                    }
                }
                fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
                fullscreenDataset.pointRadius = fullscreenPointRadius;
                fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
                fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
                fullscreenDataset.pointBorderWidth = 2;
                fullscreenChartInstance.update('none');
            }
        }
        const canvas = document.getElementById('elevationChartFullscreen');
        const isPointInLabel = (x, y, labelBounds) => {
            if (!labelBounds) return false;
            return x >= labelBounds.x && x <= labelBounds.x + labelBounds.width &&
                   y >= labelBounds.y && y <= labelBounds.y + labelBounds.height;
        };
        const getMousePos = (canvas, evt) => {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        };
        const getTouchPos = (canvas, evt) => {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.touches[0].clientX - rect.left,
                y: evt.touches[0].clientY - rect.top
            };
        };
        canvas.addEventListener('mousedown', function(e) {
            const pos = getMousePos(canvas, e);
            if (isPointInLabel(pos.x, pos.y, window.fullscreenLabelABounds)) {
                fullscreenDraggingLabel = 'A';
                fullscreenIgnoreNextClick = true;
                window.fullscreenDragStartX = pos.x;
                window.fullscreenDragStartY = pos.y;
                window.fullscreenDragStartOffsetX = fullscreenLabelAOffset.x;
                window.fullscreenDragStartOffsetY = fullscreenLabelAOffset.y;
                e.preventDefault();
                e.stopPropagation();
            } else if (isPointInLabel(pos.x, pos.y, window.fullscreenLabelBBounds)) {
                fullscreenDraggingLabel = 'B';
                fullscreenIgnoreNextClick = true;
                window.fullscreenDragStartX = pos.x;
                window.fullscreenDragStartY = pos.y;
                window.fullscreenDragStartOffsetX = fullscreenLabelBOffset.x;
                window.fullscreenDragStartOffsetY = fullscreenLabelBOffset.y;
                e.preventDefault();
                e.stopPropagation();
            } else {
                fullscreenIgnoreNextClick = false;
            }
        });
        canvas.addEventListener('click', function(e) {
            const pos = getMousePos(canvas, e);
            if (isPointInLabel(pos.x, pos.y, window.fullscreenLabelABounds) ||
                isPointInLabel(pos.x, pos.y, window.fullscreenLabelBBounds)) {
                console.log('åœ°åæ¨™ç±¤é»æ“Šè¢«æ””æˆª');
                e.preventDefault();
                e.stopPropagation();
            }
        }, true);
        canvas.addEventListener('mousemove', function(e) {
            if (fullscreenDraggingLabel) {
                const pos = getMousePos(canvas, e);
                const deltaX = pos.x - window.fullscreenDragStartX;
                const deltaY = pos.y - window.fullscreenDragStartY;
                if (fullscreenDraggingLabel === 'A') {
                    fullscreenLabelAOffset.x = window.fullscreenDragStartOffsetX + deltaX;
                    fullscreenLabelAOffset.y = window.fullscreenDragStartOffsetY + deltaY;
                } else if (fullscreenDraggingLabel === 'B') {
                    fullscreenLabelBOffset.x = window.fullscreenDragStartOffsetX + deltaX;
                    fullscreenLabelBOffset.y = window.fullscreenDragStartOffsetY + deltaY;
                }
                fullscreenChartInstance.update('none');
                e.preventDefault();
            }
        });
        canvas.addEventListener('mouseup', function(e) {
            if (fullscreenDraggingLabel) {
                fullscreenDraggingLabel = null;
                fullscreenChartInstance.update();
                
                // ğŸ¯ ä¿å­˜æ¨™ç±¤åç§»é‡
                if (window.lastFullscreenState) {
                    window.lastFullscreenState.labelAOffset = {...fullscreenLabelAOffset};
                    window.lastFullscreenState.labelBOffset = {...fullscreenLabelBOffset};
                }
            }
        });
        canvas.addEventListener('touchstart', function(e) {
            const pos = getTouchPos(canvas, e);
            if (isPointInLabel(pos.x, pos.y, window.fullscreenLabelABounds)) {
                fullscreenDraggingLabel = 'A';
                window.fullscreenDragStartX = pos.x;
                window.fullscreenDragStartY = pos.y;
                window.fullscreenDragStartOffsetX = fullscreenLabelAOffset.x;
                window.fullscreenDragStartOffsetY = fullscreenLabelAOffset.y;
                e.preventDefault();
            } else if (isPointInLabel(pos.x, pos.y, window.fullscreenLabelBBounds)) {
                fullscreenDraggingLabel = 'B';
                window.fullscreenDragStartX = pos.x;
                window.fullscreenDragStartY = pos.y;
                window.fullscreenDragStartOffsetX = fullscreenLabelBOffset.x;
                window.fullscreenDragStartOffsetY = fullscreenLabelBOffset.y;
                e.preventDefault();
            }
        });
        canvas.addEventListener('touchmove', function(e) {
            if (fullscreenDraggingLabel) {
                const pos = getTouchPos(canvas, e);
                const deltaX = pos.x - window.fullscreenDragStartX;
                const deltaY = pos.y - window.fullscreenDragStartY;
                if (fullscreenDraggingLabel === 'A') {
                    fullscreenLabelAOffset.x = window.fullscreenDragStartOffsetX + deltaX;
                    fullscreenLabelAOffset.y = window.fullscreenDragStartOffsetY + deltaY;
                } else if (fullscreenDraggingLabel === 'B') {
                    fullscreenLabelBOffset.x = window.fullscreenDragStartOffsetX + deltaX;
                    fullscreenLabelBOffset.y = window.fullscreenDragStartOffsetY + deltaY;
                }
                fullscreenChartInstance.update('none');
                e.preventDefault();
            }
        });
        canvas.addEventListener('touchend', function(e) {
            if (fullscreenDraggingLabel) {
                fullscreenDraggingLabel = null;
                fullscreenChartInstance.update();
                
                // ğŸ¯ ä¿å­˜æ¨™ç±¤åç§»é‡
                if (window.lastFullscreenState) {
                    window.lastFullscreenState.labelAOffset = {...fullscreenLabelAOffset};
                    window.lastFullscreenState.labelBOffset = {...fullscreenLabelBOffset};
                }
            }
        });
        const pointControl = document.querySelector('.chart-fullscreen-point-control');
        if (pointControl) {
            pointControl.style.display = fullscreenInfoVisible ? 'flex' : 'none';
        }
        
        // ğŸ¯ æ¢å¾©ä¸Šæ¬¡ä¿å­˜çš„ç‹€æ…‹
        setTimeout(() => {
            if (window.lastFullscreenState) {
                const state = window.lastFullscreenState;
                console.log('ğŸ”„ æ¢å¾©ä¸Šæ¬¡å…¨å±ç‹€æ…‹:', state);
                
                // æ¢å¾©è¨Šæ¯æ¡†é¡¯ç¤ºç‹€æ…‹
                if (state.infoVisible !== fullscreenInfoVisible) {
                    toggleFullscreenInfo();
                }
                
                // æ¢å¾©é®è”½ç·šé¡è‰²ç‹€æ…‹
                if (state.obstructionEnabled !== obstructionColorEnabled) {
                    toggleObstructionColor();
                }
                
                // æ¢å¾©å°é»ƒé»ä½ç½®
                if (state.selectedPointIndex !== undefined && state.selectedPointIndex >= 0) {
                    window.currentSelectedPointIndex = state.selectedPointIndex;
                    
                    // æ›´æ–°å°é»ƒé»é¡¯ç¤º
                    const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
                        d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
                    );
                    if (fullscreenDataset && fullscreenDataset.data) {
                        const fullscreenPointColors = new Array(fullscreenDataset.data.length);
                        const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
                        const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
                        const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);
                        
                        for (let i = 0; i < fullscreenDataset.data.length; i++) {
                            if (i === state.selectedPointIndex) {
                                fullscreenPointColors[i] = '#ffd43b';
                                fullscreenPointRadius[i] = 8;
                                fullscreenPointHoverRadius[i] = 12;
                                fullscreenPointBorderColor[i] = '#fff';
                            } else {
                                fullscreenPointColors[i] = 'transparent';
                                fullscreenPointRadius[i] = 0;
                                fullscreenPointHoverRadius[i] = 6;
                                fullscreenPointBorderColor[i] = 'transparent';
                            }
                        }
                        
                        fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
                        fullscreenDataset.pointRadius = fullscreenPointRadius;
                        fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
                        fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
                        fullscreenDataset.pointBorderWidth = 2;
                    }
                    
                    // æ¢å¾©è—è‰²è¨Šæ¯æ¡†å…§å®¹å’Œä½ç½®
                    if (fullscreenInfoVisible && pathData && elevationData) {
                        const idx = state.selectedPointIndex;
                        const overlay = document.getElementById('chartFullscreenOverlay');
                        let tooltipEl = overlay ? overlay.querySelector('#chartjs-tooltip-fullscreen') : null;
                        
                        if (tooltipEl && idx < pathData.length && idx < elevationData.length) {
                            const currentLat = pathData[idx].lat;
                            const currentLng = pathData[idx].lng;
                            const dataValue = elevationData[idx];
                            const losValue = losLineData ? losLineData[idx] : null;
                            
                            let clearanceText = 'N/A';
                            let clearanceColor = '#a8b3c3';
                            if (losValue !== null && !isNaN(losValue)) {
                                const clearance = losValue - dataValue;
                                if (clearance >= 0) {
                                    clearanceText = `æ·¨ç©º +${clearance.toFixed(1)} m`;
                                    clearanceColor = '#36c74d';
                                } else {
                                    clearanceText = `é®è”½ ${clearance.toFixed(1)} m`;
                                    clearanceColor = '#ff4444';
                                }
                            }
                            
                            const innerHTML = `
                                <div>è·é›¢èµ·é»: ${(idx * (totalPathDistance / (elevationData.length - 1))).toFixed(2)} km</div>
                                <div>æµ·æ‹”é«˜åº¦: ${dataValue.toFixed(0)} m</div>
                                <div>åº§æ¨™: ${currentLat.toFixed(6)}, ${currentLng.toFixed(6)}</div>
                                <div style="color: ${clearanceColor}; font-weight: bold;">é®è”½: ${clearanceText}</div>
                            `;
                            tooltipEl.innerHTML = innerHTML;
                            
                            // æ¢å¾© tooltip åç§»é‡
                            tooltipOffsetX = state.tooltipOffsetX || 0;
                            tooltipOffsetY = state.tooltipOffsetY || 0;
                            
                            tooltipEl.style.opacity = '1';
                            tooltipEl.style.display = 'block';
                        }
                    }
                }
                
                // æ¢å¾©æ¨™ç±¤åç§»é‡
                if (state.labelAOffset) {
                    fullscreenLabelAOffset = {...state.labelAOffset};
                }
                if (state.labelBOffset) {
                    fullscreenLabelBOffset = {...state.labelBOffset};
                }
                
                // æ¢å¾©åœ–ä¾‹çš„é¡¯ç¤º/éš±è—ç‹€æ…‹
                if (state.datasetHiddenStates && fullscreenChartInstance) {
                    Object.keys(state.datasetHiddenStates).forEach(indexStr => {
                        const index = parseInt(indexStr);
                        const hidden = state.datasetHiddenStates[index];
                        const meta = fullscreenChartInstance.getDatasetMeta(index);
                        if (meta) {
                            meta.hidden = hidden;
                        }
                    });
                    console.log('ğŸ”„ å·²æ¢å¾©åœ–ä¾‹ç‹€æ…‹:', state.datasetHiddenStates);
                }
                
                // æ›´æ–°åœ–è¡¨
                if (fullscreenChartInstance) {
                    fullscreenChartInstance.update('none');
                }
                
                console.log('âœ… å…¨å±ç‹€æ…‹å·²æ¢å¾©');
            }
        }, 500);
        
        console.log('å…¨è¢å¹•å‰–é¢åœ–å·²é–‹å•Ÿï¼ˆæ©«å‘é¡¯ç¤ºï¼‰');
    }, 300);
}
function closeChartFullscreen() {
    // ğŸ¯ ä¿å­˜é—œé–‰å‰çš„ç‹€æ…‹ï¼Œä¾›ä¸‹æ¬¡é–‹å•Ÿæ™‚ä½¿ç”¨
    
    // ä¿å­˜åœ–ä¾‹çš„é¡¯ç¤º/éš±è—ç‹€æ…‹
    const datasetHiddenStates = {};
    if (fullscreenChartInstance && fullscreenChartInstance.data && fullscreenChartInstance.data.datasets) {
        fullscreenChartInstance.data.datasets.forEach((dataset, index) => {
            const meta = fullscreenChartInstance.getDatasetMeta(index);
            datasetHiddenStates[index] = meta.hidden;
        });
        console.log('ğŸ’¾ å·²ä¿å­˜åœ–ä¾‹ç‹€æ…‹:', datasetHiddenStates);
    }
    
    const fullscreenState = {
        infoVisible: fullscreenInfoVisible,
        obstructionEnabled: obstructionColorEnabled,
        selectedPointIndex: window.currentSelectedPointIndex,
        tooltipOffsetX: tooltipOffsetX,
        tooltipOffsetY: tooltipOffsetY,
        labelAOffset: fullscreenLabelAOffset ? {...fullscreenLabelAOffset} : { x: 0, y: -30 },
        labelBOffset: fullscreenLabelBOffset ? {...fullscreenLabelBOffset} : { x: 0, y: -30 },
        datasetHiddenStates: datasetHiddenStates  // åŠ å…¥åœ–ä¾‹ç‹€æ…‹
    };
    window.lastFullscreenState = fullscreenState;
    console.log('ğŸ’¾ å·²ä¿å­˜é—œé–‰å‰ç‹€æ…‹:', fullscreenState);
    
    const overlay = document.getElementById('chartFullscreenOverlay');
    overlay.classList.remove('active');
    const tooltipEl = overlay.querySelector('#chartjs-tooltip-fullscreen');
    if (tooltipEl) {
        tooltipEl.remove();
    }
    
    // éš±è—å ±å‘Šç¢ºèªæŒ‰éˆ•
    const confirmBtn = overlay.querySelector('#reportConfirmButton');
    if (confirmBtn) {
        confirmBtn.style.display = 'none';
    }
    window.isGeneratingReport = false;
    
    if (screen.orientation && screen.orientation.unlock) {
        screen.orientation.unlock();
    }
    if (document.exitFullscreen) {
        document.exitFullscreen().catch(err => console.log('é€€å‡ºå…¨è¢å¹•å¤±æ•—:', err));
    } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen().catch(err => console.log('é€€å‡ºå…¨è¢å¹•å¤±æ•—:', err));
    } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen().catch(err => console.log('é€€å‡ºå…¨è¢å¹•å¤±æ•—:', err));
    } else if (document.msExitFullscreen) {
        document.msExitFullscreen().catch(err => console.log('é€€å‡ºå…¨è¢å¹•å¤±æ•—:', err));
    }
    document.body.style.overflow = '';
    if (typeof window.currentSelectedPointIndex !== 'undefined' &&
        window.currentSelectedPointIndex !== null &&
        window.currentSelectedPointIndex >= 0 &&
        pathData &&
        pathData[window.currentSelectedPointIndex]) {
        const selectedIdx = window.currentSelectedPointIndex;
        if (elevationData && elevationData[selectedIdx] !== undefined) {
            showMap(selectedIdx, elevationData[selectedIdx]);
            console.log('å·²åŒæ­¥é»ƒé»ã€åœ°åœ–å’Œä½ç½®è³‡è¨Šåˆ°éå…¨è¢å¹•ï¼Œç´¢å¼•:', selectedIdx);
        }
    }
    if (fullscreenChartInstance) {
        fullscreenChartInstance.destroy();
        fullscreenChartInstance = null;
    }
    fullscreenDraggingLabel = null;
    console.log('å…¨è¢å¹•å‰–é¢åœ–å·²é—œé–‰');
}
async function generateChartImage() {
    try {
        if (!fullscreenChartInstance) {
            alert('âŒ æ‰¾ä¸åˆ°å…¨è¢å¹•å‰–é¢åœ–ï¼Œè«‹å…ˆé€²å…¥å…¨è¢å¹•æ¨¡å¼');
            return;
        }
        const button = document.querySelector('.chart-fullscreen-screenshot');
        if (button) {
            button.textContent = 'â³';
            button.style.background = 'rgba(255, 193, 7, 1)';
        }
        const overlay = document.getElementById('chartFullscreenOverlay');
        if (!overlay) {
            alert('âŒ æ‰¾ä¸åˆ°å…¨è¢å¹•å®¹å™¨');
            if (button) {
                button.textContent = 'ğŸ“·';
                button.style.background = '';
            }
            return;
        }
        const controlsToHide = [
            overlay.querySelector('.chart-fullscreen-close'),
            overlay.querySelector('.chart-fullscreen-screenshot'),
            overlay.querySelector('.chart-fullscreen-rotate-toggle'),
            overlay.querySelector('.chart-fullscreen-info-toggle'),
            overlay.querySelector('.chart-fullscreen-obstruction-toggle'),
            overlay.querySelector('.chart-fullscreen-map-toggle'),
            overlay.querySelector('.chart-fullscreen-end-obstruction'),
            overlay.querySelector('.chart-fullscreen-max-obstruction'),
            overlay.querySelector('.chart-fullscreen-start-obstruction'),
            overlay.querySelector('.chart-fullscreen-point-control')
        ];
        const originalDisplayStates = controlsToHide.map(el => {
            if (el) {
                const display = el.style.display;
                el.style.display = 'none';
                return display;
            }
            return null;
        });
        await new Promise(resolve => setTimeout(resolve, 50));
        const canvas = await html2canvas(overlay, {
            backgroundColor: '#0b1526',
            scale: 2,
            logging: false,
            useCORS: true,
            allowTaint: true,
            foreignObjectRendering: false,
            imageTimeout: 0
        });
        controlsToHide.forEach((el, index) => {
            if (el) {
                el.style.display = originalDisplayStates[index] || '';
            }
        });
        const imageUrl = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const nameA = window.elevationPointAName || 'Aé»';
        const nameB = window.elevationPointBName || 'Bé»';
        link.download = `å‰–é¢åœ–_${nameA}_åˆ°_${nameB}_${timestamp}.png`;
        link.href = imageUrl;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        console.log('âœ“ å‰–é¢åœ–åœ–ç‰‡å·²ç”Ÿæˆä¸¦ä¸‹è¼‰ï¼ˆç›´æ¥æˆªå–ç•¶å‰ç•«é¢ï¼‰');
        if (button) {
            const originalText = 'ğŸ“·';
            button.textContent = 'âœ“';
            button.style.background = 'rgba(76, 175, 80, 1)';
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '';
            }, 1500);
        }
    } catch (error) {
        console.error('ç”Ÿæˆåœ–ç‰‡æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
        alert('âŒ ç”Ÿæˆåœ–ç‰‡å¤±æ•—: ' + error.message);
        const button = document.querySelector('.chart-fullscreen-screenshot');
        if (button) {
            button.textContent = 'ğŸ“·';
            button.style.background = '';
        }
    }
}
function toggleLandscapeFullscreen() {
    const overlay = document.getElementById('chartFullscreenOverlay');
    const elem = overlay;
    if (elem.requestFullscreen) {
        elem.requestFullscreen().catch(err => {
            console.log('é€²å…¥å…¨è¢å¹•å¤±æ•—:', err);
            alert('ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨æ¬Šé™è¨­å®š');
        });
    } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen().catch(err => {
            console.log('é€²å…¥å…¨è¢å¹•å¤±æ•—:', err);
            alert('ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨æ¬Šé™è¨­å®š');
        });
    } else if (elem.mozRequestFullScreen) {
        elem.mozRequestFullScreen().catch(err => {
            console.log('é€²å…¥å…¨è¢å¹•å¤±æ•—:', err);
            alert('ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨æ¬Šé™è¨­å®š');
        });
    } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen().catch(err => {
            console.log('é€²å…¥å…¨è¢å¹•å¤±æ•—:', err);
            alert('ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨æ¬Šé™è¨­å®š');
        });
    }
    if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('landscape').catch(err => {
            console.log('é–å®šæ©«å‘å¤±æ•—:', err);
            screen.orientation.lock('landscape-primary').catch(err => {
                console.log('é–å®šæ©«å‘-ä¸»è¦å¤±æ•—:', err);
                screen.orientation.lock('landscape-secondary').catch(err => {
                    console.log('é–å®šæ©«å‘-æ¬¡è¦å¤±æ•—:', err);
                });
            });
        });
    }
    console.log('å·²è«‹æ±‚æ©«å±å…¨ç•«é¢æ¨¡å¼');
}
let fullscreenInfoVisible = true;
let preventHoverUpdate = false;
function forceSync(targetIndex) {
    console.log('=== å¼·åˆ¶åŒæ­¥é–‹å§‹ ===ï¼Œç›®æ¨™ç´¢å¼•:', targetIndex);
    window.currentSelectedPointIndex = targetIndex;
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (selectedPointInput) {
        selectedPointInput.value = targetIndex + 1;
        console.log('åŒæ­¥ä¸‹æ–¹è¼¸å…¥æ¬„ä½:', targetIndex + 1);
    }
    const fullscreenPointInput = document.getElementById('fullscreenPointInput');
    if (fullscreenPointInput) {
        fullscreenPointInput.value = targetIndex + 1;
        console.log('åŒæ­¥å…¨è¢å¹•è¼¸å…¥æ¬„ä½:', targetIndex + 1);
    }
    const overlay = document.getElementById('chartFullscreenOverlay');
    const isInFullscreen = overlay && overlay.classList.contains('active');
    if (isInFullscreen && fullscreenChartInstance) {
        console.log('åœ¨å…¨è¢å¹•æ¨¡å¼ä¸‹ï¼Œå¼·åˆ¶åŒæ­¥å…¨è¢å¹•åœ–è¡¨');
        syncFullscreenChartAfterButtonClick(targetIndex);
    }
    console.log('=== å¼·åˆ¶åŒæ­¥å®Œæˆ ===');
}
function syncFullscreenChartAfterButtonClick(targetIndex) {
    console.log('=== syncFullscreenChartAfterButtonClick é–‹å§‹ ===');
    console.log('ç›®æ¨™ç´¢å¼•:', targetIndex);
    console.log('ç•¶å‰ currentSelectedPointIndex:', window.currentSelectedPointIndex);
    preventHoverUpdate = true;
    const overlay = document.getElementById('chartFullscreenOverlay');
    if (!overlay || !overlay.classList.contains('active')) {
        console.log('éå…¨è¢å¹•æ¨¡å¼ï¼Œç„¡éœ€åŒæ­¥');
        preventHoverUpdate = false;
        return;
    }
    if (!fullscreenChartInstance) {
        console.log('å…¨è¢å¹•åœ–è¡¨ä¸å­˜åœ¨ï¼Œç„¡éœ€åŒæ­¥');
        preventHoverUpdate = false;
        return;
    }
    console.log('åŸ·è¡Œå…¨è¢å¹•æ¨¡å¼åŒæ­¥ï¼Œç›®æ¨™ç´¢å¼•:', targetIndex);
    window.currentSelectedPointIndex = targetIndex;
    const fullscreenPointInput = document.getElementById('fullscreenPointInput');
    if (fullscreenPointInput) {
        fullscreenPointInput.value = targetIndex + 1;
    }
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (selectedPointInput) {
        selectedPointInput.value = targetIndex + 1;
    }
    if (!fullscreenInfoVisible) {
        fullscreenInfoVisible = true;
        const toggleBtn = document.querySelector('.chart-fullscreen-info-toggle');
        if (toggleBtn) {
            toggleBtn.classList.remove('disabled');
            toggleBtn.style.opacity = '1';
        }
    }
    const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
        d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
    );
    if (fullscreenDataset && fullscreenDataset.data) {
        const pointCount = fullscreenDataset.data.length;
        const fullscreenPointColors = new Array(pointCount);
        const fullscreenPointRadius = new Array(pointCount);
        const fullscreenPointHoverRadius = new Array(pointCount);
        const fullscreenPointBorderColor = new Array(pointCount);
        for (let i = 0; i < pointCount; i++) {
            if (i === targetIndex) {
                fullscreenPointColors[i] = '#ffd43b';
                fullscreenPointRadius[i] = 8;
                fullscreenPointHoverRadius[i] = 12;
                fullscreenPointBorderColor[i] = '#fff';
            } else {
                fullscreenPointColors[i] = 'transparent';
                fullscreenPointRadius[i] = 0;
                fullscreenPointHoverRadius[i] = 6;
                fullscreenPointBorderColor[i] = 'transparent';
            }
        }
        fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
        fullscreenDataset.pointRadius = fullscreenPointRadius;
        fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
        fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
        fullscreenDataset.pointBorderWidth = 2;
        fullscreenChartInstance.update('none');
        console.log('å…¨è¢å¹•åœ–è¡¨é»ƒé»å·²æ›´æ–°åˆ°ç´¢å¼•:', targetIndex);
    }
    const canvas = document.getElementById('elevationChartFullscreen');
    const fullscreenContainer = document.getElementById('chartFullscreenOverlay');
    if (canvas && fullscreenContainer && fullscreenChartInstance) {
        const xScale = fullscreenChartInstance.scales.x;
        const yScale = fullscreenChartInstance.scales.y;
        const dataset = fullscreenChartInstance.data.datasets.find(d =>
            d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
        );
        if (dataset && dataset.data[targetIndex] !== undefined) {
            const pixelX = xScale.getPixelForValue(targetIndex);
            const pixelY = yScale.getPixelForValue(dataset.data[targetIndex]);
            let tooltipEl = fullscreenContainer.querySelector('#chartjs-tooltip-fullscreen');
            if (!tooltipEl) {
                tooltipEl = document.createElement('div');
                tooltipEl.id = 'chartjs-tooltip-fullscreen';
                tooltipEl.style.background = 'rgba(13, 71, 161, 0.35)';
                tooltipEl.style.borderRadius = '8px';
                tooltipEl.style.color = 'white';
                tooltipEl.style.opacity = '0';
                tooltipEl.style.pointerEvents = 'auto';
                tooltipEl.style.position = 'fixed';
                tooltipEl.style.transform = 'translate(-50%, -120%)';
                tooltipEl.style.transition = 'all .1s ease';
                tooltipEl.style.padding = '10px 12px';
                tooltipEl.style.border = '2px solid #4dabf7';
                tooltipEl.style.fontSize = '13px';
                tooltipEl.style.lineHeight = '1.5';
                tooltipEl.style.zIndex = '10002';
                tooltipEl.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                tooltipEl.style.whiteSpace = 'nowrap';
                tooltipEl.style.cursor = 'move';
                fullscreenContainer.appendChild(tooltipEl);
                
                // ç«‹å³ç¶å®šæ‹–æ›³åŠŸèƒ½
                makeTooltipDraggable(tooltipEl);
            }
            const dataValue = dataset.data[targetIndex];
            const totalPoints = dataset.data.length;
            const sLat = parseFloat(document.getElementById('sLat').value);
            const sLng = parseFloat(document.getElementById('sLng').value);
            const eLat = parseFloat(document.getElementById('eLat').value);
            const eLng = parseFloat(document.getElementById('eLng').value);
            const totalDistance = getDistance(sLat, sLng, eLat, eLng);
            const distanceFromStart = (targetIndex / (totalPoints - 1)) * totalDistance;
            const distanceFromEnd = totalDistance - distanceFromStart;
            const fraction = targetIndex / (totalPoints - 1);
            const currentLat = sLat + (eLat - sLat) * fraction;
            const currentLng = sLng + (eLng - sLng) * fraction;
            const startName = window.elevationPointAName || 'Aé»';
            const endName = window.elevationPointBName || 'Bé»';
            let clearanceValue = 0;
            let clearanceText = '';
            const losDataset = fullscreenChartInstance.data.datasets.find(d => d.label && (d.label.includes('è¦–è·é€£ç·š') || d.label.includes('è¦–è·')));
            if (losDataset && losDataset.data[targetIndex] !== undefined) {
                const losHeight = losDataset.data[targetIndex];
                clearanceValue = losHeight - dataValue;
                if (clearanceValue > 0) {
                    clearanceText = `+${clearanceValue.toFixed(2)} m`;
                } else if (clearanceValue < 0) {
                    clearanceText = `${clearanceValue.toFixed(2)} m`;
                } else {
                    clearanceText = '0.00 m';
                }
            }
            const clearanceColor = clearanceValue >= 0 ? '#4caf50' : '#ff4444';
            const innerHTML = `
                <div class="tooltip-drag-handle" style="position: absolute; top: 2px; right: 2px; width: 24px; height: 24px; cursor: move; display: flex; align-items: center; justify-content: center; opacity: 0.7; font-size: 16px; user-select: none;" title="æ‹–æ›³ç§»å‹•">â ¿</div>
                <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">ä½ç½®è³‡è¨Š: ${targetIndex + 1}</div>
                <div>è·é›¢${startName}: ${distanceFromStart.toFixed(3)} km</div>
                <div>è·é›¢${endName}: ${distanceFromEnd.toFixed(3)} km</div>
                <div>æµ·æ‹”é«˜åº¦: ${dataValue.toFixed(0)} m</div>
                <div>åº§æ¨™: ${currentLat.toFixed(6)}, ${currentLng.toFixed(6)}</div>
                <div style="color: ${clearanceColor}; font-weight: bold;">é®è”½: ${clearanceText}</div>
            `;
            tooltipEl.innerHTML = innerHTML;
            const rect = canvas.getBoundingClientRect();
            let tooltipX = rect.left + pixelX;
            let tooltipY = rect.top + pixelY;
            tooltipEl.style.left = tooltipX + 'px';
            tooltipEl.style.top = tooltipY + 'px';
            tooltipEl.style.opacity = '0';
            tooltipEl.style.display = 'block';
            const tooltipRect = tooltipEl.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            let transformX = '-50%';
            let transformY = '-120%';
            const spaceAbove = tooltipY;
            const spaceBelow = viewportHeight - tooltipY;
            if (spaceAbove < tooltipHeight + 30) {
                if (spaceBelow > tooltipHeight + 30) {
                    transformY = '20%';
                } else {
                    transformY = '-50%';
                    tooltipY = spaceAbove > spaceBelow
                        ? Math.min(tooltipY, spaceAbove - tooltipHeight/2)
                        : Math.max(tooltipY, tooltipHeight/2);
                }
            }
            const spaceLeft = tooltipX;
            const spaceRight = viewportWidth - tooltipX;
            if (spaceLeft < tooltipWidth/2 + 10) {
                transformX = '10%';
                tooltipX = Math.max(tooltipX, tooltipWidth/2 + 10);
            } else if (spaceRight < tooltipWidth/2 + 10) {
                transformX = '-110%';
                tooltipX = Math.min(tooltipX, viewportWidth - tooltipWidth/2 - 10);
            }
            tooltipEl.style.left = tooltipX + 'px';
            tooltipEl.style.top = tooltipY + 'px';
            tooltipEl.style.transform = `translate(${transformX}, ${transformY})`;
            tooltipEl.style.opacity = '1';
        }
    }
    console.log('å…¨è¢å¹•æ¨¡å¼åŒæ­¥å®Œæˆï¼Œé»ƒé»å’Œè¨Šæ¯æ¡†å·²æ›´æ–°åˆ°ç´¢å¼•:', targetIndex);
    setTimeout(() => {
        preventHoverUpdate = false;
        console.log('è§£é™¤æ‹–æ›³é˜»æ­¢æ¨™èªŒ');
    }, 200);
    console.log('=== syncFullscreenChartAfterButtonClick çµæŸ ===');
}
function toggleFullscreenInfo() {
    fullscreenInfoVisible = !fullscreenInfoVisible;
    const toggleBtn = document.querySelector('.chart-fullscreen-info-toggle');
    const fullscreenContainer = document.getElementById('chartFullscreenOverlay');
    let tooltipEl = fullscreenContainer ? fullscreenContainer.querySelector('#chartjs-tooltip-fullscreen') : null;
    if (!tooltipEl && fullscreenContainer) {
        tooltipEl = document.createElement('div');
        tooltipEl.id = 'chartjs-tooltip-fullscreen';
        tooltipEl.style.background = 'rgba(13, 71, 161, 0.35)';
        tooltipEl.style.borderRadius = '8px';
        tooltipEl.style.color = 'white';
        tooltipEl.style.opacity = '0';
        tooltipEl.style.pointerEvents = 'auto';
        tooltipEl.style.position = 'fixed';
        tooltipEl.style.transform = 'translate(-50%, -120%)';
        tooltipEl.style.transition = 'all .1s ease';
        tooltipEl.style.padding = '10px 12px';
        tooltipEl.style.border = '2px solid #4dabf7';
        tooltipEl.style.fontSize = '13px';
        tooltipEl.style.lineHeight = '1.5';
        tooltipEl.style.zIndex = '10002';
        tooltipEl.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
        tooltipEl.style.whiteSpace = 'nowrap';
        tooltipEl.style.cursor = 'move';
        fullscreenContainer.appendChild(tooltipEl);
        makeTooltipDraggable(tooltipEl);
    }
    if (fullscreenInfoVisible) {
        toggleBtn.classList.remove('disabled');
        toggleBtn.style.opacity = '1';
        const pointControl = document.querySelector('.chart-fullscreen-point-control');
        if (pointControl) {
            pointControl.style.display = 'flex';
        }
        console.log('å…¨è¢å¹•è³‡è¨Šæ¡†å·²é–‹å•Ÿ');
    } else {
        toggleBtn.classList.add('disabled');
        toggleBtn.style.opacity = '0.6';
        const pointControl = document.querySelector('.chart-fullscreen-point-control');
        if (pointControl) {
            pointControl.style.display = 'none';
        }
        if (tooltipEl) {
            tooltipEl.style.opacity = '0';
            tooltipEl.style.display = 'none';
        }
        if (fullscreenChartInstance) {
            const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
                d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
            );
            if (fullscreenDataset && fullscreenDataset.data) {
                const fullscreenPointColors = new Array(fullscreenDataset.data.length);
                const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
                const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
                const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);
                for (let i = 0; i < fullscreenDataset.data.length; i++) {
                    fullscreenPointColors[i] = 'transparent';
                    fullscreenPointRadius[i] = 0;
                    fullscreenPointHoverRadius[i] = 0;
                    fullscreenPointBorderColor[i] = 'transparent';
                }
                fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
                fullscreenDataset.pointRadius = fullscreenPointRadius;
                fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
                fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
                fullscreenChartInstance.update('none');
            }
        }
        console.log('å…¨è¢å¹•è³‡è¨Šæ¡†å·²é—œé–‰');
    }
    if (fullscreenInfoVisible) {
        if (tooltipEl) {
            tooltipEl.style.display = 'block';
        }
        if (typeof window.currentSelectedPointIndex !== 'undefined' &&
            window.currentSelectedPointIndex !== null && window.currentSelectedPointIndex >= 0) {
            const selectedIdx = window.currentSelectedPointIndex;
            if (fullscreenChartInstance) {
                const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
                    d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
                );
                if (fullscreenDataset && fullscreenDataset.data) {
                    const fullscreenPointColors = new Array(fullscreenDataset.data.length);
                    const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
                    const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
                    const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);
                    for (let i = 0; i < fullscreenDataset.data.length; i++) {
                        if (i === selectedIdx) {
                            fullscreenPointColors[i] = '#ffd43b';
                            fullscreenPointRadius[i] = 8;
                            fullscreenPointHoverRadius[i] = 12;
                            fullscreenPointBorderColor[i] = '#fff';
                        } else {
                            fullscreenPointColors[i] = 'transparent';
                            fullscreenPointRadius[i] = 0;
                            fullscreenPointHoverRadius[i] = 6;
                            fullscreenPointBorderColor[i] = 'transparent';
                        }
                    }
                    fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
                    fullscreenDataset.pointRadius = fullscreenPointRadius;
                    fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
                    fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
                    fullscreenDataset.pointBorderWidth = 2;
                    fullscreenChartInstance.update('none');
                    if (tooltipEl && fullscreenDataset.data[selectedIdx] !== undefined) {
                        const dataValue = fullscreenDataset.data[selectedIdx];
                        const totalPoints = fullscreenDataset.data.length;
                        const sLat = parseFloat(document.getElementById('sLat').value);
                        const sLng = parseFloat(document.getElementById('sLng').value);
                        const eLat = parseFloat(document.getElementById('eLat').value);
                        const eLng = parseFloat(document.getElementById('eLng').value);
                        const totalDistance = getDistance(sLat, sLng, eLat, eLng);
                        const distanceFromStart = (selectedIdx / (totalPoints - 1)) * totalDistance;
                        const distanceFromEnd = totalDistance - distanceFromStart;
                        const fraction = selectedIdx / (totalPoints - 1);
                        const currentLat = sLat + (eLat - sLat) * fraction;
                        const currentLng = sLng + (eLng - sLng) * fraction;
                        const startName = window.elevationPointAName || 'Aé»';
                        const endName = window.elevationPointBName || 'Bé»';
                        let clearanceValue = 0;
                        let clearanceText = '';
                        const losDataset = fullscreenChartInstance.data.datasets.find(d => d.label && (d.label.includes('è¦–è·é€£ç·š') || d.label.includes('è¦–è·')));
                        if (losDataset && losDataset.data[selectedIdx] !== undefined) {
                            const losHeight = losDataset.data[selectedIdx];
                            clearanceValue = losHeight - dataValue;
                            if (clearanceValue > 0) {
                                clearanceText = `+${clearanceValue.toFixed(2)} m`;
                            } else if (clearanceValue < 0) {
                                clearanceText = `${clearanceValue.toFixed(2)} m`;
                            } else {
                                clearanceText = '0.00 m';
                            }
                        }
                        const clearanceColor = clearanceValue >= 0 ? '#4caf50' : '#ff4444';
                        tooltipEl.innerHTML = `
                            <div class="tooltip-drag-handle" style="position: absolute; top: 2px; right: 2px; width: 24px; height: 24px; cursor: move; display: flex; align-items: center; justify-content: center; opacity: 0.7; font-size: 16px; user-select: none;" title="æ‹–æ›³ç§»å‹•">â ¿</div>
                            <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">ä½ç½®è³‡è¨Š: ${selectedIdx + 1}</div>
                            <div>è·é›¢${startName}: ${distanceFromStart.toFixed(3)} km</div>
                            <div>è·é›¢${endName}: ${distanceFromEnd.toFixed(3)} km</div>
                            <div>æµ·æ‹”é«˜åº¦: ${dataValue.toFixed(0)} m</div>
                            <div>åº§æ¨™: ${currentLat.toFixed(6)}, ${currentLng.toFixed(6)}</div>
                            <div style="color: ${clearanceColor}; font-weight: bold;">é®è”½: ${clearanceText}</div>
                        `;
                        const chartArea = fullscreenChartInstance.chartArea;
                        const xScale = fullscreenChartInstance.scales.x;
                        const yScale = fullscreenChartInstance.scales.y;
                        if (xScale && yScale) {
                            const xPos = xScale.getPixelForValue(selectedIdx);
                            const yPos = yScale.getPixelForValue(dataValue);
                            const canvas = fullscreenChartInstance.canvas;
                            const canvasRect = canvas.getBoundingClientRect();
                            tooltipEl.style.opacity = '1';
                            tooltipEl.style.left = (canvasRect.left + xPos) + 'px';
                            tooltipEl.style.top = (canvasRect.top + yPos) + 'px';
                            setTimeout(() => {
                                const tooltipRect = tooltipEl.getBoundingClientRect();
                                const tooltipWidth = tooltipRect.width;
                                const tooltipHeight = tooltipRect.height;
                                const tooltipX = canvasRect.left + xPos;
                                const tooltipY = canvasRect.top + yPos;
                                const canvasWidth = canvasRect.width;
                                const canvasHeight = canvasRect.height;
                                let transformX = '-50%';
                                let transformY = '-120%';
                                const offsetY = 30;
                                const spaceAbove = tooltipY - canvasRect.top;
                                const spaceBelow = (canvasRect.top + canvasHeight) - tooltipY;
                                if (spaceAbove < tooltipHeight + offsetY) {
                                    if (spaceBelow > tooltipHeight + offsetY) {
                                        transformY = '20%';
                                    } else {
                                        transformY = '-50%';
                                    }
                                }
                                const spaceLeft = tooltipX - canvasRect.left;
                                const spaceRight = (canvasRect.left + canvasWidth) - tooltipX;
                                const horizontalMargin = 10;
                                if (spaceLeft < tooltipWidth/2 + horizontalMargin) {
                                    transformX = '10%';
                                } else if (spaceRight < tooltipWidth/2 + horizontalMargin) {
                                    transformX = '-110%';
                                }
                                tooltipEl.style.transform = `translate(${transformX}, ${transformY})`;
                                console.log('Tooltipå·²é¡¯ç¤ºæ–¼ä½ç½®:', tooltipX, tooltipY, 'ä½¿ç”¨ transform:', transformX, transformY);
                            }, 10);
                        }
                    }
                }
            }
        } else {
            console.log('æ²’æœ‰é¸ä¸­çš„é»ï¼Œè«‹å…ˆé»æ“Šåœ–è¡¨é¸æ“‡ä¸€å€‹é»');
        }
    }
    
    // ğŸ¯ æ›´æ–°ä¿å­˜çš„ç‹€æ…‹
    if (window.lastFullscreenState) {
        window.lastFullscreenState.infoVisible = fullscreenInfoVisible;
    }
}
let obstructionColorEnabled = false;
function toggleObstructionColor() {
    obstructionColorEnabled = !obstructionColorEnabled;
    const toggleBtn = document.querySelector('.chart-fullscreen-obstruction-toggle');
    if (!fullscreenChartInstance) {
        console.log('å…¨è¢å¹•åœ–è¡¨æœªåˆå§‹åŒ–');
        return;
    }
    const terrainDataset = fullscreenChartInstance.data.datasets.find(d =>
        d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
    );
    const losDataset = fullscreenChartInstance.data.datasets.find(d =>
        d.label && (d.label.includes('è¦–è·é€£ç·š') || d.label.includes('è¦–è·'))
    );
    if (!terrainDataset || !losDataset) {
        console.log('æ‰¾ä¸åˆ°å¿…è¦çš„æ•¸æ“šé›†');
        return;
    }
    if (obstructionColorEnabled) {
        toggleBtn.classList.remove('disabled');
        toggleBtn.style.opacity = '1';
        const segmentColors = [];
        const terrainData = terrainDataset.data;
        const losData = losDataset.data;
        for (let i = 0; i < terrainData.length - 1; i++) {
            const isObstructed = terrainData[i] > losData[i] || terrainData[i + 1] > losData[i + 1];
            segmentColors.push({
                borderColor: isObstructed ? '#ff4444' : '#5ff0d5',
                backgroundColor: isObstructed ? 'rgba(255, 68, 68, 0.1)' : 'rgba(95, 240, 213, 0.1)'
            });
        }
        terrainDataset.segment = {
            borderColor: (ctx) => {
                const idx = ctx.p0DataIndex;
                if (idx < segmentColors.length) {
                    return segmentColors[idx].borderColor;
                }
                return '#5ff0d5';
            },
            backgroundColor: (ctx) => {
                const idx = ctx.p0DataIndex;
                if (idx < segmentColors.length) {
                    return segmentColors[idx].backgroundColor;
                }
                return 'rgba(95, 240, 213, 0.1)';
            }
        };
        terrainDataset.borderColor = '#ff8866';
        terrainDataset.backgroundColor = 'rgba(255, 136, 102, 0.1)';
        console.log('é®è”½ç·šé¡è‰²å·²é–‹å•Ÿ');
    } else {
        toggleBtn.classList.add('disabled');
        toggleBtn.style.opacity = '0.6';
        delete terrainDataset.segment;
        terrainDataset.borderColor = '#5ff0d5';
        terrainDataset.backgroundColor = 'rgba(95, 240, 213, 0.1)';
        console.log('é®è”½ç·šé¡è‰²å·²é—œé–‰');
    }
    fullscreenChartInstance.update();
    
    // ğŸ¯ æ›´æ–°ä¿å­˜çš„ç‹€æ…‹
    if (window.lastFullscreenState) {
        window.lastFullscreenState.obstructionEnabled = obstructionColorEnabled;
    }
}
function openGoogleMapForYellowPoint() {
    console.log('openGoogleMapForYellowPoint() è¢«èª¿ç”¨');
    if (typeof window.currentSelectedPointIndex === 'undefined' ||
        window.currentSelectedPointIndex === null ||
        window.currentSelectedPointIndex < 0) {
        alert('âŒ è«‹å…ˆé»æ“Šåœ–è¡¨ä¸Šçš„ä»»ä¸€é»ä»¥é¸æ“‡ä½ç½®');
        return;
    }
    if (!pathData || pathData.length === 0) {
        alert('âŒ æ‰¾ä¸åˆ°è·¯å¾‘æ•¸æ“šï¼Œè«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    const index = window.currentSelectedPointIndex;
    if (index >= pathData.length) {
        alert('âŒ é¸ä¸­çš„é»ç´¢å¼•ç„¡æ•ˆ');
        return;
    }
    const point = pathData[index];
    const lat = point.lat;
    const lng = point.lng;
    console.log('é¡¯ç¤ºåœ°åœ–ï¼Œåº§æ¨™:', lat, lng, 'ç´¢å¼•:', index);
    const overlay = document.getElementById('chartFullscreenOverlay');
    let mapContainer = overlay.querySelector('#embedded-map-container');
    if (!mapContainer) {
        mapContainer = document.createElement('div');
        mapContainer.id = 'embedded-map-container';
        mapContainer.style.position = 'fixed';
        mapContainer.style.top = '0';
        mapContainer.style.left = '0';
        mapContainer.style.width = '100%';
        mapContainer.style.height = '100%';
        mapContainer.style.background = '#1a1a1a';
        mapContainer.style.zIndex = '10004';
        mapContainer.style.display = 'none';
        mapContainer.style.padding = '0';
        mapContainer.style.overflow = 'hidden';
        const titleBar = document.createElement('div');
        titleBar.style.background = 'rgba(13, 71, 161, 0.9)';
        titleBar.style.backdropFilter = 'blur(10px)';
        titleBar.style.color = 'white';
        titleBar.style.padding = '8px 12px';
        titleBar.style.fontWeight = 'bold';
        titleBar.style.fontSize = '14px';
        titleBar.style.display = 'flex';
        titleBar.style.justifyContent = 'flex-start';
        titleBar.style.alignItems = 'center';
        titleBar.style.gap = '10px';
        titleBar.style.position = 'absolute';
        titleBar.style.top = '10px';
        titleBar.style.right = '10px';
        titleBar.style.left = 'auto';
        titleBar.style.width = 'auto';
        titleBar.style.borderRadius = '8px';
        titleBar.style.border = '2px solid #4dabf7';
        titleBar.style.boxShadow = '0 4px 12px rgba(0,0,0,0.6)';
        titleBar.style.zIndex = '10005';
        titleBar.innerHTML = `
            <span style="font-size: 13px;">ğŸ“ é»</span>
            <div style="display: flex; gap: 4px; align-items: center;">
                <button onclick="decrementMapPoint()" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); color: #022; border: none; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 14px; height: 26px; min-width: 32px;">â—€</button>
                <input type="number" id="mapPointInput" value="${index + 1}" min="1" max="${pathData.length}" style="width: 70px; padding: 3px 6px; font-size: 14px; color: #5ff0d5; background: rgba(0,0,0,0.7); border: 2px solid rgba(95,240,213,0.3); border-radius: 4px; text-align: center; height: 26px; font-weight: bold;" oninput="updateMapPointFromInput()">
                <button onclick="incrementMapPoint()" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); color: #022; border: none; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 14px; height: 26px; min-width: 32px;">â–¶</button>
            </div>
            <div style="display: flex; gap: 6px;">
                <button onclick="openInNewTabFromEmbedded()" style="background: rgba(255,255,255,0.95); color: #1971c2; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 13px; white-space: nowrap;">ğŸ”— é–‹å•Ÿ</button>
                <button onclick="closeEmbeddedMap()" style="background: rgba(255,68,68,0.95); color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 14px;">âœ•</button>
            </div>
        `;
        mapContainer.appendChild(titleBar);
        const iframeWrapper = document.createElement('div');
        iframeWrapper.style.width = '100%';
        iframeWrapper.style.height = '100%';
        iframeWrapper.style.background = '#1a1a1a';
        const iframe = document.createElement('iframe');
        iframe.id = 'embedded-map-iframe';
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.allowFullscreen = true;
        iframeWrapper.appendChild(iframe);
        mapContainer.appendChild(iframeWrapper);
        overlay.appendChild(mapContainer);
    }
    const iframe = mapContainer.querySelector('#embedded-map-iframe');
    const googleMapUrl = `https://maps.google.com/maps?q=${lat},${lng}&t=k&z=17&output=embed`;
    iframe.src = googleMapUrl;
    window.currentMapCoords = { lat, lng };
    const titleSpan = mapContainer.querySelector('span');
    if (titleSpan) {
        titleSpan.innerHTML = `ğŸ“ é»`;
    }
    const mapPointInput = mapContainer.querySelector('#mapPointInput');
    if (mapPointInput) {
        mapPointInput.value = index + 1;
        mapPointInput.max = pathData.length;
    }
    mapContainer.style.display = 'block';
    console.log('åµŒå…¥å¼åœ°åœ–å·²é¡¯ç¤ºï¼ˆå…¨è¢å¹•ï¼‰');
}
function closeEmbeddedMap() {
    const overlay = document.getElementById('chartFullscreenOverlay');
    const mapContainer = overlay.querySelector('#embedded-map-container');
    if (mapContainer) {
        mapContainer.style.display = 'none';
        const iframe = mapContainer.querySelector('#embedded-map-iframe');
        if (iframe) {
            iframe.src = 'about:blank';
        }
    }
}
function openInNewTabFromEmbedded() {
    if (window.currentMapCoords) {
        const { lat, lng } = window.currentMapCoords;
        const googleMapUrl = `https://www.google.com/maps?q=${lat},${lng}&t=k&z=17`;
        window.open(googleMapUrl, '_blank');
    }
}
function decrementMapPoint() {
    if (typeof window.currentSelectedPointIndex === 'undefined' || window.currentSelectedPointIndex === null) {
        return;
    }
    if (!pathData || pathData.length === 0) {
        return;
    }
    let newIndex = window.currentSelectedPointIndex - 1;
    if (newIndex < 0) {
        newIndex = pathData.length - 1;
    }
    window.currentSelectedPointIndex = newIndex;
    const point = pathData[newIndex];
    const lat = point.lat;
    const lng = point.lng;
    const overlay = document.getElementById('chartFullscreenOverlay');
    const mapContainer = overlay.querySelector('#embedded-map-container');
    if (mapContainer) {
        const iframe = mapContainer.querySelector('#embedded-map-iframe');
        const googleMapUrl = `https://maps.google.com/maps?q=${lat},${lng}&t=k&z=17&output=embed`;
        iframe.src = googleMapUrl;
        window.currentMapCoords = { lat, lng };
        const mapPointInput = mapContainer.querySelector('#mapPointInput');
        if (mapPointInput) {
            mapPointInput.value = newIndex + 1;
        }
    }
    const fullscreenPointInput = document.getElementById('fullscreenPointInput');
    if (fullscreenPointInput) {
        fullscreenPointInput.value = newIndex + 1;
    }
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (selectedPointInput) {
        selectedPointInput.value = newIndex + 1;
    }
    syncFullscreenChartAfterButtonClick(newIndex);
    console.log('åœ°åœ–é»å·²éæ¸›è‡³:', newIndex + 1);
}
function incrementMapPoint() {
    if (typeof window.currentSelectedPointIndex === 'undefined' || window.currentSelectedPointIndex === null) {
        return;
    }
    if (!pathData || pathData.length === 0) {
        return;
    }
    let newIndex = window.currentSelectedPointIndex + 1;
    if (newIndex >= pathData.length) {
        newIndex = 0;
    }
    window.currentSelectedPointIndex = newIndex;
    const point = pathData[newIndex];
    const lat = point.lat;
    const lng = point.lng;
    const overlay = document.getElementById('chartFullscreenOverlay');
    const mapContainer = overlay.querySelector('#embedded-map-container');
    if (mapContainer) {
        const iframe = mapContainer.querySelector('#embedded-map-iframe');
        const googleMapUrl = `https://maps.google.com/maps?q=${lat},${lng}&t=k&z=17&output=embed`;
        iframe.src = googleMapUrl;
        window.currentMapCoords = { lat, lng };
        const mapPointInput = mapContainer.querySelector('#mapPointInput');
        if (mapPointInput) {
            mapPointInput.value = newIndex + 1;
        }
    }
    const fullscreenPointInput = document.getElementById('fullscreenPointInput');
    if (fullscreenPointInput) {
        fullscreenPointInput.value = newIndex + 1;
    }
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (selectedPointInput) {
        selectedPointInput.value = newIndex + 1;
    }
    syncFullscreenChartAfterButtonClick(newIndex);
    console.log('åœ°åœ–é»å·²éå¢è‡³:', newIndex + 1);
}
function updateMapPointFromInput() {
    const mapPointInput = document.getElementById('mapPointInput');
    if (!mapPointInput) {
        return;
    }
    const value = parseInt(mapPointInput.value);
    if (isNaN(value) || value < 1 || !pathData || value > pathData.length) {
        return;
    }
    const newIndex = value - 1;
    window.currentSelectedPointIndex = newIndex;
    const point = pathData[newIndex];
    const lat = point.lat;
    const lng = point.lng;
    const overlay = document.getElementById('chartFullscreenOverlay');
    const mapContainer = overlay.querySelector('#embedded-map-container');
    if (mapContainer) {
        const iframe = mapContainer.querySelector('#embedded-map-iframe');
        const googleMapUrl = `https://maps.google.com/maps?q=${lat},${lng}&t=k&z=17&output=embed`;
        iframe.src = googleMapUrl;
        window.currentMapCoords = { lat, lng };
    }
    const fullscreenPointInput = document.getElementById('fullscreenPointInput');
    if (fullscreenPointInput) {
        fullscreenPointInput.value = newIndex + 1;
    }
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (selectedPointInput) {
        selectedPointInput.value = newIndex + 1;
    }
    syncFullscreenChartAfterButtonClick(newIndex);
    console.log('åœ°åœ–é»å·²æ›´æ–°è‡³:', value);
}
function showMap(index, height) {
    tooltipManualPosition = null;
    console.log('showMap() è¢«èª¿ç”¨ï¼Œç´¢å¼•:', index, 'é«˜åº¦:', height);
    const p = pathData[index];
    const mapContainer = document.getElementById('map-container');
    const mapFrame = document.getElementById('map-frame');
    const mapDetails = document.getElementById('map-details');
    const selectedPointInput = document.getElementById('selectedPointIndex');
    const fullscreenPointInput = document.getElementById('fullscreenPointInput');
    if (!mapContainer || !mapFrame || !mapDetails) {
        console.error('æ‰¾ä¸åˆ°åœ°åœ–ç›¸é—œå…ƒç´ ');
        return;
    }
    if (selectedPointInput) {
        selectedPointInput.value = index + 1;
        console.log('é¸å®šé»å·²æ›´æ–°:', index + 1);
    }
    if (fullscreenPointInput) {
        fullscreenPointInput.value = index + 1;
        console.log('å…¨ç•«é¢é¸å®šé»å·²æ›´æ–°:', index + 1);
    }
    if (chartInstance && chartInstance.data.datasets[0].pointBackgroundColor) {
        const pointColors = chartInstance.data.datasets[0].pointBackgroundColor;
        const pointRadius = chartInstance.data.datasets[0].pointRadius;
        const pointHoverRadius = chartInstance.data.datasets[0].pointHoverRadius;
        for (let i = 0; i < pointColors.length; i++) {
            if (i === index) {
                pointColors[i] = '#ffd43b';
                pointRadius[i] = 6;
                pointHoverRadius[i] = 10;
            } else {
                pointColors[i] = '#28a745';
                if (typeof greenPointsVisible !== 'undefined' && !greenPointsVisible) {
                    pointRadius[i] = 0;
                    pointHoverRadius[i] = 0;
                } else {
                    pointRadius[i] = 3;
                    pointHoverRadius[i] = 8;
                }
            }
        }
        chartInstance.update();
        console.log('åœ–è¡¨é»é¡è‰²å’Œå¤§å°å·²æ›´æ–°ï¼Œé¸ä¸­é»ç´¢å¼•:', index);
    }
    window.currentSelectedPointIndex = index;
    const nameA = window.elevationPointAName || 'Aé»';
    const nameB = window.elevationPointBName || 'Bé»';
    const totalDistance = pathData[pathData.length - 1].dist;
    const distanceToB = (totalDistance - parseFloat(p.dist)).toFixed(3);
    let obstructionInfo = '';
    if (elevationData && elevationData.length > 0 && chartInstance && chartInstance.data.datasets[1]) {
        const losLineData = chartInstance.data.datasets[1].data;
        if (losLineData && losLineData[index] !== undefined) {
            const losHeight = losLineData[index];
            const terrainHeight = elevationData[index];
            const clearance = losHeight - terrainHeight;
            const isStartPoint = (index === 0);
            const isEndPoint = (index === elevationData.length - 1);
            if (clearance > 0) {
                obstructionInfo = `<br><span style="color: #ffd43b;">é®è”½:</span> <span style="color: #51cf66; font-weight: bold;">${clearance.toFixed(2)} m</span>`;
            } else if (clearance === 0 && (isStartPoint || isEndPoint)) {
                obstructionInfo = `<br><span style="color: #ffd43b;">é®è”½:</span> <span style="color: #51cf66; font-weight: bold;">0.00 m</span>`;
            } else {
                obstructionInfo = `<br><span style="color: #ffd43b;">é®è”½:</span> <span style="color: #ff6b6b; font-weight: bold;">${Math.abs(clearance).toFixed(2)} m</span>`;
            }
        }
    }
    mapContainer.style.display = 'block';
    mapDetails.innerHTML = `<strong><span style="color: #ffd43b;">ä½ç½®è³‡è¨Š:</span> <span style="color: #5ff0d5;">${index + 1}</span></strong><br><span style="color: #ffd43b;">è·é›¢${nameA}:</span> <span style="color: #5ff0d5;">${p.dist} km</span><br><span style="color: #ffd43b;">è·é›¢${nameB}:</span> <span style="color: #5ff0d5;">${distanceToB} km</span><br><span style="color: #ffd43b;">æµ·æ‹”é«˜åº¦:</span> <span style="color: #5ff0d5;">${height} m</span><br><span style="color: #ffd43b;">åº§æ¨™:</span> <span style="color: #5ff0d5;">${p.lat}, ${p.lng}</span>${obstructionInfo}`;
    const mapUrl = `https://maps.google.com/maps?q=${p.lat},${p.lng}&t=k&z=17&output=embed`;
    mapFrame.src = mapUrl;
    console.log('åœ°åœ– URL:', mapUrl);
}
let routeMapInstance = null;
let routeCurrentLayer = null;
let routeStreetLayer = null;
let routeSatelliteLayer = null;
let routeHybridLayer = null;
let routeLayerControl = null;
function showRouteMap() {
    console.log('showRouteMap() è¢«èª¿ç”¨');
    if (!pathData || pathData.length < 2) {
        console.log('è·¯å¾‘æ•¸æ“šä¸è¶³ï¼Œç„¡æ³•é¡¯ç¤ºè·¯å¾‘åœ°åœ–');
        return;
    }
    const routeMapContainer = document.getElementById('route-map-container');
    const routeMapDiv = document.getElementById('route-map');
    const routeStartInfo = document.getElementById('route-start-info');
    const routeEndInfo = document.getElementById('route-end-info');
    const routeDistanceInfo = document.getElementById('route-distance-info');
    if (!routeMapContainer || !routeMapDiv) {
        console.error('æ‰¾ä¸åˆ°è·¯å¾‘åœ°åœ–ç›¸é—œå…ƒç´ ');
        return;
    }
    const startPoint = pathData[0];
    const endPoint = pathData[pathData.length - 1];
    const nameA = window.elevationPointAName || 'Aé»';
    const nameB = window.elevationPointBName || 'Bé»';
    const distance = endPoint.dist;
    if (routeStartInfo) {
        routeStartInfo.textContent = `${nameA} (${startPoint.lat}, ${startPoint.lng})`;
    }
    if (routeEndInfo) {
        routeEndInfo.textContent = `${nameB} (${endPoint.lat}, ${endPoint.lng})`;
    }
    if (routeDistanceInfo) {
        routeDistanceInfo.textContent = `${distance} km`;
    }
    routeMapContainer.style.display = 'block';
    const startLat = parseFloat(startPoint.lat);
    const startLng = parseFloat(startPoint.lng);
    const endLat = parseFloat(endPoint.lat);
    const endLng = parseFloat(endPoint.lng);
    const centerLat = (startLat + endLat) / 2;
    const centerLng = (startLng + endLng) / 2;
    const latDiff = Math.abs(startLat - endLat);
    const lngDiff = Math.abs(startLng - endLng);
    const maxDiff = Math.max(latDiff, lngDiff);
    let zoom = 13;
    if (maxDiff > 0.1) zoom = 11;
    if (maxDiff > 0.5) zoom = 9;
    if (maxDiff > 1) zoom = 8;
    if (maxDiff > 2) zoom = 7;
    routeMapDiv.innerHTML = '';
    if (typeof L === 'undefined') {
        console.error('Leaflet å°šæœªè¼‰å…¥');
        routeMapDiv.innerHTML = '<div style="padding:20px; color:#ff6b6b; text-align:center;">åœ°åœ–è¼‰å…¥ä¸­...</div>';
        return;
    }
    if (routeMapInstance) {
        routeMapInstance.remove();
        routeMapInstance = null;
    }
    routeStreetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap',
        maxZoom: 19
    });
    routeSatelliteLayer = L.tileLayer('http://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
        attribution: 'Â© Google Maps',
        maxZoom: 20,
        subdomains: ['0', '1', '2', '3']
    });
    routeEarthLayer = L.tileLayer('http://mt{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}', {
        attribution: 'Â© Google Earth',
        maxZoom: 20,
        subdomains: ['0', '1', '2', '3']
    });
    routeHybridLayer = L.layerGroup([
        L.tileLayer('http://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
            attribution: 'Â© Google Maps',
            maxZoom: 20,
            subdomains: ['0', '1', '2', '3']
        }),
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            opacity: 0.3,
            maxZoom: 19
        })
    ]);
    routeNlscLayer = L.tileLayer('https://wmts.nlsc.gov.tw/wmts/PHOTO2/default/GoogleMapsCompatible/{z}/{y}/{x}', {
        attribution: 'Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ',
        maxZoom: 19
    });
    routeMapInstance = L.map(routeMapDiv, {
        center: [centerLat, centerLng],
        zoom: zoom,
        layers: [routeSatelliteLayer]
    });
    routeCurrentLayer = 'satellite';
    const layerControlHTML = `
        <div style="position: absolute; top: 10px; right: 10px; z-index: 1000; background: rgba(0,0,0,0.7); border-radius: 8px; padding: 8px; display: flex; flex-direction: column; gap: 6px;">
            <button id="route-layer-toggle" style="background: linear-gradient(90deg, #9b59b6, #8e44ad); border: none; padding: 8px 12px; border-radius: 6px; font-weight: bold; color: #fff; cursor: pointer; font-size: 13px; white-space: nowrap;">ğŸ›°ï¸ è¡›æ˜Ÿåœ–</button>
        </div>
    `;
    const controlDiv = document.createElement('div');
    controlDiv.innerHTML = layerControlHTML;
    controlDiv.style.cssText = 'position: absolute; top: 10px; right: 10px; z-index: 1000;';
    routeMapDiv.appendChild(controlDiv);
    const toggleButton = document.getElementById('route-layer-toggle');
    if (toggleButton) {
        toggleButton.onclick = function() {
            if (routeCurrentLayer === 'street') {
                routeMapInstance.removeLayer(routeStreetLayer);
                routeSatelliteLayer.addTo(routeMapInstance);
                routeCurrentLayer = 'satellite';
                this.innerHTML = 'ğŸ›°ï¸ è¡›æ˜Ÿåœ–';
            } else if (routeCurrentLayer === 'satellite') {
                routeMapInstance.removeLayer(routeSatelliteLayer);
                routeEarthLayer.addTo(routeMapInstance);
                routeCurrentLayer = 'earth';
                this.innerHTML = 'ğŸŒ åœ°å½¢åœ–';
            } else if (routeCurrentLayer === 'earth') {
                routeMapInstance.removeLayer(routeEarthLayer);
                routeHybridLayer.addTo(routeMapInstance);
                routeCurrentLayer = 'hybrid';
                this.innerHTML = 'ğŸ”€ æ··åˆåœ–';
            } else if (routeCurrentLayer === 'hybrid') {
                routeMapInstance.removeLayer(routeHybridLayer);
                routeNlscLayer.addTo(routeMapInstance);
                routeCurrentLayer = 'nlsc';
                this.innerHTML = 'ğŸ›©ï¸ èˆªç…§åœ–';
            } else {
                routeMapInstance.removeLayer(routeNlscLayer);
                routeStreetLayer.addTo(routeMapInstance);
                routeCurrentLayer = 'street';
                this.innerHTML = 'ğŸ—ºï¸ è¡—é“åœ–';
            }
        };
    }
    const startIcon = L.divIcon({
        className: 'custom-marker',
        html: '<div style="background: #0066FF; width: 32px; height: 32px; border-radius: 50%; border: 3px solid white; display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 18px; box-shadow: 0 2px 8px rgba(0,0,0,0.4);">A</div>',
        iconSize: [32, 32],
        iconAnchor: [16, 16]
    });
    const endIcon = L.divIcon({
        className: 'custom-marker',
        html: '<div style="background: #FF0000; width: 32px; height: 32px; border-radius: 50%; border: 3px solid white; display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 18px; box-shadow: 0 2px 8px rgba(0,0,0,0.4);">B</div>',
        iconSize: [32, 32],
        iconAnchor: [16, 16]
    });
    const startMarker = L.marker([startLat, startLng], { icon: startIcon }).addTo(routeMapInstance);
    startMarker.bindPopup(`<div style="color:#000; padding:5px;"><strong>${nameA}</strong><br>èµ·é»<br>${startLat.toFixed(6)}, ${startLng.toFixed(6)}</div>`);
    const endMarker = L.marker([endLat, endLng], { icon: endIcon }).addTo(routeMapInstance);
    endMarker.bindPopup(`<div style="color:#000; padding:5px;"><strong>${nameB}</strong><br>çµ‚é»<br>${endLat.toFixed(6)}, ${endLng.toFixed(6)}</div>`);
    const line = L.polyline([
        [startLat, startLng],
        [endLat, endLng]
    ], {
        color: '#FFFF00',
        weight: 3,
        opacity: 1.0
    }).addTo(routeMapInstance);
    const bounds = L.latLngBounds([
        [startLat, startLng],
        [endLat, endLng]
    ]);
    routeMapInstance.fitBounds(bounds, { padding: [50, 50] });
    console.log('è·¯å¾‘åœ°åœ–å·²ç”Ÿæˆ (ä½¿ç”¨ Leafletï¼Œèˆ‡GPSåˆ†é ç›¸åŒ)');
}
let isMapMaximized = false;
let originalMapStyles = {};
let exitFullscreenBtn = null;
function maximizeRouteMap() {
    const container = document.getElementById('route-map-container');
    const mapDiv = document.getElementById('route-map');
    const btn = document.getElementById('maximizeMapBtn');
    const details = document.getElementById('route-map-details');
    if (!container || !mapDiv || !btn) return;
    if (!isMapMaximized) {
        if (container.requestFullscreen) {
            container.requestFullscreen();
        } else if (container.webkitRequestFullscreen) {
            container.webkitRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
            container.mozRequestFullScreen();
        } else if (container.msRequestFullscreen) {
            container.msRequestFullscreen();
        }
        originalMapStyles = {
            containerBackground: container.style.background,
            containerPadding: container.style.padding,
            containerDisplay: container.style.display,
            mapHeight: mapDiv.style.height,
            mapBorder: mapDiv.style.border,
            mapBorderRadius: mapDiv.style.borderRadius
        };
        container.style.background = '#000';
        container.style.padding = '0';
        container.style.display = 'flex';
        container.style.flexDirection = 'column';
        container.style.justifyContent = 'center';
        container.style.alignItems = 'center';
        if (details) details.style.display = 'none';
        btn.style.display = 'none';
        mapDiv.style.width = '100%';
        mapDiv.style.height = '100%';
        mapDiv.style.border = '2px solid #5ff0d5';
        mapDiv.style.borderRadius = '0';
        mapDiv.style.boxSizing = 'border-box';
        exitFullscreenBtn = document.createElement('button');
        exitFullscreenBtn.id = 'exitFullscreenBtn';
        exitFullscreenBtn.innerHTML = 'âœ•';
        exitFullscreenBtn.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(220, 38, 38, 0.95);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            z-index: 999999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            line-height: 1;
        `;
        exitFullscreenBtn.onmouseover = function() {
            this.style.background = 'rgba(185, 28, 28, 0.95)';
            this.style.transform = 'scale(1.1)';
        };
        exitFullscreenBtn.onmouseout = function() {
            this.style.background = 'rgba(220, 38, 38, 0.95)';
            this.style.transform = 'scale(1)';
        };
        exitFullscreenBtn.onclick = function() {
            exitFullscreen();
        };
        container.appendChild(exitFullscreenBtn);
        const layerToggleBtn = document.getElementById('route-layer-toggle');
        const layerToggleContainer = layerToggleBtn?.parentElement;
        if (layerToggleContainer) {
            layerToggleContainer.style.position = 'fixed';
            layerToggleContainer.style.top = '10px';
            layerToggleContainer.style.left = '50%';
            layerToggleContainer.style.right = 'auto';
            layerToggleContainer.style.transform = 'translateX(-50%)';
            layerToggleContainer.style.zIndex = '999998';
        }
        isMapMaximized = true;
        setTimeout(() => {
            if (routeMapInstance) {
                routeMapInstance.invalidateSize();
                const sLat = parseFloat(document.getElementById('sLat')?.value);
                const sLng = parseFloat(document.getElementById('sLng')?.value);
                const eLat = parseFloat(document.getElementById('eLat')?.value);
                const eLng = parseFloat(document.getElementById('eLng')?.value);
                if (!isNaN(sLat) && !isNaN(sLng) && !isNaN(eLat) && !isNaN(eLng)) {
                    const bounds = L.latLngBounds([[sLat, sLng], [eLat, eLng]]);
                    routeMapInstance.fitBounds(bounds, { padding: [50, 50] });
                }
            }
        }, 150);
    }
}
function exitFullscreen() {
    if (document.exitFullscreen) {
        document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
    } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
    } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
    }
}
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
document.addEventListener('mozfullscreenchange', handleFullscreenChange);
document.addEventListener('MSFullscreenChange', handleFullscreenChange);
function handleFullscreenChange() {
    const container = document.getElementById('route-map-container');
    const mapDiv = document.getElementById('route-map');
    const btn = document.getElementById('maximizeMapBtn');
    const details = document.getElementById('route-map-details');
    if (!document.fullscreenElement && !document.webkitFullscreenElement &&
        !document.mozFullScreenElement && !document.msFullscreenElement) {
        if (container && mapDiv && btn) {
            container.style.background = originalMapStyles.containerBackground || 'transparent';
            container.style.padding = originalMapStyles.containerPadding || '0';
            container.style.display = '';
            container.style.flexDirection = '';
            container.style.justifyContent = '';
            container.style.alignItems = '';
            if (details) details.style.display = 'block';
            btn.style.display = '';
            mapDiv.style.width = '';
            mapDiv.style.height = originalMapStyles.mapHeight || '450px';
            mapDiv.style.border = originalMapStyles.mapBorder || '2px solid #5ff0d5';
            mapDiv.style.borderRadius = originalMapStyles.mapBorderRadius || '8px';
            mapDiv.style.boxSizing = '';
            const layerToggleBtn = document.getElementById('route-layer-toggle');
            const layerToggleContainer = layerToggleBtn?.parentElement;
            if (layerToggleContainer) {
                layerToggleContainer.style.position = 'absolute';
                layerToggleContainer.style.top = '10px';
                layerToggleContainer.style.right = '10px';
                layerToggleContainer.style.left = 'auto';
                layerToggleContainer.style.transform = '';
                layerToggleContainer.style.zIndex = '1000';
            }
            if (exitFullscreenBtn && exitFullscreenBtn.parentNode) {
                exitFullscreenBtn.parentNode.removeChild(exitFullscreenBtn);
                exitFullscreenBtn = null;
            }
            isMapMaximized = false;
            setTimeout(() => {
                if (routeMapInstance) {
                    routeMapInstance.invalidateSize();
                    const sLat = parseFloat(document.getElementById('sLat')?.value);
                    const sLng = parseFloat(document.getElementById('sLng')?.value);
                    const eLat = parseFloat(document.getElementById('eLat')?.value);
                    const eLng = parseFloat(document.getElementById('eLng')?.value);
                    if (!isNaN(sLat) && !isNaN(sLng) && !isNaN(eLat) && !isNaN(eLng)) {
                        const bounds = L.latLngBounds([[sLat, sLng], [eLat, eLng]]);
                        routeMapInstance.fitBounds(bounds, { padding: [50, 50] });
                    }
                }
            }, 150);
        }
    }
}
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && isMapMaximized) {
        exitFullscreen();
    }
});
function updatePointFromInput() {
    selectedPointsInCurrentHeight.clear();
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (!selectedPointInput || !selectedPointInput.value) return;
    let inputValue = parseInt(selectedPointInput.value);
    if (inputValue < 1) {
        inputValue = 1;
        selectedPointInput.value = 1;
    } else if (inputValue > elevationData.length) {
        inputValue = elevationData.length;
        selectedPointInput.value = elevationData.length;
    }
    const index = inputValue - 1;
    console.log('æ‰‹å‹•è¼¸å…¥çš„é»æ•¸å€¼:', inputValue, 'å°æ‡‰ç´¢å¼•:', index);
    const fullscreenInput = document.getElementById('fullscreenPointInput');
    if (fullscreenInput) {
        fullscreenInput.value = inputValue;
    }
    showMap(index, elevationData[index]);
    syncFullscreenChartAfterButtonClick(index);
}
function updatePointFromFullscreenInput() {
    selectedPointsInCurrentHeight.clear();
    const fullscreenInput = document.getElementById('fullscreenPointInput');
    if (!fullscreenInput || !fullscreenInput.value) return;
    let inputValue = parseInt(fullscreenInput.value);
    if (inputValue < 1) {
        inputValue = 1;
        fullscreenInput.value = 1;
    } else if (inputValue > elevationData.length) {
        inputValue = elevationData.length;
        fullscreenInput.value = elevationData.length;
    }
    const index = inputValue - 1;
    console.log('å…¨ç•«é¢è¼¸å…¥æ¡†çš„é»æ•¸å€¼:', inputValue, 'å°æ‡‰ç´¢å¼•:', index);
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (selectedPointInput) {
        selectedPointInput.value = inputValue;
    }
    showMap(index, elevationData[index]);
    syncFullscreenChartAfterButtonClick(index);
}
function incrementSelectedPoint() {
    selectedPointsInCurrentHeight.clear();
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (!selectedPointInput || !selectedPointInput.value) return;
    let currentIndex = parseInt(selectedPointInput.value) - 1;
    let newIndex = currentIndex + 1;
    if (newIndex >= elevationData.length) {
        newIndex = 0;
    }
    console.log('ä¸Šéµï¼šå¾ç´¢å¼•', currentIndex, 'ç§»åˆ°', newIndex);
    showMap(newIndex, elevationData[newIndex]);
    syncFullscreenChartAfterButtonClick(newIndex);
}
function decrementSelectedPoint() {
    selectedPointsInCurrentHeight.clear();
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (!selectedPointInput || !selectedPointInput.value) return;
    let currentIndex = parseInt(selectedPointInput.value) - 1;
    let newIndex = currentIndex - 1;
    if (newIndex < 0) {
        newIndex = elevationData.length - 1;
    }
    console.log('ä¸‹éµï¼šå¾ç´¢å¼•', currentIndex, 'ç§»åˆ°', newIndex);
    showMap(newIndex, elevationData[newIndex]);
    syncFullscreenChartAfterButtonClick(newIndex);
}
function jumpToStartPoint() {
    selectedPointsInCurrentHeight.clear();
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    console.log('è·³åˆ°èµ·é»ï¼šç´¢å¼• 0');
    showMap(0, elevationData[0]);
    syncFullscreenChartAfterButtonClick(0);
}
function jumpToEndPoint() {
    selectedPointsInCurrentHeight.clear();
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    const endIndex = elevationData.length - 1;
    console.log('è·³åˆ°çµ‚é»ï¼šç´¢å¼•', endIndex);
    showMap(endIndex, elevationData[endIndex]);
    syncFullscreenChartAfterButtonClick(endIndex);
}
function jumpToMinPoint() {
    selectedPointsInCurrentHeight.clear();
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    let minValue = elevationData[0];
    let minIndex = 0;
    for (let i = 1; i < elevationData.length; i++) {
        if (elevationData[i] < minValue) {
            minValue = elevationData[i];
            minIndex = i;
        }
    }
    console.log('è·³åˆ°æœ€å°å€¼ï¼šç´¢å¼•', minIndex, 'é«˜åº¦', minValue);
    showMap(minIndex, elevationData[minIndex]);
    syncFullscreenChartAfterButtonClick(minIndex);
}
function jumpToMaxPoint() {
    selectedPointsInCurrentHeight.clear();
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    let maxValue = elevationData[0];
    let maxIndex = 0;
    for (let i = 1; i < elevationData.length; i++) {
        if (elevationData[i] > maxValue) {
            maxValue = elevationData[i];
            maxIndex = i;
        }
    }
    console.log('è·³åˆ°æœ€å¤§å€¼ï¼šç´¢å¼•', maxIndex, 'é«˜åº¦', maxValue);
    showMap(maxIndex, elevationData[maxIndex]);
    syncFullscreenChartAfterButtonClick(maxIndex);
}
function jumpToMaxObstruction() {
    console.log('=== jumpToMaxObstruction é–‹å§‹ ===');
    console.log('ç•¶å‰ currentSelectedPointIndex:', window.currentSelectedPointIndex);
    selectedPointsInCurrentHeight.clear();
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    if (!chartInstance || !chartInstance.data.datasets[1]) {
        alert('ç„¡æ³•ç²å–è¦–è·é€£ç·šæ•¸æ“š');
        return;
    }
    const losLineData = chartInstance.data.datasets[1].data;
    let maxObstruction = 0;
    let maxObstructionIndex = -1;
    for (let i = 1; i < elevationData.length - 1; i++) {
        const terrainHeight = elevationData[i];
        const losHeight = losLineData[i];
        const clearance = losHeight - terrainHeight;
        if (clearance < 0 && clearance < maxObstruction) {
            maxObstruction = clearance;
            maxObstructionIndex = i;
        }
    }
    if (maxObstructionIndex === -1) {
        const fullscreenOverlay = document.getElementById('chartFullscreenOverlay');
        const isInFullscreen = fullscreenOverlay && fullscreenOverlay.style.display === 'flex';
        if (isInFullscreen) {
            const alertBox = document.createElement('div');
            alertBox.style.position = 'fixed';
            alertBox.style.top = '50%';
            alertBox.style.left = '50%';
            alertBox.style.transform = 'translate(-50%, -50%)';
            alertBox.style.backgroundColor = 'rgba(39, 174, 96, 0.95)';
            alertBox.style.color = 'white';
            alertBox.style.padding = '30px 50px';
            alertBox.style.borderRadius = '12px';
            alertBox.style.fontSize = '24px';
            alertBox.style.fontWeight = 'bold';
            alertBox.style.zIndex = '10003';
            alertBox.style.boxShadow = '0 8px 24px rgba(0,0,0,0.5)';
            alertBox.style.border = '3px solid #27ae60';
            alertBox.textContent = 'âœ“ è·¯å¾‘ä¸Šæ²’æœ‰é®è”½é»';
            fullscreenOverlay.appendChild(alertBox);
            setTimeout(() => {
                if (alertBox.parentNode) {
                    alertBox.parentNode.removeChild(alertBox);
                }
            }, 3000);
        } else {
            alert('âœ“ è·¯å¾‘ä¸Šæ²’æœ‰é®è”½é»');
        }
        return;
    }
    console.log('è·³åˆ°æœ€å¤§é®è”½é»ï¼šç´¢å¼•', maxObstructionIndex, 'é®è”½é‡', Math.abs(maxObstruction).toFixed(2), 'm');
    console.log('èª¿ç”¨ showMap å‰çš„ currentSelectedPointIndex:', window.currentSelectedPointIndex);
    showMap(maxObstructionIndex, elevationData[maxObstructionIndex]);
    console.log('èª¿ç”¨ showMap å¾Œçš„ currentSelectedPointIndex:', window.currentSelectedPointIndex);
    syncFullscreenChartAfterButtonClick(maxObstructionIndex);
    console.log('=== jumpToMaxObstruction çµæŸ ===');
}
function jumpToFirstObstructionFromStart() {
    selectedPointsInCurrentHeight.clear();
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    if (!chartInstance || !chartInstance.data.datasets[1]) {
        alert('ç„¡æ³•ç²å–è¦–è·é€£ç·šæ•¸æ“š');
        return;
    }
    const losLineData = chartInstance.data.datasets[1].data;
    for (let i = 1; i < elevationData.length - 1; i++) {
        const terrainHeight = elevationData[i];
        const losHeight = losLineData[i];
        const clearance = losHeight - terrainHeight;
        if (clearance < 0) {
            console.log('æ‰¾åˆ°è·é›¢èµ·é»ç¬¬ä¸€å€‹é®è”½é»ï¼šç´¢å¼•', i, 'é®è”½é‡', Math.abs(clearance).toFixed(2), 'm');
            showMap(i, elevationData[i]);
            syncFullscreenChartAfterButtonClick(i);
            return;
        }
    }
    alert('âœ“ å¾èµ·é»é–‹å§‹æ²’æœ‰ç™¼ç¾é®è”½é»');
}
function jumpToFirstObstructionFromEnd() {
    selectedPointsInCurrentHeight.clear();
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    if (!chartInstance || !chartInstance.data.datasets[1]) {
        alert('ç„¡æ³•ç²å–è¦–è·é€£ç·šæ•¸æ“š');
        return;
    }
    const losLineData = chartInstance.data.datasets[1].data;
    for (let i = elevationData.length - 2; i > 0; i--) {
        const terrainHeight = elevationData[i];
        const losHeight = losLineData[i];
        const clearance = losHeight - terrainHeight;
        if (clearance < 0) {
            console.log('æ‰¾åˆ°è·é›¢çµ‚é»ç¬¬ä¸€å€‹é®è”½é»ï¼šç´¢å¼•', i, 'é®è”½é‡', Math.abs(clearance).toFixed(2), 'm');
            showMap(i, elevationData[i]);
            syncFullscreenChartAfterButtonClick(i);
            return;
        }
    }
    alert('âœ“ å¾çµ‚é»é–‹å§‹æ²’æœ‰ç™¼ç¾é®è”½é»');
}
let selectedPointsInCurrentHeight = new Set();
let lastButtonPressed = null;
let previousPointIndex = null;
function jumpToHigherPoint() {
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (!selectedPointInput || !selectedPointInput.value) {
        alert('è«‹å…ˆé¸æ“‡ä¸€å€‹é»');
        return;
    }
    previousPointIndex = parseInt(selectedPointInput.value) - 1;
    console.log('æŒ‰ä¸‹ + æŒ‰éˆ•å‰çš„æŒ‡å®šä½ç½®:', previousPointIndex);
    if (lastButtonPressed === 'minus') {
        console.log('ä¸Šä¸€æ¬¡æŒ‰çš„æ˜¯ - æŒ‰éˆ•ï¼Œé‡ç½®ç›¸åŒé«˜åº¦åŠŸèƒ½');
        selectedPointsInCurrentHeight.clear();
    }
    lastButtonPressed = 'plus';
    const currentIndex = previousPointIndex;
    const currentHeight = elevationData[currentIndex];
    if (!selectedPointsInCurrentHeight.has(currentIndex)) {
        selectedPointsInCurrentHeight.add(currentIndex);
        console.log('æ¨™è¨˜ç•¶å‰é»ç‚ºå·²é¸:', currentIndex);
    }
    let sameHeightPoints = [];
    for (let i = 0; i < elevationData.length; i++) {
        if (Math.abs(elevationData[i] - currentHeight) < 0.01) {
            sameHeightPoints.push(i);
        }
    }
    if (sameHeightPoints.length > 0) {
        for (let idx of sameHeightPoints) {
            if (!selectedPointsInCurrentHeight.has(idx) && idx !== currentIndex) {
                console.log('é¸æ“‡æœªé¸éçš„åŒé«˜åº¦é»:', idx, 'é«˜åº¦:', elevationData[idx]);
                selectedPointsInCurrentHeight.add(idx);
                showMap(idx, elevationData[idx]);
                syncFullscreenChartAfterButtonClick(idx);
                return;
            }
        }
        console.log('ç›¸åŒé«˜åº¦çš„é»éƒ½å·²é¸éï¼Œå°‹æ‰¾æ›´é«˜çš„é«˜åº¦');
    }
    let higherHeights = new Set();
    for (let i = 0; i < elevationData.length; i++) {
        if (elevationData[i] > currentHeight + 0.001) {
            higherHeights.add(Math.round(elevationData[i] * 100) / 100);
        }
    }
    if (higherHeights.size === 0) {
        console.log('æ²’æœ‰æ›´é«˜çš„é«˜åº¦ï¼Œç„¡å‹•ä½œ');
        return;
    }
    let targetHeight = Math.min(...higherHeights);
    selectedPointsInCurrentHeight.clear();
    let nextIndex = -1;
    for (let i = currentIndex + 1; i < elevationData.length; i++) {
        if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
            nextIndex = i;
            break;
        }
    }
    if (nextIndex === -1) {
        for (let i = 0; i < currentIndex; i++) {
            if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
                nextIndex = i;
                break;
            }
        }
    }
    if (nextIndex === -1) {
        console.log('æ‰¾ä¸åˆ°ç›®æ¨™é«˜åº¦çš„é»');
        return;
    }
    console.log('è·³åˆ°æ›´é«˜çš„é»ï¼šå¾ç´¢å¼•', currentIndex, '(é«˜åº¦', currentHeight, ') è·³åˆ°ç´¢å¼•', nextIndex, '(é«˜åº¦', elevationData[nextIndex], ')');
    selectedPointsInCurrentHeight.add(nextIndex);
    showMap(nextIndex, elevationData[nextIndex]);
    syncFullscreenChartAfterButtonClick(nextIndex);
}
function jumpToLowerPoint() {
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (!selectedPointInput || !selectedPointInput.value) {
        alert('è«‹å…ˆé¸æ“‡ä¸€å€‹é»');
        return;
    }
    previousPointIndex = parseInt(selectedPointInput.value) - 1;
    console.log('æŒ‰ä¸‹ - æŒ‰éˆ•å‰çš„æŒ‡å®šä½ç½®:', previousPointIndex);
    if (lastButtonPressed === 'plus') {
        console.log('ä¸Šä¸€æ¬¡æŒ‰çš„æ˜¯ + æŒ‰éˆ•ï¼Œé‡ç½®ç›¸åŒé«˜åº¦åŠŸèƒ½');
        selectedPointsInCurrentHeight.clear();
    }
    lastButtonPressed = 'minus';
    const currentIndex = previousPointIndex;
    const currentHeight = elevationData[currentIndex];
    if (!selectedPointsInCurrentHeight.has(currentIndex)) {
        selectedPointsInCurrentHeight.add(currentIndex);
        console.log('æ¨™è¨˜ç•¶å‰é»ç‚ºå·²é¸:', currentIndex);
    }
    let sameHeightPoints = [];
    for (let i = 0; i < elevationData.length; i++) {
        if (Math.abs(elevationData[i] - currentHeight) < 0.01) {
            sameHeightPoints.push(i);
        }
    }
    if (sameHeightPoints.length > 0) {
        for (let i = sameHeightPoints.length - 1; i >= 0; i--) {
            let idx = sameHeightPoints[i];
            if (!selectedPointsInCurrentHeight.has(idx) && idx !== currentIndex) {
                console.log('é¸æ“‡æœªé¸éçš„åŒé«˜åº¦é»:', idx, 'é«˜åº¦:', elevationData[idx]);
                selectedPointsInCurrentHeight.add(idx);
                showMap(idx, elevationData[idx]);
                syncFullscreenChartAfterButtonClick(idx);
                return;
            }
        }
        console.log('ç›¸åŒé«˜åº¦çš„é»éƒ½å·²é¸éï¼Œå°‹æ‰¾æ›´ä½çš„é«˜åº¦');
    }
    let lowerHeights = new Set();
    for (let i = 0; i < elevationData.length; i++) {
        if (elevationData[i] < currentHeight - 0.001) {
            lowerHeights.add(Math.round(elevationData[i] * 100) / 100);
        }
    }
    if (lowerHeights.size === 0) {
        console.log('æ²’æœ‰æ›´ä½çš„é«˜åº¦ï¼Œç„¡å‹•ä½œ');
        return;
    }
    let targetHeight = Math.max(...lowerHeights);
    selectedPointsInCurrentHeight.clear();
    let nextIndex = -1;
    for (let i = currentIndex - 1; i >= 0; i--) {
        if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
            nextIndex = i;
            break;
        }
    }
    if (nextIndex === -1) {
        for (let i = currentIndex + 1; i < elevationData.length; i++) {
            if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
                nextIndex = i;
                break;
            }
        }
    }
    if (nextIndex === -1) {
        console.log('æ‰¾ä¸åˆ°ç›®æ¨™é«˜åº¦çš„é»');
        return;
    }
    console.log('è·³åˆ°æ›´ä½çš„é»ï¼šå¾ç´¢å¼•', currentIndex, '(é«˜åº¦', currentHeight, ') è·³åˆ°ç´¢å¼•', nextIndex, '(é«˜åº¦', elevationData[nextIndex], ')');
    selectedPointsInCurrentHeight.add(nextIndex);
    showMap(nextIndex, elevationData[nextIndex]);
    syncFullscreenChartAfterButtonClick(nextIndex);
}
let elevationData = [];
let isFirstProfileGeneration = true;
console.log('é«˜åº¦åœ– JavaScript å·²åŠ è¼‰');
</script>
<script>
(function(){
  function enforceGpsIsolation(){
    var gpsTab = document.getElementById('gps-content');
    var isGpsActive = gpsTab && gpsTab.classList.contains('active');
    var ids = ['gpsCalcBtn','gpsResetBtn','gpsClearBtn','gpsRes','gps-controls-container'];
    ids.forEach(function(id){
      var el = document.getElementById(id);
      if(!el) return;
      if(isGpsActive){
        el.style.display = '';
        el.style.visibility = 'visible';
      }else{
        el.style.display = 'none';
        el.style.visibility = 'hidden';
      }
    });
  }
  var _showTab = window.showTab;
  window.showTab = function(tab){
    if(typeof _showTab === 'function'){
      _showTab(tab);
    }else{
      document.querySelectorAll('.tab-content').forEach(function(c){c.classList.remove('active');});
      var t = document.getElementById(tab+'-content');
      if(t) t.classList.add('active');
    }
    enforceGpsIsolation();
  };
  document.addEventListener('DOMContentLoaded', function(){
    var actives = document.querySelectorAll('.tab-content.active');
    if(actives.length>1){
      actives.forEach(function(c,i){ if(i>0) c.classList.remove('active'); });
    }
    enforceGpsIsolation();
  });
})();
</script>
<script>
(function() {
  function fixGpsPadding() {
    console.log('é–‹å§‹ä¿®æ­£GPS padding...');
    const gpsBoxes = document.querySelectorAll('.gps-ig.orange-border-card');
    console.log('æ‰¾åˆ°', gpsBoxes.length, 'å€‹GPSæ¡†');
    gpsBoxes.forEach((box, index) => {
      box.style.padding = '10px 12px';
      box.style.paddingTop = '10px';
      box.style.paddingBottom = '10px';
      box.style.paddingLeft = '12px';
      box.style.paddingRight = '12px';
      box.style.setProperty('padding', '10px 12px', 'important');
      console.log('å·²ä¿®æ­£GPSæ¡†', index + 1, 'çš„padding');
    });
    const allGpsBoxes = document.querySelectorAll('.gps-ig');
    allGpsBoxes.forEach((box, index) => {
      box.style.setProperty('padding', '10px 12px', 'important');
    });
    console.log('GPS paddingä¿®æ­£å®Œæˆï¼');
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', fixGpsPadding);
  } else {
    fixGpsPadding();
  }
  setTimeout(fixGpsPadding, 500);
  setTimeout(fixGpsPadding, 1000);
  setTimeout(fixGpsPadding, 2000);
})();
</script>
<script>
(function() {
  function handleCoordinatePaste(event, point) {
    const pastedText = (event.clipboardData || window.clipboardData).getData('text');
    const coordPattern = /^\s*([-+]?\d+\.?\d*)\s*,\s*([-+]?\d+\.?\d*)\s*$/;
    const match = pastedText.trim().match(coordPattern);
    if (match) {
      event.preventDefault();
      const lat = parseFloat(match[1]);
      const lon = parseFloat(match[2]);
      if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
        document.getElementById(`lat${point}`).value = lat;
        document.getElementById(`lon${point}`).value = lon;
        console.log(`åº§æ¨™å·²è‡ªå‹•å¡«å…¥åœ°é»${point}: ç·¯åº¦=${lat}, ç¶“åº¦=${lon}`);
        const resultDiv = document.getElementById('gpsRes');
        if (resultDiv) {
          resultDiv.innerHTML = `âœ“ åº§æ¨™å·²è‡ªå‹•å¡«å…¥åœ°é»${point}ï¼šç·¯åº¦ ${lat}Â°, ç¶“åº¦ ${lon}Â°`;
          resultDiv.style.color = '#ffd43b';
          resultDiv.style.background = 'rgba(255, 212, 59, 0.1)';
          resultDiv.style.padding = '12px';
          resultDiv.style.borderRadius = '6px';
          resultDiv.style.marginTop = '8px';
        }
      } else {
        alert('âŒ åº§æ¨™è¶…å‡ºæœ‰æ•ˆç¯„åœ\nç·¯åº¦: -90 ~ 90\nç¶“åº¦: -180 ~ 180');
      }
    }
  }
  function initCoordinatePaste() {
    const latA = document.getElementById('latA');
    const lonA = document.getElementById('lonA');
    const latB = document.getElementById('latB');
    const lonB = document.getElementById('lonB');
    if (latA) {
      latA.addEventListener('paste', (e) => handleCoordinatePaste(e, 'A'));
      console.log('âœ“ latA paste ç›£è½å·²è¨­ç½®');
    }
    if (lonA) {
      lonA.addEventListener('paste', (e) => handleCoordinatePaste(e, 'A'));
      console.log('âœ“ lonA paste ç›£è½å·²è¨­ç½®');
    }
    if (latB) {
      latB.addEventListener('paste', (e) => handleCoordinatePaste(e, 'B'));
      console.log('âœ“ latB paste ç›£è½å·²è¨­ç½®');
    }
    if (lonB) {
      lonB.addEventListener('paste', (e) => handleCoordinatePaste(e, 'B'));
      console.log('âœ“ lonB paste ç›£è½å·²è¨­ç½®');
    }
    console.log('GPS åº§æ¨™æ™ºèƒ½è²¼ä¸ŠåŠŸèƒ½å·²å•Ÿç”¨');
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCoordinatePaste);
  } else {
    initCoordinatePaste();
  }
  setTimeout(initCoordinatePaste, 500);
  setTimeout(initCoordinatePaste, 1000);
})();
</script>
<script>
const LS_KEY="html_saved_configs";
function collectFields(){
  const data={};
  document.querySelectorAll("input,select,textarea").forEach(el=>{
    if(el.id && el.id !== 'ls_save_name' && el.id !== 'ls_import' && el.id !== 'sort_order') {
      data[el.id]=el.value;
    }
  });
  return data;
}
function applyFields(data){
  Object.keys(data).forEach(id=>{
    const el=document.getElementById(id);
    if(el && id !== 'timestamp') el.value=data[id];
  });
  window.scrollTo({top:0,behavior:"smooth"});
  alert("âœ“ åƒæ•¸å·²æˆåŠŸå¡«å…¥");
  setTimeout(() => {
    if (typeof importFromGPS === 'function') {
      importFromGPS();
      console.log('âœ“ å·²åœ¨å¾Œå°è®€å–GPSåº§æ¨™åˆ°é«˜åº¦åœ–åˆ†é ');
    }
  }, 100);
}
function lsLoadTable(){
  const tb=document.getElementById("ls_table");
  if(!tb) return;
  tb.innerHTML="";
  const all=JSON.parse(localStorage.getItem(LS_KEY)||"{}");
  let entries = Object.entries(all);
  
  // å–å¾—æœå°‹é—œéµå­—
  const searchInput = document.getElementById("archive_search");
  const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : "";
  
  // å¦‚æœæœ‰æœå°‹é—œéµå­—ï¼Œé€²è¡Œéæ¿¾
  if(searchTerm) {
    entries = entries.filter(([name]) => name.toLowerCase().includes(searchTerm));
  }
  
  if(entries.length === 0){
    const noResultMsg = searchTerm ? "æ‰¾ä¸åˆ°ç¬¦åˆçš„å­˜æª”" : "å°šç„¡å·²ä¿å­˜çš„åƒæ•¸";
    tb.innerHTML=`<tr><td colspan='2' style='text-align:center; padding:16px; color:var(--muted);'>${noResultMsg}</td></tr>`;
    return;
  }
  const sortOrder = document.getElementById("sort_order")?.value || "time-new";
  if(sortOrder === "name-az"){
    entries.sort((a, b) => a[0].localeCompare(b[0], 'zh-Hant'));
  } else if(sortOrder === "name-za"){
    entries.sort((a, b) => b[0].localeCompare(a[0], 'zh-Hant'));
  } else if(sortOrder === "time-new"){
    entries.sort((a, b) => {
      const timeA = a[1].timestamp || 0;
      const timeB = b[1].timestamp || 0;
      return timeB - timeA;
    });
  } else if(sortOrder === "time-old"){
    entries.sort((a, b) => {
      const timeA = a[1].timestamp || 0;
      const timeB = b[1].timestamp || 0;
      return timeA - timeB;
    });
  }
  entries.forEach(([name, data])=>{
    const tr=document.createElement("tr");
    const dataStr = JSON.stringify(data).replace(/'/g, "\\'");
    const losStatus = data.losStatus || '--';
    let nameColor;
    if (losStatus === 'NLOS') {
      nameColor = '#e74c3c';
    } else if (losStatus === 'LOS') {
      nameColor = '#5ff0d5';
    } else {
      nameColor = '#ffffff';
    }
    tr.innerHTML=`
      <td style="padding:8px 8px 8px 4px; color:var(--title); font-weight:600; white-space:nowrap;">
        <span style="cursor:pointer; text-decoration:underline; color:${nameColor};" onclick='fillNameWithDate("${name.replace(/'/g, "\\'")}")'>${name}</span>
      </td>
      <td style="padding:4px 6px; text-align:center; white-space:nowrap;">
        <button style="background:none; border:none; padding:4px 6px; font-size:20px; cursor:pointer; color:#5ff0d5; line-height:1;" onclick='applyFields(${dataStr})' title="å¡«å…¥åƒæ•¸">ğŸ“‚</button>
        <button style="background:none; border:none; padding:4px 6px; font-size:20px; cursor:pointer; color:#ff6b6b; margin-left:4px; line-height:1;" onclick='lsDelete("${name}")' title="åˆªé™¤">ğŸ—‘ï¸</button>
      </td>`;
    tb.appendChild(tr);
  });
}
function updateNamePreview() {
  const input = document.getElementById("ls_save_name");
  const suffix = document.getElementById("ls_name_suffix");
  if (!input || !suffix) return;
  const userInput = input.value;
  const today = new Date();
  const rocYear = today.getFullYear() - 1911;
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  const dateStr = `_${rocYear}${month}${day}`;
  if (userInput) {
    suffix.textContent = dateStr;
  } else {
    suffix.textContent = '';
  }
}
function clearArchiveSearch() {
  const searchInput = document.getElementById("archive_search");
  if (searchInput) {
    searchInput.value = "";
    lsLoadTable();
  }
}
function fillNameWithDate(name) {
  let baseName = name;
  let previousName;
  do {
    previousName = baseName;
    baseName = baseName.replace(/_\d{6,7}/g, '');
    baseName = baseName.replace(/_[a-zA-Z]{1,3}\d{6,7}/g, '');
    baseName = baseName.replace(/\d{8}/g, '');
    baseName = baseName.replace(/\d{6,7}$/g, '');
    baseName = baseName.replace(/\s+/g, ' ').trim();
    baseName = baseName.replace(/_+$/g, '');
  } while (baseName !== previousName);
  const nameInput = document.getElementById("ls_save_name");
  if (nameInput) {
    nameInput.value = baseName;
    updateNamePreview();
    nameInput.focus();
    nameInput.setSelectionRange(baseName.length, baseName.length);
  }
  console.log(`âœ“ åŸå§‹åç¨±: ${name}`);
  console.log(`âœ“ ç§»é™¤æ—¥æœŸå¾Œ: ${baseName}`);
}
let currentLosStatus = '--';
function toggleLosStatus() {
  const btn = document.getElementById('los_toggle_btn');
  const nameContainer = document.getElementById('ls_name_container');
  const nameInput = document.getElementById('ls_save_name');
  if (currentLosStatus === '--') {
    currentLosStatus = 'LOS';
    btn.innerHTML = 'LOS';
    btn.style.background = 'linear-gradient(90deg, #3498db, #2980b9)';
    nameContainer.style.borderColor = '#3498db';
    nameInput.style.color = '#5ff0d5';
  } else if (currentLosStatus === 'LOS') {
    currentLosStatus = 'NLOS';
    btn.innerHTML = 'NLOS';
    btn.style.background = 'linear-gradient(90deg, #e74c3c, #c0392b)';
    nameContainer.style.borderColor = '#e74c3c';
    nameInput.style.color = '#e74c3c';
  } else {
    currentLosStatus = '--';
    btn.innerHTML = 'N/A';
    btn.style.background = 'linear-gradient(90deg, #95a5a6, #7f8c8d)';
    nameContainer.style.borderColor = '#ffffff';
    nameInput.style.color = '#ffffff';
  }
  console.log(`âœ“ LOSç‹€æ…‹åˆ‡æ›ç‚º: ${currentLosStatus}`);
}
function loadGpsNamesToArchive() {
  const nameA = document.getElementById('nameA').value.trim();
  const nameB = document.getElementById('nameB').value.trim();
  const inputElement = document.getElementById('ls_save_name');
  if (!nameA && !nameB) {
    alert('âŒ GPSåˆ†é çš„Aé»å’ŒBé»åœ°åéƒ½æ˜¯ç©ºçš„ï¼Œè«‹å…ˆå¡«å¯«åœ°å');
    return;
  }
  if (!nameA || !nameB) {
    alert('âš ï¸ åªæœ‰ä¸€å€‹åœ°åæœ‰å€¼ï¼Œå»ºè­°å¡«å¯«å®Œæ•´çš„Aé»å’ŒBé»åœ°å');
  }
  const combinedName = nameA && nameB ? `${nameA}â†”${nameB}` : (nameA || nameB);
  inputElement.value = combinedName;
  updateNamePreview();
  console.log(`âœ“ å·²è®€å–GPSåœ°å: ${combinedName}`);
}
function lsSave(){
  const inputElement = document.getElementById("ls_save_name");
  const userInput = inputElement.value.trim();
  if(!userInput){
    alert("âŒ è«‹è¼¸å…¥åç¨±");
    return;
  }
  const today = new Date();
  const rocYear = today.getFullYear() - 1911;
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  const dateStr = `_${rocYear}${month}${day}`;
  const fullName = userInput + dateStr;
  const all=JSON.parse(localStorage.getItem(LS_KEY)||"{}");
  const existingNames = Object.keys(all);
  let hasDuplicateBaseName = false;
  let duplicateFullName = '';
  for (let existingName of existingNames) {
    const baseName = existingName.replace(/_\d{6,7}$/g, '');
    if (baseName === userInput) {
      hasDuplicateBaseName = true;
      duplicateFullName = existingName;
      break;
    }
  }
  if (hasDuplicateBaseName) {
    const confirmMsg = `âš ï¸ å·²å­˜åœ¨ç›¸åŒåç¨±çš„æª”æ¡ˆï¼š\n\nã€Œ${duplicateFullName}ã€\n\næ˜¯å¦è¦è¦†è“‹æ­¤æª”æ¡ˆï¼Ÿ`;
    if (!confirm(confirmMsg)) {
      return;
    }
    delete all[duplicateFullName];
  }
  const saveData = collectFields();
  saveData.timestamp = Date.now();
  saveData.losStatus = currentLosStatus;
  all[fullName]=saveData;
  localStorage.setItem(LS_KEY,JSON.stringify(all));
  inputElement.value = "";
  updateNamePreview();
  currentLosStatus = '--';
  const btn = document.getElementById('los_toggle_btn');
  const nameContainer = document.getElementById('ls_name_container');
  btn.innerHTML = 'N/A';
  btn.style.background = 'linear-gradient(90deg, #95a5a6, #7f8c8d)';
  nameContainer.style.borderColor = '#ffffff';
  inputElement.style.color = '#ffffff';
  lsLoadTable();
  if (hasDuplicateBaseName) {
    alert("âœ“ åƒæ•¸å·²è¦†è“‹ä¿å­˜ï¼š" + fullName);
  } else {
    alert("âœ“ åƒæ•¸å·²ä¿å­˜ï¼š" + fullName);
  }
}
function lsDelete(name){
  if(!confirm("ç¢ºå®šè¦åˆªé™¤ã€Œ" + name + "ã€å—ï¼Ÿ")){
    return;
  }
  const all=JSON.parse(localStorage.getItem(LS_KEY)||"{}");
  delete all[name];
  localStorage.setItem(LS_KEY,JSON.stringify(all));
  lsLoadTable();
  alert("âœ“ å·²åˆªé™¤ï¼š" + name);
}
function lsExport(){
  const data = localStorage.getItem(LS_KEY)||"{}";
  const blob=new Blob([data],{type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  const date = new Date().toISOString().slice(0,10);
  a.download=`RFå·¥å…·ç®±backup_${date}.json`;
  a.click();
  alert("âœ“ JSON æª”æ¡ˆå·²åŒ¯å‡º");
}
function lsImport(e){
  const f=e.target.files[0];
  if(!f) return;
  const r=new FileReader();
  r.onload=()=>{
    try{
      JSON.parse(r.result);
      localStorage.setItem(LS_KEY,r.result);
      lsLoadTable();
      alert("âœ“ JSON æª”æ¡ˆå·²æˆåŠŸè®€å–");
    } catch(err){
      alert("âŒ æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹é¸æ“‡æœ‰æ•ˆçš„JSONæª”æ¡ˆ");
    }
  };
  r.readAsText(f);
  e.target.value = '';
}
document.addEventListener("DOMContentLoaded", () => {
  lsLoadTable();
  updateNamePreview();
});
</script>
<script>
(function(){
  window.__LOS_REFRACTION = false;
  function updateBtn(){
    const btn = document.getElementById('refBtn');
    if(!btn) return;
    btn.textContent = window.__LOS_REFRACTION ? 'ç›®å‰ï¼šå«å¤§æ°£æŠ˜å°„' : 'ç›®å‰ï¼šä¸å«å¤§æ°£æŠ˜å°„';
    btn.style.color = '#bb66ff';
  }
  window.toggleRefraction = function(){
    window.__LOS_REFRACTION = !window.__LOS_REFRACTION;
    updateBtn();
    window.calculateMaxLOS();
  };
  window.calculateMaxLOS = function(){
    const g1 = parseFloat(document.getElementById('los_g1')?.value) || 0;
    const h1 = parseFloat(document.getElementById('los_h1')?.value) || 0;
    const g2 = parseFloat(document.getElementById('los_g2')?.value) || 0;
    const h2 = parseFloat(document.getElementById('los_h2')?.value) || 0;
    let R = 6371000;
    if(window.__LOS_REFRACTION){
      R = R * 4 / 3;
    }
    const d1 = Math.sqrt(2 * R * (g1 + h1));
    const d2 = Math.sqrt(2 * R * (g2 + h2));
    const totalKm = (d1 + d2) / 1000;
    const out = document.getElementById('los_output');
    if(out){
      out.innerHTML =
        'æœ€å¤§é€šè¦–è·é›¢ï¼š<span class="result-value">' + totalKm.toFixed(2) + '</span> km<br>' +
        '(A:' + (d1/1000).toFixed(2) + ' km, B:' + (d2/1000).toFixed(2) + ' km)';
    }
  };
  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('refBtn');
    if(btn){
      btn.onclick = window.toggleRefraction;
    }
    updateBtn();
    window.calculateMaxLOS();
  });
})();
</script>
<div id="chartFullscreenOverlay" class="chart-fullscreen-overlay">
    <div class="chart-fullscreen-container">
        <button class="chart-fullscreen-close" onclick="closeChartFullscreen()">âœ•</button>
        <button class="chart-fullscreen-screenshot" onclick="generateChartImage()" title="ç”Ÿæˆå‰–é¢åœ–åœ–ç‰‡">ğŸ“·</button>
        <button class="chart-fullscreen-rotate-toggle" onclick="toggleLandscapeFullscreen()" title="å¼·åˆ¶æ©«å±å…¨ç•«é¢">â›¶</button>
        <button class="chart-fullscreen-info-toggle" onclick="toggleFullscreenInfo()" title="é–‹é—œè¨Šæ¯æ¡†èˆ‡é»ƒé»">â„¹ï¸</button>
        <button class="chart-fullscreen-obstruction-toggle" onclick="toggleObstructionColor()" title="åˆ‡æ›é®è”½ç·šé¡è‰²">ğŸš§</button>
        <button class="chart-fullscreen-map-toggle" onclick="openGoogleMapForYellowPoint()" title="åœ¨Googleåœ°åœ–ä¸­é–‹å•Ÿé»ƒé»ä½ç½®">ğŸ“</button>
        <button class="chart-fullscreen-end-obstruction" onclick="jumpToFirstObstructionFromStart()" title="è·³åˆ°è·é›¢èµ·é»æœ€è¿‘çš„é®è”½é»">â®</button>
        <button class="chart-fullscreen-max-obstruction" onclick="jumpToMaxObstruction()" title="è·³åˆ°æœ€å¤§é®è”½é»">â›°ï¸</button>
        <button class="chart-fullscreen-start-obstruction" onclick="jumpToFirstObstructionFromEnd()" title="è·³åˆ°è·é›¢çµ‚é»æœ€è¿‘çš„é®è”½é»">â­</button>
        <div class="chart-fullscreen-point-control">
            <button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:4px 10px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:26px; min-width:40px;" onclick="decrementSelectedPoint()">â—€</button>
            <input type="number" id="fullscreenPointInput" placeholder="é»" style="width: 80px; padding: 4px 6px; font-size:14px; color: #5ff0d5; background: rgba(0, 0, 0, 0.5); border-radius: 4px; border: 2px solid rgba(95, 240, 213, 0.3); text-align: center; height:26px; font-weight: bold;" oninput="updatePointFromFullscreenInput()">
            <button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:4px 10px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:26px; min-width:40px;" onclick="incrementSelectedPoint()">â–¶</button>
        </div>
        <div class="chart-fullscreen-canvas-wrapper">
            <canvas id="elevationChartFullscreen"></canvas>
        </div>
    </div>
</div>
</body></html>
<script>
let useRefraction = false;
function toggleRefraction(){
  useRefraction = !useRefraction;
  const btn = document.getElementById('refBtn');
  btn.innerText = useRefraction ? 'ç›®å‰ï¼šå«å¤§æ°£æŠ˜å°„' : 'ç›®å‰ï¼šä¸å«å¤§æ°£æŠ˜å°„';
  btn.style.color = '#bb66ff';
  calculateMaxLOS();
}
function calculateMaxLOS(){
  const g1 = parseFloat(document.getElementById('los_g1').value) || 0;
  const h1 = parseFloat(document.getElementById('los_h1').value) || 0;
  const g2 = parseFloat(document.getElementById('los_g2').value) || 0;
  const h2 = parseFloat(document.getElementById('los_h2').value) || 0;
  let R = 6371000;
  if(useRefraction){
    R = R * 4 / 3;
  }
  const d1 = Math.sqrt(2 * R * (g1 + h1));
  const d2 = Math.sqrt(2 * R * (g2 + h2));
  const dTotal = (d1 + d2) / 1000;
  document.getElementById('los_output').innerHTML =
    'æœ€å¤§é€šè¦–è·é›¢ï¼š<span class="result-value">' + dTotal.toFixed(2) + '</span> km<br>' +
    '(A:' + (d1/1000).toFixed(2) + ' km, B:' + (d2/1000).toFixed(2) + ' km)';
}
let elevationChart = null;
let elevationDataProvider = 'taiwan-dsm';
function initElevationTab() {
  const apiSelector = document.getElementById('elevationApiSelector');
  const nodataHandlingDiv = document.getElementById('nodataHandlingDiv');
  if (apiSelector) {
    if (apiSelector.value === 'taiwan-dsm' && nodataHandlingDiv) {
      nodataHandlingDiv.style.display = 'block';
    }
    apiSelector.addEventListener('change', (e) => {
      elevationDataProvider = e.target.value;
      console.log('å·²åˆ‡æ¢è‡³:', elevationDataProvider);
      if (nodataHandlingDiv) {
        if (e.target.value === 'taiwan-dsm') {
          nodataHandlingDiv.style.display = 'block';
        } else {
          nodataHandlingDiv.style.display = 'none';
        }
      }
    });
  }
}
async function fetchElevationData() {
  const sLat = parseFloat(document.getElementById('sLat')?.value);
  const sLng = parseFloat(document.getElementById('sLng')?.value);
  const eLat = parseFloat(document.getElementById('eLat')?.value);
  const eLng = parseFloat(document.getElementById('eLng')?.value);
  if (!sLat || !sLng || !eLat || !eLng) {
    showElevationStatus('âŒ è«‹å…ˆè¼¸å…¥Aé»å’ŒBé»åº§æ¨™', 'error');
    return;
  }
  showElevationStatus('â³ æ­£åœ¨è¼‰å…¥é«˜åº¦æ•¸æ“š...', 'loading');
  try {
    let elevationData = [];
    if (elevationDataProvider === 'openmeteo') {
      elevationData = await fetchElevationFromOpenMeteo(sLat, sLng, eLat, eLng);
    } else if (elevationDataProvider === 'astergdem') {
      elevationData = await fetchElevationFromAsterGdem(sLat, sLng, eLat, eLng);
    } else if (elevationDataProvider === 'usgs') {
      elevationData = await fetchElevationFromUSGS(sLat, sLng, eLat, eLng);
    }
    if (elevationData.length > 0) {
      drawElevationChart(elevationData);
      showElevationStatus('âœ“ é«˜åº¦æ•¸æ“šè¼‰å…¥æˆåŠŸ', 'success');
    } else {
      showElevationStatus('âŒ ç„¡æ³•ç²å–é«˜åº¦æ•¸æ“š', 'error');
    }
  } catch (error) {
    console.error('é«˜åº¦æ•¸æ“šç²å–å¤±æ•—:', error);
    showElevationStatus('âŒ æ•¸æ“šç²å–å¤±æ•—: ' + error.message, 'error');
  }
}
async function fetchElevationFromOpenMeteo(sLat, sLng, eLat, eLng) {
  try {
    const points = generatePathPoints(sLat, sLng, eLat, eLng, 100);
    const lats = points.map(p => p.lat).join(',');
    const lons = points.map(p => p.lng).join(',');
    const url = `https://open-meteo.com/api/v1/elevation?latitude=${lats}&longitude=${lons}`;
    const response = await fetch(url);
    if (!response.ok) throw new Error('Open-Meteo API è«‹æ±‚å¤±æ•—');
    const data = await response.json();
    return data.elevation.map((elev, idx) => ({
      distance: (idx / (data.elevation.length - 1)) * getDistance(sLat, sLng, eLat, eLng),
      elevation: elev || 0
    }));
  } catch (error) {
    console.error('Open-Meteo ç²å–å¤±æ•—:', error);
    throw error;
  }
}
async function fetchElevationFromAsterGdem(sLat, sLng, eLat, eLng) {
  try {
    const points = generatePathPoints(sLat, sLng, eLat, eLng, 100);
    const elevations = [];
    console.log('ä½¿ç”¨ ASTER GDEM æŸ¥è©¢é«˜åº¦æ•¸æ“š...');
    for (let point of points) {
      try {
        const fallbackUrl = `https://api.open-elevation.com/api/v1/lookup?locations=${point.lat},${point.lng}`;
        const response = await fetch(fallbackUrl);
        if (response.ok) {
          const data = await response.json();
          if (data.results && data.results.length > 0) {
            elevations.push(data.results[0].elevation || 0);
          } else {
            elevations.push(0);
          }
        }
        await new Promise(resolve => setTimeout(resolve, 50));
      } catch (error) {
        console.warn('ASTER GDEM æŸ¥è©¢å¤±æ•—:', error);
        elevations.push(0);
      }
    }
    const distance = getDistance(sLat, sLng, eLat, eLng);
    return elevations.map((elev, idx) => ({
      distance: (idx / (elevations.length - 1)) * distance,
      elevation: elev || 0
    }));
  } catch (error) {
    console.error('ASTER GDEM ç²å–å¤±æ•—:', error);
    throw error;
  }
}
async function fetchElevationFromUSGS(sLat, sLng, eLat, eLng) {
  try {
    const points = generatePathPoints(sLat, sLng, eLat, eLng, 50);
    const elevations = [];
    for (let point of points) {
      const url = `https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/getSamples?locations=[{"x":${point.lng},"y":${point.lat}}]&outSR=4326&f=json`;
      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        if (data.samples && data.samples.length > 0) {
          elevations.push(data.samples[0].value || 0);
        } else {
          elevations.push(0);
        }
      } else {
        elevations.push(0);
      }
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    return elevations.map((elev, idx) => ({
      distance: (idx / (elevations.length - 1)) * getDistance(sLat, sLng, eLat, eLng),
      elevation: elev
    }));
  } catch (error) {
    console.error('USGS ç²å–å¤±æ•—:', error);
    throw error;
  }
}
function generatePathPoints(sLat, sLng, eLat, eLng, pointCount) {
  const points = [];
  for (let i = 0; i < pointCount; i++) {
    const fraction = i / (pointCount - 1);
    const lat = sLat + (eLat - sLat) * fraction;
    const lng = sLng + (eLng - sLng) * fraction;
    points.push({ lat, lng });
  }
  return points;
}
function drawElevationChart(data) {
  const ctx = document.getElementById('elevationCanvas');
  if (!ctx) {
    console.error('æ‰¾ä¸åˆ° elevationCanvas å…ƒç´ ');
    return;
  }
  const labels = data.map(d => Math.round(d.distance).toString());
  const elevations = data.map(d => d.elevation);
  if (elevationChart) {
    elevationChart.destroy();
  }
  elevationChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: 'é«˜åº¦ (m)',
        data: elevations,
        borderColor: '#5ff0d5',
        backgroundColor: 'rgba(95, 240, 213, 0.1)',
        tension: 0.4,
        fill: true,
        borderWidth: 2,
        pointRadius: 3,
        pointBackgroundColor: 'transparent',
        pointBorderColor: 'transparent',
        pointHoverRadius: 6,
        pointHoverBackgroundColor: '#5ff0d5',
        pointHoverBorderColor: '#fff',
        pointHoverBorderWidth: 2
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          labels: { color: '#e8eef5', font: { size: 14 } }
        }
      },
      scales: {
        y: {
          ticks: { color: '#a8b3c3', font: { size: 12 } },
          grid: { color: 'rgba(255,255,255,0.05)' },
          title: { display: true, text: 'æµ·æ‹”é«˜åº¦ (m)', color: '#85c9ff' }
        },
        x: {
          ticks: { color: '#a8b3c3', font: { size: 12 }, maxRotation: 0, minRotation: 0 },
          grid: { color: 'rgba(255,255,255,0.05)' },
          title: { display: true, text: 'è·é›¢ (km)', color: '#85c9ff' }
        }
      }
    }
  });
}
function showElevationStatus(message, type) {
  const statusDiv = document.getElementById('elevationStatus');
  if (statusDiv) {
    statusDiv.textContent = message;
    statusDiv.className = 'elevation-status ' + type;
  }
}
document.addEventListener('DOMContentLoaded', () => {
  initElevationTab();
});

// ===== è—è‰²è¨Šæ¯æ¡†é»æ“Šäº‹ä»¶æ””æˆª =====
(function() {
  'use strict';
  
  // æ””æˆªtooltipçš„é»æ“Šäº‹ä»¶ï¼Œé˜²æ­¢å…¶å†’æ³¡åˆ°canvasè§¸ç™¼å°é»ƒé»æ›´æ–°
  document.addEventListener('click', function(e) {
    const tooltipEl = document.getElementById('chartjs-tooltip-fullscreen');
    if (!tooltipEl) return;
    
    // æª¢æŸ¥é»æ“Šæ˜¯å¦åœ¨tooltipå…§
    if (tooltipEl.contains(e.target) || tooltipEl === e.target) {
      console.log('é»æ“Šè—è‰²è¨Šæ¯æ¡†ï¼Œé˜»æ­¢äº‹ä»¶å†’æ³¡');
      e.stopPropagation();
      e.preventDefault();
    }
  }, true);
})();

// ===== æœ¬åœ° TIF æª”æ¡ˆè™•ç† =====
function toggleLocalFileUpload() {
  const apiSelector = document.getElementById('elevationApiSelector');
  const localFileDiv = document.getElementById('localFileUploadDiv');
  
  if (apiSelector && localFileDiv) {
    if (apiSelector.value === 'taiwan-dsm') {
      localFileDiv.style.display = 'block';
    } else {
      localFileDiv.style.display = 'none';
    }
  }
}

async function handleLocalTifFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const fileInfo = document.getElementById('localFileInfo');
  const clearBtn = document.getElementById('clearLocalTifBtn');
  const currentSourceText = document.getElementById('currentSourceText');
  
  fileInfo.textContent = 'ğŸ“‚ è¼‰å…¥ä¸­...';
  fileInfo.style.color = '#fbbf24';
  
  try {
    // æª¢æŸ¥æª”æ¡ˆé¡å‹
    if (!file.name.match(/\.(tif|tiff)$/i)) {
      throw new Error('è«‹é¸æ“‡ TIF æˆ– TIFF æ ¼å¼çš„æª”æ¡ˆ');
    }
    
    // è®€å–æª”æ¡ˆ
    const arrayBuffer = await file.arrayBuffer();
    
    // è¼‰å…¥ GeoTIFF å‡½å¼åº«ï¼ˆå¦‚æœå°šæœªè¼‰å…¥ï¼‰
    if (!window.GeoTIFF) {
      fileInfo.textContent = 'ğŸ“‚ è¼‰å…¥ GeoTIFF å‡½å¼åº«...';
      await loadGeoTIFFLibrary();
    }
    
    fileInfo.textContent = 'ğŸ“‚ è§£æ TIF æª”æ¡ˆ...';
    
    // è§£æ TIF æª”æ¡ˆ
    const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
    const image = await tiff.getImage();
    
    // å„²å­˜æª”æ¡ˆè³‡æ–™
    localTifFileData = {
      file: file,
      tiff: tiff,
      image: image,
      fileName: file.name,
      fileSize: (file.size / 1024 / 1024).toFixed(2) + ' MB'
    };
    
    // ğŸš€ å„ªåŒ–: åŒæ™‚å¿«å–åˆ°è¨˜æ†¶é«”
    cachedTiffData.local = tiff;
    cachedImageData.local = image;
    console.log('ğŸ’¾ æœ¬åœ° TIF æª”æ¡ˆå·²å¿«å–åˆ°è¨˜æ†¶é«”');
    
    // é¡¯ç¤ºæª”æ¡ˆè³‡è¨Š
    fileInfo.textContent = `âœ… å·²è¼‰å…¥: ${file.name} (${localTifFileData.fileSize})`;
    fileInfo.style.color = '#36c74d';
    clearBtn.style.display = 'inline-block';
    
    // æ›´æ–°ç•¶å‰ä½¿ç”¨ç‹€æ…‹
    if (currentSourceText) {
      currentSourceText.textContent = `ğŸ“± æœ¬åœ°æª”æ¡ˆ: ${file.name}`;
      currentSourceText.style.color = '#5ff0d5';
    }
    
    console.log('âœ… æœ¬åœ° TIF æª”æ¡ˆå·²è¼‰å…¥:', localTifFileData);
    
  } catch (error) {
    console.error('âŒ è¼‰å…¥ TIF æª”æ¡ˆå¤±æ•—:', error);
    fileInfo.textContent = 'âŒ è¼‰å…¥å¤±æ•—: ' + error.message;
    fileInfo.style.color = '#dc3545';
    localTifFileData = null;
    clearBtn.style.display = 'none';
    
    // æ¢å¾©é¡¯ç¤ºGitHubç‹€æ…‹
    if (currentSourceText) {
      currentSourceText.textContent = 'ğŸŒ GitHub ç·šä¸Šåœ–è³‡';
      currentSourceText.style.color = '#5ff0d5';
    }
  }
}

function clearLocalTifFile() {
  localTifFileData = null;
  
  // ğŸš€ å„ªåŒ–: æ¸…é™¤æœ¬åœ°æª”æ¡ˆå¿«å–
  clearTiffCache('local');
  
  document.getElementById('localTifFile').value = '';
  const fileInfo = document.getElementById('localFileInfo');
  fileInfo.textContent = '';
  document.getElementById('clearLocalTifBtn').style.display = 'none';
  
  // æ›´æ–°ç•¶å‰ä½¿ç”¨ç‹€æ…‹
  const currentSourceText = document.getElementById('currentSourceText');
  if (currentSourceText) {
    currentSourceText.textContent = 'ğŸŒ GitHub ç·šä¸Šåœ–è³‡';
    currentSourceText.style.color = '#5ff0d5';
  }
  
  console.log('å·²æ¸…é™¤æœ¬åœ° TIF æª”æ¡ˆ');
}

function useGithubTifFile() {
  // æ¸…é™¤æœ¬åœ°æª”æ¡ˆ
  clearLocalTifFile();
  
  const fileInfo = document.getElementById('localFileInfo');
  fileInfo.textContent = '';
  
  // æ›´æ–°ç•¶å‰ä½¿ç”¨ç‹€æ…‹
  const currentSourceText = document.getElementById('currentSourceText');
  if (currentSourceText) {
    currentSourceText.textContent = 'ğŸŒ GitHub ç·šä¸Šåœ–è³‡';
    currentSourceText.style.color = '#5ff0d5';
  }
  
  console.log('å·²åˆ‡æ›è‡³ GitHub ç·šä¸Šåœ–è³‡');
}

// åˆå§‹åŒ–æ™‚è¨­å®šé¡¯ç¤ºç‹€æ…‹
document.addEventListener('DOMContentLoaded', () => {
  toggleLocalFileUpload();
});

