<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>å®‰å…¨é€šè¨Šè·é›¢åˆ†æ - è²»æ¶…çˆ¾å€ä¿®æ­£ç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: sans-serif; background: #f4f7f9; padding: 20px; }
        .container { max-width: 1000px; margin: auto; background: white; padding: 25px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); }
        .input-row { display: grid; grid-template-columns: 1fr 1fr 100px 80px; gap: 10px; margin-bottom: 20px; }
        input { padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        button { background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        #log { background: #222; color: #adbac7; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; height: 120px; overflow-y: auto; margin-bottom: 20px; }
    </style>
</head>
<body>

<div class="container">
    <h2>ğŸ“¡ é€šè¨Šå‰–é¢åˆ†æ (è€ƒæ…®è²»æ¶…çˆ¾å€ & æ›²ç‡)</h2>
    <div class="input-row">
        <input type="text" id="posA" value="25.214458, 121.563209" placeholder="Aé» (ç·¯, ç¶“)">
        <input type="text" id="posB" value="24.499911, 121.087641" placeholder="Bé» (ç·¯, ç¶“)">
        <input type="number" id="freq" value="2400" placeholder="MHz">
        <input type="number" id="antH" value="5" placeholder="å¤©ç·š(m)">
        <button onclick="startAnalysis()">åˆ†æ</button>
    </div>
    
    <div id="log">è«‹ç¢ºèªé™„ä»¶ <b>taiwan_dsm_wgs84_cog.tif</b> å·²ä¸Šå‚³ä¸”é LFS ç‹€æ…‹ã€‚</div>
    
    <div style="height: 450px;">
        <canvas id="profileChart"></canvas>
    </div>
</div>

<script>
async function startAnalysis() {
    const log = document.getElementById('log');
    const filename = "taiwan_dsm_wgs84_cog.tif";
    log.innerHTML = `[${new Date().toLocaleTimeString()}] é–‹å§‹è®€å– COG æ•¸æ“š...<br>`;

    try {
        const tiff = await GeoTIFF.fromUrl(filename);
        const image = await tiff.getImage();
        const bbox = image.getBoundingBox(); // [minLon, minLat, maxLon, maxLat]
        const [w, h] = [image.getWidth(), image.getHeight()];

        const pA = document.getElementById('posA').value.split(',').map(v => parseFloat(v.trim()));
        const pB = document.getElementById('posB').value.split(',').map(v => parseFloat(v.trim()));
        const freq = parseFloat(document.getElementById('freq').value) / 1000; // è½‰ç‚º GHz
        const antH = parseFloat(document.getElementById('antH').value);

        // è·é›¢è¨ˆç®— (Haversine ç°¡åŒ–ç‰ˆ)
        const distKM = Math.sqrt(Math.pow(pA[0]-pB[0],2) + Math.pow(pA[1]-pB[1],2)) * 111.32;
        
        let terrain = [], los = [], safety = [], labels = [];
        const samples = 150;

        for (let i = 0; i <= samples; i++) {
            const r = i / samples;
            const lat = pA[0] + (pB[0] - pA[0]) * r;
            const lon = pA[1] + (pB[1] - pA[1]) * r;

            // 1. åº§æ¨™å°ä½ (COG é—œéµ)
            const x = Math.floor(((lon - bbox[0]) / (bbox[2] - bbox[0])) * w);
            const y = Math.floor(((bbox[3] - lat) / (bbox[3] - bbox[1])) * h);

            let elev = 0;
            if (x >= 0 && x < w && y >= 0 && y < h) {
                const raster = await image.readRasters({ window: [x, y, x + 1, y + 1] });
                elev = raster[0][0] > -500 ? raster[0][0] : 0;
            }

            // 2. åœ°çƒæ›²ç‡ä¿®æ­£ (Earth Curvature)
            const d1 = distKM * r;
            const d2 = distKM * (1 - r);
            const drop = (d1 * d2) / 12.742; // å…¬å°º

            // 3. è²»æ¶…çˆ¾åŠå¾‘ (Fresnel Zone)
            const f1 = 17.32 * Math.sqrt((d1 * d2) / (freq * distKM));

            terrain.push(elev + drop);
            labels.push(d1.toFixed(1));
            
            // è¦–è·ç·š (å‡è¨­ A, B é»å¤©ç·šé«˜åº¦)
            const lineH = (terrain[0] + antH) + ((elev + antH) - (terrain[0] + antH)) * r; // é€™è£¡ç°¡åŒ–è¨ˆç®—ï¼Œå¯¦éš›æœƒç”± render è™•ç†
            safety.push(f1);
        }

        render(labels, terrain, antH, safety);
        log.innerHTML += `âœ… åˆ†æå®Œæˆã€‚è·é›¢: ${distKM.toFixed(2)} km<br>`;
    } catch (err) {
        log.innerHTML += `<span style="color:red">âŒ éŒ¯èª¤: ${err.message}</span>`;
    }
}

function render(labels, terrain, antH, f1_array) {
    const ctx = document.getElementById('profileChart').getContext('2d');
    if (window.myChart) window.myChart.destroy();

    const startH = terrain[0] + antH;
    const endH = terrain[terrain.length - 1] + antH;
    
    const los = terrain.map((_, i) => startH + (endH - startH) * (i / (terrain.length - 1)));
    const fresnel60 = los.map((val, i) => val - (f1_array[i] * 0.6));

    window.myChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                { label: 'è¦–è· (LoS)', data: los, borderColor: '#f1c40f', pointRadius: 0, fill: false },
                { label: '60% è²»æ¶…çˆ¾å®‰å…¨ç·š', data: fresnel60, borderColor: '#e74c3c', borderDash: [5,5], pointRadius: 0, fill: false },
                { label: 'ä¿®æ­£åœ°å½¢ (å«æ›²ç‡)', data: terrain, backgroundColor: 'rgba(44, 62, 80, 0.7)', fill: true, pointRadius: 0 }
            ]
        },
        options: { 
            responsive: true, 
            maintainAspectRatio: false,
            scales: { x: { title: { display: true, text: 'è·é›¢ (km)' } }, y: { title: { display: true, text: 'æµ·æ‹”é«˜åº¦ (m)' } } }
        }
    });
}
</script>
</body>
</html>