<!doctype html><html lang="zh-Hant"><head><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"> <script>
/* è§£é™¤æ‰€æœ‰èˆŠ Service Workerï¼ˆPWA å¿«å–ä¾†æºï¼‰ */
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then(function(regs) {
    regs.forEach(function(reg) {
      reg.unregister();
    });
  });
}

/* åŠ ç‰ˆæœ¬åƒæ•¸ï¼Œå¼·åˆ¶ Chrome è¼‰å…¥æœ€æ–° HTML */
(function () {
  const VERSION = '20241214';
  if (!location.search.includes('v=')) {
    const sep = location.search ? '&' : '?';
    location.replace(
      location.pathname +
      location.search +
      sep + 'v=' + VERSION +
      location.hash
    );
  }
})();

// --- Link Budget Tx Power å–®ä½åˆ‡æ›è‡ªå‹•æ›ç®— ---
let link_tx_last_unit = 'w';
function setMaxEffectivePoints() {
    console.log('setMaxEffectivePoints() è¢«èª¿ç”¨');
    
    // ç²å–åº§æ¨™
    const sLatVal = document.getElementById('sLat').value;
    const sLngVal = document.getElementById('sLng').value;
    const eLatVal = document.getElementById('eLat').value;
    const eLngVal = document.getElementById('eLng').value;
    
    if (!sLatVal || !sLngVal || !eLatVal || !eLngVal) {
        alert('âŒ è«‹å…ˆè¼¸å…¥Aé»å’ŒBé»åº§æ¨™');
        return;
    }
    
    const sLat = parseFloat(sLatVal);
    const sLng = parseFloat(sLngVal);
    const eLat = parseFloat(eLatVal);
    const eLng = parseFloat(eLngVal);
    
    // é©—è­‰åº§æ¨™
    if (isNaN(sLat) || isNaN(sLng) || isNaN(eLat) || isNaN(eLng)) {
        alert('âŒ åº§æ¨™å€¼ç„¡æ•ˆ');
        return;
    }
    
    // è¨ˆç®—è·é›¢
    const distance = getDistance(sLat, sLng, eLat, eLng);
    
    // æœ€å¤§æœ‰æ•ˆé» = è·é›¢(km) Ã— 33.333333
    const maxEffectivePoints = Math.ceil(distance * 33.333333);
    
    // è¨­ç½®å–æ¨£é»æ•¸å€¼
    document.getElementById('samples').value = maxEffectivePoints;
    
    // æ›´æ–°æ‘˜è¦é¡¯ç¤º
    const summary = document.getElementById('summary');
    summary.innerHTML = `âœ“ å·²è¨­ç½®æœ€å¤§æœ‰æ•ˆé»æ•¸ï¼š<strong>${maxEffectivePoints}</strong> é»<br>
    <span style="font-size: 12px; color: var(--muted);">è·é›¢: ${distance.toFixed(2)} km | é»å¯†åº¦: 33.33é»/km</span>`;
    summary.style.color = '#27ae60';
    summary.style.background = 'rgba(39, 174, 96, 0.1)';
    
    console.log('æœ€å¤§æœ‰æ•ˆé»æ•¸è¨­ç½®ç‚º:', maxEffectivePoints, '(è·é›¢:', distance.toFixed(2), 'km)');
}


function swapLinkTxUnit() {
    const unitSel = document.getElementById('link_tx_power_unit');
    const input = document.getElementById('link_tx_power_input');
    const currentUnit = unitSel.value;
    const val = parseFloat(input.value);

    if (!isNaN(val) && input.value.trim() !== '') {
        const newVal = convertPower(val, link_tx_last_unit, currentUnit);
        if (!isNaN(newVal) && newVal !== Infinity && newVal !== -Infinity) {
            input.value = newVal.toFixed(3);
        }
    }
    link_tx_last_unit = currentUnit;
    calculateLinkBudget();
}

</script> <meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" /><title>è¨ˆç®—å·¥å…·</title><script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Google Maps JavaScript API (ç„¡éœ€API keyçš„é–‹ç™¼ç‰ˆæœ¬) -->
<script src="https://maps.googleapis.com/maps/api/js?v=3&callback=Function.prototype"></script>
<meta name="theme-color" content="#071026"><style> :root{ --bg-0:#050a16; --bg-1:#0b1526; --muted:#a8b3c3; --label:#85c9ff; --title:#ffe58f; --value:#5ff0d5; --accent1:#5ff0d5; --accent2:#79a8ff; --orange-border: #ffaa00; --glass: rgba(255,255,255,0.06); --shadow: 0 4px 12px rgba(0,0,0,0.40); font-size:24px; --gps-error-border: #dc3545; --rf-green-start: #36c74d; --rf-green-end: #1e8030; --rf-green-border: #1e8030; --red-clear: #dd4444; --purple-accent: #bb66ff; } *{box-sizing:border-box} body{ margin:0; padding:0; background:linear-gradient(180deg,var(--bg-0),var(--bg-1)); color:#e8eef5; font-family:Inter, 'Noto Sans TC', system-ui; line-height:1.3; } header{ padding: 0 10px; background-color: var(--bg-1); border-bottom: 1px solid rgba(255,255,255,0.08); height: 0; } h1{ display: none; } main{padding:6px; max-width:880px; margin:0 auto;} .card{ background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:10px; margin-bottom:6px; box-shadow:var(--shadow); border:1px solid rgba(255,255,255,0.03); } .gps-container .card { padding: 5px 8px; } .section-title{ color:var(--title); font-size:18px; font-weight:700; margin-bottom:4px; display:block; } .rf-header { margin-bottom: 6px; } .rf-header .section-title { color: var(--title); font-size: 18px; font-weight: 700; margin-bottom: 2px; display: block; } .unit-selector-row { display: flex; align-items: center; justify-content: flex-start; gap: 8px; padding: 4px 0; margin-bottom: 2px; } .unit-selector-row .unit-label { font-size: 15px; color: var(--label); margin-bottom: 0; font-weight: 700; } .form-grid{ display:grid; grid-template-columns:1fr 1fr; gap:5px; align-items:end; } label{ color:var(--label); font-size:15px; margin-bottom:1px; display:block; } input,select{ width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15); } .input-with-clear-rf { display: flex; align-items: center; position: relative; } .input-with-clear-rf input { flex-grow: 1; padding-right: 35px; } .clear-btn-rf { position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--red-clear); font-size: 18px; cursor: pointer; padding: 0 8px; line-height: 1; font-weight: bold; opacity: 0.8; z-index: 10; height: 100%; display: flex; align-items: center; } #unit, #displayMode { border: 1px solid var(--purple-accent) !important; color: var(--purple-accent) !important; background-color: rgba(187, 102, 255, 0.08) !important; width: auto !important; max-width: 120px !important; padding: 3px 6px !important; font-size: 15px !important; flex-shrink: 0; } .gps-container input[type="number"], .gps-container input[type="text"] { padding: 3px 5px; font-size: 14px; border: 1px solid rgba(255,255,255,0.2); } .controls{ margin-top:2px; display:flex; gap:5px; } .btn{ background:linear-gradient(90deg,var(--accent1),var(--accent2)); border:0; padding:8px 12px; border-radius:6px; font-weight:700; font-size:16px; color:#022; cursor:pointer; } .btn.ghost{ border:1px solid var(--accent2); background:transparent; color:#e8eef5; } .btn.clear{ background:var(--red-clear); color:white; border-radius:6px; } #rf-content + .btn-row .btn { background: linear-gradient(90deg, var(--rf-green-start), var(--rf-green-end)); color: #022; border: none; } #rf-content + .btn-row .btn.ghost { background: transparent; border: 1px solid var(--rf-green-border); color: #e8eef5; } #rf-content + .btn-row .btn.clear { background: var(--red-clear); color: white; border: none; } .btn-row{ display:flex; flex-wrap:nowrap; justify-content:stretch; align-items:center; gap:12px; width:100%; box-sizing:border-box; } .btn-row .btn{ flex:1 1 0%; text-align:center; white-space:nowrap; min-width:0; } #liveInputs{ margin-top:3px; font-size:14px; color:var(--muted); } table{ width:100%; border-collapse:collapse; margin-top:6px; font-size:16px; } thead th{ color:var(--label); padding:3px 3px; border-bottom:1px solid rgba(255,255,255,0.06); text-align:center; } tbody td{ padding:4px 3px; border-bottom:1px solid rgba(255,255,255,0.03); text-align:center; } .name{ color:#ffd369; font-weight:700; white-space:nowrap; } th:first-child, td:first-child{ width:32%; text-align:left; } .value, .percent{ color:var(--value); font-weight:800; font-variant-numeric:tabular-nums; } .small-note{ font-size:13px; margin-top:3px; color:var(--muted); } @media (max-width:640px){ .form-grid{grid-template-columns:1fr;} } .tabs{ display:flex; margin-bottom: 6px; overflow-x: auto; border-bottom: 1px solid rgba(255,255,255,0.06); } .tab-button{ flex-shrink: 0; padding: 6px 10px; margin: 0 2px; background: transparent; border: 0; color: var(--muted); font-size: 18px; cursor: pointer; font-weight: 600; border-radius: 8px 8px 0 0; transition: all 0.2s ease; } .tab-button.active{ background: var(--glass); color: var(--title); border-bottom: 2px solid var(--accent1); } .tab-content{ display: none; padding-top: 5px; } .tab-content.active{ display: block; } .gps-container { padding: 0; } .gps-tip { color: var(--label) !important; font-size: 13px !important; margin: 0 0 2px 0 !important; } .display-mode-container { margin-top: 3px; } .gps-ig { margin-bottom: 2px !important; padding: 3px 7px !important; border: 1px solid rgba(255,255,255,0.05); border-radius: 8px; background-color: rgba(255,255,255,0.02); } .gps-loc-header { margin-bottom: 2px !important; font-weight: bold; color: var(--title); font-size: 17px; display: flex; align-items: center; justify-content: space-between; } .gps-loc-header > div { display: flex; align-items: center; gap: 5px; } #nameA, #nameB { width: 144px !important; max-width: 144px !important; font-size: 14px !important; text-align: center; flex-shrink: 0; padding: 4px 6px !important; } .gps-loc-header span { color: var(--muted); font-size: 13px; flex-shrink: 0; } .gps-cg { padding: 2px !important; margin-bottom: 2px !important; border: 1px solid rgba(255,255,255,0.05); border-radius: 6px; } .gps-cl { font-weight: bold; color: var(--label); display: block; margin-bottom: 1px; font-size: 14px !important; } .gps-ddr { display: flex; align-items: center; margin-bottom: 0 !important; } .gps-ddr input { flex-grow: 1; text-align: right; padding: 4px 8px !important; font-size: 16px !important; } .gps-ddr span { color: var(--muted); font-size: 14px !important; margin-right: 4px; flex-shrink: 0; } .gps-dmsr { display: flex; align-items: center; justify-content: space-between; gap: 4px; margin-bottom: 0 !important; } .gps-dmsr input { padding: 4px 8px !important; font-size: 16px !important; } .gps-dmsf { display: flex; align-items: center; flex: 1; min-width: 0; } .gps-dmsf input { text-align: center; margin-right: 3px; max-width: none; flex-grow: 1; min-width: 30px; } .gps-dmsf:nth-child(1) input { flex: 2; } .gps-dmsf:nth-child(2) input { flex: 1.5; } .gps-dmsf:nth-child(3) input { flex: 2.5; } .gps-dmsr span { color: var(--muted); font-size: 14px !important; margin-right: 0; flex-shrink: 0; } .gps-er { display: flex; align-items: center; justify-content: flex-start; gap: 5px; margin-top: 2px !important; padding-top: 2px !important; border-top: 1px dashed rgba(255,255,255,0.08); flex-wrap: nowrap !important; } .gps-er label { font-size: 15px !important; flex-shrink: 0; color: var(--label); width: 120px; margin-right: 8px; } .gps-er input { text-align: right; flex-grow: 1.2 !important; padding: 4px 8px !important; font-size: 16px !important; min-width: 60px !important; max-width: 100px !important; } .gps-er > .control-group { display: flex; align-items: center; flex-shrink: 0; min-width: 0; margin-left: auto !important; } .gps-er .control-group span { font-size: 14px !important; flex-shrink: 0; color: var(--muted); margin-left: 4px; } .gps-cb { background: none; border: none; color: #ff6347; font-size: 18px; cursor: pointer; padding: 0 5px; line-height: 1; font-weight: bold; opacity: 0.9; margin: 0; flex-shrink: 0; } .gps-ddr .gps-cb { margin-left: auto; } .gps-er .control-group .gps-cb { margin-left: 5px !important; } #gpsRes { margin-top: 5px !important; padding: 8px !important; border: 2px solid var(--accent2); border-radius: 8px; background-color: rgba(121, 168, 255, 0.05); font-size: 16px !important; font-weight: 500; text-align: left; color: #e8eef5; } #gpsRes p { margin: 4px 0 !important; } .gps-label-title { color: var(--title); font-weight: 700; margin-right: 5px; } .v-dist, .v-bearing, .v-pitch-value { font-weight: 900 !important; font-size: 1.1em; color: var(--value) !important; } .display-mode-container { display: flex; align-items: center; justify-content: flex-start; gap: 8px; margin-top: 3px; } #displayMode { width: auto !important; max-width: 170px; flex-shrink: 0; } .display-mode-container label { display: none; } .display-mode-text { font-weight: 700; color: var(--label); font-size: 14px; flex-shrink: 0; } .results-card-border { border: 2px solid var(--accent2) !important; border-radius: 8px !important; background-color: rgba(121, 168, 255, 0.05) !important; } .orange-border-card { border: 2px solid var(--orange-border) !important; border-radius: 8px !important; background-color: rgba(255, 170, 0, 0.05) !important; }

/* æµæ°´ç‡ˆå‹•ç•«æ¨£å¼ */
@keyframes blink-dots {
    0%, 20% { content: ''; }
    40% { content: '.'; }
    60% { content: '..'; }
    80%, 100% { content: '...'; }
}

.loading-dots {
    color: #FFD700 !important;
    font-weight: bold;
    display: inline-block;
}

.loading-dots::after {
    content: '';
    animation: blink-dots 1.5s steps(4, end) infinite;
}

</style><link rel="manifest" href="manifest.json"><meta name="theme-color" content="#0a4cff">
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/Gps-Cable-Loss-Calculator/service-worker.js');
}
</script> <style> :root{ --bg-0:#050a16; --bg-1:#0b1526; --muted:#a8b3c3; --label:#85c9ff; --title:#ffe58f; --value:#5ff0d5; --accent1:#5ff0d5; --accent2:#79a8ff; --orange-border: #ffaa00; --red-clear: #dd4444; --purple-accent: #bb66ff; --glass: rgba(255,255,255,0.06); --shadow: 0 4px 12px rgba(0,0,0,0.40); font-size:22px; } *{box-sizing:border-box} body{ margin:0; padding:0; background:linear-gradient(180deg,var(--bg-0),var(--bg-1)); color:#e8eef5; font-family:Inter, 'Noto Sans TC', system-ui; line-height:1.3; } header{ padding: 0 10px; background-color: var(--bg-1); border-bottom: 1px solid rgba(255,255,255,0.08); height: 0; } h1{ display: none; } main{padding:6px; max-width:880px; margin:0 auto;} .card{ background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:10px; margin-bottom:6px; box-shadow:var(--shadow); border:1px solid rgba(255,255,255,0.03); } .section-header-with-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; } .section-header-with-controls .section-title { margin-bottom: 0; } .section-header-with-controls .btn-group { display: flex; gap: 5px; flex-shrink: 0; } .btn{ padding: 5px 8px; border-radius: 6px; font-weight: 700; font-size: 16px; color: #022; cursor: pointer; border: none; background: linear-gradient(90deg,var(--accent1),var(--accent2)); } .section-header-with-controls .btn { padding: 3px 6px; font-size: 14px; border-radius: 4px; white-space: nowrap; } .btn-reset { border: 1px solid var(--accent2); background: transparent; color: #e8eef5; } .btn-clear { background: var(--red-clear); color: white; border: none; } .section-title{ color:var(--title); font-size:17px; font-weight:700; margin-bottom:4px; display:block; } .rf-header { margin-bottom: 6px; } .los-point-title { color: var(--title); font-size: 1.1em; font-weight: 700; margin-top: 10px; margin-bottom: 5px; border-bottom: 1px dashed rgba(255,255,255,0.08); padding-bottom: 3px; } label{ color:var(--label); font-size:17px; margin-bottom:1px; display:block; } input,select{ width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15); } .input-with-clear { display: flex; align-items: center; gap: 5px; margin-bottom: 5px; } .input-with-clear input { flex-grow: 1; width: auto; } .clear-button { background: transparent; border: none; color: var(--red-clear); font-size:22px; font-weight: bold; cursor: pointer; padding: 5px 0; line-height: 1; width: 30px; flex-shrink: 0; border-radius: 4px; transition: background-color 0.2s; } .clear-button:hover { background-color: rgba(221, 68, 68, 0.2); } #power_unit, #matching_unit, #link_tx_power_unit { border: 1px solid var(--purple-accent) !important; color: var(--purple-accent) !important; background-color: rgba(187, 102, 255, 0.08) !important; width: 100% !important; max-width: none !important; padding: 5px 8px !important; font-size: 17px !important; flex-shrink: 0; } #power_unit, #link_tx_power_unit { margin-bottom: 8px; } .input-group-border { border: 2px solid var(--orange-border) !important; border-radius: 8px !important; background-color: rgba(255, 170, 0, 0.05) !important; padding: 10px 12px; margin-bottom: 8px; margin-top: 5px; } .input-group-border > :first-child { margin-top: 0 !important; } .input-group-border .input-with-clear { margin-bottom: 8px; } .input-group-border .input-with-clear:last-child { margin-bottom: 0; } .input-group-border .los-point-title { margin-top: 8px; } .input-group-border .los-point-title:first-child { margin-top: 0 !important; margin-bottom: 5px; } .los-input-container { display: block; gap: 0; margin-bottom: 0 !important; } .los-input-container .input-item { width: 100%; flex: none; min-width: auto; box-sizing: border-box; padding-bottom: 8px; border-bottom: 1px dotted rgba(255,255,255,0.05); margin-bottom: 8px; } .los-input-container .input-item:last-child { padding-bottom: 0; border-bottom: none; margin-bottom: 0; } .results-card-border { border: 2px solid var(--accent2) !important; border-radius: 8px !important; background-color: rgba(121, 168, 255, 0.05) !important; padding: 10px 12px; margin-top: 8px !important; } .result-value { color: var(--value); font-weight: 900; font-size: 1.1em; } .result-value-small { font-size: 1em !important; } .function-selector-container { margin-bottom: 10px; padding: 6px 8px; background: rgba(255,255,255,0.02); border-radius: 10px; box-shadow: var(--shadow); border: 1px solid rgba(255,255,255,0.03); } #function_selector { border: 1px solid var(--accent1) !important; color: var(--accent1) !important; background-color: rgba(95, 240, 213, 0.08) !important; font-weight: 700; font-size: 18px; margin-top: 4px; }
</style>
<style>
/* === Force dark mode on all browsers === */
html, body {
  background-color: #050a16 !important;
  color-scheme: dark;
}

/* === Select / option unified grey background === */
select {
  background-color: #2b2b2b !important;
  color: #e8eef5 !important;
  border: 1px solid #555 !important;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
}

select option {
  background-color: #3a3a3a !important;
  color: #ffffff !important;
}

/* Chrome / Edge / IE focus */
select:focus {
  outline: none;
  border-color: #888 !important;
}

/* Fix IE arrow */
select::-ms-expand {
  display: none;
}
</style>


<style>
/* === GPS A/B BOX NORMALIZATION FIX === */
.gps-ig {
  padding: 6px 8px !important;
  box-sizing: border-box !important;
}

.gps-ig .gps-cg,
.gps-ig .gps-er {
  margin-bottom: 4px !important;
}

.gps-ig .gps-er:last-child {
  margin-bottom: 0 !important;
}

#gps-content .gps-ig {
  width: 100% !important;
  min-width: 100% !important;
}

.gps-loc-header {
  padding-bottom: 2px !important;
}
</style>

<!-- çµ‚æ¥µCSSè¦†è“‹ - ç¢ºä¿paddingæ­£ç¢º -->
<style>
.gps-ig,
.gps-ig.orange-border-card,
div.gps-ig,
div.gps-ig.orange-border-card,
#gps-content .gps-ig,
#gps-content .gps-ig.orange-border-card,
#gps-content div.gps-ig,
#gps-content div.gps-ig.orange-border-card {
  padding: 10px 12px !important;
  padding-top: 10px !important;
  padding-bottom: 10px !important;
  padding-left: 12px !important;
  padding-right: 12px !important;
}
</style>

</head><body><div id="splash-screen"><div class="splash-content"><img src="1.png" alt="splash"><div class="splash-text">é˜¿è‰¯è£½_1141212</div></div></div><style> #splash-screen{
  position:fixed;
  inset:0;
  background:#000;
  display:flex;
  justify-content:center;
  align-items:center;
  z-index:99999;
}
.splash-content{
  position:absolute;
  inset:0;
}
#splash-screen img{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  width:auto;
  max-width:90vw;
  max-height:90vh;
}
.splash-text{
  position:absolute;
  right:16px;
  bottom:16px;
  font-size:14px;
  color:#fff;
  font-weight:700;
  letter-spacing:1px;
  opacity:.9;
}

/* GPSæ§åˆ¶å®¹å™¨éšæ˜¾è§„åˆ™ */
#gps-controls-container {
    display: block !important;
}
.tab-content:not(.active) #gps-controls-container {
    display: none !important;
}
.tab-content.active #gps-controls-container {
    display: block !important;
}

/* ========== GPS CONTROLS VISIBILITY RULES ========== */
/* è¿™äº›è§„åˆ™ç¡®ä¿GPSæŒ‰é’®åªåœ¨GPSåˆ†é¡µæ˜¾ç¤º */

/* éšè—GPSæŒ‰é’® - åœ¨éactiveåˆ†é¡µ */
.tab-content:not(.active) #gpsCalcBtn { 
    display: none !important; 
    visibility: hidden !important;
}

.tab-content:not(.active) #gpsResetBtn { 
    display: none !important; 
    visibility: hidden !important;
}

.tab-content:not(.active) #gpsClearBtn { 
    display: none !important; 
    visibility: hidden !important;
}

.tab-content:not(.active) .btn-row:has(#gpsCalcBtn) {
    display: none !important;
    visibility: hidden !important;
}

/* æ˜¾ç¤ºGPSæŒ‰é’® - åœ¨GPSåˆ†é¡µ(active) */
.tab-content.active #gpsCalcBtn { 
    display: inline-block !important; 
    visibility: visible !important;
    flex: 2.5 1 0% !important;
}

.tab-content.active #gpsResetBtn { 
    display: inline-block !important; 
    visibility: visible !important;
    flex: 2.5 1 0% !important;
}

.tab-content.active #gpsClearBtn { 
    display: inline-block !important; 
    visibility: visible !important;
    flex: 2.5 1 0% !important;
}

.tab-content.active .btn-row:has(#gpsCalcBtn) {
    display: block !important;
    visibility: visible !important;
}

/* gpsResæ˜¾ç¤ºè§„åˆ™ */
.tab-content.active #gpsRes {
    display: block !important;
    visibility: visible !important;
}

.tab-content:not(.active) #gpsRes {
    display: none !important;
    visibility: hidden !important;
}
</style> <script>
  setTimeout(() => {
    const splash = document.getElementById("splash-screen");
    splash.style.opacity = "0";
    splash.style.transition = "0.4s";
    setTimeout(() => splash.remove(), 400);
  }, 500);
</script> <header></header><main><div class="tabs"><button class="tab-button active" data-tab="rftool" onclick="showTab('rftool')">ğŸ“¡ RFå·¥å…·</button><button class="tab-button" data-tab="rf" onclick="showTab('rf')">ã€°ï¸ ç·šæ</button><button class="tab-button" data-tab="gps" onclick="showTab('gps')">ğŸŒ GPS</button><button class="tab-button" data-tab="elevation" onclick="showTab('elevation')">ğŸ“ˆ é«˜åº¦åœ–</button><button class="tab-button" data-tab="archive" onclick="showTab('archive')">ğŸ’¾ å­˜æª”</button></div><div id="rf-content" class="tab-content"><div class="rf-header"><div class="section-title">TIMES ç·šæè¨ˆç®—</div><div class="unit-selector-row"><label for="unit" class="unit-label">é•·åº¦å–®ä½ï¼š</label><select id="unit"><option value="m">å…¬å°º (m)</option><option value="ft">è‹±å°º (ft)</option></select></div></div><section class="card orange-border-card" style="margin-top: 6px;"><div class="form-grid"><div><label for="freq">é »ç‡ (MHz)</label><div class="input-with-clear-rf"><input id="freq" type="number" value="900" min="0" step="1"><button class="clear-btn-rf" onclick="clearRfInput('freq')">âœ–</button></div></div><div><label for="lenInput">é•·åº¦</label><div class="input-with-clear-rf"><input id="lenInput" type="number" value="10" min="0" step="0.01"><button class="clear-btn-rf" onclick="clearRfInput('lenInput')">âœ–</button></div></div></div><div id="liveInputs" class="small-note">è¼¸å…¥ä¸¦æŒ‰ã€Œè¨ˆç®—ã€æŸ¥çœ‹çµæœã€‚</div></section><div class="btn-row" style="margin-top: 6px; margin-bottom: 6px;"><button id="calc" class="btn" onclick="compute()">è¨ˆç®—</button><button id="reset" class="btn ghost" onclick="resetRf()">é è¨­</button><button id="clear" class="btn clear" onclick="clearRf()">æ¸…é™¤</button></div><section class="card results-card-border"><span class="section-title">è¨ˆç®—çµæœï¼ˆç”±å°åˆ°å¤§ï¼‰</span><div id="tableArea"></div></section></div><div id="gps-content" class="tab-content gps-container"><div class="card"><h2 class="section-title" style="margin-top: 0;">å…©é»GPS è·é›¢ã€æ–¹ä½è§’èˆ‡ä¿¯ä»°è§’è¨ˆç®—</h2><p class="gps-tip">è€ƒæ…®åœ°çƒæ›²ç‡èˆ‡é«˜åº¦å·® (WGS84)</p><div class="display-mode-container"><span class="display-mode-text">é¡¯ç¤ºæ ¼å¼</span><select id="displayMode" style="padding:6px;border-radius:6px;font-size:14px;"><option value="decimal">åº¦ â€” åé€²åˆ¶ (DD)</option><option value="dms">åº¦åˆ†ç§’ (DMS)</option></select></div></div><div class="gps-ig orange-border-card"><div class="gps-loc-header"> ğŸ“ åœ°é» A åº§æ¨™ <div style="display: flex; align-items: center; gap: 5px;"><input type="text" id="nameA" placeholder="åœ°å A" maxlength="5"><span>(åœ°å)</span><button class="gps-cb" onclick="clearNameOnly('A')">âœ–</button></div></div><div class="gps-cg"><span class="gps-cl">ç·¯åº¦ (Latitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="latA" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('latA')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="latA_deg" placeholder="åº¦" oninput="dmsToD('latA')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="latA_min" placeholder="åˆ†" oninput="dmsToD('latA')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="latA_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('latA')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('latA')">âœ–</button></div></div><div class="gps-cg"><span class="gps-cl">ç¶“åº¦ (Longitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="lonA" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('lonA')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="lonA_deg" placeholder="åº¦" oninput="dmsToD('lonA')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="lonA_min" placeholder="åˆ†" oninput="dmsToD('lonA')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="lonA_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('lonA')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('lonA')">âœ–</button></div></div><div class="gps-er"><label for="eleA">é«˜åº¦ (Elevation)</label><div style="position: relative; flex-grow: 1.2;"><input type="number" id="eleA" placeholder="è«‹è¼¸å…¥æ•¸å€¼" step="0.01"><span id="eleA-loading" style="position: absolute; top: 50%; left: 0; transform: translateY(-50%); color: #FFD700; font-weight: bold; display: none; pointer-events: none; padding: 4px 8px;"></span></div><div class="control-group"><span>å…¬å°º (m)</span><button class="gps-cb" onclick="clearElevation('A')">âœ–</button><button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 6px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink: 0; display: flex; align-items: center; justify-content: center; text-align: center; min-width: fit-content;" onclick="getElevationFromSRTM('A')">å–å¾—é«˜åº¦</button></div></div></div><div class="gps-ig orange-border-card"><div class="gps-loc-header"> ğŸ¯ åœ°é» B åº§æ¨™ <div style="display: flex; align-items: center; gap: 5px;"><input type="text" id="nameB" placeholder="åœ°å B" maxlength="5"><span>(åœ°å)</span><button class="gps-cb" onclick="clearNameOnly('B')">âœ–</button></div></div><div class="gps-cg"><span class="gps-cl">ç·¯åº¦ (Latitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="latB" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('latB')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="latB_deg" placeholder="åº¦" oninput="dmsToD('latB')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="latB_min" placeholder="åˆ†" oninput="dmsToD('latB')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="latB_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('latB')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('latB')">âœ–</button></div></div><div class="gps-cg"><span class="gps-cl">ç¶“åº¦ (Longitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="lonB" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('lonB')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="lonB_deg" placeholder="åº¦" oninput="dmsToD('lonB')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="lonB_min" placeholder="åˆ†" oninput="dmsToD('lonB')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="lonB_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('lonB')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('lonB')">âœ–</button></div></div><div class="gps-er"><label for="eleB">é«˜åº¦ (Elevation)</label><div style="position: relative; flex-grow: 1.2;"><input type="number" id="eleB" placeholder="è«‹è¼¸å…¥æ•¸å€¼" step="0.01"><span id="eleB-loading" style="position: absolute; top: 50%; left: 0; transform: translateY(-50%); color: #FFD700; font-weight: bold; display: none; pointer-events: none; padding: 4px 8px;"></span></div><div class="control-group"><span>å…¬å°º (m)</span><button class="gps-cb" onclick="clearElevation('B')">âœ–</button><button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 6px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink: 0; display: flex; align-items: center; justify-content: center; text-align: center; min-width: fit-content;" onclick="getElevationFromSRTM('B')">å–å¾—é«˜åº¦</button></div></div></div><div id="gps-controls-container"><div class="btn-row" style="margin-top: 5px; margin-bottom: 5px; gap: 12px; display: flex !important; width: 100% !important; justify-content: space-between !important;"><button id="gpsCalcBtn" class="btn" style="flex: 1 1 0% !important; min-width: 0 !important; width: 25% !important; box-sizing: border-box !important;" onclick="calculate()">è¨ˆç®—</button><button id="gpsSwapBtn" class="btn" style="flex: 1 1 0% !important; min-width: 0 !important; width: 25% !important; box-sizing: border-box !important; background: linear-gradient(90deg, #bb66ff, #9945ff) !important; color: #fff !important;" onclick="swapGpsCoordinates()">äº’æ›Aâ†”B</button><button id="gpsResetBtn" class="btn ghost" style="flex: 1 1 0% !important; min-width: 0 !important; width: 25% !important; box-sizing: border-box !important;" onclick="resetGps()">é è¨­</button><button id="gpsClearBtn" class="btn clear" style="flex: 1 1 0% !important; min-width: 0 !important; width: 25% !important; box-sizing: border-box !important;" onclick="clearAllGps()">æ¸…é™¤</button></div><div id="gpsRes"> é»æ“Šã€Œè¨ˆç®—ã€ä»¥é¡¯ç¤ºçµæœ </div></div></div><header></header><div class="tab-content active" id="rftool-content"><div class="rf-header"><div class="section-title">ğŸš€ ç¶œåˆ RFå·¥å…·</div></div><div class="function-selector-container"><label for="function_selector">é¸æ“‡é¡¯ç¤ºåŠŸèƒ½æ¨¡çµ„:</label><select id="function_selector" onchange="toggleSections()"><option value="ALL">ALL - é¡¯ç¤ºæ‰€æœ‰è¨ˆç®—å™¨</option><option value="power">1. åŠŸç‡è½‰æ› (dBm / W)</option><option value="matching">2. åŒ¹é…åº¦åƒæ•¸æ›ç®—</option><option value="sensitivity">3. ç³»çµ±éˆæ•åº¦ (Sensitivity) è¨ˆç®—</option><option value="los">4. é€šè¦–æœ€å¤§è·é›¢è¨ˆç®—</option><option value="fspl">5. è‡ªç”±ç©ºé–“æè€— (FSPL)</option><option value="linkbudget">6. é€šè¨Šæ¨¡æ“¬ (Link Budget)</option></select></div><section class="card section-item" id="section-power"><div class="section-header-with-controls"><div class="section-title">1. åŠŸç‡è½‰æ› (dBm / W)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-power')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-power')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="power_unit">é¸æ“‡è¼¸å…¥å–®ä½:</label><select id="power_unit" onchange="swapAndCalculate()"><option value="w">W</option><option value="dbm">dBm</option></select><label for="power_input">è¼¸å…¥æ•¸å€¼:</label><div class="input-with-clear"><input id="power_input" oninput="calculateDbmWNew()" placeholder="è¼¸å…¥æ•¸å€¼" type="number" value="1"/><button class="clear-button" onclick="clearAndRecalculate('power_input', 'calculateDbmWNew')">Ã—</button></div></div><div class="results-card-border" id="power_output_result">æ›ç®—çµæœ:</div></section><section class="card section-item" id="section-matching"><div class="section-header-with-controls"><div class="section-title">2. åŒ¹é…åº¦åƒæ•¸æ›ç®—</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-matching')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-matching')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="matching_unit">é¸æ“‡è¼¸å…¥åƒæ•¸:</label><select id="matching_unit" onchange="swapAndConvertMatching()"><option value="rl">å›æ³¢æè€— (Return Loss, RL) [dB]</option><option value="vswr">é§æ³¢æ¯” (VSWR)</option><option value="gamma">åå°„ä¿‚æ•¸ (V, Î“)</option><option value="refl_pct">åå°„åŠŸç‡ [%]</option><option value="pass_pct">é€šéåŠŸç‡ [%]</option></select><label for="matching_input_value" style="margin-top: 8px;">è¼¸å…¥æ•¸å€¼:</label><div class="input-with-clear"><input id="matching_input_value" oninput="calculateMatching()" placeholder="ä¾‹å¦‚: 20" type="number" value="20"/><button class="clear-button" onclick="clearAndRecalculate('matching_input_value', 'calculateMatching')">Ã—</button></div></div><div class="results-card-border" id="matching_output"> å›æ³¢æè€— (RL) [dB]: <span class="result-value" id="rl_val"></span><br/> é§æ³¢æ¯” (VSWR): <span class="result-value" id="vswr_val"></span><br/> åå°„ä¿‚æ•¸ (Vï¼ŒÎ“): <span class="result-value" id="gamma_val"></span><br/> åå°„åŠŸç‡ [%]: <span class="result-value" id="refl_percent"></span><br/> é€šéåŠŸç‡ [%]: <span class="result-value" id="pass_percent"></span></div></section><section class="card section-item" id="section-sensitivity"><div class="section-header-with-controls"><div class="section-title">3. ç³»çµ±éˆæ•åº¦ (Sensitivity) è¨ˆç®—</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-sensitivity')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-sensitivity')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="sensitivity_bw">è¨Šè™Ÿé »å¯¬ (BW) [MHz]:</label><div class="input-with-clear"><input id="sensitivity_bw" oninput="calculateSensitivity()" placeholder="ä¾‹å¦‚: 1 (1MHz)" type="number" value="1"/><button class="clear-button" onclick="clearAndRecalculate('sensitivity_bw', 'calculateSensitivity')">Ã—</button></div><label for="sensitivity_nf">é›œè¨ŠæŒ‡æ•¸ (Noise Figure, NF) [dB]:</label><div class="input-with-clear"><input id="sensitivity_nf" oninput="calculateSensitivity()" placeholder="ä¾‹å¦‚: 5" type="number" value="5"/><button class="clear-button" onclick="clearAndRecalculate('sensitivity_nf', 'calculateSensitivity')">Ã—</button></div><label for="sensitivity_sn">æ‰€éœ€è¨Šé›œæ¯” (S/N) [dB]:</label><div class="input-with-clear"><input id="sensitivity_sn" oninput="calculateSensitivity()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('sensitivity_sn', 'calculateSensitivity')">Ã—</button></div></div><div class="results-card-border" id="sensitivity_output">æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity):</div></section><section class="card section-item" id="section-los"><div class="section-header-with-controls"><div class="section-title">4. é€šè¦–æœ€å¤§è·é›¢è¨ˆç®— (åœ°çƒæ›²åº¦é®è”½)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-los')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-los')">æ¸…é™¤</button></div></div><div class="input-group-border"><div class="los-point-title">A é»</div><div class="los-input-container"><div class="input-item"><label for="los_g1">å¤©ç·šæ¶è¨­é»æ°´å¹³é¢é«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_g1" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 100" type="number" value="0"/><button class="clear-button" onclick="clearAndRecalculate('los_g1', 'calculateMaxLOS')">Ã—</button></div></div><div class="input-item"><label for="los_h1">å¤©ç·šé«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_h1" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('los_h1', 'calculateMaxLOS')">Ã—</button></div></div></div><div class="los-point-title">B é»</div><div class="los-input-container"><div class="input-item"><label for="los_g2">å¤©ç·šæ¶è¨­é»æ°´å¹³é¢é«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_g2" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 150" type="number" value="0"/><button class="clear-button" onclick="clearAndRecalculate('los_g2', 'calculateMaxLOS')">Ã—</button></div></div><div class="input-item"><label for="los_h2">å¤©ç·šé«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_h2" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 20" type="number" value="20"/><button class="clear-button" onclick="clearAndRecalculate('los_h2', 'calculateMaxLOS')">Ã—</button></div></div></div></div>
<div style="margin-top:6px;">
  <button class="btn ghost" onclick="toggleRefraction()" id="refBtn" style="color: #bb66ff;">ç›®å‰ï¼šä¸å«å¤§æ°£æŠ˜å°„</button>
</div>

<div class="results-card-border" id="los_output">æœ€å¤§é€šè¦–è·é›¢:</div></section><section class="card section-item" id="section-fspl"><div class="section-header-with-controls"><div class="section-title">5. è‡ªç”±ç©ºé–“æè€— (Free Space Path Loss, FSPL)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-fspl')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-fspl')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="fspl_freq">é »ç‡ (Frequency) [MHz]:</label><div class="input-with-clear"><input id="fspl_freq" oninput="calculateFSPL()" placeholder="ä¾‹å¦‚: 2400 (2.4 GHz)" type="number" value="2400"/><button class="clear-button" onclick="clearAndRecalculate('fspl_freq', 'calculateFSPL')">Ã—</button></div><label for="fspl_dist">è·é›¢ (Distance) [km]:</label><div class="input-with-clear"><input id="fspl_dist" oninput="calculateFSPL()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('fspl_dist', 'calculateFSPL')">Ã—</button></div></div><div class="results-card-border" id="fspl_output">è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL):</div></section><section class="card section-item" id="section-linkbudget"><div class="section-header-with-controls"><div class="section-title">6. é€šè¨Šæ¨¡æ“¬ (Link Budget)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-linkbudget')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-linkbudget')">æ¸…é™¤</button></div></div><div class="input-group-border"><div class="los-point-title" style="margin-top: 0;">é€šä¿¡åƒæ•¸</div><div class="los-input-container"><div class="input-item"><label for="link_freq_mhz">é »ç‡ (Frequency) [MHz]:</label><div class="input-with-clear"><input id="link_freq_mhz" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 2400 (2.4 GHz)" type="number" value="2400"/><button class="clear-button" onclick="clearAndRecalculate('link_freq_mhz', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_dist_km">è·é›¢ (Distance) [km]:</label><div class="input-with-clear"><input id="link_dist_km" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('link_dist_km', 'calculateLinkBudget')">Ã—</button></div></div></div><div class="los-point-title">ç™¼å°„ç«¯ (Tx)</div><label for="link_tx_power_unit">ç™¼å°„åŠŸç‡è¼¸å…¥å–®ä½:</label><select id="link_tx_power_unit" onchange="swapLinkTxUnit()"><option value="w">W</option><option value="dbm">dBm</option></select><div class="los-input-container"><div class="input-item"><label for="link_tx_power_input">ç™¼å°„åŠŸç‡ (Tx Power) [W/dBm]:</label><div class="input-with-clear"><input id="link_tx_power_input" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 1 (1W)" type="number" value="1"/><button class="clear-button" onclick="clearAndRecalculate('link_tx_power_input', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_tx_gain_dbi">å¤©ç·šå¢ç›Š (Tx Gain) [dBi]:</label><div class="input-with-clear"><input id="link_tx_gain_dbi" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 20" type="number" value="20"/><button class="clear-button" onclick="clearAndRecalculate('link_tx_gain_dbi', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_tx_loss_db">ç·šæ (Tx Loss) [dB]:</label><div class="input-with-clear"><input id="link_tx_loss_db" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 3 (3 dB)" type="number" value="3"/><button class="clear-button" onclick="clearAndRecalculate('link_tx_loss_db', 'calculateLinkBudget')">Ã—</button></div></div></div><div class="los-point-title">æ¥æ”¶ç«¯ (Rx)</div><div class="los-input-container"><div class="input-item"><label for="link_rx_gain_dbi">å¤©ç·šå¢ç›Š (Rx Gain) [dBi]:</label><div class="input-with-clear"><input id="link_rx_gain_dbi" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 20" type="number" value="20"/><button class="clear-button" onclick="clearAndRecalculate('link_rx_gain_dbi', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_rx_loss_db">ç·šæ (Rx Loss) [dB]:</label><div class="input-with-clear"><input id="link_rx_loss_db" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 2 (2 dB)" type="number" value="2"/><button class="clear-button" onclick="clearAndRecalculate('link_rx_loss_db', 'calculateLinkBudget')">Ã—</button></div></div></div></div><div class="results-card-border" id="linkbudget_output">æ¥æ”¶è¨Šè™Ÿå¼·åº¦:</div></section></div><div id="elevation-content" class="tab-content">
<div class="card">
<h2 class="section-title" style="margin-top: 0;">åœ°å½¢é®è”½åˆ†æ - è·¯å¾‘é«˜åº¦åœ–</h2>
<div class="orange-border-card" style="padding: 10px 12px; margin-bottom: 15px;">
<button class="btn" style="width:100%; background:linear-gradient(90deg,#79a8ff,#5ff0d5); margin-bottom: 10px;" onclick="importFromGPS()">ğŸ“ å¾GPSåˆ†é è®€å–åº§æ¨™</button>
<div style="display:grid; grid-template-columns:2fr 2fr 1.2fr; gap:5px; align-items:end; margin-bottom:10px;">
<div><label id="labelALat" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Aé»ç·¯åº¦</label><input type="number" id="sLat" value="25.0336" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label id="labelALng" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Aé»ç¶“åº¦</label><input type="number" id="sLng" value="121.5648" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">å¤©ç·šé«˜ (m)</label><input type="number" id="antennaHeightStart" value="3" step="0.1" min="0" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label id="labelBLat" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Bé»ç·¯åº¦</label><input type="number" id="eLat" value="25.1325" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label id="labelBLng" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Bé»ç¶“åº¦</label><input type="number" id="eLng" value="121.5065" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">å¤©ç·šé«˜ (m)</label><input type="number" id="antennaHeightEnd" value="3" step="0.1" min="0" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
</div>
<div style="grid-column: span 3; display: flex; gap: 10px; align-items: flex-end; margin-bottom: 8px;">
<div style="display: flex; align-items: center; gap: 5px; flex: 1;">
<label style="color:var(--label); font-size:15px; margin-bottom:0; display:block; flex-shrink:0;">å–æ¨£é»æ•¸é‡</label>
<input type="number" id="samples" value="40" min="2" max="200" style="flex: 1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);">
</div>
<button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:6px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; height:fit-content; flex-shrink:0;" onclick="setMaxEffectivePoints()">æœ€å¤§æœ‰æ•ˆé»</button>
</div>
<div style="display: flex; gap: 10px; align-items: flex-start;">
<div style="flex: 1; display: flex; flex-direction: column; gap: 3px;"><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">æœ€å°é«˜åº¦ (m)</label><div style="display: flex; gap: 3px;"><input type="number" id="minElevation" placeholder="è‡ªå‹•" style="flex: 1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"><button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="document.getElementById('minElevation').value=''; document.getElementById('minElevation').placeholder='è‡ªå‹•';">è‡ªå‹•</button></div></div>
<div style="flex: 1; display: flex; flex-direction: column; gap: 3px;"><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">æœ€å¤§é«˜åº¦ (m)</label><div style="display: flex; gap: 3px;"><input type="number" id="maxElevation" placeholder="è‡ªå‹•" style="flex: 1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"><button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="document.getElementById('maxElevation').value=''; document.getElementById('maxElevation').placeholder='è‡ªå‹•';">è‡ªå‹•</button></div></div>
</div>
</div>
<div style="margin-bottom: 12px; padding: 10px 8px; background: rgba(187, 102, 255, 0.08); border: 1px solid var(--purple-accent); border-radius: 6px;">
<label style="color: var(--label); font-size: 15px; font-weight: 700; display: block; margin-bottom: 6px;">é«˜åº¦è³‡æ–™ä¾†æºé¸æ“‡</label>
<select id="elevationApiSelector" style="width: 100%; padding: 6px 8px; font-size: 15px; color: var(--value); background: transparent; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15); cursor: pointer;">
<option value="open-elevation">ğŸ—» Open-Elevation SRTM (30m) - é è¨­</option>
<option value="openmeteo">ğŸŒ Open-Meteo API (90ç±³)</option>
<option value="astergdem">ğŸ”ï¸ ASTER GDEM v3 (30m)</option>
</select>
<span id="apiInfo" style="font-size: 12px; color: var(--muted); margin-top: 4px; display: block;"></span>
</div>
<button class="btn" style="background:linear-gradient(90deg,var(--accent1),var(--accent2)); border:0; padding:5px 8px; border-radius:6px; font-weight:700; font-size:16px; color:#022; cursor:pointer; width:100%; margin-bottom:15px;" onclick="runAnalysis()">ğŸŒ ç”Ÿæˆè·¯å¾‘å‰–é¢</button>
<div id="summary" style="margin:15px 0; padding:10px; background:rgba(121, 168, 255, 0.1); border-radius:6px; text-align:center; font-weight:bold; color:#79a8ff; border: 1px solid rgba(121, 168, 255, 0.3);">è«‹è¼¸å…¥åº§æ¨™ä¸¦åŸ·è¡Œ</div>
<div style="position: relative; height:300px; width:100%; margin-bottom:20px;">
<canvas id="elevationChart"></canvas>
</div>
<div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px; padding: 10px; background: rgba(121, 168, 255, 0.05); border-radius: 6px; border: 1px solid rgba(121, 168, 255, 0.2);">
<label style="color: var(--label); font-size: 15px; font-weight: 700; flex-shrink: 0;">é¸å®šä½ç½®ï¼š</label>
<input type="number" id="selectedPointIndex" placeholder="é»æ“Šåœ–è¡¨é¸æ“‡é»" style="flex: 1; padding: 6px 8px; font-size: 16px; color: var(--value); background: transparent; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15); text-align: center;" oninput="updatePointFromInput()">
<button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:6px 10px; border-radius:4px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="decrementSelectedPoint()">â¬‡</button>
<button class="btn" style="background: linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:6px 10px; border-radius:4px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="incrementSelectedPoint()">â¬†</button>
<button class="btn" style="background: linear-gradient(90deg, #ffd43b, #fab005); border:0; padding:6px 10px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="jumpToStartPoint()">èµ·é»</button>
<button class="btn" style="background: linear-gradient(90deg, #748ffc, #5c7cfa); border:0; padding:6px 10px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="jumpToEndPoint()">çµ‚é»</button>
</div>
<div style="display: flex; gap: 8px; align-items: center; justify-content: center; margin-bottom: 15px; padding: 10px; background: rgba(121, 168, 255, 0.05); border-radius: 6px; border: 1px solid rgba(121, 168, 255, 0.2);">
<button class="btn" style="background: linear-gradient(90deg, #ff6b6b, #ee5a5a); border:0; padding:6px 12px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0;" onclick="jumpToMinPoint()">æœ€ä½é»</button>
<button class="btn" style="background: linear-gradient(90deg, #51cf66, #37b24d); border:0; padding:6px 12px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0;" onclick="jumpToMaxPoint()">æœ€é«˜é»</button>
<button class="btn" style="background: linear-gradient(90deg, #4dabf7, #339af0); border:0; padding:6px 18px; border-radius:4px; font-weight:700; font-size:18px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0; min-width:50px;" onclick="jumpToLowerPoint()" title="è·³åˆ°æ›´ä½çš„é»">-</button>
<button class="btn" style="background: linear-gradient(90deg, #ff922b, #fd7e14); border:0; padding:6px 18px; border-radius:4px; font-weight:700; font-size:18px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0; min-width:50px;" onclick="jumpToHigherPoint()" title="è·³åˆ°æ›´é«˜çš„é»">+</button>
</div>
<div style="display: flex; gap: 8px; align-items: center; justify-content: center; margin-bottom: 15px; padding: 10px; background: rgba(255, 107, 107, 0.08); border-radius: 6px; border: 1px solid rgba(255, 107, 107, 0.3);">
<button class="btn" style="background: linear-gradient(90deg, #e03131, #c92a2a); border:0; padding:6px 14px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0;" onclick="jumpToMaxObstruction()">ä¸»é®è”½</button>
<button class="btn" style="background: linear-gradient(90deg, #fa5252, #e03131); border:0; padding:6px 14px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0;" onclick="jumpToFirstObstructionFromStart()">èµ·é»éšœç¤™</button>
<button class="btn" style="background: linear-gradient(90deg, #ff6b6b, #fa5252); border:0; padding:6px 14px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0;" onclick="jumpToFirstObstructionFromEnd()">çµ‚é»éšœç¤™</button>
</div>
<div id="map-container" style="margin-top:30px; text-align:center; display:none; padding:20px; border-top:2px dashed rgba(255,255,255,0.1);">
<div id="map-details" style="margin-bottom:15px; font-size:0.95em; color:#e8eef5; text-align:left;">è«‹é»æ“Šä¸Šæ–¹åœ–è¡¨çš„é»</div>
<iframe id="map-frame" style="border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.2); border:1px solid rgba(255,255,255,0.1); width:100%; height:450px;" src="" allowfullscreen loading="lazy"></iframe>
</div>

<!-- æ–°å¢ï¼šèµ·é»çµ‚é»è·¯å¾‘åœ°åœ– -->
<div id="route-map-container" style="margin-top:30px; text-align:center; display:none; padding:20px; border-top:2px dashed rgba(95, 240, 213, 0.3);">
<div style="margin-bottom:15px; font-size:1.1em; color:var(--title); font-weight:700;">
ğŸ“ èµ·é»çµ‚é»è·¯å¾‘åœ–
</div>
<div id="route-map-details" style="margin-bottom:15px; font-size:0.95em; color:#e8eef5; text-align:left;">
<strong><span style="color: #FFD700;">è·¯å¾‘è³‡è¨Š</span></strong><br>
<span style="color: #FFD700;">èµ·é»:</span> <span style="color: #5ff0d5;" id="route-start-info">-</span><br>
<span style="color: #FFD700;">çµ‚é»:</span> <span style="color: #5ff0d5;" id="route-end-info">-</span><br>
<span style="color: #FFD700;">ç›´ç·šè·é›¢:</span> <span style="color: #5ff0d5;" id="route-distance-info">-</span>
</div>
<div id="route-map" style="width:100%; height:450px; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.2); border:2px solid var(--accent1);"></div>
</div>
</div>
</div>

<!-- === Archive Tab Content === -->
<div id="archive-content" class="tab-content">
  <section class="card">
    <h3 class="section-title" style="margin-bottom:12px">ğŸ’¾ åƒæ•¸ä¿å­˜ / å‚™ä»½</h3>
    <div style="display:flex;gap:8px; margin-bottom:12px; align-items:center; flex-wrap:nowrap;">
      <input id="ls_save_name" placeholder="è‡ªè¨‚åç¨±" style="flex:1;min-width:150px; padding:8px 12px; font-size:16px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);">
      <button class="btn" onclick="lsSave()" style="padding:8px 16px; font-size:16px; white-space:nowrap; flex-shrink:0;">ä¿å­˜</button>
      <button class="btn ghost" onclick="lsExport()" style="padding:8px 16px; font-size:16px; white-space:nowrap; flex-shrink:0;">åŒ¯å‡º</button>
      <button class="btn ghost" onclick="document.getElementById('ls_import').click()" style="padding:8px 16px; font-size:16px; white-space:nowrap; flex-shrink:0;">è®€å–</button>
      <input id="ls_import" type="file" accept="application/json" style="display:none" onchange="lsImport(event)">
    </div>
    <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px; flex-wrap:nowrap;">
      <label style="color:var(--label); font-size:15px; font-weight:600; white-space:nowrap;">æ’åˆ—æ–¹å¼ï¼š</label>
      <select id="sort_order" onchange="lsLoadTable()" style="flex:1; padding:6px 10px; font-size:15px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);">
        <option value="time-new">æª”æ¡ˆåç¨±æ–°>èˆŠ</option>
        <option value="time-old">æª”æ¡ˆåç¨±èˆŠ>æ–°</option>
        <option value="name-az">æª”æ¡ˆåç¨±A>Z</option>
        <option value="name-za">æª”æ¡ˆåç¨±Z>A</option>
      </select>
    </div>
    <div style="overflow-x:auto;">
      <table style="width:100%; table-layout:fixed;">
        <thead>
          <tr>
            <th style="text-align:left; padding:8px;">åç¨±</th>
            <th style="text-align:center; padding:8px; width:200px;">æ“ä½œ</th>
          </tr>
        </thead>
        <tbody id="ls_table"></tbody>
      </table>
    </div>
  </section>
</div>

</main>
<script>
// æ‰€æœ‰è¨ˆç®—æ¨¡çµ„çš„ ID æ˜ å°„
const sectionIds = {
    'power': 'section-power',
    'matching': 'section-matching',
    'sensitivity': 'section-sensitivity',
    'los': 'section-los',
    'fspl': 'section-fspl',
    'linkbudget': 'section-linkbudget'
};

// --- æ–°å¢é è¨­/æ¸…é™¤åŠŸèƒ½ ---

// 1. é è¨­å€¼èˆ‡è¨ˆç®—å‡½æ•¸æ˜ å°„
const defaultValues = {
    // 1. åŠŸç‡è½‰æ› (dBm / W)
    'section-power': {
        'power_input': '1',
        'power_unit': 'w',
    },
    // 2. åŒ¹é…åº¦åƒæ•¸æ›ç®—
    'section-matching': {
        'matching_input_value': '20',
        'matching_unit': 'rl',
    },
    // 3. ç³»çµ±éˆæ•åº¦ (Sensitivity) è¨ˆç®—
    'section-sensitivity': {
        'sensitivity_bw': '1',
        'sensitivity_nf': '5',
        'sensitivity_sn': '10',
    },
    // 4. é€šè¦–æœ€å¤§è·é›¢è¨ˆç®—
    'section-los': {
        'los_g1': '0',
        'los_h1': '10',
        'los_g2': '0',
        'los_h2': '20',
    },
    // 5. è‡ªç”±ç©ºé–“æè€— (FSPL)
    'section-fspl': {
        'fspl_freq': '2400',
        'fspl_dist': '10',
    },
    // 6. é€šè¨Šæ¨¡æ“¬ (Link Budget)
    'section-linkbudget': {
        'link_tx_power_input': '1',
        'link_tx_power_unit': 'w',
        'link_tx_loss_db': '3',
        'link_tx_gain_dbi': '20',
        'link_dist_km': '10',
        'link_freq_mhz': '2400',
        'link_rx_gain_dbi': '20',
        'link_rx_loss_db': '2',
    }
};

const calculationFunctions = {
    'section-power': 'calculateDbmWNew',
    'section-matching': 'calculateMatching',
    'section-sensitivity': 'calculateSensitivity',
    'section-los': 'calculateMaxLOS',
    'section-fspl': 'calculateFSPL',
    'section-linkbudget': 'calculateLinkBudget',
};

/**
 * å–å¾—æŒ‡å®šå€å¡Šä¸­æ‰€æœ‰éœ€è¦æ§åˆ¶çš„è¼¸å…¥æ¬„ä½ (input, select)
 * @param {string} sectionId å€å¡Š ID
 * @returns {HTMLElement[]} å…ƒç´ é™£åˆ—
 */
function getSectionControls(sectionId) {
    const sectionEl = document.getElementById(sectionId);
    if (!sectionEl) return [];
    
    // é™åˆ¶åœ¨ .input-group-border å…§ï¼Œæ’é™¤ä¸»åŠŸèƒ½é¸æ“‡å™¨
    const inputGroup = sectionEl.querySelector('.input-group-border');
    if (!inputGroup) return [];

    // å–å¾—æ‰€æœ‰å…·æœ‰ ID çš„ input å’Œ select å…ƒç´ 
    return Array.from(inputGroup.querySelectorAll('input, select')).filter(el => el.id);
}

/**
 * å°‡æŒ‡å®šå€å¡Šæ‰€æœ‰æ•¸å€¼å›å¾©æˆé è¨­å€¼ (Reset)
 * @param {string} sectionId å€å¡Š ID
 */
function resetSection(sectionId) {
    const defaults = defaultValues[sectionId];
    if (defaults) {
        // è¿­ä»£é è¨­å€¼åˆ—è¡¨ï¼Œè¨­å®šå…ƒç´ å€¼
        for (const id in defaults) {
            const element = document.getElementById(id);
            if (element) {
                element.value = defaults[id];
                // ç¢ºä¿æ•¸å€¼è¼¸å…¥æ¬„ä½å¯ä»¥æ¥å—ç©ºå­—ä¸² (Clear)
                if(element.tagName === 'INPUT') element.value = defaults[id];
            }
        }
    }
    // åŸ·è¡Œè¨ˆç®—
    const calcFunc = calculationFunctions[sectionId];
    if (calcFunc && typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}

/**
 * æ¸…é™¤æŒ‡å®šå€å¡Šæ‰€æœ‰æ•¸å€¼ (Clear)
 * - è¼¸å…¥æ¬„ä½è¨­å®šç‚ºç©ºå­—ä¸² ''
 * - å–®ä½é¸æ“‡å™¨è¨­å®šå›é è¨­ functional default (èˆ‡ reset ç›¸åŒçš„å€¼)
 * @param {string} sectionId å€å¡Š ID
 */
function clearSection(sectionId) {
    const controls = getSectionControls(sectionId);
    const defaults = defaultValues[sectionId] || {}; // ç”¨æ–¼å–å¾— Select çš„é è¨­å€¼

    controls.forEach(element => {
        const id = element.id;
        if (element.tagName === 'INPUT') {
            element.value = ''; // æ¸…é™¤è¼¸å…¥æ¡†æ•¸å€¼
        } else if (element.tagName === 'SELECT') {
            // å–®ä½é¸æ“‡å™¨ (Select) æ‡‰è¨­å®šå›é è¨­åŠŸèƒ½å€¼ (é¿å…ç„¡æ•ˆé¸é …å°è‡´éŒ¯èª¤)
            if (defaults[id]) {
                element.value = defaults[id];
            } else {
                element.selectedIndex = 0; 
            }
        }
    });
    
    // åŸ·è¡Œè¨ˆç®—
    const calcFunc = calculationFunctions[sectionId];
    if (calcFunc && typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}
// --- çµæŸæ–°å¢ ---

// --- åŠŸèƒ½åˆ‡æ›å‡½æ•¸ --- 
function toggleSections() { 
    const selector = document.getElementById('function_selector'); 
    const selectedValue = selector.value; 
    const allSections = document.querySelectorAll('.section-item'); 
    allSections.forEach(section => { 
        const sectionKey = Object.keys(sectionIds).find(key => sectionIds[key] === section.id); 
        if (selectedValue === 'ALL') { 
            section.style.display = 'block'; 
        } else if (sectionKey === selectedValue) { 
            section.style.display = 'block'; 
        } else { 
            section.style.display = 'none'; 
        } 
    }); 
    // ç¢ºä¿åœ¨åˆ‡æ›æ™‚ï¼Œç•«é¢æœƒé‡æ–°è¨ˆç®—ä¸¦é¡¯ç¤ºçµæœ (å¦‚æœæ¨¡çµ„è¢«é¡¯ç¤º) 
    if (selectedValue === 'ALL' || selectedValue === 'power') calculateDbmWNew(); 
    if (selectedValue === 'ALL' || selectedValue === 'matching') calculateMatching(); 
    if (selectedValue === 'ALL' || selectedValue === 'sensitivity') calculateSensitivity(); 
    if (selectedValue === 'ALL' || selectedValue === 'los') calculateMaxLOS();
    if (selectedValue === 'ALL' || selectedValue === 'fspl') calculateFSPL();
    if (selectedValue === 'ALL' || selectedValue === 'linkbudget') calculateLinkBudget();
}

/**
 * å€‹åˆ¥è¼¸å…¥æ¬„ä½æ¸…é™¤ä¸¦é‡æ–°è¨ˆç®—
 * @param {string} inputId è¼¸å…¥æ¬„ä½ ID
 * @param {string} calcFunc è¨ˆç®—å‡½æ•¸åç¨±
 */
function clearAndRecalculate(inputId, calcFunc) {
    const inputElement = document.getElementById(inputId);
    if (inputElement) {
        inputElement.value = '';
    }
    if (typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}

// --- 1. åŠŸç‡è½‰æ› (dBm / W) ---
// è¼”åŠ©å‡½æ•¸ï¼šåŸ·è¡Œ dBm <-> W è½‰æ›
function convertPower(value, fromUnit, toUnit) {
    if (fromUnit === toUnit) return value;
    if (fromUnit === 'w' && toUnit === 'dbm') {
        // W to dBm: 10 * log10(P_W / 1mW) = 10 * log10(P_W * 1000)
        return 10 * Math.log10(value * 1000);
    } else if (fromUnit === 'dbm' && toUnit === 'w') {
        // dBm to W: 10^(P_dBm / 10) * 1mW = 10^(P_dBm / 10 - 3)
        return Math.pow(10, (value / 10) - 3);
    }
    return NaN;
}

// ç”¨æ–¼è¨˜éŒ„ä¸Šä¸€æ¬¡è¼¸å…¥çš„å–®ä½ï¼Œä»¥åœ¨åˆ‡æ›å–®ä½æ™‚é€²è¡Œæ•¸å€¼æ›ç®—
let power_conv_last_unit = 'w'; 

function calculateDbmWNew() {
    const input = document.getElementById('power_input');
    const unit = document.getElementById('power_unit').value;
    const output = document.getElementById('power_output_result');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color; // ä¸»è¦æ–‡å­—é¡è‰² (ç™½è‰²)

    const input_value = parseFloat(input.value);

    if (isNaN(input_value) || input.value.trim() === '') {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">è«‹è¼¸å…¥æ•¸å€¼</span>`;
        return;
    }
    
    // æª¢æŸ¥æ•¸å€¼ç¯„åœ
    if (unit === 'w' && input_value < 0) {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">åŠŸç‡ (W) å¿…é ˆ â‰¥ 0</span>`;
        return;
    }

    let result_value, result_unit;

    if (unit === 'w') {
        result_value = convertPower(input_value, 'w', 'dbm');
        result_unit = 'dBm';
        // é¡å¤–æª¢æŸ¥ dBm è½‰æ›æ˜¯å¦æœ‰æ•ˆ (åªæœ‰ 0 W æœƒæ˜¯ -Infinity)
        if (result_value === -Infinity) {
            output.innerHTML = `æ›ç®—çµæœ: <span class="result-value">-âˆ</span> <span style="color:${unit_color};">${result_unit}</span>`;
            return;
        }
    } else { // unit === 'dbm'
        result_value = convertPower(input_value, 'dbm', 'w');
        result_unit = 'W';
        // æª¢æŸ¥ W è½‰æ›æ˜¯å¦æœ‰æ•ˆ (æ¥µå°çš„æ•¸å€¼)
        if (result_value < 0) result_value = 0;
    }
    
    if (isNaN(result_value)) {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">è¼¸å…¥ç„¡æ•ˆ</span>`;
        return;
    } else {
        // è¼¸å‡ºæ•¸å€¼ï¼Œå–®ä½å¥—ç”¨ç™½è‰²
        output.innerHTML = `æ›ç®—çµæœ: <span class="result-value">${result_value.toFixed(3)}</span> <span style="color:${unit_color};">${result_unit}</span>`;
    }
    power_conv_last_unit = unit;
}

function swapAndCalculate() {
    const input = document.getElementById('power_input');
    const current_unit = document.getElementById('power_unit').value;
    const input_value = parseFloat(input.value);

    if (!isNaN(input_value) && input.value.trim() !== '') {
        const new_value = convertPower(input_value, power_conv_last_unit, current_unit);
        if (!isNaN(new_value)) {
            // è™•ç† 0 W è½‰æ›ç‚º -Infinity dBm çš„æƒ…æ³
            if (current_unit === 'dbm' && new_value === -Infinity) {
                // å¦‚æœå–®ä½åˆ‡æ›åˆ° dBm ä¸”åŸå€¼ç‚º 0 Wï¼Œä¸æ”¹è®Š input.valueï¼Œè®“ calculateDbmWNew è™•ç†è¼¸å‡º
            } else {
                input.value = new_value.toFixed(3);
            }
        } else {
             // è™•ç†è¼¸å…¥ç„¡æ•ˆå°è‡´çš„ NaNï¼Œä½†å¦‚æœåŸå€¼æ˜¯æœ‰æ•ˆçš„ï¼Œé€™è£¡ä¸æ‡‰æ¸…é™¤
        }
    }
    calculateDbmWNew();
}


// --- 2. åŒ¹é…åº¦è½‰æ› (å‹•æ…‹æ›ç®—é‚è¼¯) ---
let last_matching_unit = 'rl'; 

function getGammaFromValue(value, type) {
    if (type === 'rl') {
        if (value < 0) throw new Error("RL å¿…é ˆ â‰¥ 0 dB");
        return Math.pow(10, -value / 20);
    } else if (type === 'vswr') {
        if (value < 1) throw new Error("VSWR å¿…é ˆ â‰¥ 1");
        return (value - 1) / (value + 1);
    } else if (type === 'gamma') {
        if (value < 0 || value > 1) throw new Error("Î“ å¿…é ˆä»‹æ–¼ 0 åˆ° 1 ä¹‹é–“");
        return value;
    } else if (type === 'refl_pct') {
        if (value < 0 || value > 100) throw new Error("åå°„åŠŸç‡å¿…é ˆä»‹æ–¼ 0 åˆ° 100 ä¹‹é–“");
        return Math.sqrt(value / 100);
    } else if (type === 'pass_pct') {
        if (value < 0 || value > 100) throw new Error("é€šéåŠŸç‡å¿…é ˆä»‹æ–¼ 0 åˆ° 100 ä¹‹é–“");
        return Math.sqrt(1 - (value / 100));
    }
    return NaN;
}

function getValueFromGamma(gamma, type) {
    if (isNaN(gamma) || gamma === Infinity) return NaN;

    if (type === 'rl') {
        // -20 * log10(|Î“|)
        if (gamma === 0) return Infinity;
        // ç¢ºä¿è¼¸å…¥æ˜¯æ­£æ•¸ä»¥é¿å… Math.log10 éŒ¯èª¤
        return -20 * Math.log10(Math.abs(gamma));
    } else if (type === 'vswr') {
        // (1 + |Î“|) / (1 - |Î“|)
        if (gamma === 1) return Infinity;
        return (1 + Math.abs(gamma)) / (1 - Math.abs(gamma));
    } else if (type === 'gamma') {
        return Math.abs(gamma);
    } else if (type === 'refl_pct') {
        // |Î“|^2 * 100%
        return Math.abs(gamma)**2 * 100;
    } else if (type === 'pass_pct') {
        // (1 - |Î“|^2) * 100%
        return (1 - Math.abs(gamma)**2) * 100;
    }
    return NaN;
}

function swapAndConvertMatching() {
    const current_unit = document.getElementById('matching_unit').value;
    const input_element = document.getElementById('matching_input_value');
    const input_value = parseFloat(input_element.value);

    // åªæœ‰åœ¨è¼¸å…¥æ•¸å€¼æœ‰æ•ˆæ™‚æ‰å˜—è©¦æ›ç®—
    if (!isNaN(input_value) && input_element.value.trim() !== '') {
        let gamma_abs;
        try {
            // 1. å¾èˆŠå–®ä½æ›ç®—åˆ°çµ•å°å€¼åå°„ä¿‚æ•¸ |Î“|
            gamma_abs = getGammaFromValue(input_value, last_matching_unit);
            if (!isNaN(gamma_abs)) {
                // 2. å°‡ |Î“| æ›ç®—æˆæ–°å–®ä½çš„å€¼
                const new_value = getValueFromGamma(gamma_abs, current_unit);
                if (!isNaN(new_value) && new_value !== Infinity) {
                    // å¦‚æœæ–°å–®ä½æ˜¯ RLï¼Œä¿ç•™ 2 ä½å°æ•¸ï¼Œå…¶ä»–ä¿ç•™ 4 ä½å°æ•¸
                    const precision = (current_unit === 'rl' || current_unit === 'refl_pct' || current_unit === 'pass_pct') ? 2 : 4;
                    input_element.value = new_value.toFixed(precision);
                } else if (new_value === Infinity) {
                    input_element.value = '1'; // VSWR/RL ç„¡çª®å¤§æ™‚ï¼Œåå°„ä¿‚æ•¸ç‚º 1
                } else {
                    input_element.value = '';
                }
            } else {
                input_element.value = '';
            }
        } catch (error) {
             input_element.value = '';
        }
    }
    calculateMatching();
    last_matching_unit = current_unit;
}

function calculateMatching() {
    const input_type = document.getElementById('matching_unit').value;
    const input_element = document.getElementById('matching_input_value');
    const input_value = parseFloat(input_element.value);
    
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;

    const output_elements = {
        rl: document.getElementById('rl_val'),
        vswr: document.getElementById('vswr_val'),
        gamma: document.getElementById('gamma_val'),
        refl_pct: document.getElementById('refl_percent'),
        pass_pct: document.getElementById('pass_percent')
    };

    const empty_output = `<span style="color:${redColor};font-size:17px;">è«‹è¼¸å…¥æ•¸å€¼</span>`;

    // æ¸…ç©ºæ‰€æœ‰è¼¸å‡º
    Object.values(output_elements).forEach(el => el.innerHTML = '');

    if (isNaN(input_value) || input_element.value.trim() === '') {
        output_elements.rl.innerHTML = empty_output;
        return;
    }

    let gamma_abs;
    try {
        gamma_abs = getGammaFromValue(input_value, input_type);
    } catch (error) {
        output_elements.rl.innerHTML = `<span style="color:${redColor};font-size:17px;">${error.message}</span>`;
        return;
    }
    
    // è¼¸å‡ºæ›ç®—çµæœ
    const rl_val = getValueFromGamma(gamma_abs, 'rl');
    const vswr_val = getValueFromGamma(gamma_abs, 'vswr');
    const gamma_val = getValueFromGamma(gamma_abs, 'gamma');
    const refl_pct = getValueFromGamma(gamma_abs, 'refl_pct');
    const pass_pct = getValueFromGamma(gamma_abs, 'pass_pct');

    const formatOutput = (value, unit, precision=2) => {
        if (value === Infinity) return `<span class="result-value">âˆ</span> <span style="color:${unit_color};">${unit}</span>`;
        if (isNaN(value)) return `<span style="color:${redColor};font-size:17px;">è¨ˆç®—éŒ¯èª¤</span>`;
        return `<span class="result-value">${value.toFixed(precision)}</span> <span style="color:${unit_color};">${unit}</span>`;
    }

    output_elements.rl.innerHTML = formatOutput(rl_val, 'dB');
    output_elements.vswr.innerText = vswr_val === Infinity ? 'âˆ' : vswr_val.toFixed(3);
    output_elements.gamma.innerText = gamma_val.toFixed(4);
    output_elements.refl_pct.innerHTML = formatOutput(refl_pct, '%');
    output_elements.pass_pct.innerHTML = formatOutput(pass_pct, '%');

    last_matching_unit = input_type;
}

// --- 3. é€šä¿¡ç³»çµ±éˆæ•åº¦è¨ˆç®— ---
// è¼”åŠ©å¸¸æ•¸
const BOLTZMANN_K_J = 1.380649e-23; // J/K
const T_KELVIN = 290; // åƒè€ƒæº«åº¦ (290 K)
// é›œè¨Šåœ°æ¿ (Noise Floor) P_n (dBm) = -174 + 10 * log10(BW_Hz) + NF_dB
// P_n (dBm) = -174 + 10 * log10(BW_MHz * 10^6) + NF_dB
// P_n (dBm) = -174 + 10 * (log10(BW_MHz) + 6) + NF_dB
// P_n (dBm) = -174 + 10*log10(BW_MHz) + 60 + NF_dB
// P_n (dBm) = -114 + 10*log10(BW_MHz) + NF_dB

function calculateSensitivity() {
    const bw_mhz = parseFloat(document.getElementById('sensitivity_bw').value);
    const nf_db = parseFloat(document.getElementById('sensitivity_nf').value);
    const sn_db = parseFloat(document.getElementById('sensitivity_sn').value);
    const output = document.getElementById('sensitivity_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;

    if (isNaN(bw_mhz) || isNaN(nf_db) || isNaN(sn_db) || bw_mhz <= 0 || nf_db < 0) {
        output.innerHTML = `æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity): <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å€¼ (BW > 0, NF â‰¥ 0)</span>`;
        return;
    }

    // 1. è¨ˆç®—ç†±é›œè¨Šåœ°æ¿ (Noise Floor) P_n (dBm)
    // P_n (dBm) = -174 + 10 * log10(BW_Hz) + NF_dB
    // ç°¡åŒ–ç‚ºï¼š -114 + 10*log10(BW_MHz) + NF_dB
    const noise_floor_dbm = -114 + (10 * Math.log10(bw_mhz)) + nf_db;

    // 2. è¨ˆç®—éˆæ•åº¦ (Sensitivity)
    // Sensitivity (dBm) = P_n (dBm) + S/N (dB)
    const sensitivity_dbm = noise_floor_dbm + sn_db;

    output.innerHTML = `
        æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity): <span class="result-value">${sensitivity_dbm.toFixed(2)}</span> <span style="color:${unit_color};">dBm</span><br>
        <span class="result-value-small">ç†±é›œè¨Šåœ°æ¿ (Noise Floor) Pn: ${noise_floor_dbm.toFixed(2)} dBm</span>
    `;
}

// --- 4. é€šè¦–æœ€å¤§è·é›¢è¨ˆç®— (åœ°çƒæ›²åº¦é®è”½) ---
// è¼”åŠ©å¸¸æ•¸
const K_FACTOR = 4 / 3; // K=4/3 (ç­‰æ•ˆåœ°çƒåŠå¾‘å¸¸æ•¸)
const R_EARTH_KM = 6371; // åœ°çƒåŠå¾‘ (km)

function calculateMaxLOS() {
    // è®€å–è¼¸å…¥å€¼ (å¤©ç·šé«˜åº¦ H + åœ°å¹³é¢é«˜åº¦ G = çµ•å°é«˜åº¦ A)
    const g1 = parseFloat(document.getElementById('los_g1').value) || 0;
    const h1 = parseFloat(document.getElementById('los_h1').value) || 0;
    const g2 = parseFloat(document.getElementById('los_g2').value) || 0;
    const h2 = parseFloat(document.getElementById('los_h2').value) || 0;

    const output = document.getElementById('los_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;

    // æª¢æŸ¥é«˜åº¦æ˜¯å¦æœ‰æ•ˆ
    if (h1 < 0 || h2 < 0) {
        output.innerHTML = `æœ€å¤§é€šè¦–è·é›¢: <span style="color:${redColor};">å¤©ç·šé«˜åº¦å¿…é ˆ â‰¥ 0</span>`;
        return;
    }
    
    // çµ•å°é«˜åº¦ (m)
    const a1 = g1 + h1;
    const a2 = g2 + h2;
    
    // æª¢æŸ¥çµ•å°é«˜åº¦æ˜¯å¦æœ‰æ•ˆ
    if (a1 <= 0 || a2 <= 0) {
        output.innerHTML = `æœ€å¤§é€šè¦–è·é›¢: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (å¤©ç·šçµ•å°é«˜åº¦ > 0) æ•¸å€¼</span>`;
        return;
    }

    // ç­‰æ•ˆåœ°çƒåŠå¾‘ (km)
    const R_eff = K_FACTOR * R_EARTH_KM; 
    
    // æœ€å¤§é€šè¦–è·é›¢å…¬å¼ (Distance D_km) = sqrt(2 * R_eff * A_1 / 1000) + sqrt(2 * R_eff * A_2 / 1000)
    // é€™è£¡ A_1, A_2 æ˜¯çµ•å°é«˜åº¦ (m)ï¼Œæ‰€ä»¥é™¤ä»¥ 1000 è½‰æ›ç‚º km
    const d1_km = Math.sqrt(2 * R_eff * a1 / 1000);
    const d2_km = Math.sqrt(2 * R_eff * a2 / 1000);

    const max_los_km = d1_km + d2_km;

    output.innerHTML = `
        æœ€å¤§é€šè¦–è·é›¢: <span class="result-value">${max_los_km.toFixed(2)}</span> <span style="color:${unit_color};">km</span><br>
        <span class="result-value-small">Aé»è¦–è·: ${d1_km.toFixed(2)} km; Bé»è¦–è·: ${d2_km.toFixed(2)} km</span>
    `;
}

// --- 5. è‡ªç”±ç©ºé–“æè€— (Free Space Path Loss, FSPL) ---
// FSPL (dB) = 20 log10(d) + 20 log10(f) + 20 log10(4Ï€/c)
// FSPL (dB) = 32.44 + 20 * log10(f_MHz) + 20 * log10(d_km)
function calculateFSPL() {
    const freq_mhz = parseFloat(document.getElementById('fspl_freq').value);
    const dist_km = parseFloat(document.getElementById('fspl_dist').value);
    const output = document.getElementById('fspl_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;

    if (isNaN(freq_mhz) || isNaN(dist_km) || freq_mhz <= 0 || dist_km <= 0) {
        output.innerHTML = `è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL): <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (é »ç‡ > 0, è·é›¢ > 0) æ•¸å€¼</span>`;
        return;
    }

    // FSPL (dB) = 32.44 + 20 * log10(f_MHz) + 20 * log10(d_km)
    const fspl_db = 32.44 + (20 * Math.log10(freq_mhz)) + (20 * Math.log10(dist_km));
    
    output.innerHTML = `è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL): <span class="result-value">${fspl_db.toFixed(2)}</span> <span style="color:${unit_color};">dB</span>`;
}

// --- 6. é€šè¨Šæ¨¡æ“¬ (Link Budget) ---
function calculateLinkBudget() {
    // é€šä¿¡åƒæ•¸
    const freq_mhz = parseFloat(document.getElementById('link_freq_mhz').value);
    const dist_km = parseFloat(document.getElementById('link_dist_km').value);

    // Tx ç«¯åƒæ•¸
    const tx_power_input = parseFloat(document.getElementById('link_tx_power_input').value);
    const tx_power_unit = document.getElementById('link_tx_power_unit').value;
    const tx_loss_db = parseFloat(document.getElementById('link_tx_loss_db').value) || 0;
    const tx_gain_dbi = parseFloat(document.getElementById('link_tx_gain_dbi').value) || 0;
    
    // Rx ç«¯åƒæ•¸
    const rx_gain_dbi = parseFloat(document.getElementById('link_rx_gain_dbi').value) || 0;
    const rx_loss_db = parseFloat(document.getElementById('link_rx_loss_db').value) || 0;
    
    const output = document.getElementById('linkbudget_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;

    // æª¢æŸ¥åŸºæœ¬è¼¸å…¥æœ‰æ•ˆæ€§
    if (isNaN(freq_mhz) || isNaN(dist_km) || freq_mhz <= 0 || dist_km <= 0) {
        output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (é »ç‡ > 0, è·é›¢ > 0) æ•¸å€¼</span>`;
        return;
    }
    
    if (isNaN(tx_power_input) || (tx_power_unit === 'w' && tx_power_input < 0)) {
         output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ç™¼å°„åŠŸç‡</span>`;
         return;
    }

    // 1. è½‰æ›ç™¼å°„åŠŸç‡ç‚º dBm
    const tx_power_dbm = convertPower(tx_power_input, tx_power_unit, 'dbm');

    if (isNaN(tx_power_dbm)) {
         output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">ç™¼å°„åŠŸç‡ (W) å¿…é ˆ > 0</span>`;
         return;
    }

    // 2. è¨ˆç®— FSPL (è‡ªç”±ç©ºé–“æè€—)
    // FSPL (dB) = 32.44 + 20 * log10(f_MHz) + 20 * log10(d_km)
    const fspl_db = 32.44 + (20 * Math.log10(freq_mhz)) + (20 * Math.log10(dist_km));
    
    // 3. è¨ˆç®— Link Budget (æ¥æ”¶åŠŸç‡)
    // P_R (dBm) = P_T(dBm) - L_Tx + G_Tx - FSPL + G_Rx - L_Rx
    const rx_power_dbm = tx_power_dbm - tx_loss_db + tx_gain_dbi - fspl_db + rx_gain_dbi - rx_loss_db;
    
    // è¼¸å‡ºæ•¸å€¼
    output.innerHTML = `
        æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span class="result-value">${rx_power_dbm.toFixed(2)}</span> <span style="color:${unit_color};">dBm</span><br>
        <span style="font-size:14px;color:var(--muted);">
            è·¯å¾‘æè€— (Path Loss): ${fspl_db.toFixed(2)} dB (FSPL) + ${(tx_loss_db + rx_loss_db).toFixed(2)} dB (ç·šæ) = ${(fspl_db + tx_loss_db + rx_loss_db).toFixed(2)} dB<br>
            ç™¼å°„ EIRP: ${(tx_power_dbm - tx_loss_db + tx_gain_dbi).toFixed(2)} dBm
        </span>
    `;
}


// --- åˆå§‹åŒ–åŸ·è¡Œ ---
document.addEventListener('DOMContentLoaded', () => {
    // åˆå§‹è¨ˆç®—æ‰€æœ‰é¡¯ç¤ºçš„å€å¡Š
    toggleSections(); 
});
</script>  <script>
  // --- Tab åˆ‡æ›åŠŸèƒ½ ---
  function showTab(tabId) {
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

    // ä¿®æ­£: ä½¿ç”¨ data-tab å±¬æ€§é€²è¡Œæ›´ç©©å®šçš„é¸æ“‡
    const clickedButton = document.querySelector(`.tab-button[data-tab="${tabId}"]`);
    if(clickedButton) clickedButton.classList.add('active');
    
    const tabContent = document.getElementById(tabId + '-content');
    if(tabContent) tabContent.classList.add('active');

    // ç¢ºä¿åˆ‡æ›æ™‚åŸ·è¡Œè¨ˆç®—
    if (tabId === 'rf') {
      compute();
    } else if (tabId === 'gps') {
      calculate(); 
    }
  }

  // --- å°„é »ç·šè¨ˆç®—å™¨ (RF Calculator) JS ---
  const cables = [
    { name: "LMR-600", a: 0.07555, b: 0.00026 },
    { name: "TCOM-600", a: 0.080075, b: 0.000256 },
    { name: "LMR-600-UF", a: 0.09066, b: 0.000312 },
    { name: "LMR-400", a: 0.12229, b: 0.00026 },
    { name: "LMR-400-UF", a: 0.146748, b: 0.000312 },
    { name: "M17/RG214", a: 0.21, b: 0.00126 },
    { name: "M17/RG142", a: 0.368, b: 0.0012 },
    // ä¿®æ­£å¾Œçš„ç·šæ LSSB-RG214
    { name: "LSSB-RG214", a: 0.191365, b: 0.001895 },
    // æ–°å¢ç·šæ LSSB-RG58
    { name: "LSSB-RG58", a: 0.444971, b: 0.003370 }
  ];
  
  // *** æ–°å¢å…¨åŸŸè®Šæ•¸ä¾†è¿½è¹¤ä¸Šä¸€æ¬¡çš„å–®ä½é¸æ“‡ ***
  let lastUnit = 'm'; 
  const FT_PER_METER = 3.28084; // 1 å…¬å°º = 3.28084 è‹±å°º

  function calcAttenPer100ft(f,a,b){
    // è¡°æ¸›å…¬å¼: A = a * sqrt(f) + b * f
    return a * Math.sqrt(f) + b * f;
  }
  function ftFromLength(len,unit){
    return unit === "ft" ? len : len * FT_PER_METER;
  }
  
  // *** æ–°å¢é•·åº¦å–®ä½è½‰æ›åŠŸèƒ½ ***
  function convertLength() {
      const lenInput = document.getElementById("lenInput");
      let len = parseFloat(lenInput.value);
      const newUnit = document.getElementById("unit").value;

      if (isNaN(len) || len === 0) {
          lastUnit = newUnit;
          compute();
          return;
      }

      if (lastUnit === 'm' && newUnit === 'ft') {
          // å…¬å°º -> è‹±å°º
          len *= FT_PER_METER;
      } else if (lastUnit === 'ft' && newUnit === 'm') {
          // è‹±å°º -> å…¬å°º
          len /= FT_PER_METER;
      }

      // å°‡æ›ç®—çµæœå¯«å›è¼¸å…¥æ¬„ä½ï¼Œä¿ç•™å°æ•¸é»å¾Œ 2 ä½
      lenInput.value = len.toFixed(2); 
      lastUnit = newUnit; 
      compute();
  }

  function powerPassPercent(db){
    return Math.pow(10, -db / 10) * 100;
  }

  function compute(){
    const f = parseFloat(document.getElementById("freq").value) || 0;
    const len = parseFloat(document.getElementById("lenInput").value) || 0;
    const unit = document.getElementById("unit").value || "m";
    const ftLen = ftFromLength(len, unit); // é•·åº¦ (è‹±å°º)
    
    // è¨ˆç®—é•·åº¦ (å…¬å°º)
    const mLen = unit === "m" ? len : len / FT_PER_METER; 
    
    let alternateDisplay;

    if (unit === "m") {
        // ä¸»è¦é¡¯ç¤º: å…¬å°º (m)ã€‚è¼”åŠ©é¡¯ç¤º: è‹±å°º (ft)
        alternateDisplay = `(${ftLen.toFixed(2)} ft)`;
    } else { // unit === "ft"
        // ä¸»è¦é¡¯ç¤º: è‹±å°º (ft)ã€‚è¼”åŠ©é¡¯ç¤º: å…¬å°º (m)
        alternateDisplay = `(${mLen.toFixed(2)} m)`;
    }

    // *** é€™è£¡ä¿®æ”¹äº† liveInputs çš„é¡¯ç¤ºå…§å®¹ ***
    document.getElementById("liveInputs").innerText =
      `${f} MHz â€¢ ${len.toFixed(2)} ${unit} ${alternateDisplay}`;
      
    // æ›´æ–° lastUnitï¼Œç¢ºä¿ä¸‹æ¬¡åˆ‡æ›æ™‚çš„èµ·é»æ­£ç¢º
    lastUnit = unit; 

    const results = cables.map(c=>{
      const per100 = calcAttenPer100ft(f, c.a, c.b);
      const total = per100 * (ftLen / 100);

      const pass = powerPassPercent(total);
      const loss = 100 - pass;

      return {
        name: c.name,
        // ä¿ç•™åˆ°å°æ•¸é»å¾Œ 6 ä½é€²è¡Œè¨ˆç®—ï¼Œé¿å…ç´¯ç©èª¤å·®
        total: Number(total.toFixed(6)), 
        pass: pass,
        loss: loss
      };
    });

    results.sort((x,y)=> x.total - y.total);

    let html =
      "<table><thead><tr>" +
      "<th>ç·šæ</th>" +
      "<th>è¡°æ¸› (dB)</th>" +
      "<th>é€šéåŠŸç‡ (%)</th>" +
      "<th>è¡°æ¸›åŠŸç‡ (%)</th>" +
      "</tr></thead><tbody>";

    results.forEach(r=>{
      html += `
        <tr>
          <td class="name">${r.name}</td>
          <td class="value">${r.total.toFixed(3)}</td> 
          <td class="percent">${r.pass.toFixed(1)}</td>
          <td class="percent">${r.loss.toFixed(1)}</td>
        </tr>`;
    });

    html += "</tbody></table>";

    document.getElementById("tableArea").innerHTML = html;
  }

  // --- æ¸…é™¤å–®ä¸€ RF è¼¸å…¥æ¬„ä½åŠŸèƒ½ ---
  function clearRfInput(id) {
    document.getElementById(id).value = '';
    // æ¸…é™¤è¼¸å…¥å¾Œç«‹å³é‡æ–°è¨ˆç®—ä»¥æ›´æ–°çµæœè¡¨æ ¼
    compute(); 
  }
  
  // RF é è¨­æŒ‰éˆ•åŠŸèƒ½
  function resetRf(){
    document.getElementById("freq").value = 900;
    document.getElementById("lenInput").value = 10;
    document.getElementById("unit").value = "m";
    // ç¢ºä¿ lastUnit èˆ‡é è¨­å€¼åŒæ­¥
    lastUnit = 'm'; 
    compute();
  }

  // RF æ¸…é™¤æŒ‰éˆ•åŠŸèƒ½
  function clearRf(){
    document.getElementById("freq").value = "";
    document.getElementById("lenInput").value = "";
    // å‘¼å« compute() è™•ç† liveInputs å’Œ tableArea çš„æ›´æ–°
    document.getElementById("unit").value = "m"; // å–®ä½é è¨­ç‚º m
    compute(); 
  }
  
  // --- GPS è¨ˆç®—å™¨ (GPS Calculator) JS ---
  const R_KM = 6371; 
  const tRad = a => a * (Math.PI / 180); 
  const tDeg = r => r * (180 / Math.PI); 

  // DD to DMS è½‰æ›
  const dToDMS = (id) => {
    const ddInput = document.getElementById(id);
    const dd = parseFloat(ddInput.value);
    
    if (isNaN(dd) || ddInput.value.trim() === '') {
        ['deg', 'min', 'sec'].forEach(s => document.getElementById(id + '_' + s).value = '');
        return;
    }
    
    const absDD = Math.abs(dd);
    const deg = Math.floor(absDD);
    
    // è¨ˆç®—å‰©é¤˜çš„å°æ•¸éƒ¨åˆ† (åˆ†)
    let minFloat = (absDD - deg) * 60;
    const min = Math.floor(minFloat);
    
    // è¨ˆç®—å‰©é¤˜çš„å°æ•¸éƒ¨åˆ† (ç§’)
    let sec = (minFloat - min) * 60;
    
    // ä¿®æ­£ï¼šç§’æ•¸å››æ¨äº”å…¥åˆ°å°æ•¸é»å¾Œå…©ä½ (toFixed(2) æœƒè‡ªå‹•å››æ¨äº”å…¥)
    sec = Number(sec.toFixed(2)); 

    let finalMin = min;
    let finalSec = sec;
    let finalDeg = deg;

    // è™•ç†ç§’æ•¸é€²ä½åˆ°åˆ†
    if (finalSec >= 60) {
      finalMin += Math.floor(finalSec / 60);
      finalSec = finalSec % 60;
      // ç¢ºä¿ finalSec ä»ä¿æŒå…©ä½å°æ•¸
      finalSec = Number(finalSec.toFixed(2));
    }
    
    // è™•ç†åˆ†é˜é€²ä½åˆ°åº¦
    if (finalMin >= 60) {
      finalDeg += Math.floor(finalMin / 60);
      finalMin = finalMin % 60;
    }

    document.getElementById(id + '_deg').value = (dd < 0 ? -finalDeg : finalDeg);
    document.getElementById(id + '_min').value = finalMin;
    // ä¿®æ­£ï¼šç¢ºä¿ç§’æ•¸é¡¯ç¤ºç‚ºå…©ä½å°æ•¸ (å¦‚ 24.40)
    document.getElementById(id + '_sec').value = finalSec.toFixed(2);
  };

  // DMS to DD è½‰æ›
  const dmsToD = (id) => {
    const d = parseFloat(document.getElementById(id + '_deg').value);
    const m = parseFloat(document.getElementById(id + '_min').value) || 0;
    const s = parseFloat(document.getElementById(id + '_sec').value) || 0;
    
    if (isNaN(d) && !m && !s) { document.getElementById(id).value = ''; return; }
    
    const sign = (d < 0) ? -1 : 1;
    // ç¢ºä¿åº¦/åˆ†/ç§’éƒ½æ˜¯æ­£æ•¸å†é€²è¡Œè¨ˆç®—ï¼Œæœ€å¾Œæ‡‰ç”¨ç¬¦è™Ÿ
    const dd = sign * (Math.abs(d) + Math.abs(m) / 60 + Math.abs(s) / 3600);
    if (!isNaN(dd)) { 
      document.getElementById(id).value = dd.toFixed(6); // DMS è¼¸å…¥æ™‚ï¼ŒDD æ¬„ä½å¼·åˆ¶æ ¼å¼åŒ–
    } else { 
      document.getElementById(id).value = ''; 
    }
  };
  
  // æ¸…é™¤å–®çµ„åº§æ¨™ (ç·¯åº¦/ç¶“åº¦) - åƒ…æ¸…é™¤åº§æ¨™
  const clearCoord = (idPrefix) => {
    document.getElementById(idPrefix).value = '';
    ['deg', 'min', 'sec'].forEach(s => document.getElementById(idPrefix + '_' + s).value = '');
    calculate();
  };

  // æ¸…é™¤é«˜åº¦è¼¸å…¥æ¬„ä½
  const clearElevation = (suffix) => {
    document.getElementById('ele' + suffix).value = '';
    calculate();
  };
  
  // *** æ–°å¢: åªæ¸…é™¤åœ°åæ¬„ä½ ***
  const clearNameOnly = (suffix) => {
    document.getElementById('name' + suffix).value = '';
  };

  // æ¸…é™¤ A/B é»æ‰€æœ‰æ¬„ä½ (åœ°å, ç·¯åº¦, ç¶“åº¦, é«˜åº¦) - ä¾› clearAllGps å…§éƒ¨ä½¿ç”¨
  const clearAllCoord = (suffix) => {
    const latPrefix = 'lat' + suffix;
    const lonPrefix = 'lon' + suffix;

    document.getElementById('name' + suffix).value = '';

    document.getElementById(latPrefix).value = '';
    ['deg', 'min', 'sec'].forEach(s => document.getElementById(latPrefix + '_' + s).value = '');

    document.getElementById(lonPrefix).value = '';
    ['deg', 'min', 'sec'].forEach(s => document.getElementById(lonPrefix + '_' + s).value = '');

    document.getElementById('ele' + suffix).value = '';
    
    calculate();
  };

  // GPS é è¨­æŒ‰éˆ•åŠŸèƒ½
  const resetGps = () => {
    document.getElementById('latA').value = '24.164547'; 
    document.getElementById('lonA').value = '120.641258'; 
    document.getElementById('eleA').value = '50'; 
    document.getElementById('nameA').value = 'åŒ—ä¸ƒè·¯'; 
    document.getElementById('latB').value = '23.877521'; 
    document.getElementById('lonB').value = '120.360578'; 
    document.getElementById('eleB').value = '2000'; 
    document.getElementById('nameB').value = 'ç«ç‡’å'; 
    
    // åŸ·è¡Œè½‰æ›å’Œè¨ˆç®— (ç¢ºä¿ DMS æ¬„ä½ä¹ŸåŒæ­¥)
    const mode = document.getElementById('displayMode').value;
    if (mode === 'dms') {
        dToDMS('latA'); dToDMS('lonA'); dToDMS('latB'); dToDMS('lonB');
    } 
    
    calculate(); 
  };

  // GPS åº§æ¨™äº’æ›åŠŸèƒ½ (äº¤æ› A å’Œ B çš„æ‰€æœ‰è³‡æ–™)
  const swapGpsCoordinates = () => {
    // å–å¾— A é»çš„æ‰€æœ‰è³‡æ–™
    const tempNameA = document.getElementById('nameA').value;
    const tempLatA = document.getElementById('latA').value;
    const tempLonA = document.getElementById('lonA').value;
    const tempEleA = document.getElementById('eleA').value;
    
    // å–å¾— B é»çš„æ‰€æœ‰è³‡æ–™
    const tempNameB = document.getElementById('nameB').value;
    const tempLatB = document.getElementById('latB').value;
    const tempLonB = document.getElementById('lonB').value;
    const tempEleB = document.getElementById('eleB').value;
    
    // äº¤æ›åœ°å
    document.getElementById('nameA').value = tempNameB;
    document.getElementById('nameB').value = tempNameA;
    
    // äº¤æ›åé€²åˆ¶åº§æ¨™
    document.getElementById('latA').value = tempLatB;
    document.getElementById('lonA').value = tempLonB;
    document.getElementById('eleA').value = tempEleB;
    
    document.getElementById('latB').value = tempLatA;
    document.getElementById('lonB').value = tempLonA;
    document.getElementById('eleB').value = tempEleA;
    
    // åŒæ­¥æ›´æ–° DMS æ¬„ä½
    const mode = document.getElementById('displayMode').value;
    if (mode === 'dms') {
        dToDMS('latA');
        dToDMS('lonA');
        dToDMS('latB');
        dToDMS('lonB');
    }
    
    console.log('å·²äº¤æ› A å’Œ B çš„åº§æ¨™è³‡æ–™');
  };

  // GPS æ¸…é™¤æŒ‰éˆ•åŠŸèƒ½ (å…¨éƒ¨æ¸…é™¤)
  const clearAllGps = () => {
    clearAllCoord('A');
    clearAllCoord('B');
    // æ¸…é™¤çµæœå€å¡Š
    document.getElementById('gpsRes').innerHTML = "é»æ“Šã€Œè¨ˆç®—ã€ä»¥é¡¯ç¤ºçµæœ";
    document.getElementById('gpsRes').classList.remove('gps-error');
  };

  // Haversine è·é›¢ (çƒé¢æŠ•å½±è·é›¢, km)
  const hDist = (lat1, lon1, lat2, lon2) => {
    const [rLat1, rLat2, dLat, dLon] = [tRad(lat1), tRad(lat2), tRad(lat2 - lat1), tRad(lon2 - lon1)];
    const a = Math.sin(dLat / 2)**2 + Math.cos(rLat1) * Math.cos(rLat2) * Math.sin(dLon / 2)**2;
    return R_KM * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  };
  
  // 3D ç›´ç·šè·é›¢ (km)
  const straightDist = (hD, eleA, eleB) => {
    const dH = (eleB - eleA) / 1000;
    return Math.sqrt(hD * hD + dH * dH);
  };

  // æ–¹ä½è§’ (Bearing, 0-360Â°)
  const getBearing = (lat1, lon1, lat2, lon2) => {
    const [rL1, rL2, dLon] = [tRad(lat1), tRad(lat2), tRad(lon2 - lon1)];
    const y = Math.sin(dLon) * Math.cos(rL2);
    const x = Math.cos(rL1) * Math.sin(rL2) - Math.sin(rL1) * Math.cos(rL2) * Math.cos(dLon);
    return (tDeg(Math.atan2(y, x)) + 360) % 360;
  };
  
  // ä¿¯ä»°è§’ (Pitch Angle, åº¦)
  const getPitch = (distKm, eleA, eleB) => {
    if (distKm === 0) return { pitchAB: 0, pitchBA: 0 };
    const [hA, hB] = [eleA / 1000, eleB / 1000];
    const offset = distKm**2 / (2 * R_KM); 
    
    const H_AB = (hB - hA) - offset;
    const pitchAB = tDeg(Math.atan2(H_AB, distKm));
    
    const H_BA = (hA - hB) - offset;
    const pitchBA = tDeg(Math.atan2(H_BA, distKm));

    return { pitchAB, pitchBA };
  };


  // ä¸»è¨ˆç®—å‡½æ•¸
  // ========== å¾ SRTM è³‡æ–™å–å¾—é«˜åº¦ ==========
// é¡¯ç¤ºå¸¶æœ‰æµæ°´ç‡ˆæ•ˆæœçš„è¼‰å…¥ç‹€æ…‹ï¼ˆåœ¨é«˜åº¦è¼¸å…¥æ¡†æ—é¡¯ç¤ºï¼‰
function showLoadingWithDots(elementId, message, eleInput = null) {
    if (eleInput) {
        // åœ¨é«˜åº¦è¼¸å…¥æ¡†ä¸Šæ–¹é¡¯ç¤ºloadingæç¤º
        const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
        const loadingSpan = document.getElementById(loadingId);
        if (loadingSpan) {
            loadingSpan.innerHTML = `${message}<span class="loading-dots"></span>`;
            loadingSpan.style.display = 'inline';
            eleInput.style.opacity = '0.5';  // é™ä½è¼¸å…¥æ¡†é€æ˜åº¦
        }
    } else {
        // åŸæœ¬çš„é‚è¼¯ï¼ˆå¦‚æœæœ‰å…¶ä»–ç”¨é€”ï¼‰
        const element = document.getElementById(elementId);
        element.innerHTML = `<span style="color: #FFD700; font-weight: bold;">${message}<span class="loading-dots"></span></span>`;
        element.style.color = '#FFD700';
        element.style.background = 'rgba(255, 215, 0, 0.1)';
    }
}

async function getElevationFromSRTM(location) {
    console.log('getElevationFromSRTM() è¢«èª¿ç”¨ï¼Œåœ°é»:', location);
    
    // ç²å–è©²åœ°é»çš„åº§æ¨™
    const latId = location === 'A' ? 'latA' : 'latB';
    const lonId = location === 'A' ? 'lonA' : 'lonB';
    const eleId = location === 'A' ? 'eleA' : 'eleB';
    
    const latVal = document.getElementById(latId).value;
    const lonVal = document.getElementById(lonId).value;
    
    // é©—è­‰åº§æ¨™
    if (!latVal || !lonVal) {
        alert(`âŒ è«‹å…ˆè¼¸å…¥åœ°é»${location}çš„åº§æ¨™`);
        return;
    }
    
    const lat = parseFloat(latVal);
    const lon = parseFloat(lonVal);
    
    if (isNaN(lat) || isNaN(lon)) {
        alert(`âŒ åœ°é»${location}çš„åº§æ¨™ç„¡æ•ˆ`);
        return;
    }
    
    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
        alert(`âŒ åº§æ¨™è¶…å‡ºæœ‰æ•ˆç¯„åœ\nç·¯åº¦: -90 ~ 90\nç¶“åº¦: -180 ~ 180`);
        return;
    }
    
    // é¡¯ç¤ºè¼‰å…¥ç‹€æ…‹
    const eleInput = document.getElementById(eleId);
    const originalValue = eleInput.value;
    eleInput.disabled = true;
    
    // ä¿å­˜åŸæœ¬çš„è¨ˆç®—çµæœ
    const gpsRes = document.getElementById('gpsRes');
    const originalContent = gpsRes.innerHTML;
    const originalColor = gpsRes.style.color;
    const originalBg = gpsRes.style.background;
    
    // åœ¨é«˜åº¦è¼¸å…¥æ¡†é¡¯ç¤ºè¼‰å…¥ç‹€æ…‹
    showLoadingWithDots('gpsRes', 'è®€å–ä¸­', eleInput);
    
    try {
        // èª¿ç”¨ Open-Elevation API å–å¾—é«˜åº¦
        console.log(`èª¿ç”¨ SRTM APIï¼Œåº§æ¨™: ${lat}, ${lon}`);
        
        const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                locations: [{ latitude: lat, longitude: lon }]
            })
        });
        
        if (!response.ok) {
            throw new Error(`API è¿”å›ç‹€æ…‹ ${response.status}`);
        }
        
        const result = await response.json();
        console.log('API éŸ¿æ‡‰:', result);
        
        if (!result.results || result.results.length === 0) {
            throw new Error('ç„¡æ³•å–å¾—è©²ä½ç½®çš„é«˜åº¦æ•¸æ“š');
        }
        
        const elevation = result.results[0].elevation;
        
        if (elevation === null || elevation === undefined) {
            throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
        }
        
        // è¨­ç½®é«˜åº¦å€¼ï¼ˆä¸é¡¯ç¤ºå°æ•¸é»ï¼‰
        eleInput.value = Math.round(parseFloat(elevation));
        
        console.log(`åœ°é»${location}é«˜åº¦å·²æ›´æ–°: ${elevation}m`);
        
        // ç«‹å³é‡æ–°è¨ˆç®—ä¸€æ¬¡ï¼ˆæ›´æ–°ä¿¯ä»°è§’ï¼‰
        calculate();
        
        // åœ¨è¨ˆç®—çµæœä¸Šæ–¹è‡¨æ™‚é¡¯ç¤ºæˆåŠŸè¨Šæ¯
        const currentResult = gpsRes.innerHTML;
        const successMsg = `<span style="color: #FFD700; font-weight: bold;">âœ“ åœ°é»${location}é«˜åº¦å·²å¾ SRTM è³‡æ–™æ›´æ–°ï¼š<strong>${Math.round(parseFloat(elevation))} m</strong></span><br><br>${currentResult}`;
        gpsRes.innerHTML = successMsg;
        
        // éš±è—loadingæç¤º
        const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
        const loadingSpan = document.getElementById(loadingId);
        if (loadingSpan) {
            loadingSpan.style.display = 'none';
            eleInput.style.opacity = '1';
        }
        
        // 3ç§’å¾Œç§»é™¤æˆåŠŸè¨Šæ¯æç¤ºï¼Œä¿ç•™è¨ˆç®—çµæœ
        setTimeout(() => {
            gpsRes.innerHTML = currentResult;
        }, 3000);
        
    } catch (err) {
        console.error('å–å¾—é«˜åº¦å¤±æ•—:', err);
        eleInput.value = originalValue;
        
        // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯åˆ°gpsRes
        let errorHTML = 'âŒ å–å¾—é«˜åº¦å¤±æ•—<br><span style="color: #FFD700; font-weight: bold;">è©²åŠŸèƒ½éœ€é€£ç¶²</span>';
        if (err.message.includes('API')) {
            errorHTML = 'âŒ å–å¾—é«˜åº¦å¤±æ•—<br><span style="color: #FFD700; font-weight: bold;">è©²åŠŸèƒ½éœ€é€£ç¶²</span><br><small>API é€£ç·šå•é¡Œï¼Œè«‹æª¢æŸ¥ç¶²è·¯</small>';
        } else if (err.message.includes('ä¸å¯ç”¨')) {
            errorHTML += '<br><small>è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šæš«ä¸å¯ç”¨</small>';
        } else {
            errorHTML += '<br><small>' + err.message + '</small>';
        }
        
        gpsRes.innerHTML = errorHTML;
        gpsRes.style.color = '#e8eef5';
        gpsRes.style.background = 'rgba(220, 53, 69, 0.15)';
        gpsRes.style.border = '1px solid #dc3545';
        gpsRes.style.borderRadius = '8px';
        gpsRes.style.padding = '8px';
    } finally {
        // æ¢å¾©è¼¸å…¥æ¡†ç‹€æ…‹
        eleInput.disabled = false;
        // éš±è—loadingæç¤º
        const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
        const loadingSpan = document.getElementById(loadingId);
        if (loadingSpan) {
            loadingSpan.style.display = 'none';
            eleInput.style.opacity = '1';
        }
        // æ¢å¾©åŸæœ¬çš„è¨ˆç®—çµæœ
        gpsRes.innerHTML = originalContent;
        gpsRes.style.color = originalColor;
        gpsRes.style.background = originalBg;
    }
}

function calculate() {
    // ç•¶å‰æ¨¡å¼ç‚º DMS æ™‚ï¼Œå…ˆå¾ DMS è½‰æ›åˆ° DD (ç¢ºä¿è¨ˆç®—ä½¿ç”¨æœ€æ–°çš„ DD å€¼)
    const mode = document.getElementById('displayMode').value;
    if (mode === 'dms') {
        ['latA','lonA','latB','lonB'].forEach(id => { try{ dmsToD(id); }catch(e){} });
    }
    
    const [latA, lonA, latB, lonB, eleA, eleB] = 
        ['latA', 'lonA', 'latB', 'lonB', 'eleA', 'eleB'].map(id => parseFloat(document.getElementById(id).value || 0));
    
    const [nameA, nameB] = 
        ['nameA', 'nameB'].map(id => document.getElementById(id).value || (id === 'nameA' ? 'A' : 'B'));

    const resDiv = document.getElementById('gpsRes');

    if (isNaN(latA) || isNaN(lonA) || isNaN(latB) || isNaN(lonB)) {
        resDiv.innerHTML = "âŒ **è«‹è¼¸å…¥æœ‰æ•ˆçš„ GPS åº§æ¨™æ•¸å­—**";
        resDiv.classList.add('gps-error');
        return;
    }
    resDiv.classList.remove('gps-error');

    const hD = hDist(latA, lonA, latB, lonB);
    const sD = straightDist(hD, eleA, eleB);
    const bAB = getBearing(latA, lonA, latB, lonB);
    const bBA = getBearing(latB, lonB, latA, lonA); 
    const pitch = getPitch(hD, eleA, eleB);
    
    // æ•¸å€¼å°‡ç¹¼æ‰¿é’ç¶ è‰²æ¨£å¼
    const fDist = sD < 1 
        ? `<strong class="v-dist">${(sD * 1000).toFixed(2)}</strong> å…¬å°º`
        : `<strong class="v-dist">${sD.toFixed(2)}</strong> å…¬é‡Œ`;
    
    // é¡¯ç¤ºçµæœ
    resDiv.innerHTML = `
        <p><span class="gps-label-title">âœ… å…©é»é–“çš„ç›´ç·šè·é›¢</span>ï¼š${fDist}</p>
        <hr>
        <p><span class="gps-label-title">ğŸ§­ å¾ ${nameA} åˆ° ${nameB} çš„æ–¹ä½è§’</span>ï¼š<strong class="v-bearing">${bAB.toFixed(2)}Â°</strong></p>
        <p><span class="gps-label-title">â†©ï¸ å¾ ${nameB} åˆ° ${nameA} çš„æ–¹ä½è§’</span>ï¼š<strong class="v-bearing">${bBA.toFixed(2)}Â°</strong></p>
        <hr style="border: 0; border-top: 1px dashed rgba(255,255,255,0.06); margin: 3px 0;">
        <p><span class="gps-label-title">â« ${nameA} å° ${nameB} çš„ä¿¯ä»°è§’</span>ï¼š<strong class="v-pitch-value">${pitch.pitchAB.toFixed(2)}Â°</strong></p>
        <p><span class="gps-label-title">â¬ ${nameB} å° ${nameA} çš„ä¿¯ä»°è§’</span>ï¼š<strong class="v-pitch-value">${pitch.pitchBA.toFixed(2)}Â°</strong></p>
    `;
  }
  
  // --- é¡¯ç¤ºæ¨¡å¼åˆ‡æ›ï¼ˆåé€²åˆ¶ / åº¦åˆ†ç§’ï¼‰ ---
    const displayModeSelect = document.getElementById('displayMode');
    
    function updateDisplayMode(mode){
      if(!mode) mode = displayModeSelect ? displayModeSelect.value : 'decimal';
      
      const ids = ['latA','lonA','latB','lonB'];
      
      if(mode === 'dms'){
        // é¡¯ç¤º DMS æ¬„ä½ï¼Œéš±è—åé€²åˆ¶æ¬„ä½
        document.querySelectorAll('.gps-dmsr').forEach(el => el.style.display = 'flex');
        document.querySelectorAll('.gps-ddr').forEach(el => el.style.display = 'none');
        
        // å°‡ç¾æœ‰åé€²åˆ¶è½‰ç‚º DMS é¡¯ç¤º
        ids.forEach(id => { 
            try{ dToDMS(id); }catch(e){} 
        });
      } else {
        // é¡¯ç¤ºåé€²åˆ¶æ¬„ä½ï¼Œéš±è— DMS æ¬„ä½
        document.querySelectorAll('.gps-dmsr').forEach(el => el.style.display = 'none');
        document.querySelectorAll('.gps-ddr').forEach(el => el.style.display = 'flex');
        
        // ä¿®æ­£ 1: åƒ…åœ¨ DD æ¬„ä½ç‚ºç©ºæ™‚ï¼Œæ‰å°‡ DMS å€¼è½‰å› DD
        ids.forEach(id => { 
            const ddInput = document.getElementById(id);
            if (ddInput.value.trim() === '') {
                try{ dmsToD(id); }catch(e){} 
            } 
        });
      }
      
      // æ¨¡å¼åˆ‡æ›å¾Œç«‹å³è¨ˆç®—çµæœ
      calculate(); 
    }
    
    if(displayModeSelect){
      displayModeSelect.addEventListener('change', e => updateDisplayMode(e.target.value));
    }

  // --- åˆå§‹åŒ–è¨­å®šèˆ‡åŸ·è¡Œ ---
  document.addEventListener('DOMContentLoaded', () => {
    // *** æ–°å¢ RF å–®ä½åˆ‡æ›çš„ç›£è½å™¨ ***
    document.getElementById('unit').addEventListener('change', convertLength);

    // 1. RF è¨ˆç®—å™¨åˆå§‹åŒ– (RF é è¨­ç‚º active)
    if (document.getElementById('rf-content').classList.contains('active')) {
      compute();
    }
    
    // 2. GPS è¨ˆç®—å™¨åˆå§‹åŒ–é è¨­å€¼
    resetGps(); 
    
    // ç¢ºä¿æ­£ç¢ºé¡¯ç¤ºåˆå§‹æ¨¡å¼ (é è¨­ç‚º decimal)
    try { updateDisplayMode(document.getElementById('displayMode').value || 'decimal'); } catch(e){}
    
  });
</script> <script>

// æ‰€æœ‰è¨ˆç®—æ¨¡çµ„çš„ ID æ˜ å°„
const sectionIds = {
    'power': 'section-power',
    'matching': 'section-matching',
    'sensitivity': 'section-sensitivity',
    'los': 'section-los',
    'fspl': 'section-fspl',
    'linkbudget': 'section-linkbudget'
};

// --- æ–°å¢é è¨­/æ¸…é™¤åŠŸèƒ½ ---

// 1. é è¨­å€¼èˆ‡è¨ˆç®—å‡½æ•¸æ˜ å°„
const defaultValues = {
    // 1. åŠŸç‡è½‰æ› (dBm / W)
    'section-power': {
        'power_input': '1',
        'power_unit': 'w',
    },
    // 2. åŒ¹é…åº¦åƒæ•¸æ›ç®—
    'section-matching': {
        'matching_input_value': '20',
        'matching_unit': 'rl',
    },
    // 3. ç³»çµ±éˆæ•åº¦ (Sensitivity) è¨ˆç®—
    'section-sensitivity': {
        'sensitivity_bw': '1',
        'sensitivity_nf': '5',
        'sensitivity_sn': '10',
    },
    // 4. é€šè¦–æœ€å¤§è·é›¢è¨ˆç®—
    'section-los': {
        'los_g1': '0',
        'los_h1': '10',
        'los_g2': '0',
        'los_h2': '20',
    },
    // 5. è‡ªç”±ç©ºé–“æè€— (FSPL)
    'section-fspl': {
        'fspl_freq': '2400',
        'fspl_dist': '10',
    },
    // 6. é€šè¨Šæ¨¡æ“¬ (Link Budget)
    'section-linkbudget': {
        'link_tx_power_input': '1',
        'link_tx_power_unit': 'w',
        'link_tx_loss_db': '3',
        'link_tx_gain_dbi': '20',
        'link_dist_km': '10',
        'link_freq_mhz': '2400',
        'link_rx_gain_dbi': '20',
        'link_rx_loss_db': '2',
    }
};

const calculationFunctions = {
    'section-power': 'calculateDbmWNew',
    'section-matching': 'calculateMatching',
    'section-sensitivity': 'calculateSensitivity',
    'section-los': 'calculateMaxLOS',
    'section-fspl': 'calculateFSPL',
    'section-linkbudget': 'calculateLinkBudget',
};

/**
 * å–å¾—æŒ‡å®šå€å¡Šä¸­æ‰€æœ‰éœ€è¦æ§åˆ¶çš„è¼¸å…¥æ¬„ä½ (input, select)
 * @param {string} sectionId å€å¡Š ID
 * @returns {HTMLElement[]} å…ƒç´ é™£åˆ—
 */
function getSectionControls(sectionId) {
    const sectionEl = document.getElementById(sectionId);
    if (!sectionEl) return [];
    
    // é™åˆ¶åœ¨ .input-group-border å…§ï¼Œæ’é™¤ä¸»åŠŸèƒ½é¸æ“‡å™¨
    const inputGroup = sectionEl.querySelector('.input-group-border');
    if (!inputGroup) return [];

    // å–å¾—æ‰€æœ‰å…·æœ‰ ID çš„ input å’Œ select å…ƒç´ 
    return Array.from(inputGroup.querySelectorAll('input, select')).filter(el => el.id);
}

/**
 * å°‡æŒ‡å®šå€å¡Šæ‰€æœ‰æ•¸å€¼å›å¾©æˆé è¨­å€¼ (Reset)
 * @param {string} sectionId å€å¡Š ID
 */
function resetSection(sectionId) {
    const defaults = defaultValues[sectionId];
    if (defaults) {
        // è¿­ä»£é è¨­å€¼åˆ—è¡¨ï¼Œè¨­å®šå…ƒç´ å€¼
        for (const id in defaults) {
            const element = document.getElementById(id);
            if (element) {
                element.value = defaults[id];
                // ç¢ºä¿æ•¸å€¼è¼¸å…¥æ¬„ä½å¯ä»¥æ¥å—ç©ºå­—ä¸² (Clear)
                if(element.tagName === 'INPUT') element.value = defaults[id];
            }
        }
    }
    // åŸ·è¡Œè¨ˆç®—
    const calcFunc = calculationFunctions[sectionId];
    if (calcFunc && typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}

/**
 * æ¸…é™¤æŒ‡å®šå€å¡Šæ‰€æœ‰æ•¸å€¼ (Clear)
 * - è¼¸å…¥æ¬„ä½è¨­å®šç‚ºç©ºå­—ä¸² ''
 * - å–®ä½é¸æ“‡å™¨è¨­å®šå›é è¨­ functional default (èˆ‡ reset ç›¸åŒçš„å€¼)
 * @param {string} sectionId å€å¡Š ID
 */
function clearSection(sectionId) {
    const controls = getSectionControls(sectionId);
    const defaults = defaultValues[sectionId] || {}; // ç”¨æ–¼å–å¾— Select çš„é è¨­å€¼

    controls.forEach(element => {
        const id = element.id;
        if (element.tagName === 'INPUT') {
            element.value = ''; // æ¸…é™¤è¼¸å…¥æ¡†æ•¸å€¼
        } else if (element.tagName === 'SELECT') {
            // å–®ä½é¸æ“‡å™¨ (Select) æ‡‰è¨­å®šå›é è¨­åŠŸèƒ½å€¼ (é¿å…ç„¡æ•ˆé¸é …å°è‡´éŒ¯èª¤)
            if (defaults[id]) {
                element.value = defaults[id];
            } else {
                element.selectedIndex = 0; 
            }
        }
    });
    
    // åŸ·è¡Œè¨ˆç®—
    const calcFunc = calculationFunctions[sectionId];
    if (calcFunc && typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}
// --- çµæŸæ–°å¢ ---

// --- åŠŸèƒ½åˆ‡æ›å‡½æ•¸ --- 
function toggleSections() { 
    const selector = document.getElementById('function_selector'); 
    const selectedValue = selector.value; 
    const allSections = document.querySelectorAll('.section-item'); 
    allSections.forEach(section => { 
        const sectionKey = Object.keys(sectionIds).find(key => sectionIds[key] === section.id); 
        if (selectedValue === 'ALL') { 
            section.style.display = 'block'; 
        } else if (sectionKey === selectedValue) { 
            section.style.display = 'block'; 
        } else { 
            section.style.display = 'none'; 
        } 
    }); 
    // ç¢ºä¿åœ¨åˆ‡æ›æ™‚ï¼Œç•«é¢æœƒé‡æ–°è¨ˆç®—ä¸¦é¡¯ç¤ºçµæœ (å¦‚æœæ¨¡çµ„è¢«é¡¯ç¤º) 
    if (selectedValue === 'ALL' || selectedValue === 'power') calculateDbmWNew(); 
    if (selectedValue === 'ALL' || selectedValue === 'matching') calculateMatching(); 
    if (selectedValue === 'ALL' || selectedValue === 'sensitivity') calculateSensitivity(); 
    if (selectedValue === 'ALL' || selectedValue === 'los') calculateMaxLOS();
    if (selectedValue === 'ALL' || selectedValue === 'fspl') calculateFSPL();
    if (selectedValue === 'ALL' || selectedValue === 'linkbudget') calculateLinkBudget();
}

/**
 * å€‹åˆ¥è¼¸å…¥æ¬„ä½æ¸…é™¤ä¸¦é‡æ–°è¨ˆç®—
 * @param {string} inputId è¼¸å…¥æ¬„ä½ ID
 * @param {string} calcFunc è¨ˆç®—å‡½æ•¸åç¨±
 */
function clearAndRecalculate(inputId, calcFunc) {
    const inputElement = document.getElementById(inputId);
    if (inputElement) {
        inputElement.value = '';
    }
    if (typeof window[calcFunc] === 'function') {
        window[calcFunc]();
    }
}

// --- 1. åŠŸç‡è½‰æ› (dBm / W) ---
// è¼”åŠ©å‡½æ•¸ï¼šåŸ·è¡Œ dBm <-> W è½‰æ›
function convertPower(value, fromUnit, toUnit) {
    if (fromUnit === toUnit) return value;
    if (fromUnit === 'w' && toUnit === 'dbm') {
        // W to dBm: 10 * log10(P_W / 1mW) = 10 * log10(P_W * 1000)
        return 10 * Math.log10(value * 1000);
    } else if (fromUnit === 'dbm' && toUnit === 'w') {
        // dBm to W: 10^(P_dBm / 10) * 1mW = 10^(P_dBm / 10 - 3)
        return Math.pow(10, (value / 10) - 3);
    }
    return NaN;
}

// ç”¨æ–¼è¨˜éŒ„ä¸Šä¸€æ¬¡è¼¸å…¥çš„å–®ä½ï¼Œä»¥åœ¨åˆ‡æ›å–®ä½æ™‚é€²è¡Œæ•¸å€¼æ›ç®—
let power_conv_last_unit = 'w'; 

function calculateDbmWNew() {
    const input = document.getElementById('power_input');
    const unit = document.getElementById('power_unit').value;
    const output = document.getElementById('power_output_result');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color; // ä¸»è¦æ–‡å­—é¡è‰² (ç™½è‰²)

    const input_value = parseFloat(input.value);

    if (isNaN(input_value) || input.value.trim() === '') {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">è«‹è¼¸å…¥æ•¸å€¼</span>`;
        return;
    }
    
    // æª¢æŸ¥æ•¸å€¼ç¯„åœ
    if (unit === 'w' && input_value < 0) {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">åŠŸç‡ (W) å¿…é ˆ â‰¥ 0</span>`;
        return;
    }

    let result_value, result_unit;

    if (unit === 'w') {
        result_value = convertPower(input_value, 'w', 'dbm');
        result_unit = 'dBm';
        // é¡å¤–æª¢æŸ¥ dBm è½‰æ›æ˜¯å¦æœ‰æ•ˆ (åªæœ‰ 0 W æœƒæ˜¯ -Infinity)
        if (result_value === -Infinity) {
            output.innerHTML = `æ›ç®—çµæœ: <span class="result-value">-âˆ</span> <span style="color:${unit_color};">${result_unit}</span>`;
            return;
        }
    } else { // unit === 'dbm'
        result_value = convertPower(input_value, 'dbm', 'w');
        result_unit = 'W';
        // æª¢æŸ¥ W è½‰æ›æ˜¯å¦æœ‰æ•ˆ (æ¥µå°çš„æ•¸å€¼)
        if (result_value < 0) result_value = 0;
    }
    
    if (isNaN(result_value)) {
        output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">è¼¸å…¥ç„¡æ•ˆ</span>`;
        return;
    } else {
        // è¼¸å‡ºæ•¸å€¼ï¼Œå–®ä½å¥—ç”¨ç™½è‰²
        output.innerHTML = `æ›ç®—çµæœ: <span class="result-value">${result_value.toFixed(3)}</span> <span style="color:${unit_color};">${result_unit}</span>`;
    }
    power_conv_last_unit = unit;
}

function swapAndCalculate() {
    const input = document.getElementById('power_input');
    const current_unit = document.getElementById('power_unit').value;
    const input_value = parseFloat(input.value);

    if (!isNaN(input_value) && input.value.trim() !== '') {
        const new_value = convertPower(input_value, power_conv_last_unit, current_unit);
        if (!isNaN(new_value)) {
            // è™•ç† 0 W è½‰æ›ç‚º -Infinity dBm çš„æƒ…æ³
            if (current_unit === 'dbm' && new_value === -Infinity) {
                // å¦‚æœå–®ä½åˆ‡æ›åˆ° dBm ä¸”åŸå€¼ç‚º 0 Wï¼Œä¸æ”¹è®Š input.valueï¼Œè®“ calculateDbmWNew è™•ç†è¼¸å‡º
            } else {
                input.value = new_value.toFixed(3);
            }
        } else {
             // è™•ç†è¼¸å…¥ç„¡æ•ˆå°è‡´çš„ NaNï¼Œä½†å¦‚æœåŸå€¼æ˜¯æœ‰æ•ˆçš„ï¼Œé€™è£¡ä¸æ‡‰æ¸…é™¤
        }
    }
    calculateDbmWNew();
}


// --- 2. åŒ¹é…åº¦è½‰æ› (å‹•æ…‹æ›ç®—é‚è¼¯) ---
let last_matching_unit = 'rl'; 

function getGammaFromValue(value, type) {
    if (type === 'rl') {
        if (value < 0) throw new Error("RL å¿…é ˆ â‰¥ 0 dB");
        return Math.pow(10, -value / 20);
    } else if (type === 'vswr') {
        if (value < 1) throw new Error("VSWR å¿…é ˆ â‰¥ 1");
        return (value - 1) / (value + 1);
    } else if (type === 'gamma') {
        if (value < 0 || value > 1) throw new Error("Î“ å¿…é ˆä»‹æ–¼ 0 åˆ° 1 ä¹‹é–“");
        return value;
    } else if (type === 'refl_pct') {
        if (value < 0 || value > 100) throw new Error("åå°„åŠŸç‡å¿…é ˆä»‹æ–¼ 0 åˆ° 100 ä¹‹é–“");
        return Math.sqrt(value / 100);
    } else if (type === 'pass_pct') {
        if (value < 0 || value > 100) throw new Error("é€šéåŠŸç‡å¿…é ˆä»‹æ–¼ 0 åˆ° 100 ä¹‹é–“");
        return Math.sqrt(1 - (value / 100));
    }
    return NaN;
}

function getValueFromGamma(gamma, type) {
    if (isNaN(gamma) || gamma === Infinity) return NaN;

    if (type === 'rl') {
        // -20 * log10(|Î“|)
        if (gamma === 0) return Infinity;
        // ç¢ºä¿è¼¸å…¥æ˜¯æ­£æ•¸ä»¥é¿å… Math.log10 éŒ¯èª¤
        return -20 * Math.log10(Math.abs(gamma));
    } else if (type === 'vswr') {
        // (1 + |Î“|) / (1 - |Î“|)
        if (gamma === 1) return Infinity;
        return (1 + Math.abs(gamma)) / (1 - Math.abs(gamma));
    } else if (type === 'gamma') {
        return Math.abs(gamma);
    } else if (type === 'refl_pct') {
        // |Î“|^2 * 100%
        return Math.abs(gamma)**2 * 100;
    } else if (type === 'pass_pct') {
        // (1 - |Î“|^2) * 100%
        return (1 - Math.abs(gamma)**2) * 100;
    }
    return NaN;
}

function swapAndConvertMatching() {
    const current_unit = document.getElementById('matching_unit').value;
    const input_element = document.getElementById('matching_input_value');
    const input_value = parseFloat(input_element.value);

    // åªæœ‰åœ¨è¼¸å…¥æ•¸å€¼æœ‰æ•ˆæ™‚æ‰å˜—è©¦æ›ç®—
    if (!isNaN(input_value) && input_element.value.trim() !== '') {
        let gamma_abs;
        try {
            // 1. å¾èˆŠå–®ä½æ›ç®—åˆ°çµ•å°å€¼åå°„ä¿‚æ•¸ |Î“|
            gamma_abs = getGammaFromValue(input_value, last_matching_unit);
            if (!isNaN(gamma_abs)) {
                // 2. å°‡ |Î“| æ›ç®—æˆæ–°å–®ä½çš„å€¼
                const new_value = getValueFromGamma(gamma_abs, current_unit);
                if (!isNaN(new_value) && new_value !== Infinity) {
                    // å¦‚æœæ–°å–®ä½æ˜¯ RLï¼Œä¿ç•™ 2 ä½å°æ•¸ï¼Œå…¶ä»–ä¿ç•™ 4 ä½å°æ•¸
                    const precision = (current_unit === 'rl' || current_unit === 'refl_pct' || current_unit === 'pass_pct') ? 2 : 4;
                    input_element.value = new_value.toFixed(precision);
                } else if (new_value === Infinity) {
                    input_element.value = '1'; // VSWR/RL ç„¡çª®å¤§æ™‚ï¼Œåå°„ä¿‚æ•¸ç‚º 1
                } else {
                    input_element.value = '';
                }
            } else {
                input_element.value = '';
            }
        } catch (error) {
             input_element.value = '';
        }
    }
    calculateMatching();
    last_matching_unit = current_unit;
}

function calculateMatching() {
    const input_type = document.getElementById('matching_unit').value;
    const input_element = document.getElementById('matching_input_value');
    const input_value = parseFloat(input_element.value);
    
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;

    const output_elements = {
        rl: document.getElementById('rl_val'),
        vswr: document.getElementById('vswr_val'),
        gamma: document.getElementById('gamma_val'),
        refl_pct: document.getElementById('refl_percent'),
        pass_pct: document.getElementById('pass_percent')
    };

    const empty_output = `<span style="color:${redColor};font-size:17px;">è«‹è¼¸å…¥æ•¸å€¼</span>`;

    // æ¸…ç©ºæ‰€æœ‰è¼¸å‡º
    Object.values(output_elements).forEach(el => el.innerHTML = '');

    if (isNaN(input_value) || input_element.value.trim() === '') {
        output_elements.rl.innerHTML = empty_output;
        return;
    }

    let gamma_abs;
    try {
        gamma_abs = getGammaFromValue(input_value, input_type);
    } catch (error) {
        output_elements.rl.innerHTML = `<span style="color:${redColor};font-size:17px;">${error.message}</span>`;
        return;
    }
    
    // è¼¸å‡ºæ›ç®—çµæœ
    const rl_val = getValueFromGamma(gamma_abs, 'rl');
    const vswr_val = getValueFromGamma(gamma_abs, 'vswr');
    const gamma_val = getValueFromGamma(gamma_abs, 'gamma');
    const refl_pct = getValueFromGamma(gamma_abs, 'refl_pct');
    const pass_pct = getValueFromGamma(gamma_abs, 'pass_pct');

    const formatOutput = (value, unit, precision=2) => {
        if (value === Infinity) return `<span class="result-value">âˆ</span> <span style="color:${unit_color};">${unit}</span>`;
        if (isNaN(value)) return `<span style="color:${redColor};font-size:17px;">è¨ˆç®—éŒ¯èª¤</span>`;
        return `<span class="result-value">${value.toFixed(precision)}</span> <span style="color:${unit_color};">${unit}</span>`;
    }

    output_elements.rl.innerHTML = formatOutput(rl_val, 'dB');
    output_elements.vswr.innerText = vswr_val === Infinity ? 'âˆ' : vswr_val.toFixed(3);
    output_elements.gamma.innerText = gamma_val.toFixed(4);
    output_elements.refl_pct.innerHTML = formatOutput(refl_pct, '%');
    output_elements.pass_pct.innerHTML = formatOutput(pass_pct, '%');

    last_matching_unit = input_type;
}

// --- 3. é€šä¿¡ç³»çµ±éˆæ•åº¦è¨ˆç®— ---
// è¼”åŠ©å¸¸æ•¸
const BOLTZMANN_K_J = 1.380649e-23; // J/K
const T_KELVIN = 290; // åƒè€ƒæº«åº¦ (290 K)
// é›œè¨Šåœ°æ¿ (Noise Floor) P_n (dBm) = -174 + 10 * log10(BW_Hz) + NF_dB
// P_n (dBm) = -174 + 10 * log10(BW_MHz * 10^6) + NF_dB
// P_n (dBm) = -174 + 10 * (log10(BW_MHz) + 6) + NF_dB
// P_n (dBm) = -174 + 10*log10(BW_MHz) + 60 + NF_dB
// P_n (dBm) = -114 + 10*log10(BW_MHz) + NF_dB

function calculateSensitivity() {
    const bw_mhz = parseFloat(document.getElementById('sensitivity_bw').value);
    const nf_db = parseFloat(document.getElementById('sensitivity_nf').value);
    const sn_db = parseFloat(document.getElementById('sensitivity_sn').value);
    const output = document.getElementById('sensitivity_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;

    if (isNaN(bw_mhz) || isNaN(nf_db) || isNaN(sn_db) || bw_mhz <= 0 || nf_db < 0) {
        output.innerHTML = `æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity): <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å€¼ (BW > 0, NF â‰¥ 0)</span>`;
        return;
    }

    // 1. è¨ˆç®—ç†±é›œè¨Šåœ°æ¿ (Noise Floor) P_n (dBm)
    // P_n (dBm) = -174 + 10 * log10(BW_Hz) + NF_dB
    // ç°¡åŒ–ç‚ºï¼š -114 + 10*log10(BW_MHz) + NF_dB
    const noise_floor_dbm = -114 + (10 * Math.log10(bw_mhz)) + nf_db;

    // 2. è¨ˆç®—éˆæ•åº¦ (Sensitivity)
    // Sensitivity (dBm) = P_n (dBm) + S/N (dB)
    const sensitivity_dbm = noise_floor_dbm + sn_db;

    output.innerHTML = `
        æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity): <span class="result-value">${sensitivity_dbm.toFixed(2)}</span> <span style="color:${unit_color};">dBm</span><br>
        <span class="result-value-small">ç†±é›œè¨Šåœ°æ¿ (Noise Floor) Pn: ${noise_floor_dbm.toFixed(2)} dBm</span>
    `;
}

// --- 4. é€šè¦–æœ€å¤§è·é›¢è¨ˆç®— (åœ°çƒæ›²åº¦é®è”½) ---
// è¼”åŠ©å¸¸æ•¸
const K_FACTOR = 4 / 3; // K=4/3 (ç­‰æ•ˆåœ°çƒåŠå¾‘å¸¸æ•¸)
const R_EARTH_KM = 6371; // åœ°çƒåŠå¾‘ (km)

function calculateMaxLOS() {
    // è®€å–è¼¸å…¥å€¼ (å¤©ç·šé«˜åº¦ H + åœ°å¹³é¢é«˜åº¦ G = çµ•å°é«˜åº¦ A)
    const g1 = parseFloat(document.getElementById('los_g1').value) || 0;
    const h1 = parseFloat(document.getElementById('los_h1').value) || 0;
    const g2 = parseFloat(document.getElementById('los_g2').value) || 0;
    const h2 = parseFloat(document.getElementById('los_h2').value) || 0;

    const output = document.getElementById('los_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;

    // æª¢æŸ¥é«˜åº¦æ˜¯å¦æœ‰æ•ˆ
    if (h1 < 0 || h2 < 0) {
        output.innerHTML = `æœ€å¤§é€šè¦–è·é›¢: <span style="color:${redColor};">å¤©ç·šé«˜åº¦å¿…é ˆ â‰¥ 0</span>`;
        return;
    }
    
    // çµ•å°é«˜åº¦ (m)
    const a1 = g1 + h1;
    const a2 = g2 + h2;
    
    // æª¢æŸ¥çµ•å°é«˜åº¦æ˜¯å¦æœ‰æ•ˆ
    if (a1 <= 0 || a2 <= 0) {
        output.innerHTML = `æœ€å¤§é€šè¦–è·é›¢: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (å¤©ç·šçµ•å°é«˜åº¦ > 0) æ•¸å€¼</span>`;
        return;
    }

    // ç­‰æ•ˆåœ°çƒåŠå¾‘ (km)
    const R_eff = K_FACTOR * R_EARTH_KM; 
    
    // æœ€å¤§é€šè¦–è·é›¢å…¬å¼ (Distance D_km) = sqrt(2 * R_eff * A_1 / 1000) + sqrt(2 * R_eff * A_2 / 1000)
    // é€™è£¡ A_1, A_2 æ˜¯çµ•å°é«˜åº¦ (m)ï¼Œæ‰€ä»¥é™¤ä»¥ 1000 è½‰æ›ç‚º km
    const d1_km = Math.sqrt(2 * R_eff * a1 / 1000);
    const d2_km = Math.sqrt(2 * R_eff * a2 / 1000);

    const max_los_km = d1_km + d2_km;

    output.innerHTML = `
        æœ€å¤§é€šè¦–è·é›¢: <span class="result-value">${max_los_km.toFixed(2)}</span> <span style="color:${unit_color};">km</span><br>
        <span class="result-value-small">Aé»è¦–è·: ${d1_km.toFixed(2)} km; Bé»è¦–è·: ${d2_km.toFixed(2)} km</span>
    `;
}

// --- 5. è‡ªç”±ç©ºé–“æè€— (Free Space Path Loss, FSPL) ---
// FSPL (dB) = 20 log10(d) + 20 log10(f) + 20 log10(4Ï€/c)
// FSPL (dB) = 32.44 + 20 * log10(f_MHz) + 20 * log10(d_km)
function calculateFSPL() {
    const freq_mhz = parseFloat(document.getElementById('fspl_freq').value);
    const dist_km = parseFloat(document.getElementById('fspl_dist').value);
    const output = document.getElementById('fspl_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;

    if (isNaN(freq_mhz) || isNaN(dist_km) || freq_mhz <= 0 || dist_km <= 0) {
        output.innerHTML = `è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL): <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (é »ç‡ > 0, è·é›¢ > 0) æ•¸å€¼</span>`;
        return;
    }

    // FSPL (dB) = 32.44 + 20 * log10(f_MHz) + 20 * log10(d_km)
    const fspl_db = 32.44 + (20 * Math.log10(freq_mhz)) + (20 * Math.log10(dist_km));
    
    output.innerHTML = `è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL): <span class="result-value">${fspl_db.toFixed(2)}</span> <span style="color:${unit_color};">dB</span>`;
}

// --- 6. é€šè¨Šæ¨¡æ“¬ (Link Budget) ---
function calculateLinkBudget() {
    // é€šä¿¡åƒæ•¸
    const freq_mhz = parseFloat(document.getElementById('link_freq_mhz').value);
    const dist_km = parseFloat(document.getElementById('link_dist_km').value);

    // Tx ç«¯åƒæ•¸
    const tx_power_input = parseFloat(document.getElementById('link_tx_power_input').value);
    const tx_power_unit = document.getElementById('link_tx_power_unit').value;
    const tx_loss_db = parseFloat(document.getElementById('link_tx_loss_db').value) || 0;
    const tx_gain_dbi = parseFloat(document.getElementById('link_tx_gain_dbi').value) || 0;
    
    // Rx ç«¯åƒæ•¸
    const rx_gain_dbi = parseFloat(document.getElementById('link_rx_gain_dbi').value) || 0;
    const rx_loss_db = parseFloat(document.getElementById('link_rx_loss_db').value) || 0;
    
    const output = document.getElementById('linkbudget_output');
    const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
    const unit_color = getComputedStyle(document.body).color;

    // æª¢æŸ¥åŸºæœ¬è¼¸å…¥æœ‰æ•ˆæ€§
    if (isNaN(freq_mhz) || isNaN(dist_km) || freq_mhz <= 0 || dist_km <= 0) {
        output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (é »ç‡ > 0, è·é›¢ > 0) æ•¸å€¼</span>`;
        return;
    }
    
    if (isNaN(tx_power_input) || (tx_power_unit === 'w' && tx_power_input < 0)) {
         output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ç™¼å°„åŠŸç‡</span>`;
         return;
    }

    // 1. è½‰æ›ç™¼å°„åŠŸç‡ç‚º dBm
    const tx_power_dbm = convertPower(tx_power_input, tx_power_unit, 'dbm');

    if (isNaN(tx_power_dbm)) {
         output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">ç™¼å°„åŠŸç‡ (W) å¿…é ˆ > 0</span>`;
         return;
    }

    // 2. è¨ˆç®— FSPL (è‡ªç”±ç©ºé–“æè€—)
    // FSPL (dB) = 32.44 + 20 * log10(f_MHz) + 20 * log10(d_km)
    const fspl_db = 32.44 + (20 * Math.log10(freq_mhz)) + (20 * Math.log10(dist_km));
    
    // 3. è¨ˆç®— Link Budget (æ¥æ”¶åŠŸç‡)
    // P_R (dBm) = P_T(dBm) - L_Tx + G_Tx - FSPL + G_Rx - L_Rx
    const rx_power_dbm = tx_power_dbm - tx_loss_db + tx_gain_dbi - fspl_db + rx_gain_dbi - rx_loss_db;
    
    // è¼¸å‡ºæ•¸å€¼
    output.innerHTML = `
        æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span class="result-value">${rx_power_dbm.toFixed(2)}</span> <span style="color:${unit_color};">dBm</span><br>
        <span style="font-size:14px;color:var(--muted);">
            è·¯å¾‘æè€— (Path Loss): ${fspl_db.toFixed(2)} dB (FSPL) + ${(tx_loss_db + rx_loss_db).toFixed(2)} dB (ç·šæ) = ${(fspl_db + tx_loss_db + rx_loss_db).toFixed(2)} dB<br>
            ç™¼å°„ EIRP: ${(tx_power_dbm - tx_loss_db + tx_gain_dbi).toFixed(2)} dBm
        </span>
    `;
}


// --- åˆå§‹åŒ–åŸ·è¡Œ ---
document.addEventListener('DOMContentLoaded', () => {
    // åˆå§‹è¨ˆç®—æ‰€æœ‰é¡¯ç¤ºçš„å€å¡Š
    toggleSections(); 
});

</script>
<script>
// ========== é«˜åº¦åœ–åˆ†é çš„å…¨éƒ¨åŠŸèƒ½ ==========
let chartInstance = null;
let pathData = [];

function importFromGPS() {
    console.log('importFromGPS() è¢«èª¿ç”¨');
    
    // ç²å– GPS åˆ†é çš„åœ°é» A åº§æ¨™
    const latA = document.getElementById('latA').value;
    const lonA = document.getElementById('lonA').value;
    const latADeg = document.getElementById('latA_deg').value;
    const latAMin = document.getElementById('latA_min').value;
    const latASec = document.getElementById('latA_sec').value;
    const lonADeg = document.getElementById('lonA_deg').value;
    const lonAMin = document.getElementById('lonA_min').value;
    const lonASec = document.getElementById('lonA_sec').value;
    
    // ç²å– GPS åˆ†é çš„åœ°é» B åº§æ¨™
    const latB = document.getElementById('latB').value;
    const lonB = document.getElementById('lonB').value;
    const latBDeg = document.getElementById('latB_deg').value;
    const latBMin = document.getElementById('latB_min').value;
    const latBSec = document.getElementById('latB_sec').value;
    const lonBDeg = document.getElementById('lonB_deg').value;
    const lonBMin = document.getElementById('lonB_min').value;
    const lonBSec = document.getElementById('lonB_sec').value;
    
    // ç²å– GPS åˆ†é çš„åœ°å
    const nameA = document.getElementById('nameA').value || '';
    const nameB = document.getElementById('nameB').value || '';
    
    // å„ªå…ˆä½¿ç”¨åé€²åˆ¶æ ¼å¼ï¼Œå¦‚æœç‚ºç©ºå‰‡å˜—è©¦ DMS è½‰æ›
    let startLat = latA ? parseFloat(latA) : (latADeg || latAMin || latASec) ? dmsToDecimal(latADeg, latAMin, latASec) : null;
    let startLon = lonA ? parseFloat(lonA) : (lonADeg || lonAMin || lonASec) ? dmsToDecimal(lonADeg, lonAMin, lonASec) : null;
    let endLat = latB ? parseFloat(latB) : (latBDeg || latBMin || latBSec) ? dmsToDecimal(latBDeg, latBMin, latBSec) : null;
    let endLon = lonB ? parseFloat(lonB) : (lonBDeg || lonBMin || lonBSec) ? dmsToDecimal(lonBDeg, lonBMin, lonBSec) : null;
    
    console.log('è®€å–åˆ°çš„åº§æ¨™:', {startLat, startLon, endLat, endLon});
    console.log('è®€å–åˆ°çš„åœ°å:', {nameA, nameB});
    
    if (!startLat || !startLon || !endLat || !endLon) {
        alert('âŒ GPS åˆ†é çš„åœ°é» A æˆ– B åº§æ¨™æœªå®Œæ•´å¡«å¯«ï¼Œè«‹å…ˆåœ¨ GPS åˆ†é è¼¸å…¥åº§æ¨™');
        return;
    }
    
    // å°‡åº§æ¨™å¡«å…¥é«˜åº¦åœ–åˆ†é 
    document.getElementById('sLat').value = startLat.toFixed(6);
    document.getElementById('sLng').value = startLon.toFixed(6);
    document.getElementById('eLat').value = endLat.toFixed(6);
    document.getElementById('eLng').value = endLon.toFixed(6);
    
    // ç•°æ­¥ç²å–åœ°åä¸¦æ›´æ–°æ¨™ç±¤
    updateElevationLabelsWithPlaceNames(startLat, startLon, endLat, endLon, nameA, nameB);
    
    const summary = document.getElementById('summary');
    summary.innerText = `âœ“ å·²å¾ GPS åˆ†é è®€å–åº§æ¨™å®Œæˆï¼Aé»: (${startLat.toFixed(6)}, ${startLon.toFixed(6)}), Bé»: (${endLat.toFixed(6)}, ${endLon.toFixed(6)})`;
    summary.style.color = '#27ae60';
    summary.style.background = 'rgba(39, 174, 96, 0.1)';
    
    console.log('åº§æ¨™å·²å¡«å…¥é«˜åº¦åœ–åˆ†é ');
}

// æ–°å¢ï¼šåå‘åœ°ç†ç·¨ç¢¼ç²å–åœ°å
async function getPlaceNameFromCoords(lat, lon) {
    try {
        // ä½¿ç”¨ OpenStreetMap Nominatim API é€²è¡Œåå‘åœ°ç†ç·¨ç¢¼
        const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`,
            {
                headers: {
                    'User-Agent': 'GPS Calculator App'
                }
            }
        );
        
        if (!response.ok) {
            throw new Error('APIè«‹æ±‚å¤±æ•—');
        }
        
        const data = await response.json();
        
        // å„ªå…ˆé¸æ“‡æœ‰æ„ç¾©çš„åœ°å
        if (data.address) {
            const addr = data.address;
            // ä¾åºå˜—è©¦ä¸åŒçš„åœ°åå±¤ç´š
            return addr.road || addr.village || addr.town || addr.city || 
                   addr.suburb || addr.neighbourhood || addr.hamlet || 
                   addr.county || addr.state || 'æœªçŸ¥åœ°é»';
        }
        
        return 'æœªçŸ¥åœ°é»';
    } catch (error) {
        console.error('ç²å–åœ°åå¤±æ•—:', error);
        return 'æœªçŸ¥åœ°é»';
    }
}

// æ–°å¢ï¼šæ›´æ–°é«˜åº¦åœ–åˆ†é çš„æ¨™ç±¤ç‚ºåœ°å
async function updateElevationLabelsWithPlaceNames(latA, lonA, latB, lonB, nameA, nameB) {
    const labelALat = document.getElementById('labelALat');
    const labelALng = document.getElementById('labelALng');
    const labelBLat = document.getElementById('labelBLat');
    const labelBLng = document.getElementById('labelBLng');
    
    // å¦‚æœGPSåˆ†é æœ‰åœ°åï¼Œç›´æ¥ä½¿ç”¨ï¼›å¦å‰‡é€²è¡Œåå‘åœ°ç†ç·¨ç¢¼
    let placeNameA = nameA;
    let placeNameB = nameB;
    
    if (!placeNameA || placeNameA.trim() === '') {
        // é¡¯ç¤ºè¼‰å…¥æç¤º
        labelALat.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
        labelALng.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
        
        // ç²å–Aé»åœ°å
        placeNameA = await getPlaceNameFromCoords(latA, lonA);
        
        // å»¶é²ä»¥é¿å…APIé€Ÿç‡é™åˆ¶
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    if (!placeNameB || placeNameB.trim() === '') {
        // é¡¯ç¤ºè¼‰å…¥æç¤º
        labelBLat.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
        labelBLng.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
        
        // ç²å–Bé»åœ°å
        placeNameB = await getPlaceNameFromCoords(latB, lonB);
    }
    
    // æ›´æ–°æ¨™ç±¤é¡¯ç¤ºåœ°åï¼ˆåœ°åç”¨é»ƒè‰²é¡¯ç¤ºï¼‰
    labelALat.innerHTML = `<span style="color: var(--title); font-weight: 700;">${placeNameA}</span> ç·¯åº¦`;
    labelALng.innerHTML = `<span style="color: var(--title); font-weight: 700;">${placeNameA}</span> ç¶“åº¦`;
    labelBLat.innerHTML = `<span style="color: var(--title); font-weight: 700;">${placeNameB}</span> ç·¯åº¦`;
    labelBLng.innerHTML = `<span style="color: var(--title); font-weight: 700;">${placeNameB}</span> ç¶“åº¦`;
    
    // ä¿å­˜åœ°ååˆ°å…¨å±€è®Šé‡ï¼Œä¾›åœ–è¡¨æ¨™æ³¨ä½¿ç”¨
    window.elevationPointAName = placeNameA;
    window.elevationPointBName = placeNameB;
    
    console.log('åœ°åå·²æ›´æ–°:', {placeNameA, placeNameB});
}

function dmsToDecimal(degrees, minutes, seconds) {
    const d = parseFloat(degrees) || 0;
    const m = parseFloat(minutes) || 0;
    const s = parseFloat(seconds) || 0;
    return d + m/60 + s/3600;
}

function getDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // åœ°çƒåŠå¾‘ km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

// ç•¶é é¢è¼‰å…¥æ™‚è¨­ç½® API é¸æ“‡å™¨äº‹ä»¶ç›£è½
document.addEventListener('DOMContentLoaded', function() {
    const apiSelector = document.getElementById('elevationApiSelector');
    if (apiSelector) {
        apiSelector.addEventListener('change', function() {
            updateApiInfo();
        });
    }
});

function updateApiInfo() {
    const apiSelector = document.getElementById('elevationApiSelector');
    const apiInfo = document.getElementById('apiInfo');
    
    // APIè³‡è¨Šå·²ç§»é™¤
    apiInfo.textContent = '';
}


// ===== æ–°çš„ runAnalysis å‡½æ•¸ - æ ¹æ“šé¸æ“‡çš„APIèª¿ç”¨ç›¸æ‡‰çš„å‡½æ•¸ =====
async function runAnalysis() {
    console.log('runAnalysis() è¢«èª¿ç”¨');
    
    const apiSelector = document.getElementById('elevationApiSelector');
    const selectedApi = apiSelector ? apiSelector.value : 'open-elevation';
    
    console.log('é¸ä¸­çš„API:', selectedApi);
    
    // æ‰€æœ‰APIé¸é …éƒ½ä½¿ç”¨Open-Elevationçš„è™•ç†æ–¹å¼
    await runAnalysisWithOpenElevation();
}

// ===== Open-Elevation (SRTM) API ç‰ˆæœ¬ =====
async function runAnalysisWithOpenElevation() {
    console.log('runAnalysisWithOpenElevation() è¢«èª¿ç”¨');
    

    const sLat = parseFloat(document.getElementById('sLat').value);
    const sLng = parseFloat(document.getElementById('sLng').value);
    const eLat = parseFloat(document.getElementById('eLat').value);
    const eLng = parseFloat(document.getElementById('eLng').value);
    const numPoints = parseInt(document.getElementById('samples').value);

    console.log('è¼¸å…¥å€¼:', {sLat, sLng, eLat, eLng, numPoints});

    if (isNaN(sLat) || isNaN(sLng) || isNaN(eLat) || isNaN(eLng)) {
        summary.innerText = 'âŒ è«‹è¼¸å…¥æ‰€æœ‰åº§æ¨™æ•¸å€¼';
        console.error('åº§æ¨™è¼¸å…¥ç„¡æ•ˆ');
        return;
    }

    const totalDist = getDistance(sLat, sLng, eLat, eLng);
    console.log('ç¸½è·é›¢:', totalDist);
    summary.innerHTML = `<span style="color: #FFD700; font-weight: bold;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (åˆ†æä¸­<span class="loading-dots"></span>)</span>`;

    pathData = [];
    const locations = [];
    for (let i = 0; i < numPoints; i++) {
        const f = i / (numPoints - 1);
        const lat = sLat + (eLat - sLat) * f;
        const lng = sLng + (eLng - sLng) * f;
        locations.push({ latitude: lat, longitude: lng });
        pathData.push({ dist: (totalDist * f).toFixed(3), lat: lat.toFixed(6), lng: lng.toFixed(6) });
    }

    console.log('å–æ¨£é»æ•¸:', locations.length);

    try {
        console.log('é–‹å§‹èª¿ç”¨ Open-Elevation API...');
        const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations })
        });
        
        if (!response.ok) {
            throw new Error(`API è¿”å›ç‹€æ…‹ ${response.status}`);
        }
        
        const result = await response.json();
        console.log('API éŸ¿æ‡‰:', result);
        
        const elevations = result.results.map(r => r.elevation);
        console.log('é«˜åº¦æ•¸æ“š:', elevations);
        
        summary.innerText = `è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km`;
        renderChart(elevations);
    } catch (err) {
        console.error('API éŒ¯èª¤:', err);
        summary.innerHTML = 'âŒ è³‡æ–™ç²å–å¤±æ•—<br><span style="color: #FFD700; font-weight: bold;">ğŸŒ è©²åŠŸèƒ½éœ€é€£ç¶²</span><br>' + err.message;
    }
}

function renderChart(elevations) {
    console.log('renderChart() è¢«èª¿ç”¨ï¼Œé«˜åº¦æ•¸æ“šé•·åº¦:', elevations.length);
    
    // ç²å–å¤©ç·šé«˜åº¦
    const antennaHeightStart = parseFloat(document.getElementById('antennaHeightStart').value) || 0;
    const antennaHeightEnd = parseFloat(document.getElementById('antennaHeightEnd').value) || 0;
    
    // èª¿æ•´èµ·é»å’Œçµ‚é»çš„é«˜åº¦ï¼šåŠ ä¸Šå¤©ç·šé«˜åº¦
    const adjustedElevations = elevations.map((elev, i) => {
        if (i === 0) {
            return elev + antennaHeightStart;
        } else if (i === elevations.length - 1) {
            return elev + antennaHeightEnd;
        }
        return elev;
    });
    
    // ä¿å­˜elevationæ•¸æ“šä¾›ä¸Šä¸‹éµæŒ‰éˆ•ä½¿ç”¨
    elevationData = adjustedElevations;
    console.log('å·²ä¿å­˜elevationæ•¸æ“šï¼ˆå«å¤©ç·šé«˜åº¦ï¼‰');
    console.log('å¤©ç·šé«˜åº¦ - Aé»:', antennaHeightStart, 'Bé»:', antennaHeightEnd);
    
    const ctx = document.getElementById('elevationChart');
    if (!ctx) {
        console.error('æ‰¾ä¸åˆ° elevationChart canvas');
        return;
    }
    
    // å‰µå»ºé»é¡è‰²æ•¸çµ„ï¼Œé»˜èªç‚ºç¶ è‰²
    const pointColors = adjustedElevations.map((_, i) => '#28a745');
    
    // åŸå§‹è¦–è·é€£ç·š (ä¸è€ƒæ…®åœ°çƒæ›²åº¦)
    const losLine = adjustedElevations.map((_, i) => 
        adjustedElevations[0] + (adjustedElevations[adjustedElevations.length-1] - adjustedElevations[0]) * (i / (adjustedElevations.length-1))
    );
    
    // è€ƒæ…®åœ°çƒæ›²åº¦çš„è¦–è·é€£ç·š
    // åœ°çƒåŠå¾‘ (m)
    const R = 6371000;
    
    // è¨ˆç®—è·¯å¾‘ç¸½é•·åº¦ (km)
    const sLat = parseFloat(document.getElementById('sLat').value);
    const sLng = parseFloat(document.getElementById('sLng').value);
    const eLat = parseFloat(document.getElementById('eLat').value);
    const eLng = parseFloat(document.getElementById('eLng').value);
    const totalDist = getDistance(sLat, sLng, eLat, eLng);
    const totalDistM = totalDist * 1000; // è½‰æ›ç‚ºå…¬å°º
    
    // è¨ˆç®—åœ°çƒæ›²åº¦ä¸‹é™ (åœ°çƒæ›²ç‡é€ æˆçš„é«˜åº¦å·®)
    const losLineWithCurvature = adjustedElevations.map((_, i) => {
        const f = i / (adjustedElevations.length - 1);
        const distFromStart = totalDistM * f;
        
        // ç›´ç·šé«˜åº¦
        const straightLineHeight = adjustedElevations[0] + (adjustedElevations[adjustedElevations.length-1] - adjustedElevations[0]) * f;
        
        // åœ°çƒæ›²åº¦ä¸‹é™ = (d1 * d2) / (2 * R)
        // å…¶ä¸­ d1 æ˜¯å¾Aé»çš„è·é›¢ï¼Œd2 æ˜¯å¾Bé»çš„è·é›¢
        const d1 = distFromStart;
        const d2 = totalDistM - distFromStart;
        const earthDrop = (d1 * d2) / (2 * R);
        
        // è€ƒæ…®æ›²åº¦å¾Œçš„é«˜åº¦
        return straightLineHeight - earthDrop;
    });

    if (chartInstance) {
        chartInstance.destroy();
    }
    
    // åˆå§‹åŒ–æ¨™ç±¤åç§»é‡ï¼ˆå¦‚æœé‚„æ²’æœ‰è¨­å®šï¼‰
    if (typeof window.labelAOffset === 'undefined') {
        window.labelAOffset = { x: 0, y: -40 };
    }
    if (typeof window.labelBOffset === 'undefined') {
        window.labelBOffset = { x: 0, y: -40 };
    }
    
    // æ‹–æ›³ç‹€æ…‹è®Šæ•¸
    if (typeof window.draggingLabel === 'undefined') {
        window.draggingLabel = null; // 'A', 'B', or null
        window.dragStartX = 0;
        window.dragStartY = 0;
        window.dragStartOffsetX = 0;
        window.dragStartOffsetY = 0;
    }
    
    // æ–‡å­—æ–¹å‘ç‹€æ…‹è®Šæ•¸ï¼ˆç”¨æ–¼åŒ—ä¸ƒè·¯å’Œç«ç‡’åæ¨™ç±¤ï¼‰
    if (typeof window.labelTextVertical === 'undefined') {
        window.labelTextVertical = {
            A: false,  // false = æ©«å‘ï¼Œtrue = å‚ç›´
            B: false
        };
    }
    
    // è‡ªå®šç¾©æ’ä»¶ï¼šåœ¨åœ–è¡¨ä¸Šç¹ªè£½ A é»å’Œ B é»åœ°åæ¨™æ³¨ï¼ˆå¯æ‹–æ›³ï¼‰
    const pointLabelPlugin = {
        id: 'pointLabelPlugin',
        afterDatasetsDraw: (chart) => {
            const ctx = chart.ctx;
            const xAxis = chart.scales.x;
            const yAxis = chart.scales.y;
            const chartArea = chart.chartArea;
            
            // ç²å–åœ°å
            const nameA = window.elevationPointAName || 'Aé»';
            const nameB = window.elevationPointBName || 'Bé»';
            
            // ç²å–æ•¸æ“š
            const datasetIndex = 0;
            const dataset = chart.data.datasets[datasetIndex];
            
            // ç¹ªè£½ A é»æ¨™æ³¨
            if (dataset.data.length > 0) {
                const xA = xAxis.getPixelForValue(0);
                const yA = yAxis.getPixelForValue(dataset.data[0]);
                
                ctx.save();
                ctx.font = 'bold 14px Inter, sans-serif';
                
                const textWidthA = ctx.measureText(nameA).width;
                const paddingA = 8;
                const boxWidthA = textWidthA + paddingA * 2;
                const boxHeightA = 24;
                
                // ä½¿ç”¨åç§»é‡
                let labelXA = xA + window.labelAOffset.x;
                let labelYA = yA + window.labelAOffset.y;
                
                // ç¢ºä¿æ¨™ç±¤åœ¨åœ–è¡¨å€åŸŸå…§ - å·¦å³é‚Šç•Œæª¢æŸ¥
                const halfBoxWidth = boxWidthA / 2;
                if (labelXA - halfBoxWidth < chartArea.left) {
                    labelXA = chartArea.left + halfBoxWidth + 2;
                }
                if (labelXA + halfBoxWidth > chartArea.right) {
                    labelXA = chartArea.right - halfBoxWidth - 2;
                }
                
                // ä¸Šä¸‹é‚Šç•Œæª¢æŸ¥
                const halfBoxHeight = boxHeightA / 2;
                if (labelYA - halfBoxHeight < chartArea.top) {
                    labelYA = chartArea.top + halfBoxHeight + 2;
                }
                if (labelYA + halfBoxHeight > chartArea.bottom) {
                    labelYA = chartArea.bottom - halfBoxHeight - 2;
                }
                
                const boxY = labelYA - halfBoxHeight;
                const boxX = labelXA - halfBoxWidth;
                
                // ä¿å­˜æ¨™ç±¤ä½ç½®ä¾›æ‹–æ›³æª¢æ¸¬ä½¿ç”¨
                window.labelABounds = {
                    x: boxX,
                    y: boxY,
                    width: boxWidthA,
                    height: boxHeightA,
                    centerX: labelXA,
                    centerY: labelYA
                };
                
                // ç¹ªè£½èƒŒæ™¯æ¡†ï¼ˆå¦‚æœæ­£åœ¨æ‹–æ›³å‰‡æ”¹è®Šæ¨£å¼ï¼‰
                if (window.draggingLabel === 'A') {
                    ctx.fillStyle = 'rgba(255, 229, 143, 1)';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 2;
                } else {
                    ctx.fillStyle = 'rgba(255, 229, 143, 0.95)';
                }
                ctx.beginPath();
                ctx.roundRect(boxX, boxY, boxWidthA, boxHeightA, 5);
                ctx.fill();
                
                // æ·»åŠ é‚Šæ¡†
                ctx.strokeStyle = 'rgba(255, 200, 100, 1)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // ç¹ªè£½æ–‡å­—
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#022';
                
                // æ ¹æ“šå‚ç›´ç‹€æ…‹æ±ºå®šå¦‚ä½•ç¹ªè£½æ–‡å­—
                if (window.labelTextVertical.A) {
                    // å‚ç›´é¡¯ç¤º - é€å­—ç¹ªè£½
                    ctx.save();
                    const chars = nameA.split('');
                    const charHeight = boxHeightA / (chars.length + 1);
                    chars.forEach((char, i) => {
                        ctx.fillText(char, labelXA, boxY + charHeight * (i + 1));
                    });
                    ctx.restore();
                } else {
                    // æ©«å‘é¡¯ç¤º
                    ctx.fillText(nameA, labelXA, boxY + boxHeightA / 2);
                }
                
                // ç¹ªè£½æ‹–æ›³åœ–æ¨™ï¼ˆå°åœ“é»è¡¨ç¤ºå¯æ‹–æ›³ï¼‰
                ctx.fillStyle = 'rgba(0, 34, 34, 0.3)';
                ctx.beginPath();
                ctx.arc(boxX + 6, boxY + boxHeightA / 2, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(boxX + boxWidthA - 6, boxY + boxHeightA / 2, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            // ç¹ªè£½ B é»æ¨™æ³¨
            if (dataset.data.length > 0) {
                const lastIndex = dataset.data.length - 1;
                const xB = xAxis.getPixelForValue(lastIndex);
                const yB = yAxis.getPixelForValue(dataset.data[lastIndex]);
                
                ctx.save();
                ctx.font = 'bold 14px Inter, sans-serif';
                
                const textWidthB = ctx.measureText(nameB).width;
                const paddingB = 8;
                const boxWidthB = textWidthB + paddingB * 2;
                const boxHeightB = 24;
                
                // ä½¿ç”¨åç§»é‡
                let labelXB = xB + window.labelBOffset.x;
                let labelYB = yB + window.labelBOffset.y;
                
                // ç¢ºä¿æ¨™ç±¤åœ¨åœ–è¡¨å€åŸŸå…§ - å·¦å³é‚Šç•Œæª¢æŸ¥
                const halfBoxWidth = boxWidthB / 2;
                if (labelXB - halfBoxWidth < chartArea.left) {
                    labelXB = chartArea.left + halfBoxWidth + 2;
                }
                if (labelXB + halfBoxWidth > chartArea.right) {
                    labelXB = chartArea.right - halfBoxWidth - 2;
                }
                
                // ä¸Šä¸‹é‚Šç•Œæª¢æŸ¥
                const halfBoxHeight = boxHeightB / 2;
                if (labelYB - halfBoxHeight < chartArea.top) {
                    labelYB = chartArea.top + halfBoxHeight + 2;
                }
                if (labelYB + halfBoxHeight > chartArea.bottom) {
                    labelYB = chartArea.bottom - halfBoxHeight - 2;
                }
                
                const boxY = labelYB - halfBoxHeight;
                const boxX = labelXB - halfBoxWidth;
                
                // ä¿å­˜æ¨™ç±¤ä½ç½®ä¾›æ‹–æ›³æª¢æ¸¬ä½¿ç”¨
                window.labelBBounds = {
                    x: boxX,
                    y: boxY,
                    width: boxWidthB,
                    height: boxHeightB,
                    centerX: labelXB,
                    centerY: labelYB
                };
                
                // ç¹ªè£½èƒŒæ™¯æ¡†ï¼ˆå¦‚æœæ­£åœ¨æ‹–æ›³å‰‡æ”¹è®Šæ¨£å¼ï¼‰
                if (window.draggingLabel === 'B') {
                    ctx.fillStyle = 'rgba(255, 229, 143, 1)';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 2;
                } else {
                    ctx.fillStyle = 'rgba(255, 229, 143, 0.95)';
                }
                ctx.beginPath();
                ctx.roundRect(boxX, boxY, boxWidthB, boxHeightB, 5);
                ctx.fill();
                
                // æ·»åŠ é‚Šæ¡†
                ctx.strokeStyle = 'rgba(255, 200, 100, 1)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // ç¹ªè£½æ–‡å­—
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#022';
                
                // æ ¹æ“šå‚ç›´ç‹€æ…‹æ±ºå®šå¦‚ä½•ç¹ªè£½æ–‡å­—
                if (window.labelTextVertical.B) {
                    // å‚ç›´é¡¯ç¤º - é€å­—ç¹ªè£½
                    ctx.save();
                    const chars = nameB.split('');
                    const charHeight = boxHeightB / (chars.length + 1);
                    chars.forEach((char, i) => {
                        ctx.fillText(char, labelXB, boxY + charHeight * (i + 1));
                    });
                    ctx.restore();
                } else {
                    // æ©«å‘é¡¯ç¤º
                    ctx.fillText(nameB, labelXB, boxY + boxHeightB / 2);
                }
                
                // ç¹ªè£½æ‹–æ›³åœ–æ¨™ï¼ˆå°åœ“é»è¡¨ç¤ºå¯æ‹–æ›³ï¼‰
                ctx.fillStyle = 'rgba(0, 34, 34, 0.3)';
                ctx.beginPath();
                ctx.arc(boxX + 6, boxY + boxHeightB / 2, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(boxX + boxWidthB - 6, boxY + boxHeightB / 2, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
    };
    
    // å…¨å±€è®Šæ•¸ï¼šä¿å­˜ç•¶å‰é¸å®šçš„é»ç´¢å¼•
    window.currentSelectedPointIndex = -1;
    
    // å‰µå»ºé»åŠå¾‘æ•¸çµ„ï¼ˆé¸å®šé»è®Šå¤§ï¼‰
    const pointRadiusArray = adjustedElevations.map((_, i) => 3);
    const pointHoverRadiusArray = adjustedElevations.map((_, i) => 8);
    
    // å‰µå»ºé»é¡è‰²æ•¸çµ„
    const pointColorArray = adjustedElevations.map((_, i) => '#28a745');

    chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: pathData.map(p => Math.round(parseFloat(p.dist)).toString()),
            datasets: [
                { 
                    label: 'è¦–è·é€£ç·š (è€ƒæ…®åœ°çƒæ›²åº¦)', 
                    data: losLineWithCurvature, 
                    borderColor: '#dc3545', 
                    borderDash: [5, 5], 
                    fill: false, 
                    pointRadius: 0 
                },
                { 
                    label: 'åœ°å½¢æµ·æ‹” (m)', 
                    data: adjustedElevations, 
                    borderColor: '#28a745', 
                    backgroundColor: 'rgba(40, 167, 69, 0.2)', 
                    fill: true, 
                    tension: 0.3, 
                    pointRadius: pointRadiusArray,
                    pointHoverRadius: pointHoverRadiusArray,
                    pointBackgroundColor: pointColorArray,
                    pointBorderWidth: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            onClick: (event, elements) => {
                // âœ… æ¸…ç©ºåŒé«˜åº¦é»è¨˜éŒ„ï¼Œé–‹å§‹æ–°çš„é¸æ“‡
                selectedPointsInCurrentHeight.clear();
                
                console.log('é»æ“Šåœ–è¡¨ï¼Œelements:', elements);
                if (elements.length > 0) {
                    const idx = elements[0].index;
                    console.log('é¸ä¸­ç´¢å¼•:', idx);
                    
                    // æ›´æ–°æ‰€æœ‰é»çš„é¡è‰²å’Œå¤§å°
                    for (let i = 0; i < pointColorArray.length; i++) {
                        if (i === idx) {
                            pointColorArray[i] = '#FFD700';
                            pointRadiusArray[i] = 6; // é»ƒé»è®Šå¤§
                            pointHoverRadiusArray[i] = 10;
                        } else {
                            pointColorArray[i] = '#28a745';
                            pointRadiusArray[i] = 3;
                            pointHoverRadiusArray[i] = 8;
                        }
                    }
                    
                    window.currentSelectedPointIndex = idx;
                    
                    // æ›´æ–°åœ–è¡¨
                    chartInstance.data.datasets[1].pointBackgroundColor = pointColorArray;
                    chartInstance.data.datasets[1].pointRadius = pointRadiusArray;
                    chartInstance.data.datasets[1].pointHoverRadius = pointHoverRadiusArray;
                    chartInstance.update();
                    
                    showMap(idx, elevations[idx]);
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: (ctx) => `é«˜åº¦: ${ctx.parsed.y} m | è·é›¢: ${pathData[ctx.dataIndex].dist} km`
                    }
                },
                legend: {
                    labels: {
                        color: '#e8eef5',
                        font: { size: 14 },
                        boxWidth: 15,
                        boxHeight: 15,
                        padding: 10,
                        usePointStyle: false
                    },
                    display: true,
                    position: 'top',
                    align: 'center'
                }
            },
            scales: {
                x: {
                    ticks: { color: '#e8eef5', font: { size: 12 }, maxRotation: 0, minRotation: 0 },
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    title: { display: true, text: 'è·é›¢ (km)', color: '#e8eef5' }
                },
                y: {
                    ticks: { color: '#e8eef5', font: { size: 12 } },
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    title: { display: true, text: 'é«˜åº¦ (m)', color: '#e8eef5' },
                    min: isNaN(parseFloat(document.getElementById('minElevation').value)) ? undefined : parseFloat(document.getElementById('minElevation').value),
                    max: isNaN(parseFloat(document.getElementById('maxElevation').value)) ? undefined : parseFloat(document.getElementById('maxElevation').value)
                }
            }
        },
        plugins: [pointLabelPlugin]
    });
    
    // æ·»åŠ æ»‘é¼ æ‹–æ›³äº‹ä»¶ç›£è½å™¨
    const canvas = document.getElementById('elevationChart');
    
    // æª¢æŸ¥é»æ˜¯å¦åœ¨æ¨™ç±¤å…§
    function isPointInLabel(x, y, labelBounds) {
        if (!labelBounds) return false;
        return x >= labelBounds.x && 
               x <= labelBounds.x + labelBounds.width &&
               y >= labelBounds.y && 
               y <= labelBounds.y + labelBounds.height;
    }
    
    // å–å¾—æ»‘é¼ ç›¸å°æ–¼ canvas çš„åº§æ¨™
    function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }
    
    // mousedown äº‹ä»¶
    canvas.addEventListener('mousedown', function(e) {
        const pos = getMousePos(canvas, e);
        
        // è¨˜éŒ„é»æ“Šèµ·å§‹ä½ç½®å’Œæ™‚é–“ï¼ˆç”¨æ–¼æª¢æ¸¬å–®æ“Šï¼‰
        window.clickStartTime = Date.now();
        window.clickStartPos = { x: pos.x, y: pos.y };
        
        // æª¢æŸ¥æ˜¯å¦é»æ“Šåœ¨æ¨™ç±¤ä¸Š
        if (isPointInLabel(pos.x, pos.y, window.labelABounds)) {
            window.draggingLabel = 'A';
            window.dragStartX = pos.x;
            window.dragStartY = pos.y;
            window.dragStartOffsetX = window.labelAOffset.x;
            window.dragStartOffsetY = window.labelAOffset.y;
            canvas.style.cursor = 'grabbing';
            e.preventDefault();
        } else if (isPointInLabel(pos.x, pos.y, window.labelBBounds)) {
            window.draggingLabel = 'B';
            window.dragStartX = pos.x;
            window.dragStartY = pos.y;
            window.dragStartOffsetX = window.labelBOffset.x;
            window.dragStartOffsetY = window.labelBOffset.y;
            canvas.style.cursor = 'grabbing';
            e.preventDefault();
        }
    });
    
    // mousemove äº‹ä»¶
    canvas.addEventListener('mousemove', function(e) {
        const pos = getMousePos(canvas, e);
        
        if (window.draggingLabel) {
            // è¨ˆç®—æ–°çš„åç§»é‡
            const deltaX = pos.x - window.dragStartX;
            const deltaY = pos.y - window.dragStartY;
            
            if (window.draggingLabel === 'A') {
                window.labelAOffset.x = window.dragStartOffsetX + deltaX;
                window.labelAOffset.y = window.dragStartOffsetY + deltaY;
            } else if (window.draggingLabel === 'B') {
                window.labelBOffset.x = window.dragStartOffsetX + deltaX;
                window.labelBOffset.y = window.dragStartOffsetY + deltaY;
            }
            
            // æ›´æ–°åœ–è¡¨
            chartInstance.update('none'); // ä½¿ç”¨ 'none' æ¨¡å¼ä»¥ç²å¾—æ›´å¹³æ»‘çš„æ‹–æ›³
            e.preventDefault();
        } else {
            // æ›´æ–°æ»‘é¼ æ¸¸æ¨™æ¨£å¼
            if (isPointInLabel(pos.x, pos.y, window.labelABounds) || 
                isPointInLabel(pos.x, pos.y, window.labelBBounds)) {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'default';
            }
        }
    });
    
    // mouseup äº‹ä»¶
    canvas.addEventListener('mouseup', function(e) {
        const pos = getMousePos(canvas, e);
        const clickDuration = Date.now() - (window.clickStartTime || 0);
        const moveDistance = window.clickStartPos ? 
            Math.sqrt(Math.pow(pos.x - window.clickStartPos.x, 2) + Math.pow(pos.y - window.clickStartPos.y, 2)) : 0;
        
        // æª¢æ¸¬æ˜¯å¦ç‚ºå–®æ“Šï¼ˆæ™‚é–“çŸ­ä¸”ç§»å‹•è·é›¢å°ï¼‰
        const isClick = clickDuration < 300 && moveDistance < 5;
        
        if (window.draggingLabel && isClick) {
            // å–®æ“Šæ¨™ç±¤æ™‚åˆ‡æ›æ–‡å­—æ–¹å‘
            const label = window.draggingLabel;
            window.labelTextVertical[label] = !window.labelTextVertical[label];
            console.log(`åˆ‡æ›${label}æ¨™ç±¤æ–‡å­—æ–¹å‘ï¼š${window.labelTextVertical[label] ? 'å‚ç›´' : 'æ©«å‘'}`);
        }
        
        if (window.draggingLabel) {
            window.draggingLabel = null;
            canvas.style.cursor = 'default';
            chartInstance.update(); // æœ€çµ‚æ›´æ–°
        }
    });
    
    // mouseleave äº‹ä»¶ï¼ˆç•¶æ»‘é¼ é›¢é–‹ canvas æ™‚åœæ­¢æ‹–æ›³ï¼‰
    canvas.addEventListener('mouseleave', function(e) {
        if (window.draggingLabel) {
            window.draggingLabel = null;
            canvas.style.cursor = 'default';
            chartInstance.update();
        }
    });
    
    // è§¸æ§æ”¯æ´ï¼ˆç§»å‹•è£ç½®ï¼‰
    canvas.addEventListener('touchstart', function(e) {
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            const pos = getMousePos(canvas, touch);
            
            if (isPointInLabel(pos.x, pos.y, window.labelABounds)) {
                window.draggingLabel = 'A';
                window.dragStartX = pos.x;
                window.dragStartY = pos.y;
                window.dragStartOffsetX = window.labelAOffset.x;
                window.dragStartOffsetY = window.labelAOffset.y;
                e.preventDefault();
            } else if (isPointInLabel(pos.x, pos.y, window.labelBBounds)) {
                window.draggingLabel = 'B';
                window.dragStartX = pos.x;
                window.dragStartY = pos.y;
                window.dragStartOffsetX = window.labelBOffset.x;
                window.dragStartOffsetY = window.labelBOffset.y;
                e.preventDefault();
            }
        }
    });
    
    canvas.addEventListener('touchmove', function(e) {
        if (window.draggingLabel && e.touches.length === 1) {
            const touch = e.touches[0];
            const pos = getMousePos(canvas, touch);
            
            const deltaX = pos.x - window.dragStartX;
            const deltaY = pos.y - window.dragStartY;
            
            if (window.draggingLabel === 'A') {
                window.labelAOffset.x = window.dragStartOffsetX + deltaX;
                window.labelAOffset.y = window.dragStartOffsetY + deltaY;
            } else if (window.draggingLabel === 'B') {
                window.labelBOffset.x = window.dragStartOffsetX + deltaX;
                window.labelBOffset.y = window.dragStartOffsetY + deltaY;
            }
            
            chartInstance.update('none');
            e.preventDefault();
        }
    });
    
    canvas.addEventListener('touchend', function(e) {
        if (window.draggingLabel) {
            window.draggingLabel = null;
            chartInstance.update();
        }
    });
    
    console.log('åœ–è¡¨å·²ç¹ªè£½');
    
    // è·å–å½“å‰é€‰å®šçš„ä½ç½®
    const selectedPointInput = document.getElementById('selectedPointIndex');
    let currentSelectedIndex = 0; // é»˜è®¤ä¸ºç¬¬ä¸€ä¸ªç‚¹
    
    if (selectedPointInput && selectedPointInput.value) {
        // å¦‚æœå·²ç»æœ‰é€‰å®šä½ç½®ï¼Œä¿æŒä¸å˜
        currentSelectedIndex = parseInt(selectedPointInput.value) - 1; // è½¬æ¢ä¸º0-basedç´¢å¼•
        
        // æ£€æŸ¥ç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
        if (currentSelectedIndex < 0 || currentSelectedIndex >= adjustedElevations.length) {
            currentSelectedIndex = 0;
        }
    } else if (isFirstProfileGeneration) {
        // åªåœ¨ç¬¬ä¸€æ¬¡æ—¶è®¾ç½®ä¸º1
        if (selectedPointInput) {
            selectedPointInput.value = 1;
        }
        currentSelectedIndex = 0;
    }
    
    console.log('å½“å‰é€‰å®šç´¢å¼•:', currentSelectedIndex);
    
    // è°ƒç”¨ showMap å‡½æ•°æ›´æ–°æ˜¾ç¤ºï¼ˆä½¿ç”¨å½“å‰é€‰å®šçš„ç´¢å¼•ï¼‰
    showMap(currentSelectedIndex, adjustedElevations[currentSelectedIndex]);
    
    // åªåœ¨ç¬¬ä¸€æ¬¡æ™‚æ¨™è¨˜ç‚ºå·²ç”Ÿæˆ
    if (isFirstProfileGeneration) {
        isFirstProfileGeneration = false;
    }
    
    // é¡¯ç¤ºèµ·é»çµ‚é»è·¯å¾‘åœ°åœ–
    showRouteMap();
}

function showMap(index, height) {
    console.log('showMap() è¢«èª¿ç”¨ï¼Œç´¢å¼•:', index, 'é«˜åº¦:', height);
    
    const p = pathData[index];
    const mapContainer = document.getElementById('map-container');
    const mapFrame = document.getElementById('map-frame');
    const mapDetails = document.getElementById('map-details');
    const selectedPointInput = document.getElementById('selectedPointIndex');

    if (!mapContainer || !mapFrame || !mapDetails) {
        console.error('æ‰¾ä¸åˆ°åœ°åœ–ç›¸é—œå…ƒç´ ');
        return;
    }

    // æ›´æ–°é¸å®šé»çš„è¼¸å…¥æ¬„ä½
    if (selectedPointInput) {
        selectedPointInput.value = index + 1; // ç´¢å¼•+1ä»¥ä¾¿äººé¡å¯è®€
        console.log('é¸å®šé»å·²æ›´æ–°:', index + 1);
    }

    // æ›´æ–°åœ–è¡¨ä¸­çš„é»é¡è‰²å’Œå¤§å°ï¼šé¸ä¸­çš„è®Šé»ƒè‰²ä¸”è®Šå¤§ï¼Œå…¶ä»–è®Šç¶ è‰²
    if (chartInstance && chartInstance.data.datasets[1].pointBackgroundColor) {
        const pointColors = chartInstance.data.datasets[1].pointBackgroundColor;
        const pointRadius = chartInstance.data.datasets[1].pointRadius;
        const pointHoverRadius = chartInstance.data.datasets[1].pointHoverRadius;
        
        for (let i = 0; i < pointColors.length; i++) {
            if (i === index) {
                pointColors[i] = '#FFD700';
                pointRadius[i] = 6; // é»ƒé»è®Šå¤§
                pointHoverRadius[i] = 10;
            } else {
                pointColors[i] = '#28a745';
                pointRadius[i] = 3;
                pointHoverRadius[i] = 8;
            }
        }
        chartInstance.update();
        console.log('åœ–è¡¨é»é¡è‰²å’Œå¤§å°å·²æ›´æ–°ï¼Œé¸ä¸­é»ç´¢å¼•:', index);
    }

    window.currentSelectedPointIndex = index;

    // ç²å–Aé»å’ŒBé»çš„åœ°å
    const nameA = window.elevationPointAName || 'Aé»';
    const nameB = window.elevationPointBName || 'Bé»';
    
    // è¨ˆç®—ç¸½è·é›¢ï¼ˆå¾Aåˆ°Bçš„ç¸½è·é›¢ï¼‰
    const totalDistance = pathData[pathData.length - 1].dist;
    
    // è¨ˆç®—è·é›¢Bé»çš„è·é›¢
    const distanceToB = (totalDistance - parseFloat(p.dist)).toFixed(3);

    // è¨ˆç®—é®è”½æƒ…æ³
    let obstructionInfo = '';
    if (elevationData && elevationData.length > 0 && chartInstance && chartInstance.data.datasets[0]) {
        // ç²å–è¦–è·é€£ç·šï¼ˆè€ƒæ…®åœ°çƒæ›²åº¦ï¼‰çš„æ•¸æ“š
        const losLineData = chartInstance.data.datasets[0].data;
        
        if (losLineData && losLineData[index] !== undefined) {
            const losHeight = losLineData[index]; // è¦–è·é€£ç·šåœ¨è©²é»çš„é«˜åº¦
            const terrainHeight = elevationData[index]; // åœ°å½¢åœ¨è©²é»çš„é«˜åº¦
            const clearance = losHeight - terrainHeight; // é›¢é®è”½çš„è·é›¢ï¼ˆæ­£æ•¸è¡¨ç¤ºæ²’é®è”½ï¼Œè² æ•¸è¡¨ç¤ºè¢«é®è”½ï¼‰
            
            // åˆ¤æ–·æ˜¯å¦ç‚ºèµ·é»æˆ–çµ‚é»
            const isStartPoint = (index === 0);
            const isEndPoint = (index === elevationData.length - 1);
            
            if (clearance > 0) {
                // æ²’æœ‰é®è”½ï¼Œé¡¯ç¤ºç¶ è‰²
                obstructionInfo = `<br><span style="color: #FFD700;">é®è”½:</span> <span style="color: #51cf66; font-weight: bold;">${clearance.toFixed(2)} m</span>`;
            } else if (clearance === 0 && (isStartPoint || isEndPoint)) {
                // èµ·é»æˆ–çµ‚é»çš„0ç±³é®è”½é¡¯ç¤ºç¶ è‰²
                obstructionInfo = `<br><span style="color: #FFD700;">é®è”½:</span> <span style="color: #51cf66; font-weight: bold;">0.00 m</span>`;
            } else {
                // æœ‰é®è”½æˆ–å…¶å®ƒé»çš„0ç±³ï¼Œé¡¯ç¤ºç´…è‰²
                obstructionInfo = `<br><span style="color: #FFD700;">é®è”½:</span> <span style="color: #ff6b6b; font-weight: bold;">${Math.abs(clearance).toFixed(2)} m</span>`;
            }
        }
    }

    mapContainer.style.display = 'block';
    mapDetails.innerHTML = `<strong><span style="color: #FFD700;">é¸å®šä½ç½®è³‡è¨Š:</span> <span style="color: #5ff0d5;">${index + 1}</span></strong><br><span style="color: #FFD700;">è·é›¢${nameA}:</span> <span style="color: #5ff0d5;">${p.dist} km</span><br><span style="color: #FFD700;">è·é›¢${nameB}:</span> <span style="color: #5ff0d5;">${distanceToB} km</span><br><span style="color: #FFD700;">æµ·æ‹”é«˜åº¦:</span> <span style="color: #5ff0d5;">${height} m</span><br><span style="color: #FFD700;">åº§æ¨™:</span> <span style="color: #5ff0d5;">${p.lat}, ${p.lng}</span>${obstructionInfo}`;



    const mapUrl = `https://maps.google.com/maps?q=${p.lat},${p.lng}&t=k&z=17&output=embed`;
    mapFrame.src = mapUrl;
    
    console.log('åœ°åœ– URL:', mapUrl);
    // ç§»é™¤è‡ªå‹•æ»¾å‹•åˆ°åœ°åœ–çš„åŠŸèƒ½ï¼Œä½†åœ°åœ–ä»æœƒæ›´æ–°
    // mapContainer.scrollIntoView({ behavior: 'smooth' });
}

// æ–°å¢ï¼šé¡¯ç¤ºèµ·é»çµ‚é»è·¯å¾‘åœ°åœ–
let routeMapInstance = null;

function showRouteMap() {
    console.log('showRouteMap() è¢«èª¿ç”¨');
    
    if (!pathData || pathData.length < 2) {
        console.log('è·¯å¾‘æ•¸æ“šä¸è¶³ï¼Œç„¡æ³•é¡¯ç¤ºè·¯å¾‘åœ°åœ–');
        return;
    }
    
    const routeMapContainer = document.getElementById('route-map-container');
    const routeMapDiv = document.getElementById('route-map');
    const routeStartInfo = document.getElementById('route-start-info');
    const routeEndInfo = document.getElementById('route-end-info');
    const routeDistanceInfo = document.getElementById('route-distance-info');
    
    if (!routeMapContainer || !routeMapDiv) {
        console.error('æ‰¾ä¸åˆ°è·¯å¾‘åœ°åœ–ç›¸é—œå…ƒç´ ');
        return;
    }
    
    // ç²å–èµ·é»å’Œçµ‚é»
    const startPoint = pathData[0];
    const endPoint = pathData[pathData.length - 1];
    
    // ç²å–Aé»å’ŒBé»çš„åœ°å
    const nameA = window.elevationPointAName || 'Aé»';
    const nameB = window.elevationPointBName || 'Bé»';
    
    // è¨ˆç®—ç›´ç·šè·é›¢
    const distance = endPoint.dist;
    
    // æ›´æ–°è³‡è¨Šé¡¯ç¤º
    if (routeStartInfo) {
        routeStartInfo.textContent = `${nameA} (${startPoint.lat}, ${startPoint.lng})`;
    }
    if (routeEndInfo) {
        routeEndInfo.textContent = `${nameB} (${endPoint.lat}, ${endPoint.lng})`;
    }
    if (routeDistanceInfo) {
        routeDistanceInfo.textContent = `${distance} km`;
    }
    
    // é¡¯ç¤ºå®¹å™¨
    routeMapContainer.style.display = 'block';
    
    const startLat = parseFloat(startPoint.lat);
    const startLng = parseFloat(startPoint.lng);
    const endLat = parseFloat(endPoint.lat);
    const endLng = parseFloat(endPoint.lng);
    
    // è¨ˆç®—åœ°åœ–ä¸­å¿ƒé»
    const centerLat = (startLat + endLat) / 2;
    const centerLng = (startLng + endLng) / 2;
    
    // è¨ˆç®—åˆé©çš„ç¸®æ”¾ç´šåˆ¥
    const latDiff = Math.abs(startLat - endLat);
    const lngDiff = Math.abs(startLng - endLng);
    const maxDiff = Math.max(latDiff, lngDiff);
    let zoom = 13;
    if (maxDiff > 0.1) zoom = 11;
    if (maxDiff > 0.5) zoom = 9;
    if (maxDiff > 1) zoom = 8;
    if (maxDiff > 2) zoom = 7;
    
    // æ¸…ç©ºå®¹å™¨
    routeMapDiv.innerHTML = '';
    
    // ç­‰å¾… Google Maps API è¼‰å…¥
    if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
        console.error('Google Maps API å°šæœªè¼‰å…¥');
        routeMapDiv.innerHTML = '<div style="padding:20px; color:#ff6b6b; text-align:center;">Google Maps è¼‰å…¥ä¸­...</div>';
        
        // å˜—è©¦é‡æ–°è¼‰å…¥
        setTimeout(() => {
            if (typeof google !== 'undefined' && typeof google.maps !== 'undefined') {
                showRouteMap();
            }
        }, 2000);
        return;
    }
    
    // å‰µå»ºåœ°åœ–
    routeMapInstance = new google.maps.Map(routeMapDiv, {
        center: { lat: centerLat, lng: centerLng },
        zoom: zoom,
        mapTypeId: 'satellite' // ä½¿ç”¨è¡›æ˜Ÿåœ–
    });
    
    // å‰µå»ºèµ·é»æ¨™è¨˜ï¼ˆè—è‰²ï¼‰
    const startMarker = new google.maps.Marker({
        position: { lat: startLat, lng: startLng },
        map: routeMapInstance,
        title: `${nameA} (èµ·é»)`,
        label: {
            text: 'A',
            color: 'white',
            fontWeight: 'bold'
        },
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: '#0066FF',
            fillOpacity: 1,
            strokeColor: '#FFFFFF',
            strokeWeight: 2,
            scale: 10
        }
    });
    
    // å‰µå»ºçµ‚é»æ¨™è¨˜ï¼ˆç´…è‰²ï¼‰
    const endMarker = new google.maps.Marker({
        position: { lat: endLat, lng: endLng },
        map: routeMapInstance,
        title: `${nameB} (çµ‚é»)`,
        label: {
            text: 'B',
            color: 'white',
            fontWeight: 'bold'
        },
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: '#FF0000',
            fillOpacity: 1,
            strokeColor: '#FFFFFF',
            strokeWeight: 2,
            scale: 10
        }
    });
    
    // æ·»åŠ è³‡è¨Šè¦–çª—
    const startInfoWindow = new google.maps.InfoWindow({
        content: `<div style="color:#000; padding:5px;"><strong>${nameA}</strong><br>èµ·é»<br>${startLat}, ${startLng}</div>`
    });
    
    const endInfoWindow = new google.maps.InfoWindow({
        content: `<div style="color:#000; padding:5px;"><strong>${nameB}</strong><br>çµ‚é»<br>${endLat}, ${endLng}</div>`
    });
    
    // é»æ“Šæ¨™è¨˜é¡¯ç¤ºè³‡è¨Š
    startMarker.addListener('click', () => {
        startInfoWindow.open(routeMapInstance, startMarker);
    });
    
    endMarker.addListener('click', () => {
        endInfoWindow.open(routeMapInstance, endMarker);
    });
    
    // ç•«ç›´ç·šé€£æ¥å…©é»ï¼ˆé»ƒè‰²ï¼‰
    const line = new google.maps.Polyline({
        path: [
            { lat: startLat, lng: startLng },
            { lat: endLat, lng: endLng }
        ],
        geodesic: true,
        strokeColor: '#FFFF00',
        strokeOpacity: 1.0,
        strokeWeight: 3,
        map: routeMapInstance
    });
    
    // èª¿æ•´è¦–åœ–ä»¥åŒ…å«æ‰€æœ‰æ¨™è¨˜
    const bounds = new google.maps.LatLngBounds();
    bounds.extend({ lat: startLat, lng: startLng });
    bounds.extend({ lat: endLat, lng: endLng });
    routeMapInstance.fitBounds(bounds);
    
    console.log('è·¯å¾‘åœ°åœ–å·²ç”Ÿæˆ (ä½¿ç”¨ Google Maps JavaScript API)');
}


function updatePointFromInput() {
    // âœ… æ¸…ç©ºåŒé«˜åº¦é»è¨˜éŒ„ï¼Œé–‹å§‹æ–°çš„é¸æ“‡
    selectedPointsInCurrentHeight.clear();
    
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (!selectedPointInput || !selectedPointInput.value) return;
    
    let inputValue = parseInt(selectedPointInput.value);
    
    // âœ… æª¢æŸ¥é‚Šç•Œ - æ”¹ç‚ºä½¿ç”¨ elevationData.length
    if (inputValue < 1) {
        inputValue = 1;
        selectedPointInput.value = 1;
    } else if (inputValue > elevationData.length) {
        inputValue = elevationData.length;
        selectedPointInput.value = elevationData.length;
    }
    
    const index = inputValue - 1; // è½‰æ›å›0-basedç´¢å¼•
    console.log('æ‰‹å‹•è¼¸å…¥çš„é»æ•¸å€¼:', inputValue, 'å°æ‡‰ç´¢å¼•:', index);
    showMap(index, elevationData[index]);
}

function incrementSelectedPoint() {
    // âœ… æ¸…ç©ºåŒé«˜åº¦é»è¨˜éŒ„ï¼Œé–‹å§‹æ–°çš„é¸æ“‡
    selectedPointsInCurrentHeight.clear();
    
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (!selectedPointInput || !selectedPointInput.value) return;
    
    let currentIndex = parseInt(selectedPointInput.value) - 1; // è½‰æ›å›0-basedç´¢å¼•
    let newIndex = currentIndex + 1;
    
    // âœ… å¾ªç’°éæ­·è€Œä¸æ˜¯åœåœ¨æœ€å¾Œ
    if (newIndex >= elevationData.length) {
        newIndex = 0;  // æ”¹ç‚ºå¾ªç’°å›åˆ°é–‹å§‹
    }
    
    console.log('ä¸Šéµï¼šå¾ç´¢å¼•', currentIndex, 'ç§»åˆ°', newIndex);
    showMap(newIndex, elevationData[newIndex]);
}

function decrementSelectedPoint() {
    // âœ… æ¸…ç©ºåŒé«˜åº¦é»è¨˜éŒ„ï¼Œé–‹å§‹æ–°çš„é¸æ“‡
    selectedPointsInCurrentHeight.clear();
    
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (!selectedPointInput || !selectedPointInput.value) return;
    
    let currentIndex = parseInt(selectedPointInput.value) - 1; // è½‰æ›å›0-basedç´¢å¼•
    let newIndex = currentIndex - 1;
    
    // âœ… å¾ªç’°éæ­·è€Œä¸æ˜¯åœåœ¨0
    if (newIndex < 0) {
        newIndex = elevationData.length - 1;  // æ”¹ç‚ºå¾ªç’°åˆ°æœ€å¾Œ
    }
    
    console.log('ä¸‹éµï¼šå¾ç´¢å¼•', currentIndex, 'ç§»åˆ°', newIndex);
    showMap(newIndex, elevationData[newIndex]);
}

function jumpToStartPoint() {
    // âœ… æ¸…ç©ºåŒé«˜åº¦é»è¨˜éŒ„ï¼Œé–‹å§‹æ–°çš„é¸æ“‡
    selectedPointsInCurrentHeight.clear();
    
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    
    console.log('è·³åˆ°èµ·é»ï¼šç´¢å¼• 0');
    showMap(0, elevationData[0]);
}

function jumpToEndPoint() {
    // âœ… æ¸…ç©ºåŒé«˜åº¦é»è¨˜éŒ„ï¼Œé–‹å§‹æ–°çš„é¸æ“‡
    selectedPointsInCurrentHeight.clear();
    
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    
    const endIndex = elevationData.length - 1;
    console.log('è·³åˆ°çµ‚é»ï¼šç´¢å¼•', endIndex);
    showMap(endIndex, elevationData[endIndex]);
}

function jumpToMinPoint() {
    // âœ… æ¸…ç©ºåŒé«˜åº¦é»è¨˜éŒ„ï¼Œé–‹å§‹æ–°çš„é¸æ“‡
    selectedPointsInCurrentHeight.clear();
    
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    
    // æ‰¾åˆ°æœ€å°å€¼çš„ç´¢å¼•
    let minValue = elevationData[0];
    let minIndex = 0;
    
    for (let i = 1; i < elevationData.length; i++) {
        if (elevationData[i] < minValue) {
            minValue = elevationData[i];
            minIndex = i;
        }
    }
    
    console.log('è·³åˆ°æœ€å°å€¼ï¼šç´¢å¼•', minIndex, 'é«˜åº¦', minValue);
    showMap(minIndex, elevationData[minIndex]);
}

function jumpToMaxPoint() {
    // âœ… æ¸…ç©ºåŒé«˜åº¦é»è¨˜éŒ„ï¼Œé–‹å§‹æ–°çš„é¸æ“‡
    selectedPointsInCurrentHeight.clear();
    
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    
    // æ‰¾åˆ°æœ€å¤§å€¼çš„ç´¢å¼•
    let maxValue = elevationData[0];
    let maxIndex = 0;
    
    for (let i = 1; i < elevationData.length; i++) {
        if (elevationData[i] > maxValue) {
            maxValue = elevationData[i];
            maxIndex = i;
        }
    }
    
    console.log('è·³åˆ°æœ€å¤§å€¼ï¼šç´¢å¼•', maxIndex, 'é«˜åº¦', maxValue);
    showMap(maxIndex, elevationData[maxIndex]);
}

// è·³åˆ°æœ€å¤§é®è”½é»
function jumpToMaxObstruction() {
    // æ¸…ç©ºåŒé«˜åº¦é»è¨˜éŒ„
    selectedPointsInCurrentHeight.clear();
    
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    
    if (!chartInstance || !chartInstance.data.datasets[0]) {
        alert('ç„¡æ³•ç²å–è¦–è·é€£ç·šæ•¸æ“š');
        return;
    }
    
    // ç²å–è¦–è·é€£ç·šï¼ˆè€ƒæ…®åœ°çƒæ›²åº¦ï¼‰çš„æ•¸æ“š
    const losLineData = chartInstance.data.datasets[0].data;
    
    // æ‰¾åˆ°æœ€å¤§é®è”½é»ï¼ˆåœ°å½¢é«˜åº¦ - è¦–è·é€£ç·šé«˜åº¦çš„æœ€å¤§è² å€¼ï¼‰
    let maxObstruction = 0;
    let maxObstructionIndex = -1;
    
    for (let i = 1; i < elevationData.length - 1; i++) { // æ’é™¤èµ·é»å’Œçµ‚é»
        const terrainHeight = elevationData[i];
        const losHeight = losLineData[i];
        const clearance = losHeight - terrainHeight;
        
        if (clearance < 0 && clearance < maxObstruction) {
            maxObstruction = clearance;
            maxObstructionIndex = i;
        }
    }
    
    if (maxObstructionIndex === -1) {
        alert('âœ“ è·¯å¾‘ä¸Šæ²’æœ‰é®è”½é»');
        return;
    }
    
    console.log('è·³åˆ°æœ€å¤§é®è”½é»ï¼šç´¢å¼•', maxObstructionIndex, 'é®è”½é‡', Math.abs(maxObstruction).toFixed(2), 'm');
    showMap(maxObstructionIndex, elevationData[maxObstructionIndex]);
}

// è·³åˆ°è·é›¢èµ·é»ç¬¬ä¸€å€‹é®è”½é»
function jumpToFirstObstructionFromStart() {
    // æ¸…ç©ºåŒé«˜åº¦é»è¨˜éŒ„
    selectedPointsInCurrentHeight.clear();
    
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    
    if (!chartInstance || !chartInstance.data.datasets[0]) {
        alert('ç„¡æ³•ç²å–è¦–è·é€£ç·šæ•¸æ“š');
        return;
    }
    
    // ç²å–è¦–è·é€£ç·šï¼ˆè€ƒæ…®åœ°çƒæ›²åº¦ï¼‰çš„æ•¸æ“š
    const losLineData = chartInstance.data.datasets[0].data;
    
    // å¾èµ·é»é–‹å§‹å°‹æ‰¾ç¬¬ä¸€å€‹é®è”½é»
    for (let i = 1; i < elevationData.length - 1; i++) { // æ’é™¤èµ·é»å’Œçµ‚é»
        const terrainHeight = elevationData[i];
        const losHeight = losLineData[i];
        const clearance = losHeight - terrainHeight;
        
        if (clearance < 0) {
            console.log('æ‰¾åˆ°è·é›¢èµ·é»ç¬¬ä¸€å€‹é®è”½é»ï¼šç´¢å¼•', i, 'é®è”½é‡', Math.abs(clearance).toFixed(2), 'm');
            showMap(i, elevationData[i]);
            return;
        }
    }
    
    alert('âœ“ å¾èµ·é»é–‹å§‹æ²’æœ‰ç™¼ç¾é®è”½é»');
}

// è·³åˆ°è·é›¢çµ‚é»ç¬¬ä¸€å€‹é®è”½é»
function jumpToFirstObstructionFromEnd() {
    // æ¸…ç©ºåŒé«˜åº¦é»è¨˜éŒ„
    selectedPointsInCurrentHeight.clear();
    
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    
    if (!chartInstance || !chartInstance.data.datasets[0]) {
        alert('ç„¡æ³•ç²å–è¦–è·é€£ç·šæ•¸æ“š');
        return;
    }
    
    // ç²å–è¦–è·é€£ç·šï¼ˆè€ƒæ…®åœ°çƒæ›²åº¦ï¼‰çš„æ•¸æ“š
    const losLineData = chartInstance.data.datasets[0].data;
    
    // å¾çµ‚é»å‘èµ·é»å°‹æ‰¾ç¬¬ä¸€å€‹é®è”½é»
    for (let i = elevationData.length - 2; i > 0; i--) { // æ’é™¤èµ·é»å’Œçµ‚é»
        const terrainHeight = elevationData[i];
        const losHeight = losLineData[i];
        const clearance = losHeight - terrainHeight;
        
        if (clearance < 0) {
            console.log('æ‰¾åˆ°è·é›¢çµ‚é»ç¬¬ä¸€å€‹é®è”½é»ï¼šç´¢å¼•', i, 'é®è”½é‡', Math.abs(clearance).toFixed(2), 'm');
            showMap(i, elevationData[i]);
            return;
        }
    }
    
    alert('âœ“ å¾çµ‚é»é–‹å§‹æ²’æœ‰ç™¼ç¾é®è”½é»');
}

// âœ… å…¨å±€è®Šæ•¸ï¼šè¨˜éŒ„ç•¶å‰é«˜åº¦å·²é¸éçš„é»
let selectedPointsInCurrentHeight = new Set();
// âœ… æ–°å¢ï¼šè¨˜éŒ„ä¸Šä¸€æ¬¡æŒ‰ä¸‹çš„æŒ‰éˆ•é¡å‹ ('plus' æˆ– 'minus')
let lastButtonPressed = null;
// âœ… æ–°å¢ï¼šè¨˜éŒ„æŒ‰ä¸‹æŒ‰éˆ•å‰çš„æŒ‡å®šä½ç½®
let previousPointIndex = null;

function jumpToHigherPoint() {
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (!selectedPointInput || !selectedPointInput.value) {
        alert('è«‹å…ˆé¸æ“‡ä¸€å€‹é»');
        return;
    }
    
    // âœ… è¨˜éŒ„æŒ‰ä¸‹æŒ‰éˆ•å‰çš„æŒ‡å®šä½ç½®
    previousPointIndex = parseInt(selectedPointInput.value) - 1;
    console.log('æŒ‰ä¸‹ + æŒ‰éˆ•å‰çš„æŒ‡å®šä½ç½®:', previousPointIndex);
    
    // âœ… æª¢æŸ¥æ˜¯å¦éœ€è¦é‡ç½®ç›¸åŒé«˜åº¦åŠŸèƒ½ï¼ˆä¸Šä¸€æ¬¡æŒ‰çš„æ˜¯ - æŒ‰éˆ•ï¼‰
    if (lastButtonPressed === 'minus') {
        console.log('ä¸Šä¸€æ¬¡æŒ‰çš„æ˜¯ - æŒ‰éˆ•ï¼Œé‡ç½®ç›¸åŒé«˜åº¦åŠŸèƒ½');
        selectedPointsInCurrentHeight.clear();
    }
    
    // âœ… è¨˜éŒ„é€™æ¬¡æŒ‰çš„æ˜¯ + æŒ‰éˆ•
    lastButtonPressed = 'plus';
    
    const currentIndex = previousPointIndex;
    const currentHeight = elevationData[currentIndex];
    
    // å…ˆå°‡ç•¶å‰é»æ¨™è¨˜ç‚ºå·²é¸
    if (!selectedPointsInCurrentHeight.has(currentIndex)) {
        selectedPointsInCurrentHeight.add(currentIndex);
        console.log('æ¨™è¨˜ç•¶å‰é»ç‚ºå·²é¸:', currentIndex);
    }
    
    // ç¬¬1æ­¥ï¼šæ‰¾æ‰€æœ‰ç›¸åŒé«˜åº¦çš„é»
    let sameHeightPoints = [];
    for (let i = 0; i < elevationData.length; i++) {
        if (Math.abs(elevationData[i] - currentHeight) < 0.01) {
            sameHeightPoints.push(i);
        }
    }
    
    // ç¬¬2æ­¥ï¼šæª¢æŸ¥åŒé«˜åº¦çš„é»ä¸­æ˜¯å¦é‚„æœ‰æœªé¸éçš„
    if (sameHeightPoints.length > 0) {
        // æ‰¾æœªé¸éçš„åŒé«˜åº¦é»ï¼ˆæ’é™¤ç•¶å‰é»ï¼‰
        for (let idx of sameHeightPoints) {
            if (!selectedPointsInCurrentHeight.has(idx) && idx !== currentIndex) {
                console.log('é¸æ“‡æœªé¸éçš„åŒé«˜åº¦é»:', idx, 'é«˜åº¦:', elevationData[idx]);
                selectedPointsInCurrentHeight.add(idx);
                showMap(idx, elevationData[idx]);
                return;
            }
        }
        
        // å¦‚æœæ‰€æœ‰åŒé«˜åº¦é»éƒ½é¸éäº†ï¼Œé€²å…¥ç¬¬3æ­¥
        console.log('ç›¸åŒé«˜åº¦çš„é»éƒ½å·²é¸éï¼Œå°‹æ‰¾æ›´é«˜çš„é«˜åº¦');
    }
    
    // ç¬¬3æ­¥ï¼šåŒé«˜åº¦çš„é»éƒ½é¸å®Œäº†ï¼Œæ‰¾ä¸‹ä¸€å€‹æ›´é«˜çš„ã€ä¸åŒã€‘é«˜åº¦
    let higherHeights = new Set();
    for (let i = 0; i < elevationData.length; i++) {
        if (elevationData[i] > currentHeight + 0.001) {
            higherHeights.add(Math.round(elevationData[i] * 100) / 100);
        }
    }
    
    if (higherHeights.size === 0) {
        console.log('æ²’æœ‰æ›´é«˜çš„é«˜åº¦ï¼Œç„¡å‹•ä½œ');
        return;
    }
    
    // æ‰¾æœ€ä½çš„æ›´é«˜é«˜åº¦
    let targetHeight = Math.min(...higherHeights);
    
    // æ¸…ç©ºå·²é¸é»è¨˜éŒ„ï¼Œæº–å‚™é¸æ–°é«˜åº¦çš„é»
    selectedPointsInCurrentHeight.clear();
    
    // åœ¨å¾ŒçºŒä½ç½®æ‰¾è©²é«˜åº¦çš„ç¬¬ä¸€å€‹é»
    let nextIndex = -1;
    for (let i = currentIndex + 1; i < elevationData.length; i++) {
        if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
            nextIndex = i;
            break;
        }
    }
    
    // å¦‚æœå¾Œé¢æ²’æœ‰ï¼Œå¾å‰é¢æ‰¾
    if (nextIndex === -1) {
        for (let i = 0; i < currentIndex; i++) {
            if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
                nextIndex = i;
                break;
            }
        }
    }
    
    if (nextIndex === -1) {
        console.log('æ‰¾ä¸åˆ°ç›®æ¨™é«˜åº¦çš„é»');
        return;
    }
    
    console.log('è·³åˆ°æ›´é«˜çš„é»ï¼šå¾ç´¢å¼•', currentIndex, '(é«˜åº¦', currentHeight, ') è·³åˆ°ç´¢å¼•', nextIndex, '(é«˜åº¦', elevationData[nextIndex], ')');
    selectedPointsInCurrentHeight.add(nextIndex);
    showMap(nextIndex, elevationData[nextIndex]);
}

function jumpToLowerPoint() {
    if (!elevationData || elevationData.length === 0) {
        alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
        return;
    }
    
    const selectedPointInput = document.getElementById('selectedPointIndex');
    if (!selectedPointInput || !selectedPointInput.value) {
        alert('è«‹å…ˆé¸æ“‡ä¸€å€‹é»');
        return;
    }
    
    // âœ… è¨˜éŒ„æŒ‰ä¸‹æŒ‰éˆ•å‰çš„æŒ‡å®šä½ç½®
    previousPointIndex = parseInt(selectedPointInput.value) - 1;
    console.log('æŒ‰ä¸‹ - æŒ‰éˆ•å‰çš„æŒ‡å®šä½ç½®:', previousPointIndex);
    
    // âœ… æª¢æŸ¥æ˜¯å¦éœ€è¦é‡ç½®ç›¸åŒé«˜åº¦åŠŸèƒ½ï¼ˆä¸Šä¸€æ¬¡æŒ‰çš„æ˜¯ + æŒ‰éˆ•ï¼‰
    if (lastButtonPressed === 'plus') {
        console.log('ä¸Šä¸€æ¬¡æŒ‰çš„æ˜¯ + æŒ‰éˆ•ï¼Œé‡ç½®ç›¸åŒé«˜åº¦åŠŸèƒ½');
        selectedPointsInCurrentHeight.clear();
    }
    
    // âœ… è¨˜éŒ„é€™æ¬¡æŒ‰çš„æ˜¯ - æŒ‰éˆ•
    lastButtonPressed = 'minus';
    
    const currentIndex = previousPointIndex;
    const currentHeight = elevationData[currentIndex];
    
    // å…ˆå°‡ç•¶å‰é»æ¨™è¨˜ç‚ºå·²é¸
    if (!selectedPointsInCurrentHeight.has(currentIndex)) {
        selectedPointsInCurrentHeight.add(currentIndex);
        console.log('æ¨™è¨˜ç•¶å‰é»ç‚ºå·²é¸:', currentIndex);
    }
    
    // ç¬¬1æ­¥ï¼šæ‰¾æ‰€æœ‰ç›¸åŒé«˜åº¦çš„é»
    let sameHeightPoints = [];
    for (let i = 0; i < elevationData.length; i++) {
        if (Math.abs(elevationData[i] - currentHeight) < 0.01) {
            sameHeightPoints.push(i);
        }
    }
    
    // ç¬¬2æ­¥ï¼šæª¢æŸ¥åŒé«˜åº¦çš„é»ä¸­æ˜¯å¦é‚„æœ‰æœªé¸éçš„
    if (sameHeightPoints.length > 0) {
        // æ‰¾æœªé¸éçš„åŒé«˜åº¦é»ï¼ˆåå‘æœå°‹ï¼Œå¾å¾Œå¾€å‰ï¼Œæ’é™¤ç•¶å‰é»ï¼‰
        for (let i = sameHeightPoints.length - 1; i >= 0; i--) {
            let idx = sameHeightPoints[i];
            if (!selectedPointsInCurrentHeight.has(idx) && idx !== currentIndex) {
                console.log('é¸æ“‡æœªé¸éçš„åŒé«˜åº¦é»:', idx, 'é«˜åº¦:', elevationData[idx]);
                selectedPointsInCurrentHeight.add(idx);
                showMap(idx, elevationData[idx]);
                return;
            }
        }
        
        // å¦‚æœæ‰€æœ‰åŒé«˜åº¦é»éƒ½é¸éäº†ï¼Œé€²å…¥ç¬¬3æ­¥
        console.log('ç›¸åŒé«˜åº¦çš„é»éƒ½å·²é¸éï¼Œå°‹æ‰¾æ›´ä½çš„é«˜åº¦');
    }
    
    // ç¬¬3æ­¥ï¼šåŒé«˜åº¦çš„é»éƒ½é¸å®Œäº†ï¼Œæ‰¾ä¸‹ä¸€å€‹æ›´ä½çš„ã€ä¸åŒã€‘é«˜åº¦
    let lowerHeights = new Set();
    for (let i = 0; i < elevationData.length; i++) {
        if (elevationData[i] < currentHeight - 0.001) {
            lowerHeights.add(Math.round(elevationData[i] * 100) / 100);
        }
    }
    
    if (lowerHeights.size === 0) {
        console.log('æ²’æœ‰æ›´ä½çš„é«˜åº¦ï¼Œç„¡å‹•ä½œ');
        return;
    }
    
    // æ‰¾æœ€é«˜çš„æ›´ä½é«˜åº¦
    let targetHeight = Math.max(...lowerHeights);
    
    // æ¸…ç©ºå·²é¸é»è¨˜éŒ„ï¼Œæº–å‚™é¸æ–°é«˜åº¦çš„é»
    selectedPointsInCurrentHeight.clear();
    
    // åœ¨å‰é¢ä½ç½®æ‰¾è©²é«˜åº¦çš„é»ï¼ˆåå‘æœå°‹ï¼‰
    let nextIndex = -1;
    for (let i = currentIndex - 1; i >= 0; i--) {
        if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
            nextIndex = i;
            break;
        }
    }
    
    // å¦‚æœå‰é¢æ²’æœ‰ï¼Œå¾å¾Œé¢æ‰¾
    if (nextIndex === -1) {
        for (let i = currentIndex + 1; i < elevationData.length; i++) {
            if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
                nextIndex = i;
                break;
            }
        }
    }
    
    if (nextIndex === -1) {
        console.log('æ‰¾ä¸åˆ°ç›®æ¨™é«˜åº¦çš„é»');
        return;
    }
    
    console.log('è·³åˆ°æ›´ä½çš„é»ï¼šå¾ç´¢å¼•', currentIndex, '(é«˜åº¦', currentHeight, ') è·³åˆ°ç´¢å¼•', nextIndex, '(é«˜åº¦', elevationData[nextIndex], ')');
    selectedPointsInCurrentHeight.add(nextIndex);
    showMap(nextIndex, elevationData[nextIndex]);
}





// å…¨å±€è®Šæ•¸ä»¥ä¿å­˜elevationæ•¸æ“šï¼Œä¾›ä¸Šä¸‹éµä½¿ç”¨
let elevationData = [];
// è¿½è¹¤æ˜¯å¦æ˜¯ç¬¬ä¸€æ¬¡ç”Ÿæˆå‰–é¢åœ–
let isFirstProfileGeneration = true;

console.log('é«˜åº¦åœ– JavaScript å·²åŠ è¼‰');
</script>
<script>
// === GPS TAB ISOLATION FIX ===
// Ensure GPS controls and results ONLY render when GPS tab is active
(function(){
  function enforceGpsIsolation(){
    var gpsTab = document.getElementById('gps-content');
    var isGpsActive = gpsTab && gpsTab.classList.contains('active');

    var ids = ['gpsCalcBtn','gpsResetBtn','gpsClearBtn','gpsRes','gps-controls-container'];
    ids.forEach(function(id){
      var el = document.getElementById(id);
      if(!el) return;
      if(isGpsActive){
        el.style.display = '';
        el.style.visibility = 'visible';
      }else{
        el.style.display = 'none';
        el.style.visibility = 'hidden';
      }
    });
  }

  // Hook into existing showTab if present
  var _showTab = window.showTab;
  window.showTab = function(tab){
    if(typeof _showTab === 'function'){
      _showTab(tab);
    }else{
      // fallback minimal tab switch
      document.querySelectorAll('.tab-content').forEach(function(c){c.classList.remove('active');});
      var t = document.getElementById(tab+'-content');
      if(t) t.classList.add('active');
    }
    enforceGpsIsolation();
  };

  // Initial enforcement after load
  document.addEventListener('DOMContentLoaded', function(){
    // remove accidental multiple actives
    var actives = document.querySelectorAll('.tab-content.active');
    if(actives.length>1){
      actives.forEach(function(c,i){ if(i>0) c.classList.remove('active'); });
    }
    enforceGpsIsolation();
  });
})();
</script>

<script>
// å¼·åˆ¶ä¿®æ­£GPSåœ°é»Aå’ŒBçš„padding - ä½¿ç”¨JavaScriptç›´æ¥æ“ä½œDOM
(function() {
  function fixGpsPadding() {
    console.log('é–‹å§‹ä¿®æ­£GPS padding...');
    
    // æ‰¾åˆ°æ‰€æœ‰ .gps-ig.orange-border-card å…ƒç´ 
    const gpsBoxes = document.querySelectorAll('.gps-ig.orange-border-card');
    console.log('æ‰¾åˆ°', gpsBoxes.length, 'å€‹GPSæ¡†');
    
    gpsBoxes.forEach((box, index) => {
      // å¼·åˆ¶è¨­å®špadding
      box.style.padding = '10px 12px';
      box.style.paddingTop = '10px';
      box.style.paddingBottom = '10px';
      box.style.paddingLeft = '12px';
      box.style.paddingRight = '12px';
      box.style.setProperty('padding', '10px 12px', 'important');
      
      console.log('å·²ä¿®æ­£GPSæ¡†', index + 1, 'çš„padding');
    });
    
    // ä¹Ÿä¿®æ­£æ‰€æœ‰ .gps-ig å…ƒç´ 
    const allGpsBoxes = document.querySelectorAll('.gps-ig');
    allGpsBoxes.forEach((box, index) => {
      box.style.setProperty('padding', '10px 12px', 'important');
    });
    
    console.log('GPS paddingä¿®æ­£å®Œæˆï¼');
  }
  
  // é é¢è¼‰å…¥å®Œæˆå¾ŒåŸ·è¡Œ
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', fixGpsPadding);
  } else {
    fixGpsPadding();
  }
  
  // å»¶é²å†åŸ·è¡Œä¸€æ¬¡ï¼Œç¢ºä¿æ‰€æœ‰å…ƒç´ éƒ½å·²æ¸²æŸ“
  setTimeout(fixGpsPadding, 500);
  setTimeout(fixGpsPadding, 1000);
  setTimeout(fixGpsPadding, 2000);
})();
</script>

<!-- === LocalStorage & JSON Backup Script === -->
<script>
const LS_KEY="html_saved_configs";

function collectFields(){
  const data={};
  document.querySelectorAll("input,select,textarea").forEach(el=>{
    if(el.id && el.id !== 'ls_save_name' && el.id !== 'ls_import' && el.id !== 'sort_order') {
      data[el.id]=el.value;
    }
  });
  return data;
}

function applyFields(data){
  Object.keys(data).forEach(id=>{
    const el=document.getElementById(id);
    if(el && id !== 'timestamp') el.value=data[id];
  });
  window.scrollTo({top:0,behavior:"smooth"});
  alert("âœ“ åƒæ•¸å·²æˆåŠŸå¡«å…¥");
}

function lsLoadTable(){
  const tb=document.getElementById("ls_table");
  if(!tb) return;
  tb.innerHTML="";
  const all=JSON.parse(localStorage.getItem(LS_KEY)||"{}");
  let entries = Object.entries(all);
  
  if(entries.length === 0){
    tb.innerHTML="<tr><td colspan='2' style='text-align:center; padding:16px; color:var(--muted);'>å°šç„¡å·²ä¿å­˜çš„åƒæ•¸</td></tr>";
    return;
  }
  
  // æ’åº
  const sortOrder = document.getElementById("sort_order")?.value || "time-new";
  if(sortOrder === "name-az"){
    // æª”æ¡ˆåç¨±A>Z
    entries.sort((a, b) => a[0].localeCompare(b[0], 'zh-Hant'));
  } else if(sortOrder === "name-za"){
    // æª”æ¡ˆåç¨±Z>A
    entries.sort((a, b) => b[0].localeCompare(a[0], 'zh-Hant'));
  } else if(sortOrder === "time-new"){
    // æª”æ¡ˆåç¨±æ–°>èˆŠ
    entries.sort((a, b) => {
      const timeA = a[1].timestamp || 0;
      const timeB = b[1].timestamp || 0;
      return timeB - timeA;
    });
  } else if(sortOrder === "time-old"){
    // æª”æ¡ˆåç¨±èˆŠ>æ–°
    entries.sort((a, b) => {
      const timeA = a[1].timestamp || 0;
      const timeB = b[1].timestamp || 0;
      return timeA - timeB;
    });
  }
  
  entries.forEach(([name, data])=>{
    const tr=document.createElement("tr");
    const dataStr = JSON.stringify(data).replace(/'/g, "\\'");
    tr.innerHTML=`
      <td style="padding:8px; color:var(--title); font-weight:600; word-break:break-all;">${name}</td>
      <td style="padding:8px; text-align:center; white-space:nowrap;">
        <button class="btn" style="padding:6px 16px; font-size:14px;" onclick='applyFields(${dataStr})'>å¡«å…¥</button>
        <button class="btn clear" style="padding:6px 16px; font-size:14px; margin-left:8px;" onclick='lsDelete("${name}")'>åˆªé™¤</button>
      </td>`;
    tb.appendChild(tr);
  });
}

function lsSave(){
  const name=document.getElementById("ls_save_name").value.trim();
  if(!name){
    alert("âŒ è«‹è¼¸å…¥åç¨±");
    return;
  }
  const all=JSON.parse(localStorage.getItem(LS_KEY)||"{}");
  const saveData = collectFields();
  saveData.timestamp = Date.now(); // æ·»åŠ æ™‚é–“æˆ³
  all[name]=saveData;
  localStorage.setItem(LS_KEY,JSON.stringify(all));
  document.getElementById("ls_save_name").value = "";
  lsLoadTable();
  alert("âœ“ åƒæ•¸å·²ä¿å­˜ï¼š" + name);
}

function lsDelete(name){
  if(!confirm("ç¢ºå®šè¦åˆªé™¤ã€Œ" + name + "ã€å—ï¼Ÿ")){
    return;
  }
  const all=JSON.parse(localStorage.getItem(LS_KEY)||"{}");
  delete all[name];
  localStorage.setItem(LS_KEY,JSON.stringify(all));
  lsLoadTable();
  alert("âœ“ å·²åˆªé™¤ï¼š" + name);
}

function lsExport(){
  const data = localStorage.getItem(LS_KEY)||"{}";
  const blob=new Blob([data],{type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  const date = new Date().toISOString().slice(0,10);
  a.download=`backup_${date}.json`;
  a.click();
  alert("âœ“ JSON æª”æ¡ˆå·²åŒ¯å‡º");
}

function lsImport(e){
  const f=e.target.files[0];
  if(!f) return;
  const r=new FileReader();
  r.onload=()=>{
    try{
      JSON.parse(r.result); // é©—è­‰JSONæ ¼å¼
      localStorage.setItem(LS_KEY,r.result);
      lsLoadTable();
      alert("âœ“ JSON æª”æ¡ˆå·²æˆåŠŸè®€å–");
    } catch(err){
      alert("âŒ æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹é¸æ“‡æœ‰æ•ˆçš„JSONæª”æ¡ˆ");
    }
  };
  r.readAsText(f);
  // é‡ç½®inputä»¥å…è¨±é‡è¤‡é¸æ“‡åŒä¸€æª”æ¡ˆ
  e.target.value = '';
}

document.addEventListener("DOMContentLoaded",lsLoadTable);
</script>

</body></html> 
<script>

// === å¤§æ°£æŠ˜å°„åˆ‡æ› (k = 4/3) ===
let useRefraction = false;
function toggleRefraction(){
  useRefraction = !useRefraction;
  const btn = document.getElementById('refBtn');
  btn.innerText = useRefraction ? 'ç›®å‰ï¼šå«å¤§æ°£æŠ˜å°„' : 'ç›®å‰ï¼šä¸å«å¤§æ°£æŠ˜å°„';
  btn.style.color = '#bb66ff';
  calculateMaxLOS();
}

// è¦†å¯«/è£œå¼· é€šè¦–è·é›¢è¨ˆç®—
function calculateMaxLOS(){
  const g1 = parseFloat(document.getElementById('los_g1').value) || 0;
  const h1 = parseFloat(document.getElementById('los_h1').value) || 0;
  const g2 = parseFloat(document.getElementById('los_g2').value) || 0;
  const h2 = parseFloat(document.getElementById('los_h2').value) || 0;

  // åœ°çƒåŠå¾‘ (m)
  let R = 6371000;
  if(useRefraction){
    R = R * 4 / 3; // å«å¤§æ°£æŠ˜å°„
  }

  const d1 = Math.sqrt(2 * R * (g1 + h1));
  const d2 = Math.sqrt(2 * R * (g2 + h2));
  const dTotal = (d1 + d2) / 1000;

  document.getElementById('los_output').innerHTML =
    'æœ€å¤§é€šè¦–è·é›¢ï¼š<span class="result-value">' + dTotal.toFixed(2) + '</span> km<br>' +
    '(A:' + (d1/1000).toFixed(2) + ' km, B:' + (d2/1000).toFixed(2) + ' km)';
}

/* ========== é«˜åº¦åœ–åŠŸèƒ½ ========== */
let elevationChart = null;
let elevationDataProvider = 'openmeteo'; // é»˜è®¤ä½¿ç”¨ Open-Meteo

function initElevationTab() {
  const apiSelector = document.getElementById('elevationApiSelector');
  if (apiSelector) {
    apiSelector.addEventListener('change', (e) => {
      elevationDataProvider = e.target.value;
      console.log('å·²åˆ‡æ¢è‡³:', elevationDataProvider);
    });
  }
}

async function fetchElevationData() {
  const sLat = parseFloat(document.getElementById('sLat')?.value);
  const sLng = parseFloat(document.getElementById('sLng')?.value);
  const eLat = parseFloat(document.getElementById('eLat')?.value);
  const eLng = parseFloat(document.getElementById('eLng')?.value);

  if (!sLat || !sLng || !eLat || !eLng) {
    showElevationStatus('âŒ è«‹å…ˆè¼¸å…¥Aé»å’ŒBé»åº§æ¨™', 'error');
    return;
  }

  showElevationStatus('â³ æ­£åœ¨è¼‰å…¥é«˜åº¦æ•¸æ“š...', 'loading');

  try {
    let elevationData = [];

    if (elevationDataProvider === 'openmeteo') {
      elevationData = await fetchElevationFromOpenMeteo(sLat, sLng, eLat, eLng);
    } else if (elevationDataProvider === 'astergdem') {
      elevationData = await fetchElevationFromAsterGdem(sLat, sLng, eLat, eLng);
    } else if (elevationDataProvider === 'usgs') {
      elevationData = await fetchElevationFromUSGS(sLat, sLng, eLat, eLng);
    }

    if (elevationData.length > 0) {
      drawElevationChart(elevationData);
      showElevationStatus('âœ“ é«˜åº¦æ•¸æ“šè¼‰å…¥æˆåŠŸ', 'success');
    } else {
      showElevationStatus('âŒ ç„¡æ³•ç²å–é«˜åº¦æ•¸æ“š', 'error');
    }
  } catch (error) {
    console.error('é«˜åº¦æ•¸æ“šç²å–å¤±æ•—:', error);
    showElevationStatus('âŒ æ•¸æ“šç²å–å¤±æ•—: ' + error.message, 'error');
  }
}

async function fetchElevationFromOpenMeteo(sLat, sLng, eLat, eLng) {
  try {
    // ç”Ÿæˆè·¯å¾‘ä¸Šçš„é»
    const points = generatePathPoints(sLat, sLng, eLat, eLng, 100);
    
    // Open-Meteo APIï¼šæ‰¹é‡ç²å–é«˜åº¦ï¼ˆè‡ªç”±æ–¹æ¡ˆï¼‰
    const lats = points.map(p => p.lat).join(',');
    const lons = points.map(p => p.lng).join(',');
    
    const url = `https://open-meteo.com/api/v1/elevation?latitude=${lats}&longitude=${lons}`;
    const response = await fetch(url);
    
    if (!response.ok) throw new Error('Open-Meteo API è«‹æ±‚å¤±æ•—');
    
    const data = await response.json();
    
    // è½‰æ›æ•¸æ“šæ ¼å¼
    return data.elevation.map((elev, idx) => ({
      distance: (idx / (data.elevation.length - 1)) * getDistance(sLat, sLng, eLat, eLng),
      elevation: elev || 0
    }));
  } catch (error) {
    console.error('Open-Meteo ç²å–å¤±æ•—:', error);
    throw error;
  }
}

async function fetchElevationFromAsterGdem(sLat, sLng, eLat, eLng) {
  try {
    const points = generatePathPoints(sLat, sLng, eLat, eLng, 100);
    const elevations = [];
    console.log('ä½¿ç”¨ ASTER GDEM æŸ¥è©¢é«˜åº¦æ•¸æ“š...');
    for (let point of points) {
      try {
        const fallbackUrl = `https://api.open-elevation.com/api/v1/lookup?locations=${point.lat},${point.lng}`;
        const response = await fetch(fallbackUrl);
        if (response.ok) {
          const data = await response.json();
          if (data.results && data.results.length > 0) {
            elevations.push(data.results[0].elevation || 0);
          } else {
            elevations.push(0);
          }
        }
        await new Promise(resolve => setTimeout(resolve, 50));
      } catch (error) {
        console.warn('ASTER GDEM æŸ¥è©¢å¤±æ•—:', error);
        elevations.push(0);
      }
    }
    const distance = getDistance(sLat, sLng, eLat, eLng);
    return elevations.map((elev, idx) => ({
      distance: (idx / (elevations.length - 1)) * distance,
      elevation: elev || 0
    }));
  } catch (error) {
    console.error('ASTER GDEM ç²å–å¤±æ•—:', error);
    throw error;
  }
}

async function fetchElevationFromUSGS(sLat, sLng, eLat, eLng) {
  try {
    // ç”Ÿæˆè·¯å¾‘ä¸Šçš„é»
    const points = generatePathPoints(sLat, sLng, eLat, eLng, 50); // USGS æœ‰é™åˆ¶ï¼Œæ¸›å°‘é»æ•¸
    
    const elevations = [];
    for (let point of points) {
      const url = `https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/getSamples?locations=[{"x":${point.lng},"y":${point.lat}}]&outSR=4326&f=json`;
      const response = await fetch(url);
      
      if (response.ok) {
        const data = await response.json();
        if (data.samples && data.samples.length > 0) {
          elevations.push(data.samples[0].value || 0);
        } else {
          elevations.push(0);
        }
      } else {
        elevations.push(0);
      }
      
      // å»¶é²è«‹æ±‚ä»¥é¿å…é€Ÿç‡é™åˆ¶
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    return elevations.map((elev, idx) => ({
      distance: (idx / (elevations.length - 1)) * getDistance(sLat, sLng, eLat, eLng),
      elevation: elev
    }));
  } catch (error) {
    console.error('USGS ç²å–å¤±æ•—:', error);
    throw error;
  }
}

function generatePathPoints(sLat, sLng, eLat, eLng, pointCount) {
  const points = [];
  for (let i = 0; i < pointCount; i++) {
    const fraction = i / (pointCount - 1);
    const lat = sLat + (eLat - sLat) * fraction;
    const lng = sLng + (eLng - sLng) * fraction;
    points.push({ lat, lng });
  }
  return points;
}

function drawElevationChart(data) {
  const ctx = document.getElementById('elevationCanvas');
  if (!ctx) {
    console.error('æ‰¾ä¸åˆ° elevationCanvas å…ƒç´ ');
    return;
  }

  const labels = data.map(d => Math.round(d.distance).toString());
  const elevations = data.map(d => d.elevation);

  if (elevationChart) {
    elevationChart.destroy();
  }

  elevationChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: 'é«˜åº¦ (m)',
        data: elevations,
        borderColor: '#5ff0d5',
        backgroundColor: 'rgba(95, 240, 213, 0.1)',
        tension: 0.3,
        fill: true,
        borderWidth: 2,
        pointRadius: 0,
        pointHoverRadius: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          labels: { color: '#e8eef5', font: { size: 14 } }
        }
      },
      scales: {
        y: {
          ticks: { color: '#a8b3c3', font: { size: 12 } },
          grid: { color: 'rgba(255,255,255,0.05)' },
          title: { display: true, text: 'æµ·æ‹”é«˜åº¦ (m)', color: '#85c9ff' }
        },
        x: {
          ticks: { color: '#a8b3c3', font: { size: 12 }, maxRotation: 0, minRotation: 0 },
          grid: { color: 'rgba(255,255,255,0.05)' },
          title: { display: true, text: 'è·é›¢ (km)', color: '#85c9ff' }
        }
      }
    }
  });
}

function showElevationStatus(message, type) {
  const statusDiv = document.getElementById('elevationStatus');
  if (statusDiv) {
    statusDiv.textContent = message;
    statusDiv.className = 'elevation-status ' + type;
  }
}

// åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', () => {
  initElevationTab();
});
