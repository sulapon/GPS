<!doctype html><html lang="zh-Hant"><head><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"> <script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
  navigator.serviceWorker.register('/GPS/service-worker.js')
    .then(function(){})
    .catch(function(){});
  });
}
(function () {
  const VERSION = '20241214';
  if (!location.search.includes('v=')) {
  const sep = location.search ? '&' : '?';
  location.replace(
    location.pathname +
    location.search +
    sep + 'v=' + VERSION +
    location.hash
  );
  }
})();

// ========================================
// ğŸ¯ éŸ¿æ‡‰å¼åº§æ¨™æ•¸æ“šç¶å®šç³»çµ±
// ========================================
/**
 * ä¸­å¤®åº§æ¨™æ•¸æ“šå­˜å„² - æ‰€æœ‰GPSå’Œåœ°åœ–æ“ä½œçš„å–®ä¸€æ•¸æ“šæº
 * ä½¿ç”¨ Proxy å¯¦ç¾éŸ¿æ‡‰å¼æ•¸æ“šç¶å®š
 */
const coordinateData = {
  A: {
    lat: 25.0336,
    lng: 121.5648,
    ele: null,
    name: ''
  },
  B: {
    lat: 25.1325,
    lng: 121.5065,
    ele: null,
    name: ''
  }
};

// å‰µå»ºéŸ¿æ‡‰å¼ä»£ç†
const reactiveCoordinates = new Proxy(coordinateData, {
  set(target, property, value) {
    // å¦‚æœæ˜¯åµŒå¥—å°è±¡ï¼ˆAæˆ–Bï¼‰
    if (property === 'A' || property === 'B') {
      const point = property;
      const oldValue = target[point];

      // å‰µå»ºåµŒå¥—å°è±¡çš„ä»£ç†
      const nestedProxy = new Proxy(value, {
        set(nestedTarget, nestedProp, nestedValue) {
          const oldNestedValue = nestedTarget[nestedProp];

          // è¨­ç½®æ–°å€¼
          nestedTarget[nestedProp] = nestedValue;

          // å¦‚æœå€¼çœŸçš„æ”¹è®Šäº†ï¼Œè§¸ç™¼æ›´æ–°
          if (oldNestedValue !== nestedValue) {
            updateAllViews(point, nestedProp, nestedValue);
          }

          return true;
        }
      });

      target[property] = nestedProxy;
      return true;
    }

    return true;
  }
});

// åˆå§‹åŒ–ç‚ºéŸ¿æ‡‰å¼å°è±¡
coordinateData.A = new Proxy(coordinateData.A, {
  set(target, property, value) {
    const oldValue = target[property];
    target[property] = value;

    if (oldValue !== value) {
      updateAllViews('A', property, value);
    }

    return true;
  }
});

coordinateData.B = new Proxy(coordinateData.B, {
  set(target, property, value) {
    const oldValue = target[property];
    target[property] = value;

    if (oldValue !== value) {
      updateAllViews('B', property, value);
    }

    return true;
  }
});

/**
 * æ›´æ–°æ‰€æœ‰è¦–åœ–ï¼ˆGPSåˆ†é ã€é«˜åº¦åœ–åˆ†é ã€åœ°åœ–æ¨™è¨˜ï¼‰
 * @param {string} point - 'A' æˆ– 'B'
 * @param {string} property - 'lat', 'lng', 'ele', æˆ– 'name'
 * @param {any} value - æ–°å€¼
 */
function updateAllViews(point, property, value) {
  // é˜²æ­¢å¾ªç’°æ›´æ–°
  if (window._isUpdating) return;
  window._isUpdating = true;

  try {
    // 1. æ›´æ–°GPSåˆ†é 
    if (property === 'lat') {
      const latInput = document.getElementById(`lat${point}`);
      if (latInput && latInput.value !== String(value)) {
        latInput.value = value;
        if (typeof updateDMSFromDecimal === 'function') {
          updateDMSFromDecimal(`lat${point}`);
        }
      }
    } else if (property === 'lng') {
      const lngInput = document.getElementById(`lon${point}`);
      if (lngInput && lngInput.value !== String(value)) {
        lngInput.value = value;
        if (typeof updateDMSFromDecimal === 'function') {
          updateDMSFromDecimal(`lon${point}`);
        }
      }
    } else if (property === 'ele') {
      const eleInput = document.getElementById(`ele${point}`);
      if (eleInput && eleInput.value !== String(value)) {
        eleInput.value = value;
      }
    } else if (property === 'name') {
      const nameInput = document.getElementById(`name${point}`);
      if (nameInput && nameInput.value !== String(value)) {
        nameInput.value = value;
      }

      // æ›´æ–°å…¨åŸŸè®Šæ•¸ä¾›å‰–é¢åœ–ä½¿ç”¨
      if (point === 'A') {
        window.elevationPointAName = value || 'Aé»';
      } else {
        window.elevationPointBName = value || 'Bé»';
      }
    }

    // 2. æ›´æ–°é«˜åº¦åœ–åˆ†é 
    if (property === 'lat') {
      const elevationLatInput = document.getElementById(point === 'A' ? 'sLat' : 'eLat');
      if (elevationLatInput && elevationLatInput.value !== String(value)) {
        elevationLatInput.value = value;
      }
    } else if (property === 'lng') {
      const elevationLngInput = document.getElementById(point === 'A' ? 'sLng' : 'eLng');
      if (elevationLngInput && elevationLngInput.value !== String(value)) {
        elevationLngInput.value = value;
      }
    } else if (property === 'name') {
      // æ›´æ–°é«˜åº¦åœ–åˆ†é çš„æ¨™ç±¤
      const labelLat = document.getElementById(`label${point}Lat`);
      const labelLng = document.getElementById(`label${point}Lng`);

      if (value && labelLat && labelLng) {
        labelLat.innerHTML = `<span style="color:#FFD700;">${value}</span>ç·¯åº¦`;
        labelLng.innerHTML = `<span style="color:#FFD700;">${value}</span>ç¶“åº¦`;
      } else if (labelLat && labelLng) {
        labelLat.textContent = `${point}é»ç·¯åº¦`;
        labelLng.textContent = `${point}é»ç¶“åº¦`;
      }
    }

    // 3. æ›´æ–°åœ°åœ–æ¨™è¨˜
    if (property === 'lat' || property === 'lng') {
      updateMapMarker(point);
    } else if (property === 'name') {
      updateMapMarkerPopup(point);
    }

  } finally {
    window._isUpdating = false;
  }
}

/**
 * æ›´æ–°åœ°åœ–æ¨™è¨˜ä½ç½®
 * @param {string} point - 'A' æˆ– 'B'
 */
function updateMapMarker(point) {
  if (!window.startMarker || !window.endMarker) return;

  const marker = point === 'A' ? window.startMarker : window.endMarker;
  const data = coordinateData[point];

  if (marker && data.lat && data.lng) {
    const currentLatLng = marker.getLatLng();
    if (currentLatLng.lat !== data.lat || currentLatLng.lng !== data.lng) {
      marker.setLatLng([data.lat, data.lng]);
    }
  }
}

/**
 * æ›´æ–°åœ°åœ–æ¨™è¨˜çš„popupå…§å®¹
 * @param {string} point - 'A' æˆ– 'B'
 */
function updateMapMarkerPopup(point) {
  if (!window.startMarker || !window.endMarker) return;

  const marker = point === 'A' ? window.startMarker : window.endMarker;
  const data = coordinateData[point];
  const label = point === 'A' ? 'èµ·é»' : 'çµ‚é»';

  if (marker && marker.getPopup()) {
    const content = `<div style="color:#000; padding:5px;"><strong>${data.name || point + 'é»'}</strong><br>${label}<br>${data.lat.toFixed(6)}, ${data.lng.toFixed(6)}</div>`;
    marker.getPopup().setContent(content);
  }
}

/**
 * å¾DOMè¼¸å…¥æ¡†è®€å–å€¼ä¸¦æ›´æ–°åˆ°éŸ¿æ‡‰å¼æ•¸æ“š
 * @param {string} point - 'A' æˆ– 'B'
 * @param {string} property - 'lat', 'lng', 'ele', æˆ– 'name'
 */
function updateFromInput(point, property) {
  if (window._isUpdating) return;

  let value;

  if (property === 'lat') {
    const input = document.getElementById(`lat${point}`);
    value = input ? parseFloat(input.value) : null;
  } else if (property === 'lng') {
    const input = document.getElementById(`lon${point}`);
    value = input ? parseFloat(input.value) : null;
  } else if (property === 'ele') {
    const input = document.getElementById(`ele${point}`);
    value = input ? parseFloat(input.value) : null;
  } else if (property === 'name') {
    const input = document.getElementById(`name${point}`);
    value = input ? input.value : '';
  }

  if (value !== null && value !== undefined && !isNaN(value) || property === 'name') {
    coordinateData[point][property] = value;
  }
}

// ========================================
// éŸ¿æ‡‰å¼ç³»çµ±çµæŸ
// ========================================

// ========================================
// ğŸ·ï¸ çµ±ä¸€åœ°åå–å¾—å‡½æ•¸
// ========================================
/**
 * çµ±ä¸€å¾ GPS åˆ†é å–å¾—åœ°å
 * é«˜åº¦åœ–åˆ†é ä¸å†ä½¿ç”¨ç¨ç«‹çš„ window.elevationPointAName/BName
 * è€Œæ˜¯ç›´æ¥ä½¿ç”¨ GPS åˆ†é çš„ nameA/nameB è¼¸å…¥æ¡†å€¼æˆ– coordinateData
 */
function getPointName(point) {
  // point å¯ä»¥æ˜¯ 'A' æˆ– 'B'
  const nameInput = document.getElementById(`name${point}`);
  if (nameInput && nameInput.value) {
    return nameInput.value;
  }
  // å¦‚æœè¼¸å…¥æ¡†æ²’æœ‰å€¼ï¼Œå¾ coordinateData å–
  if (coordinateData[point] && coordinateData[point].name) {
    return coordinateData[point].name;
  }
  // é è¨­å€¼
  return `${point}é»`;
}

// ç‚ºäº†å‘å¾Œç›¸å®¹ï¼Œä¿ç•™ window.elevationPointAName/BName
// ä½†æ”¹æˆå¾ getPointName å–å¾—
Object.defineProperty(window, 'elevationPointAName', {
  get: () => getPointName('A'),
  set: (value) => {
    // ç•¶è¨­å®šæ™‚ï¼Œæ›´æ–°åˆ° GPS åˆ†é çš„è¼¸å…¥æ¡†å’Œ coordinateData
    const nameInput = document.getElementById('nameA');
    if (nameInput) nameInput.value = value;
    coordinateData.A.name = value;
  }
});

Object.defineProperty(window, 'elevationPointBName', {
  get: () => getPointName('B'),
  set: (value) => {
    // ç•¶è¨­å®šæ™‚ï¼Œæ›´æ–°åˆ° GPS åˆ†é çš„è¼¸å…¥æ¡†å’Œ coordinateData
    const nameInput = document.getElementById('nameB');
    if (nameInput) nameInput.value = value;
    coordinateData.B.name = value;
  }
});

// ========================================
// ğŸš€ TIF æª”æ¡ˆå¿«å–ç³»çµ± - å„ªåŒ–å‰–é¢åœ–ç”Ÿæˆé€Ÿåº¦
// ========================================
let cachedTiffData = {
  github: null,      // GitHub ç·šä¸Šæª”æ¡ˆå¿«å–
  local: null,       // æœ¬åœ°ä¸Šå‚³æª”æ¡ˆå¿«å–
  url: null          // å¿«å–çš„ URL
};

// å¿«å–çš„åœ–åƒå°è±¡
let cachedImageData = {
  github: null,
  local: null
};

/**
 * ç²å–å¿«å–çš„ TIFF è³‡æ–™ (æ ¸å¿ƒå„ªåŒ–å‡½æ•¸)
 * @param {string} url - TIF æª”æ¡ˆ URL
 * @param {string} source - 'github' æˆ– 'local'
 * @returns {Promise<{tiff, image}>}
 */
async function getCachedTiff(url, source = 'github') {

  // å¦‚æœæœ‰å¿«å–ä¸” URL ç›¸åŒ,ç›´æ¥è¿”å›
  if (source === 'github' && cachedTiffData.github && cachedTiffData.url === url) {
  return {
    tiff: cachedTiffData.github,
    image: cachedImageData.github
  };
  }

  if (source === 'local' && cachedTiffData.local) {
  return {
    tiff: cachedTiffData.local,
    image: cachedImageData.local
  };
  }

  // å¦å‰‡é‡æ–°è¼‰å…¥ä¸¦å¿«å–
  const tiff = await GeoTIFF.fromUrl(url);
  const image = await tiff.getImage();

  // å„²å­˜åˆ°å¿«å–
  if (source === 'github') {
  cachedTiffData.github = tiff;
  cachedImageData.github = image;
  cachedTiffData.url = url;
  } else if (source === 'local') {
  cachedTiffData.local = tiff;
  cachedImageData.local = image;
  }

  return { tiff, image };
}

/**
 * æ¸…é™¤ TIF å¿«å–
 */
function clearTiffCache(source = 'all') {
  if (source === 'all' || source === 'github') {
  cachedTiffData.github = null;
  cachedImageData.github = null;
  cachedTiffData.url = null;
  }
  if (source === 'all' || source === 'local') {
  cachedTiffData.local = null;
  cachedImageData.local = null;
  }
}
// ========================================
// å¿«å–ç³»çµ±çµæŸ
// ========================================

// ========================================
// ğŸ”„ GPSåˆ†é èˆ‡é«˜åº¦åœ–åˆ†é é›™å‘åŒæ­¥ç³»çµ±
// ========================================
/**
 * å¾GPSåˆ†é åŒæ­¥åº§æ¨™åˆ°é«˜åº¦åœ–åˆ†é 
 * @param {string} point - 'A' æˆ– 'B'
 */
function syncGpsToElevation(point) {
  if (point === 'A') {
    const latA = document.getElementById('latA');
    const lonA = document.getElementById('lonA');
    const eleA = document.getElementById('eleA');
    const nameA = document.getElementById('nameA');
    const sLat = document.getElementById('sLat');
    const sLng = document.getElementById('sLng');
    const labelALat = document.getElementById('labelALat');
    const labelALng = document.getElementById('labelALng');

    if (latA && latA.value && sLat) {
      sLat.value = parseFloat(latA.value).toFixed(6);
    }
    if (lonA && lonA.value && sLng) {
      sLng.value = parseFloat(lonA.value).toFixed(6);
    }

    // æ›´æ–°é«˜åº¦åœ–åˆ†é çš„æ¨™ç±¤ä»¥é¡¯ç¤ºåœ°å
    if (nameA && nameA.value && labelALat && labelALng) {
      labelALat.innerHTML = `<span style="color:#FFD700;">${nameA.value}</span>ç·¯åº¦`;
      labelALng.innerHTML = `<span style="color:#FFD700;">${nameA.value}</span>ç¶“åº¦`;

      // ğŸ”„ åŒæ­¥æ›´æ–°å‰–é¢åœ–çš„åº§æ¨™åç¨±
      window.elevationPointAName = nameA.value;
    } else if (labelALat && labelALng) {
      labelALat.textContent = 'Aé»ç·¯åº¦';
      labelALng.textContent = 'Aé»ç¶“åº¦';

      // æ¢å¾©é è¨­åç¨±
      window.elevationPointAName = 'Aé»';
    }
  } else if (point === 'B') {
    const latB = document.getElementById('latB');
    const lonB = document.getElementById('lonB');
    const eleB = document.getElementById('eleB');
    const nameB = document.getElementById('nameB');
    const eLat = document.getElementById('eLat');
    const eLng = document.getElementById('eLng');
    const labelBLat = document.getElementById('labelBLat');
    const labelBLng = document.getElementById('labelBLng');

    if (latB && latB.value && eLat) {
      eLat.value = parseFloat(latB.value).toFixed(6);
    }
    if (lonB && lonB.value && eLng) {
      eLng.value = parseFloat(lonB.value).toFixed(6);
    }

    // æ›´æ–°é«˜åº¦åœ–åˆ†é çš„æ¨™ç±¤ä»¥é¡¯ç¤ºåœ°å
    if (nameB && nameB.value && labelBLat && labelBLng) {
      labelBLat.innerHTML = `<span style="color:#FFD700;">${nameB.value}</span>ç·¯åº¦`;
      labelBLng.innerHTML = `<span style="color:#FFD700;">${nameB.value}</span>ç¶“åº¦`;

      // ğŸ”„ åŒæ­¥æ›´æ–°å‰–é¢åœ–çš„åº§æ¨™åç¨±
      window.elevationPointBName = nameB.value;
    } else if (labelBLat && labelBLng) {
      labelBLat.textContent = 'Bé»ç·¯åº¦';
      labelBLng.textContent = 'Bé»ç¶“åº¦';

      // æ¢å¾©é è¨­åç¨±
      window.elevationPointBName = 'Bé»';
    }
  }
}

/**
 * å¾é«˜åº¦åœ–åˆ†é åŒæ­¥åº§æ¨™åˆ°GPSåˆ†é 
 * @param {string} point - 'A' æˆ– 'B'
 */
function syncElevationToGps(point) {
  if (point === 'A') {
    const sLat = document.getElementById('sLat');
    const sLng = document.getElementById('sLng');
    const latA = document.getElementById('latA');
    const lonA = document.getElementById('lonA');

    if (sLat && sLat.value && latA) {
      latA.value = parseFloat(sLat.value).toFixed(6);
      // åŒæ­¥æ›´æ–°DMSæ¬„ä½
      if (typeof dToD === 'function') {
        dToD('latA');
      }
    }
    if (sLng && sLng.value && lonA) {
      lonA.value = parseFloat(sLng.value).toFixed(6);
      // åŒæ­¥æ›´æ–°DMSæ¬„ä½
      if (typeof dToD === 'function') {
        dToD('lonA');
      }
    }
  } else if (point === 'B') {
    const eLat = document.getElementById('eLat');
    const eLng = document.getElementById('eLng');
    const latB = document.getElementById('latB');
    const lonB = document.getElementById('lonB');

    if (eLat && eLat.value && latB) {
      latB.value = parseFloat(eLat.value).toFixed(6);
      // åŒæ­¥æ›´æ–°DMSæ¬„ä½
      if (typeof dToD === 'function') {
        dToD('latB');
      }
    }
    if (eLng && eLng.value && lonB) {
      lonB.value = parseFloat(eLng.value).toFixed(6);
      // åŒæ­¥æ›´æ–°DMSæ¬„ä½
      if (typeof dToD === 'function') {
        dToD('lonB');
      }
    }
  }
}

// åˆå§‹åŒ–éŸ¿æ‡‰å¼æ•¸æ“šç¶å®š
document.addEventListener('DOMContentLoaded', function() {
  // ğŸ¯ ç¶å®šGPSåˆ†é è¼¸å…¥æ¡†åˆ°éŸ¿æ‡‰å¼æ•¸æ“š
  const gpsInputs = [
    {id: 'latA', point: 'A', property: 'lat'},
    {id: 'lonA', point: 'A', property: 'lng'},
    {id: 'eleA', point: 'A', property: 'ele'},
    {id: 'nameA', point: 'A', property: 'name'},
    {id: 'latB', point: 'B', property: 'lat'},
    {id: 'lonB', point: 'B', property: 'lng'},
    {id: 'eleB', point: 'B', property: 'ele'},
    {id: 'nameB', point: 'B', property: 'name'}
  ];

  gpsInputs.forEach(input => {
    const element = document.getElementById(input.id);
    if (element) {
      element.addEventListener('input', function() {
        updateFromInput(input.point, input.property);
      });
    }
  });

  // ğŸ¯ ç¶å®šé«˜åº¦åœ–åˆ†é è¼¸å…¥æ¡†åˆ°éŸ¿æ‡‰å¼æ•¸æ“š
  const elevationInputs = [
    {id: 'sLat', point: 'A', property: 'lat'},
    {id: 'sLng', point: 'A', property: 'lng'},
    {id: 'eLat', point: 'B', property: 'lat'},
    {id: 'eLng', point: 'B', property: 'lng'}
  ];

  elevationInputs.forEach(input => {
    const element = document.getElementById(input.id);
    if (element) {
      element.addEventListener('input', function() {
        if (window._isUpdating) return; // é˜²æ­¢å¾ªç’°
        const value = parseFloat(element.value);
        if (!isNaN(value)) {
          coordinateData[input.point][input.property] = value;
        }
      });
    }
  });

  // ğŸ”„ åˆå§‹åŒ–éŸ¿æ‡‰å¼æ•¸æ“šå¾DOMè®€å–é è¨­å€¼
  setTimeout(function() {
    // è®€å–Aé»é è¨­å€¼
    const latA = document.getElementById('latA');
    const lonA = document.getElementById('lonA');
    const eleA = document.getElementById('eleA');
    const nameA = document.getElementById('nameA');

    if (latA && latA.value) coordinateData.A.lat = parseFloat(latA.value);
    if (lonA && lonA.value) coordinateData.A.lng = parseFloat(lonA.value);
    if (eleA && eleA.value) coordinateData.A.ele = parseFloat(eleA.value);
    if (nameA && nameA.value) coordinateData.A.name = nameA.value;

    // è®€å–Bé»é è¨­å€¼
    const latB = document.getElementById('latB');
    const lonB = document.getElementById('lonB');
    const eleB = document.getElementById('eleB');
    const nameB = document.getElementById('nameB');

    if (latB && latB.value) coordinateData.B.lat = parseFloat(latB.value);
    if (lonB && lonB.value) coordinateData.B.lng = parseFloat(lonB.value);
    if (eleB && eleB.value) coordinateData.B.ele = parseFloat(eleB.value);
    if (nameB && nameB.value) coordinateData.B.name = nameB.value;

  }, 100); // å»¶é²100msç¢ºä¿DOMå®Œå…¨è¼‰å…¥

});
// ========================================
// é›™å‘åŒæ­¥ç³»çµ±çµæŸ
// ========================================

let link_tx_last_unit = 'w';
function smartIncreaseSamples(baseValue) {
  const samplesInput = document.getElementById('samples');
  const currentValue = parseInt(samplesInput.value) || 0;
  if (baseValue === 100) {
    if (currentValue >= 100 && currentValue <= 900 && currentValue % 100 === 0) {
      samplesInput.value = currentValue + 100;
    } else {
      samplesInput.value = 100;
    }
  } else if (baseValue === 1000) {
    if (currentValue >= 1000 && currentValue <= 9000 && currentValue % 1000 === 0) {
      samplesInput.value = currentValue + 1000;
    } else {
      samplesInput.value = 1000;
    }
  }
}
function setMaxEffectivePoints() {
  const sLatVal = document.getElementById('sLat').value;
  const sLngVal = document.getElementById('sLng').value;
  const eLatVal = document.getElementById('eLat').value;
  const eLngVal = document.getElementById('eLng').value;
  if (!sLatVal || !sLngVal || !eLatVal || !eLngVal) {
    alert('âŒ è«‹å…ˆè¼¸å…¥Aé»å’ŒBé»åº§æ¨™');
    return;
  }
  const sLat = parseFloat(sLatVal);
  const sLng = parseFloat(sLngVal);
  const eLat = parseFloat(eLatVal);
  const eLng = parseFloat(eLngVal);
  if (isNaN(sLat) || isNaN(sLng) || isNaN(eLat) || isNaN(eLng)) {
    alert('âŒ åº§æ¨™å€¼ç„¡æ•ˆ');
    return;
  }
  const apiSelector = document.getElementById('elevationApiSelector');
  const selectedApi = apiSelector ? apiSelector.value : 'taiwan-dsm';
  let pointsPerKm;
  let apiName;
  if (selectedApi === 'taiwan-dsm') {
    pointsPerKm = 50;
    apiName = 'å…§æ”¿éƒ¨ DSM 20m(å«å»ºç‰©)';
  } else {
    pointsPerKm = 33.333333;
    apiName = 'å…¶ä»–è³‡æ–™æº';
  }
  const distance = getDistance(sLat, sLng, eLat, eLng);
  const maxEffectivePoints = Math.ceil(distance * pointsPerKm);
  document.getElementById('samples').value = maxEffectivePoints;
  const summary = document.getElementById('summary');
  summary.innerHTML = `âœ“ å·²è¨­ç½®æœ€å¤§æœ‰æ•ˆé»æ•¸ï¼š<strong>${maxEffectivePoints}</strong> é»<br>
  <span style="font-size:12px; color:var(--muted);">è·é›¢: ${distance.toFixed(2)} km | é»å¯†åº¦: ${pointsPerKm.toFixed(2)}é»/km (${apiName})</span>`;
  summary.style.color = '#27ae60';
  summary.style.background = 'rgba(39, 174, 96, 0.1)';
}
function swapLinkTxUnit() {
  const unitSel = document.getElementById('link_tx_power_unit');
  const input = document.getElementById('link_tx_power_input');
  const currentUnit = unitSel.value;
  const val = parseFloat(input.value);
  if (!isNaN(val) && input.value.trim() !== '') {
    const newVal = convertPower(val, link_tx_last_unit, currentUnit);
    if (!isNaN(newVal) && newVal !== Infinity && newVal !== -Infinity) {
      input.value = newVal.toFixed(3);
    }
  }
  link_tx_last_unit = currentUnit;
  calculateLinkBudget();
}
</script> <meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,minimal-ui" /><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>è¨ˆç®—å·¥å…·</title><script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.5.31/dist/jspdf.plugin.autotable.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<meta name="theme-color" content="#071026"><style> :root{ --bg-0:#050a16; --bg-1:#0b1526; --muted:#a8b3c3; --label:#85c9ff; --title:#ffe58f; --value:#5ff0d5; --accent1:#5ff0d5; --accent2:#79a8ff; --orange-border: #ffaa00; --glass: rgba(255,255,255,0.06); --shadow: 0 4px 12px rgba(0,0,0,0.40); font-size:24px; --gps-error-border: #dc3545; --rf-green-start: #36c74d; --rf-green-end: #1e8030; --rf-green-border: #1e8030; --red-clear: #dd4444; --purple-accent: #bb66ff; } *{box-sizing:border-box}
::selection {
  background-color: #5ff0d5;
  color: #000000;
}
::-moz-selection {
  background-color: #5ff0d5;
  color: #000000;
}
input::selection {
  background-color: #5ff0d5;
  color: #000000;
}
input::-moz-selection {
  background-color: #5ff0d5;
  color: #000000;
}
body{ margin:0; padding:0; background:linear-gradient(180deg,var(--bg-0),var(--bg-1)); color:#e8eef5; font-family:Inter, 'Noto Sans TC', system-ui; line-height:1.3; } header{ padding: 0 10px; background-color: var(--bg-1); border-bottom: 1px solid rgba(255,255,255,0.08); height: 0; } h1{ display: none; } main{padding:6px; max-width:880px; margin:0 auto;} .card{ background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:10px; margin-bottom:6px; box-shadow:var(--shadow); border:1px solid rgba(255,255,255,0.03); } .gps-container .card { padding: 5px 8px; } .section-title{ color:var(--title); font-size:18px; font-weight:700; margin-bottom:4px; display:block; } .rf-header { margin-bottom: 6px; } .rf-header .section-title { color: var(--title); font-size: 18px; font-weight: 700; margin-bottom: 2px; display: block; } .unit-selector-row { display: flex; align-items: center; justify-content: flex-start; gap: 8px; padding: 4px 0; margin-bottom: 2px; } .unit-selector-row .unit-label { font-size: 15px; color: var(--label); margin-bottom: 0; font-weight: 700; } .form-grid{ display:grid; grid-template-columns:1fr 1fr; gap:5px; align-items:end; } label{ color:var(--label); font-size:15px; margin-bottom:1px; display:block; } input,select{ width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15); } .input-with-clear-rf { display: flex; align-items: center; position: relative; } .input-with-clear-rf input { flex-grow: 1; padding-right: 35px; } .clear-btn-rf { position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--red-clear); font-size: 18px; cursor: pointer; padding: 0 8px; line-height: 1; font-weight: bold; opacity: 0.8; z-index: 10; height: 100%; display: flex; align-items: center; } #unit, #displayMode { border: 1px solid var(--purple-accent) !important; color: var(--purple-accent) !important; background-color: rgba(187, 102, 255, 0.08) !important; width: auto !important; max-width: 120px !important; padding: 3px 6px !important; font-size: 15px !important; flex-shrink: 0; } .gps-container input[type="number"], .gps-container input[type="text"] { padding: 3px 5px; font-size: 14px; border: 1px solid rgba(255,255,255,0.2); } .controls{ margin-top:2px; display:flex; gap:5px; } .btn{ background:linear-gradient(90deg,var(--accent1),var(--accent2)); border:0; padding:8px 12px; border-radius:6px; font-weight:700; font-size:16px; color:#022; cursor:pointer; } .btn.ghost{ border:1px solid var(--accent2); background:transparent; color:#e8eef5; } .btn.clear{ background:var(--red-clear); color:white; border-radius:6px; } #rf-content + .btn-row .btn { background: linear-gradient(90deg, var(--rf-green-start), var(--rf-green-end)); color: #022; border: none; } #rf-content + .btn-row .btn.ghost { background: transparent; border: 1px solid var(--rf-green-border); color: #e8eef5; } #rf-content + .btn-row .btn.clear { background: var(--red-clear); color: white; border: none; } .btn-row{ display:flex; flex-wrap:nowrap; justify-content:stretch; align-items:center; gap:12px; width:100%; box-sizing:border-box; } .btn-row .btn{ flex:1 1 0%; text-align:center; white-space:nowrap; min-width:0; } #liveInputs{ margin-top:3px; font-size:14px; color:var(--muted); } table{ width:100%; border-collapse:collapse; margin-top:6px; font-size:16px; } thead th{ color:var(--label); padding:3px 3px; border-bottom:1px solid rgba(255,255,255,0.06); text-align:center; } tbody td{ padding:4px 3px; border-bottom:1px solid rgba(255,255,255,0.03); text-align:center; } .name{ color:#ffd369; font-weight:700; white-space:nowrap; } th:first-child, td:first-child{ width:32%; text-align:left; } .value, .percent{ color:var(--value); font-weight:800; font-variant-numeric:tabular-nums; } .small-note{ font-size:13px; margin-top:3px; color:var(--muted); } @media (max-width:640px){ .form-grid{grid-template-columns:1fr;} } .tabs{ display:flex; margin-bottom: 6px; overflow-x: auto; border-bottom: 1px solid rgba(255,255,255,0.06); } .tab-button{ flex-shrink: 0; padding: 6px 10px; margin: 0 2px; background: transparent; border: 0; color: var(--muted); font-size: 18px; cursor: pointer; font-weight: 600; border-radius: 8px 8px 0 0; transition: all 0.2s ease; } .tab-button.active{ background: var(--glass); color: var(--title); border-bottom: 2px solid var(--accent1); } .tab-content{ display: none; padding-top: 5px; } .tab-content.active{ display: block; } .gps-container { padding: 0; } .gps-tip { color: var(--label) !important; font-size: 13px !important; margin: 0 0 2px 0 !important; } .display-mode-container { margin-top: 3px; } .gps-ig { margin-bottom: 2px !important; padding: 3px 7px !important; border: 1px solid rgba(255,255,255,0.05); border-radius: 8px; background-color: rgba(255,255,255,0.02); } .gps-loc-header { margin-bottom: 2px !important; font-weight: bold; color: var(--title); font-size: 17px; display: flex; align-items: center; justify-content: space-between; } .gps-loc-header > div { display: flex; align-items: center; gap: 5px; } #nameA, #nameB { width: 144px !important; max-width: 144px !important; font-size: 14px !important; text-align: center; flex-shrink: 0; padding: 4px 6px !important; } .gps-loc-header span { color: var(--muted); font-size: 13px; flex-shrink: 0; } .gps-cg { padding: 2px !important; margin-bottom: 2px !important; border: 1px solid rgba(255,255,255,0.05); border-radius: 6px; } .gps-cl { font-weight: bold; color: var(--label); display: block; margin-bottom: 1px; font-size: 14px !important; } .gps-ddr { display: flex; align-items: center; margin-bottom: 0 !important; } .gps-ddr input { flex-grow: 1; text-align: right; padding: 4px 8px !important; font-size: 16px !important; } .gps-ddr span { color: var(--muted); font-size: 14px !important; margin-right: 4px; flex-shrink: 0; } .gps-dmsr { display: flex; align-items: center; justify-content: space-between; gap: 4px; margin-bottom: 0 !important; } .gps-dmsr input { padding: 4px 8px !important; font-size: 16px !important; } .gps-dmsf { display: flex; align-items: center; flex: 1; min-width: 0; } .gps-dmsf input { text-align: center; margin-right: 3px; max-width: none; flex-grow: 1; min-width: 30px; } .gps-dmsf:nth-child(1) input { flex: 2; } .gps-dmsf:nth-child(2) input { flex: 1.5; } .gps-dmsf:nth-child(3) input { flex: 2.5; } .gps-dmsr span { color: var(--muted); font-size: 14px !important; margin-right: 0; flex-shrink: 0; } .gps-er { display: flex; align-items: center; justify-content: flex-start; gap: 5px; margin-top: 2px !important; padding-top: 2px !important; border-top: 1px dashed rgba(255,255,255,0.08); flex-wrap: nowrap !important; } .gps-er label { font-size: 15px !important; flex-shrink: 0; color: var(--label); width: 105px; margin-right: 8px; } .gps-er input { text-align: right; flex-grow: 1.2 !important; padding: 4px 8px !important; font-size: 16px !important; min-width: 60px !important; max-width: 100px !important; } .gps-er > .control-group { display: flex; align-items: center; flex-shrink: 0; min-width: 0; margin-left: auto !important; } .gps-er .control-group span { font-size: 14px !important; flex-shrink: 0; color: var(--muted); margin-left: 4px; } .gps-cb { background: none; border: none; color: #ff6347; font-size: 18px; cursor: pointer; padding: 0 5px; line-height: 1; font-weight: bold; opacity: 0.9; margin: 0; flex-shrink: 0; } .gps-ddr .gps-cb { margin-left: auto; } .gps-er .control-group .gps-cb { margin-left: 5px !important; } #gpsRes { margin-top: 5px !important; padding: 8px !important; border: 2px solid var(--accent2); border-radius: 8px; background-color: rgba(121, 168, 255, 0.05); font-size: 16px !important; font-weight: 500; text-align: left; color: #e8eef5; } #gpsRes p { margin: 4px 0 !important; } .gps-label-title { color: var(--title); font-weight: 700; margin-right: 5px; } .v-dist, .v-bearing, .v-pitch-value { font-weight: 900 !important; font-size: 1.1em; color: var(--value) !important; } .display-mode-container { display: flex; align-items: center; justify-content: flex-start; gap: 8px; margin-top: 3px; } #displayMode { width: auto !important; max-width: 170px; flex-shrink: 0; } .display-mode-container label { display: none; } .display-mode-text { font-weight: 700; color: var(--label); font-size: 14px; flex-shrink: 0; } .results-card-border { border: 2px solid var(--accent2) !important; border-radius: 8px !important; background-color: rgba(121, 168, 255, 0.05) !important; } .orange-border-card { border: 2px solid var(--orange-border) !important; border-radius: 8px !important; background-color: rgba(255, 170, 0, 0.05) !important; }
@keyframes blink-dots {
  0%, 20% { content: ''; }
  40% { content: '.'; }
  60% { content: '..'; }
  80%, 100% { content: '...'; }
}
.loading-dots {
  color: #ffd43b !important;
  font-weight: bold;
  display: inline-block;
}
.loading-dots::after {
  content: '';
  animation: blink-dots 1.5s steps(4, end) infinite;
}
.chart-fullscreen-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: #050a16;
  z-index: 9999;
  padding: 0;
  box-sizing: border-box;
}
.chart-fullscreen-overlay.active {
  display: block;
}
.chart-fullscreen-container {
  width: 100%;
  height: 100%;
  position: relative;
  background: transparent;
  padding: 0;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}
.chart-fullscreen-canvas-wrapper {
  width: 100%;
  height: 100%;
  position: relative;
  display: flex;
  align-items: stretch;
  justify-content: center;
  padding: 0;
  box-sizing: border-box;
}
.chart-fullscreen-container canvas {
  width: 100% !important;
  height: 100% !important;
}
.chart-fullscreen-close {
  position: absolute;
  top: 10px;
  right: 15px;
  width: 32px;
  height: 32px;
  background: rgba(220, 53, 69, 0.7);
  color: rgba(255, 255, 255, 0.9);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 50%;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  z-index: 10000;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
  padding: 0;
  line-height: 1;
  transition: all 0.2s ease;
}
.chart-fullscreen-close:hover {
  background: rgba(220, 53, 69, 0.95);
  color: rgba(255, 255, 255, 1);
  transform: scale(1.1);
  box-shadow: 0 6px 16px rgba(220, 53, 69, 0.6);
}
.chart-fullscreen-close:active {
  background: rgba(220, 53, 69, 1);
  transform: scale(0.9);
}
.chart-fullscreen-screenshot {
  position: absolute;
  top: 10px;
  right: 95px;
  width: 32px;
  height: 32px;
  background: rgba(76, 175, 80, 0.85);
  color: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(129, 199, 132, 0.8);
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
  z-index: 10001;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  padding: 0;
  line-height: 1;
  transition: all 0.2s ease;
}
.chart-fullscreen-screenshot:hover {
  background: rgba(76, 175, 80, 0.95);
  color: rgba(255, 255, 255, 1);
  transform: scale(1.1);
  box-shadow: 0 6px 16px rgba(76, 175, 80, 0.6);
}
.chart-fullscreen-screenshot:active {
  background: rgba(76, 175, 80, 1);
  transform: scale(0.9);
}
.chart-fullscreen-info-toggle {
  position: absolute;
  top: 10px;
  right: 135px;
  width: 32px;
  height: 32px;
  background: rgba(13, 71, 161, 0.85);
  color: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(77, 171, 247, 0.8);
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
  z-index: 10001;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  padding: 0;
  line-height: 1;
  transition: all 0.2s ease;
}
.chart-fullscreen-info-toggle:hover {
  background: rgba(13, 71, 161, 0.95);
  color: rgba(255, 255, 255, 1);
  transform: scale(1.1);
  box-shadow: 0 6px 16px rgba(77, 171, 247, 0.6);
}
.chart-fullscreen-info-toggle:active {
  background: rgba(13, 71, 161, 1);
  transform: scale(0.9);
}
.chart-fullscreen-info-toggle.disabled {
  background: rgba(100, 100, 100, 0.85);
  border-color: rgba(150, 150, 150, 0.8);
}
.chart-fullscreen-obstruction-toggle {
  position: absolute;
  top: 10px;
  right: 175px;
  width: 32px;
  height: 32px;
  background: rgba(255, 68, 68, 0.85);
  color: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(255, 100, 100, 0.8);
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
  z-index: 10001;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  padding: 0;
  line-height: 1;
  transition: all 0.2s ease;
}
.chart-fullscreen-obstruction-toggle:hover {
  background: rgba(255, 68, 68, 0.95);
  color: rgba(255, 255, 255, 1);
  transform: scale(1.1);
  box-shadow: 0 6px 16px rgba(255, 100, 100, 0.6);
}
.chart-fullscreen-obstruction-toggle:active {
  background: rgba(255, 68, 68, 1);
  transform: scale(0.9);
}
.chart-fullscreen-obstruction-toggle.disabled {
  background: rgba(100, 100, 100, 0.85);
  border-color: rgba(150, 150, 150, 0.8);
}
.chart-fullscreen-map-toggle {
  position: absolute;
  top: 10px;
  right: 215px;
  width: 32px;
  height: 32px;
  background: rgba(79, 171, 247, 0.85);
  color: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(79, 171, 247, 0.8);
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
  z-index: 10001;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  padding: 0;
  line-height: 1;
  transition: all 0.2s ease;
}
.chart-fullscreen-map-toggle:hover {
  background: rgba(79, 171, 247, 0.95);
  color: rgba(255, 255, 255, 1);
  transform: scale(1.1);
  box-shadow: 0 6px 16px rgba(79, 171, 247, 0.6);
}
.chart-fullscreen-map-toggle:active {
  background: rgba(79, 171, 247, 1);
  transform: scale(0.9);
}
.chart-fullscreen-map-toggle.disabled {
  background: rgba(100, 100, 100, 0.85);
  border-color: rgba(150, 150, 150, 0.8);
  cursor: not-allowed;
  opacity: 0.5;
}
.chart-fullscreen-rotate-toggle {
  position: absolute;
  top: 10px;
  right: 55px;
  width: 32px;
  height: 32px;
  background: rgba(255, 152, 0, 0.85);
  color: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(255, 167, 38, 0.8);
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
  z-index: 10001;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  padding: 0;
  line-height: 1;
  transition: all 0.2s ease;
}
.chart-fullscreen-max-obstruction {
  position: absolute;
  top: 10px;
  right: 295px;
  width: 32px;
  height: 32px;
  padding: 0;
  background: linear-gradient(135deg, #ff4444, #cc0000);
  color: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(255, 100, 100, 0.8);
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  font-weight: normal;
  z-index: 10001;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  line-height: 1;
  transition: all 0.2s ease;
}
.chart-fullscreen-max-obstruction:hover {
  background: linear-gradient(135deg, #ff5555, #dd0000);
  transform: scale(1.1);
  box-shadow: 0 6px 16px rgba(255, 68, 68, 0.6);
}
.chart-fullscreen-max-obstruction:active {
  background: linear-gradient(135deg, #ff3333, #bb0000);
  transform: scale(0.95);
}
.chart-fullscreen-start-obstruction {
  position: absolute;
  top: 10px;
  right: 255px;
  width: 32px;
  height: 32px;
  padding: 0;
  background: linear-gradient(135deg, #ff69b4, #ff1493);
  color: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(255, 105, 180, 0.8);
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  font-weight: normal;
  z-index: 10001;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  line-height: 1;
  transition: all 0.2s ease;
}
.chart-fullscreen-start-obstruction:hover {
  background: linear-gradient(135deg, #ff7ac4, #ff2aa3);
  transform: scale(1.1);
  box-shadow: 0 6px 16px rgba(255, 105, 180, 0.6);
}
.chart-fullscreen-start-obstruction:active {
  background: linear-gradient(135deg, #ff58a4, #ff0083);
  transform: scale(0.95);
}
.chart-fullscreen-end-obstruction {
  position: absolute;
  top: 10px;
  right: 335px;
  width: 32px;
  height: 32px;
  padding: 0;
  background: linear-gradient(135deg, #ff69b4, #ff1493);
  color: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(255, 105, 180, 0.8);
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  font-weight: normal;
  z-index: 10001;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  line-height: 1;
  transition: all 0.2s ease;
}
.chart-fullscreen-end-obstruction:hover {
  background: linear-gradient(135deg, #ff7ac4, #ff2aa3);
  transform: scale(1.1);
  box-shadow: 0 6px 16px rgba(255, 105, 180, 0.6);
}
.chart-fullscreen-end-obstruction:active {
  background: linear-gradient(135deg, #ff58a4, #ff0083);
  transform: scale(0.95);
}
.chart-fullscreen-point-control {
  position: absolute;
  top: 10px;
  left: calc(48% - 29px);
  transform: translateX(-50%);
  display: flex;
  gap: 6px;
  align-items: center;
  background: rgba(5, 10, 22, 0.7);
  border-radius: 8px;
  padding: 3px 8px;
  z-index: 10002;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}
/* åœ°åœ–é»æ§åˆ¶å–®å…ƒ - å³ä¸‹è§’ */
.map-point-control {
  display: flex;
  gap: 4px;
  align-items: center;
  background: rgba(5, 10, 22, 0.85);
  border-radius: 6px;
  padding: 4px 8px;
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.4);
  margin-bottom: 0px;
}
.map-point-control button {
  background: linear-gradient(90deg, #79a8ff, #5ff0d5);
  border: 0;
  padding: 4px 8px;
  border-radius: 4px;
  font-weight: 700;
  font-size: 14px;
  color: #022;
  cursor: pointer;
  white-space: nowrap;
  flex-shrink: 0;
  height: 28px;
  min-width: 36px;
}
.map-point-control input {
  width: 60px;
  padding: 3px 4px;
  font-size: 13px;
  color: #5ff0d5;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 4px;
  border: 2px solid rgba(95, 240, 213, 0.3);
  text-align: center;
  height: 28px;
  font-weight: bold;
}
  font-weight: bold;
  z-index: 10001;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  padding: 0;
  line-height: 1;
  transition: all 0.2s ease;
}
.chart-fullscreen-rotate-toggle:hover {
  background: rgba(255, 152, 0, 0.95);
  color: rgba(255, 255, 255, 1);
  transform: scale(1.1);
  box-shadow: 0 6px 16px rgba(255, 152, 0, 0.6);
}
.chart-fullscreen-rotate-toggle:active {
  background: rgba(255, 152, 0, 1);
  transform: scale(0.9);
}
.chart-zoom-btn {
  position: absolute;
  bottom: 8px;
  left: 8px;
  width: 32px;
  height: 32px;
  background: rgba(79, 168, 255, 0.6);
  border: 2px solid rgba(95, 240, 213, 0.6);
  border-radius: 8px;
  color: rgba(255, 255, 255, 0.8);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  z-index: 10;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}
.chart-zoom-btn:hover {
  background: rgba(95, 240, 213, 0.8);
  border-color: rgba(95, 240, 213, 0.9);
  color: rgba(255, 255, 255, 1);
  transform: scale(1.1);
  box-shadow: 0 4px 12px rgba(95, 240, 213, 0.4);
}
.chart-zoom-btn:active {
  transform: scale(0.95);
}
.chart-zoom-btn svg {
  width: 14px;
  height: 14px;
  opacity: 0.85;
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
}

/* ç·Šæ¹Šå½ˆçª—æ¨£å¼ - ç§»é™¤å¤šé¤˜ç©ºç™½ */
.custom-popup-compact .leaflet-popup-content-wrapper {
  padding: 0;
  border-radius: 8px;
  cursor: grab !important;
  user-select: none;
  box-shadow: 0 4px 16px rgba(0,0,0,0.35) !important;
  min-width: 150px !important;
}
.custom-popup-compact .leaflet-popup-content-wrapper:active {
  cursor: grabbing !important;
}
.custom-popup-compact .leaflet-popup-content {
  margin: 0 !important;
  line-height: 1.5;
  font-size: 14px;
}
.custom-popup-compact .leaflet-popup-tip-container {
  display: none;
}
.custom-popup-compact .leaflet-popup-close-button {
  font-size: 18px !important;
  width: 24px !important;
  height: 24px !important;
  top: 4px !important;
  right: 4px !important;
}
/* æ‹–æ›³æ‰‹æŸ„æç¤ºåˆ— */
.popup-drag-bar {
  background: linear-gradient(90deg, #0066FF, #3399ff);
  color: #fff;
  font-size: 13px;
  font-weight: bold;
  padding: 5px 10px 4px 10px;
  border-radius: 8px 8px 0 0;
  cursor: grab;
  user-select: none;
  display: flex;
  align-items: center;
  gap: 6px;
  letter-spacing: 0.5px;
}
.popup-drag-bar:active { cursor: grabbing; }
.popup-body {
  padding: 4px 8px 5px 8px;
  font-family: 'Noto Sans TC', monospace, sans-serif;
  font-size: 13px;
  line-height: 1.3;
  color: #111;
}
.popup-body > div {
  margin-bottom: 1px;
}
.popup-body > div:last-child {
  margin-bottom: 0;
}
</style><link rel="manifest" href="manifest.json"><meta name="theme-color" content="#0a4cff">
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/Gps-Cable-Loss-Calculator/service-worker.js');
}
</script> <style> :root{ --bg-0:#050a16; --bg-1:#0b1526; --muted:#a8b3c3; --label:#85c9ff; --title:#ffe58f; --value:#5ff0d5; --accent1:#5ff0d5; --accent2:#79a8ff; --orange-border: #ffaa00; --red-clear: #dd4444; --purple-accent: #bb66ff; --glass: rgba(255,255,255,0.06); --shadow: 0 4px 12px rgba(0,0,0,0.40); font-size:22px; } *{box-sizing:border-box} body{ margin:0; padding:0; background:linear-gradient(180deg,var(--bg-0),var(--bg-1)); color:#e8eef5; font-family:Inter, 'Noto Sans TC', system-ui; line-height:1.3; } header{ padding: 0 10px; background-color: var(--bg-1); border-bottom: 1px solid rgba(255,255,255,0.08); height: 0; } h1{ display: none; } main{padding:6px; max-width:880px; margin:0 auto;} .card{ background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:10px; margin-bottom:6px; box-shadow:var(--shadow); border:1px solid rgba(255,255,255,0.03); } .section-header-with-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; } .section-header-with-controls .section-title { margin-bottom: 0; } .section-header-with-controls .btn-group { display: flex; gap: 5px; flex-shrink: 0; } .btn{ padding: 5px 8px; border-radius: 6px; font-weight: 700; font-size: 16px; color: #022; cursor: pointer; border: none; background: linear-gradient(90deg,var(--accent1),var(--accent2)); } .section-header-with-controls .btn { padding: 3px 6px; font-size: 14px; border-radius: 4px; white-space: nowrap; } .btn-reset { border: 1px solid var(--accent2); background: transparent; color: #e8eef5; } .btn-clear { background: var(--red-clear); color: white; border: none; } .section-title{ color:var(--title); font-size:17px; font-weight:700; margin-bottom:4px; display:block; } .rf-header { margin-bottom: 6px; } .los-point-title { color: var(--title); font-size: 1.1em; font-weight: 700; margin-top: 10px; margin-bottom: 5px; border-bottom: 1px dashed rgba(255,255,255,0.08); padding-bottom: 3px; } label{ color:var(--label); font-size:17px; margin-bottom:1px; display:block; } input,select{ width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15); } .input-with-clear { display: flex; align-items: center; gap: 5px; margin-bottom: 5px; } .input-with-clear input { flex-grow: 1; width: auto; } .clear-button { background: transparent; border: none; color: var(--red-clear); font-size:22px; font-weight: bold; cursor: pointer; padding: 5px 0; line-height: 1; width: 30px; flex-shrink: 0; border-radius: 4px; transition: background-color 0.2s; } .clear-button:hover { background-color: rgba(221, 68, 68, 0.2); } #power_unit, #matching_unit, #link_tx_power_unit { border: 1px solid var(--purple-accent) !important; color: var(--purple-accent) !important; background-color: rgba(187, 102, 255, 0.08) !important; width: 100% !important; max-width: none !important; padding: 5px 8px !important; font-size: 17px !important; flex-shrink: 0; } #power_unit, #link_tx_power_unit { margin-bottom: 8px; } .input-group-border { border: 2px solid var(--orange-border) !important; border-radius: 8px !important; background-color: rgba(255, 170, 0, 0.05) !important; padding: 10px 12px; margin-bottom: 8px; margin-top: 5px; } .input-group-border > :first-child { margin-top: 0 !important; } .input-group-border .input-with-clear { margin-bottom: 8px; } .input-group-border .input-with-clear:last-child { margin-bottom: 0; } .input-group-border .los-point-title { margin-top: 8px; } .input-group-border .los-point-title:first-child { margin-top: 0 !important; margin-bottom: 5px; } .los-input-container { display: block; gap: 0; margin-bottom: 0 !important; } .los-input-container .input-item {
  width: 100%;
  flex: none;
  min-width: auto;
  box-sizing: border-box;
  padding-bottom: 8px;
  border-bottom: 1px dotted rgba(255,255,255,0.05);
  margin-bottom: 8px;
  /* ğŸ”§ ä¿®æ­£ï¼šä½¿ labelã€inputã€X æŒ‰éˆ•åœ¨åŒä¸€è¡Œï¼Œæ•´è¡Œå¡«æ»¿ */
  display: flex;
  align-items: center;
  gap: 8px;
}
.los-input-container .input-item label {
  /* label å›ºå®šå¯¬åº¦ï¼Œä½¿æ‰€æœ‰è¼¸å…¥æ¬„å·¦é‚Šå°é½Š */
  flex-shrink: 0;
  margin-bottom: 0 !important;
  white-space: nowrap;
  min-width: 160px; /* å›ºå®šå¯¬åº¦ï¼Œä»¥æœ€é•·çš„ label ç‚ºåŸºæº– */
  text-align: left;
}
.los-input-container .input-item .input-with-clear {
  /* input å®¹å™¨è‡ªå‹•å¡«æ»¿å‰©é¤˜ç©ºé–“ */
  flex: 1;
  margin-bottom: 0 !important;
  min-width: 0;
}
.los-input-container .input-item .input-with-clear input {
  /* input å¡«æ»¿å®¹å™¨å¯¬åº¦ï¼Œæ•¸å€¼ç½®ä¸­å°é½Š */
  width: 100%;
  flex-grow: 1;
  text-align: center;
}
/* ğŸ”§ èª¿æ•´ #link_tx_power_unit é¸å–®çš„æ¨£å¼ */
#link_tx_power_unit {
  width: auto !important;
  max-width: 120px !important;
}
/* ğŸ”§ èª¿æ•´ã€Œé€šè¦–æœ€å¤§è·é›¢ã€å€å¡Šçš„ label å¯¬åº¦ï¼Œä»¥å°é½Šæœ€é•·çš„ label */
#section-los .los-input-container .input-item label {
  min-width: 220px !important;
} .los-input-container .input-item:last-child { padding-bottom: 0; border-bottom: none; margin-bottom: 0; } .results-card-border { border: 2px solid var(--accent2) !important; border-radius: 8px !important; background-color: rgba(121, 168, 255, 0.05) !important; padding: 10px 12px; margin-top: 8px !important; } .result-value { color: var(--value); font-weight: 900; font-size: 1.1em; } .result-value-small { font-size: 1em !important; } .function-selector-container { margin-bottom: 10px; padding: 6px 8px; background: rgba(255,255,255,0.02); border-radius: 10px; box-shadow: var(--shadow); border: 1px solid rgba(255,255,255,0.03); } #function_selector { border: 1px solid var(--accent1) !important; color: var(--accent1) !important; background-color: rgba(95, 240, 213, 0.08) !important; font-weight: 700; font-size: 18px; margin-top: 4px; }
/* ğŸ”§ ç¸®å° section-linkbudget å€å¡Šçš„ä¸Šä¸‹é–“è· */
#section-linkbudget .input-group-border { padding: 6px 10px; margin-top: 3px; margin-bottom: 5px; }
#section-linkbudget .los-point-title { margin-top: 5px; margin-bottom: 3px; padding-bottom: 2px; }
#section-linkbudget .input-group-border .los-point-title { margin-top: 5px; }
#section-linkbudget .input-group-border .los-point-title:first-child { margin-top: 0 !important; margin-bottom: 3px; }
#section-linkbudget .los-input-container .input-item { padding-bottom: 4px; margin-bottom: 4px; }
#section-linkbudget .input-group-border .input-with-clear { margin-bottom: 4px; }
#section-linkbudget #link_tx_power_unit { margin-bottom: 4px; }
#section-linkbudget .results-card-border { margin-top: 5px !important; padding: 8px 10px; }
</style>
<style>
/* ğŸ”§ å…¨å±€è¨­ç½®ï¼šæ‰€æœ‰æ•¸å€¼è¼¸å…¥æ¬„ä½ç½®ä¸­å°é½Š */
input[type="number"] {
  text-align: center !important;
}
html, body {
  background-color: #050a16 !important;
  color-scheme: dark;
}
select {
  background-color: #2b2b2b !important;
  color: #e8eef5 !important;
  border: 1px solid #555 !important;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
}
select option {
  background-color: #3a3a3a !important;
  color: #ffffff !important;
}
select:focus {
  outline: none;
  border-color: #888 !important;
}
select::-ms-expand {
  display: none;
}
</style>
<style>
.gps-ig {
  padding: 6px 8px !important;
  box-sizing: border-box !important;
}
.gps-ig .gps-cg,
.gps-ig .gps-er {
  margin-bottom: 4px !important;
}
.gps-ig .gps-er:last-child {
  margin-bottom: 0 !important;
}
#gps-content .gps-ig {
  width: 100% !important;
  min-width: 100% !important;
}
.gps-loc-header {
  padding-bottom: 2px !important;
}
</style>
<style>
.gps-ig,
.gps-ig.orange-border-card,
div.gps-ig,
div.gps-ig.orange-border-card,
#gps-content .gps-ig,
#gps-content .gps-ig.orange-border-card,
#gps-content div.gps-ig,
#gps-content div.gps-ig.orange-border-card {
  padding: 10px 12px !important;
  padding-top: 10px !important;
  padding-bottom: 10px !important;
  padding-left: 12px !important;
  padding-right: 12px !important;
}
</style>
</head><body><div id="splash-screen"><div class="splash-content"><img src="1.png" alt="splash"><div class="splash-text">é˜¿è‰¯è£½_1141212</div></div></div><style> #splash-screen{
  position:fixed;
  inset:0;
  background:#000;
  display:flex;
  justify-content:center;
  align-items:center;
  z-index:99999;
}
.splash-content{
  position:absolute;
  inset:0;
}
#splash-screen img{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  width:auto;
  max-width:90vw;
  max-height:90vh;
}
.splash-text{
  position:absolute;
  right:16px;
  bottom:16px;
  font-size:14px;
  color:#fff;
  font-weight:700;
  letter-spacing:1px;
  opacity:.9;
}
#gps-controls-container {
  display: block !important;
}
.tab-content:not(.active) #gps-controls-container {
  display: none !important;
}
.tab-content.active #gps-controls-container {
  display: block !important;
}
.tab-content:not(.active) #gpsCalcBtn {
  display: none !important;
  visibility: hidden !important;
}
.tab-content:not(.active) #gpsResetBtn {
  display: none !important;
  visibility: hidden !important;
}
.tab-content:not(.active) #gpsClearBtn {
  display: none !important;
  visibility: hidden !important;
}
.tab-content:not(.active) .btn-row:has(#gpsCalcBtn) {
  display: none !important;
  visibility: hidden !important;
}
.tab-content.active #gpsCalcBtn {
  display: inline-block !important;
  visibility: visible !important;
  flex: 2.5 1 0% !important;
}
.tab-content.active #gpsResetBtn {
  display: inline-block !important;
  visibility: visible !important;
  flex: 2.5 1 0% !important;
}
.tab-content.active #gpsClearBtn {
  display: inline-block !important;
  visibility: visible !important;
  flex: 2.5 1 0% !important;
}
.tab-content.active .btn-row:has(#gpsCalcBtn) {
  display: block !important;
  visibility: visible !important;
}
.tab-content.active #gpsRes {
  display: block !important;
  visibility: visible !important;
}
.tab-content:not(.active) #gpsRes {
  display: none !important;
  visibility: hidden !important;
}
</style> <script>
  setTimeout(() => {
  const splash = document.getElementById("splash-screen");
  splash.style.opacity = "0";
  splash.style.transition = "0.4s";
  setTimeout(() => splash.remove(), 400);
  }, 500);
</script> <header></header><main><div class="tabs"><button class="tab-button active" data-tab="rftool" onclick="showTab('rftool')">ğŸ“¡ RFå·¥å…·</button><button class="tab-button" data-tab="rf" onclick="showTab('rf')">ã€°ï¸ ç·šæ</button><button class="tab-button" data-tab="gps" onclick="showTab('gps')">ğŸŒ GPS</button><button class="tab-button" data-tab="elevation" onclick="showTab('elevation')">ğŸ“ˆ é«˜åº¦åœ–</button><button class="tab-button" data-tab="report" onclick="showTab('report')">ğŸ“„ å ±å‘Š</button><button class="tab-button" data-tab="compass" onclick="showTab('compass')">ğŸ§­ æŒ‡åŒ—é‡</button><button class="tab-button" data-tab="archive" onclick="showTab('archive')">ğŸ’¾ å­˜æª”</button></div><div id="rf-content" class="tab-content"><div class="rf-header"><div class="section-title">TIMES ç·šæè¨ˆç®—</div><div class="unit-selector-row"><label for="unit" class="unit-label">é•·åº¦å–®ä½ï¼š</label><select id="unit"><option value="m">å…¬å°º (m)</option><option value="ft">è‹±å°º (ft)</option></select></div></div><section class="card orange-border-card" style="margin-top:6px;"><div class="form-grid"><div><label for="freq">é »ç‡ (MHz)</label><div class="input-with-clear-rf"><input id="freq" type="number" value="900" min="0" step="1" oninput="compute()"><button class="clear-btn-rf" onclick="clearRfInput('freq')">âœ–</button></div></div><div><label for="lenInput">é•·åº¦</label><div class="input-with-clear-rf"><input id="lenInput" type="number" value="10" min="0" step="0.01" oninput="compute()"><button class="clear-btn-rf" onclick="clearRfInput('lenInput')">âœ–</button></div></div></div><div id="liveInputs" class="small-note">å³æ™‚è¨ˆç®—ä¸­...</div></section><div class="btn-row" style="margin-top:6px; margin-bottom:6px;"><button id="reset" class="btn ghost" onclick="resetRf()">é è¨­</button><button id="clear" class="btn clear" onclick="clearRf()">æ¸…é™¤</button></div><section class="card results-card-border"><span class="section-title">è¨ˆç®—çµæœï¼ˆç”±å°åˆ°å¤§ï¼‰</span><div id="tableArea"></div></section></div><div id="gps-content" class="tab-content gps-container"><div class="card"><h2 class="section-title" style="margin-top:0;">å…©é»GPS è·é›¢ã€æ–¹ä½è§’èˆ‡ä¿¯ä»°è§’è¨ˆç®—</h2><p class="gps-tip">è€ƒæ…®åœ°çƒæ›²ç‡èˆ‡é«˜åº¦å·® (WGS84)</p><div class="display-mode-container"><span class="display-mode-text">é¡¯ç¤ºæ ¼å¼</span><select id="displayMode" style="padding:6px; border-radius:6px; font-size:14px;"><option value="decimal">åº¦ â€” åé€²åˆ¶ (DD)</option><option value="dms">åº¦åˆ†ç§’ (DMS)</option></select></div></div><div class="gps-ig orange-border-card"><div class="gps-loc-header"> åœ°é» A <div style="display:flex; align-items:center; gap:5px; flex:1;"><input type="text" id="nameA" placeholder="åœ°å A" maxlength="5" style="flex:1;" oninput="calculate()"><span>(åœ°å)</span><button class="gps-cb" onclick="clearNameOnly('A')">âœ–</button><button class="btn" style="background:linear-gradient(90deg, #ff9500, #ffcc00); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:16px; color:#000; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink:0; display:flex; align-items:center; justify-content:center; text-align:center; min-width:fit-content;" onclick="getCurrentLocation('A')" title="è®€å–ç•¶å‰GPSä½ç½®">ğŸ“</button><button class="btn" style="background:linear-gradient(90deg, #5fb3ff, #3d8eff); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:16px; color:#fff; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink:0; display:flex; align-items:center; justify-content:center; text-align:center; min-width:fit-content;" onclick="openMapPicker('A')" title="å¾åœ°åœ–é¸æ“‡åº§æ¨™">ğŸ—ºï¸</button></div></div><div class="gps-cg"><span class="gps-cl">ç·¯åº¦ (Latitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="latA" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001" value="25.0336" oninput="calculate()"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('latA')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="latA_deg" placeholder="åº¦" oninput="dmsToD('latA')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="latA_min" placeholder="åˆ†" oninput="dmsToD('latA')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="latA_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('latA')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('latA')">âœ–</button></div></div><div class="gps-cg"><span class="gps-cl">ç¶“åº¦ (Longitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="lonA" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001" value="121.5648" oninput="calculate()"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('lonA')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="lonA_deg" placeholder="åº¦" oninput="dmsToD('lonA')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="lonA_min" placeholder="åˆ†" oninput="dmsToD('lonA')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="lonA_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('lonA')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('lonA')">âœ–</button></div></div><div class="gps-er"><label for="eleA">é«˜åº¦ (Elevation)</label><div style="position:relative; flex-grow:1.2;"><input type="number" id="eleA" placeholder="è«‹è¼¸å…¥æ•¸å€¼" step="0.01" oninput="calculate()"><span id="eleA-loading" style="position:absolute; top:50%; left:0; transform:translateY(-50%); color:#ffd43b; font-weight:bold; display:none; pointer-events:none; padding:4px 8px;"></span></div><div class="control-group"><span>å…¬å°º (m)</span><button class="gps-cb" onclick="clearElevation('A')">âœ–</button><button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 6px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink:0; display:flex; align-items:center; justify-content:center; text-align:center; min-width:fit-content;" onclick="getElevationFromSRTM('A')">å–å¾—é«˜åº¦</button></div></div></div><div class="gps-ig orange-border-card"><div class="gps-loc-header"> åœ°é» B <div style="display:flex; align-items:center; gap:5px; flex:1;"><input type="text" id="nameB" placeholder="åœ°å B" maxlength="5" style="flex:1;" oninput="calculate()"><span>(åœ°å)</span><button class="gps-cb" onclick="clearNameOnly('B')">âœ–</button><button class="btn" style="background:linear-gradient(90deg, #ff9500, #ffcc00); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:16px; color:#000; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink:0; display:flex; align-items:center; justify-content:center; text-align:center; min-width:fit-content;" onclick="getCurrentLocation('B')" title="è®€å–ç•¶å‰GPSä½ç½®">ğŸ“</button><button class="btn" style="background:linear-gradient(90deg, #5fb3ff, #3d8eff); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:16px; color:#fff; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink:0; display:flex; align-items:center; justify-content:center; text-align:center; min-width:fit-content;" onclick="openMapPicker('B')" title="å¾åœ°åœ–é¸æ“‡åº§æ¨™">ğŸ—ºï¸</button></div></div><div class="gps-cg"><span class="gps-cl">ç·¯åº¦ (Latitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="latB" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001" value="25.1325" oninput="calculate()"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('latB')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="latB_deg" placeholder="åº¦" oninput="dmsToD('latB')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="latB_min" placeholder="åˆ†" oninput="dmsToD('latB')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="latB_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('latB')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('latB')">âœ–</button></div></div><div class="gps-cg"><span class="gps-cl">ç¶“åº¦ (Longitude) - åé€²åˆ¶/DMS</span><div class="gps-ddr"><input type="number" id="lonB" placeholder="åé€²åˆ¶æ•¸å€¼" step="0.000001" value="121.5065" oninput="calculate()"><span>(åº¦)</span><button class="gps-cb" onclick="clearCoord('lonB')">âœ–</button></div><div class="gps-dmsr"><div class="gps-dmsf"><input type="number" id="lonB_deg" placeholder="åº¦" oninput="dmsToD('lonB')"><span>(åº¦)</span></div><div class="gps-dmsf"><input type="number" id="lonB_min" placeholder="åˆ†" oninput="dmsToD('lonB')"><span>(åˆ†)</span></div><div class="gps-dmsf"><input style="min-width:60px;" type="number" id="lonB_sec" placeholder="ç§’" step="0.01" oninput="dmsToD('lonB')"><span>(ç§’)</span></div><button class="gps-cb" onclick="clearCoord('lonB')">âœ–</button></div></div><div class="gps-er"><label for="eleB">é«˜åº¦ (Elevation)</label><div style="position:relative; flex-grow:1.2;"><input type="number" id="eleB" placeholder="è«‹è¼¸å…¥æ•¸å€¼" step="0.01" oninput="calculate()"><span id="eleB-loading" style="position:absolute; top:50%; left:0; transform:translateY(-50%); color:#ffd43b; font-weight:bold; display:none; pointer-events:none; padding:4px 8px;"></span></div><div class="control-group"><span>å…¬å°º (m)</span><button class="gps-cb" onclick="clearElevation('B')">âœ–</button><button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 6px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; margin-left:4px; white-space:nowrap; flex-shrink:0; display:flex; align-items:center; justify-content:center; text-align:center; min-width:fit-content;" onclick="getElevationFromSRTM('B')">å–å¾—é«˜åº¦</button></div></div></div><div id="gps-controls-container"><div class="btn-row" style="margin-top:5px; margin-bottom:5px; gap:12px; display:flex !important; width:100% !important; justify-content:space-between !important;"><button id="gpsSwapBtn" class="btn" style="flex:1 1 0% !important; min-width:0 !important; box-sizing:border-box !important; background:linear-gradient(90deg, #bb66ff, #9945ff) !important; color:#fff !important;" onclick="swapGpsCoordinates()">äº’æ›Aâ†”B</button><button id="gpsResetBtn" class="btn ghost" style="flex:1 1 0% !important; min-width:0 !important; box-sizing:border-box !important;" onclick="resetGps()">é è¨­</button><button id="gpsClearBtn" class="btn clear" style="flex:1 1 0% !important; min-width:0 !important; box-sizing:border-box !important;" onclick="clearAllGps()">æ¸…é™¤</button></div><div id="gpsRes"> è¨ˆç®—ä¸­... </div></div></div><header></header><div class="tab-content active" id="rftool-content"><div class="rf-header"><div class="section-title">ğŸš€ ç¶œåˆ RFå·¥å…·</div></div><div class="function-selector-container"><label for="function_selector">é¸æ“‡é¡¯ç¤ºåŠŸèƒ½æ¨¡çµ„:</label><select id="function_selector" onchange="toggleSections()"><option value="ALL">ALL - é¡¯ç¤ºæ‰€æœ‰è¨ˆç®—å™¨</option><option value="power">1. åŠŸç‡è½‰æ› (dBm / W)</option><option value="matching">2. åŒ¹é…åº¦åƒæ•¸æ›ç®—</option><option value="sensitivity">3. ç³»çµ±éˆæ•åº¦ (Sensitivity) è¨ˆç®—</option><option value="los">4. é€šè¦–æœ€å¤§è·é›¢è¨ˆç®—</option><option value="fspl">5. è‡ªç”±ç©ºé–“æè€— (FSPL)</option><option value="linkbudget">6. é€šè¨Šæ¨¡æ“¬ (Link Budget)</option></select></div><section class="card section-item" id="section-power"><div class="section-header-with-controls"><div class="section-title">1. åŠŸç‡è½‰æ› (dBm / W)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-power')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-power')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="power_unit">é¸æ“‡è¼¸å…¥å–®ä½:</label><select id="power_unit" onchange="swapAndCalculate()"><option value="w">W</option><option value="dbm">dBm</option></select><label for="power_input">è¼¸å…¥æ•¸å€¼:</label><div class="input-with-clear"><input id="power_input" oninput="calculateDbmWNew()" placeholder="è¼¸å…¥æ•¸å€¼" type="number" value="1"/><button class="clear-button" onclick="clearAndRecalculate('power_input', 'calculateDbmWNew')">Ã—</button></div></div><div class="results-card-border" id="power_output_result">æ›ç®—çµæœ:</div></section><section class="card section-item" id="section-matching"><div class="section-header-with-controls"><div class="section-title">2. åŒ¹é…åº¦åƒæ•¸æ›ç®—</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-matching')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-matching')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="matching_unit">é¸æ“‡è¼¸å…¥åƒæ•¸:</label><select id="matching_unit" onchange="swapAndConvertMatching()"><option value="rl">å›æ³¢æè€— (Return Loss, RL) [dB]</option><option value="vswr">é§æ³¢æ¯” (VSWR)</option><option value="gamma">åå°„ä¿‚æ•¸ (V, Î“)</option><option value="refl_pct">åå°„åŠŸç‡ [%]</option><option value="pass_pct">é€šéåŠŸç‡ [%]</option></select><label for="matching_input_value" style="margin-top:8px;">è¼¸å…¥æ•¸å€¼:</label><div class="input-with-clear"><input id="matching_input_value" oninput="calculateMatching()" placeholder="ä¾‹å¦‚: 20" type="number" value="20"/><button class="clear-button" onclick="clearAndRecalculate('matching_input_value', 'calculateMatching')">Ã—</button></div></div><div class="results-card-border" id="matching_output"> å›æ³¢æè€— (RL) [dB]: <span class="result-value" id="rl_val"></span><br/> é§æ³¢æ¯” (VSWR): <span class="result-value" id="vswr_val"></span><br/> åå°„ä¿‚æ•¸ (Vï¼ŒÎ“): <span class="result-value" id="gamma_val"></span><br/> åå°„åŠŸç‡ [%]: <span class="result-value" id="refl_percent"></span><br/> é€šéåŠŸç‡ [%]: <span class="result-value" id="pass_percent"></span></div></section><section class="card section-item" id="section-sensitivity"><div class="section-header-with-controls"><div class="section-title">3. ç³»çµ±éˆæ•åº¦ (Sensitivity) è¨ˆç®—</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-sensitivity')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-sensitivity')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="sensitivity_bw">è¨Šè™Ÿé »å¯¬ (BW) [MHz]:</label><div class="input-with-clear"><input id="sensitivity_bw" oninput="calculateSensitivity()" placeholder="ä¾‹å¦‚: 1 (1MHz)" type="number" value="1"/><button class="clear-button" onclick="clearAndRecalculate('sensitivity_bw', 'calculateSensitivity')">Ã—</button></div><label for="sensitivity_nf">é›œè¨ŠæŒ‡æ•¸ (Noise Figure, NF) [dB]:</label><div class="input-with-clear"><input id="sensitivity_nf" oninput="calculateSensitivity()" placeholder="ä¾‹å¦‚: 5" type="number" value="5"/><button class="clear-button" onclick="clearAndRecalculate('sensitivity_nf', 'calculateSensitivity')">Ã—</button></div><label for="sensitivity_sn">æ‰€éœ€è¨Šé›œæ¯” (S/N) [dB]:</label><div class="input-with-clear"><input id="sensitivity_sn" oninput="calculateSensitivity()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('sensitivity_sn', 'calculateSensitivity')">Ã—</button></div></div><div class="results-card-border" id="sensitivity_output">æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity):</div></section><section class="card section-item" id="section-los"><div class="section-header-with-controls"><div class="section-title">4. é€šè¦–æœ€å¤§è·é›¢ (åœ°çƒæ›²åº¦é®è”½)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-los')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-los')">æ¸…é™¤</button></div></div><div class="input-group-border"><div class="los-point-title">A é»</div><div class="los-input-container"><div class="input-item"><label for="los_g1">å¤©ç·šæ¶è¨­é»æ°´å¹³é¢é«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_g1" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 100" type="number" value="0"/><button class="clear-button" onclick="clearAndRecalculate('los_g1', 'calculateMaxLOS')">Ã—</button></div></div><div class="input-item"><label for="los_h1">å¤©ç·šé«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_h1" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('los_h1', 'calculateMaxLOS')">Ã—</button></div></div></div><div class="los-point-title">B é»</div><div class="los-input-container"><div class="input-item"><label for="los_g2">å¤©ç·šæ¶è¨­é»æ°´å¹³é¢é«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_g2" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 150" type="number" value="0"/><button class="clear-button" onclick="clearAndRecalculate('los_g2', 'calculateMaxLOS')">Ã—</button></div></div><div class="input-item"><label for="los_h2">å¤©ç·šé«˜åº¦ [m]:</label><div class="input-with-clear"><input id="los_h2" oninput="calculateMaxLOS()" placeholder="ä¾‹å¦‚: 20" type="number" value="20"/><button class="clear-button" onclick="clearAndRecalculate('los_h2', 'calculateMaxLOS')">Ã—</button></div></div></div></div>
<div style="margin-top:6px;">
  <button class="btn ghost" onclick="toggleRefraction()" id="refBtn" style="color:#bb66ff;">ç›®å‰ï¼šä¸å«å¤§æ°£æŠ˜å°„</button>
</div>
<div class="results-card-border" id="los_output">æœ€å¤§é€šè¦–è·é›¢:</div></section><section class="card section-item" id="section-fspl"><div class="section-header-with-controls"><div class="section-title">5. è‡ªç”±ç©ºé–“æè€— (Free Space Path Loss, FSPL)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-fspl')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-fspl')">æ¸…é™¤</button></div></div><div class="input-group-border"><label for="fspl_freq">é »ç‡ (Frequency) [MHz]:</label><div class="input-with-clear"><input id="fspl_freq" oninput="calculateFSPL()" placeholder="ä¾‹å¦‚: 2400 (2.4 GHz)" type="number" value="2400"/><button class="clear-button" onclick="clearAndRecalculate('fspl_freq', 'calculateFSPL')">Ã—</button></div><label for="fspl_dist">è·é›¢ (Distance) [km]:</label><div class="input-with-clear"><input id="fspl_dist" oninput="calculateFSPL()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('fspl_dist', 'calculateFSPL')">Ã—</button></div></div><div class="results-card-border" id="fspl_output">è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL):</div></section><section class="card section-item" id="section-linkbudget"><div class="section-header-with-controls"><div class="section-title">6. é€šè¨Šæ¨¡æ“¬ (Link Budget)</div><div class="btn-group"><button class="btn btn-reset" onclick="resetSection('section-linkbudget')">é è¨­</button><button class="btn btn-clear" onclick="clearSection('section-linkbudget')">æ¸…é™¤</button></div></div><div class="input-group-border"><div class="los-point-title" style="margin-top:0;">é€šä¿¡åƒæ•¸</div><div class="los-input-container"><div class="input-item"><label for="link_freq_mhz">é »ç‡ [MHz]:</label><div class="input-with-clear"><input id="link_freq_mhz" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 2400 (2.4 GHz)" type="number" value="2400"/><button class="clear-button" onclick="clearAndRecalculate('link_freq_mhz', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_dist_km">è·é›¢ [km]:</label><div class="input-with-clear"><input id="link_dist_km" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 10" type="number" value="10"/><button class="clear-button" onclick="clearAndRecalculate('link_dist_km', 'calculateLinkBudget')">Ã—</button></div></div></div><div class="los-point-title">ç™¼å°„ç«¯(TX)</div><div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;"><label for="link_tx_power_unit" style="margin-bottom:0; flex-shrink:0; white-space:nowrap; min-width:160px;">ç™¼å°„åŠŸç‡è¼¸å…¥å–®ä½:</label><select id="link_tx_power_unit" onchange="swapLinkTxUnit()" style="flex:1; margin-bottom:0;"><option value="w">W</option><option value="dbm">dBm</option></select></div><div class="los-input-container"><div class="input-item"><label for="link_tx_power_input">ç™¼å°„åŠŸç‡ [W/dBm]:</label><div class="input-with-clear"><input id="link_tx_power_input" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 1 (1W)" type="number" value="1"/><button class="clear-button" onclick="clearAndRecalculate('link_tx_power_input', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_tx_gain_dbi">å¤©ç·šå¢ç›Š [dBi]:</label><div class="input-with-clear"><input id="link_tx_gain_dbi" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 3" type="number" value="3"/><button class="clear-button" onclick="clearAndRecalculate('link_tx_gain_dbi', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_tx_loss_db">ç·šæ [dB]:</label><div class="input-with-clear"><input id="link_tx_loss_db" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 3 (3 dB)" type="number" value="3"/><button class="clear-button" onclick="clearAndRecalculate('link_tx_loss_db', 'calculateLinkBudget')">Ã—</button></div></div></div><div class="los-point-title">æ¥æ”¶ç«¯(RX)</div><div class="los-input-container"><div class="input-item"><label for="link_rx_gain_dbi">å¤©ç·šå¢ç›Š [dBi]:</label><div class="input-with-clear"><input id="link_rx_gain_dbi" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 3" type="number" value="3"/><button class="clear-button" onclick="clearAndRecalculate('link_rx_gain_dbi', 'calculateLinkBudget')">Ã—</button></div></div><div class="input-item"><label for="link_rx_loss_db">ç·šæ [dB]:</label><div class="input-with-clear"><input id="link_rx_loss_db" oninput="calculateLinkBudget()" placeholder="ä¾‹å¦‚: 3 (3 dB)" type="number" value="3"/><button class="clear-button" onclick="clearAndRecalculate('link_rx_loss_db', 'calculateLinkBudget')">Ã—</button></div></div></div></div><div class="results-card-border" id="linkbudget_output">æ¥æ”¶è¨Šè™Ÿå¼·åº¦:</div></section></div><div id="elevation-content" class="tab-content">
<div class="card">
<h2 class="section-title" style="margin-top:0;">åœ°å½¢é®è”½åˆ†æ - è·¯å¾‘é«˜åº¦åœ–</h2>
<div class="orange-border-card" style="padding:10px 12px; margin-bottom:6px;">
<div style="display:grid; grid-template-columns:2fr 2fr 1.2fr; gap:5px; align-items:end; margin-bottom:10px;">
<div><label id="labelALat" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Aé»ç·¯åº¦</label><input type="number" id="sLat" value="25.0336" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label id="labelALng" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Aé»ç¶“åº¦</label><input type="number" id="sLng" value="121.5648" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">å¤©ç·šé«˜ (m)</label><input type="number" id="antennaHeightStart" value="3" step="0.1" min="0" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label id="labelBLat" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Bé»ç·¯åº¦</label><input type="number" id="eLat" value="25.1325" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label id="labelBLng" style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">Bé»ç¶“åº¦</label><input type="number" id="eLng" value="121.5065" step="0.0001" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
<div><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">å¤©ç·šé«˜ (m)</label><input type="number" id="antennaHeightEnd" value="3" step="0.1" min="0" style="width:100%; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"></div>
</div>
<div style="grid-column:span 3; display:flex; gap:10px; align-items:flex-end; margin-bottom:8px;">
<div style="display:flex; align-items:center; gap:5px; flex:1;">
<label style="color:var(--label); font-size:15px; margin-bottom:0; display:block; flex-shrink:0;">æ¡æ¨£é»æ•¸</label>
<input type="number" id="samples" value="500" min="2" max="2000" style="flex:1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);">
</div>
<button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:6px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; height:34px; flex-shrink:0; min-width:42px;" onclick="smartIncreaseSamples(100)">100</button>
<button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:6px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; height:34px; flex-shrink:0; min-width:42px;" onclick="smartIncreaseSamples(1000)">1K</button>
<button class="btn" style="background:linear-gradient(90deg, #2f9e44, #2b8a3e); border:0; padding:5px 8px; border-radius:6px; font-weight:700; font-size:16px; color:#fff; cursor:pointer; white-space:nowrap; height:34px; flex-shrink:0;" onclick="setMaxEffectivePoints()">æ»¿æ ¼æ¡æ¨£</button>
</div>
<div style="display:flex; gap:10px; align-items:flex-start;">
<div style="flex:1; display:flex; flex-direction:column; gap:3px;"><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">æœ€å°é«˜åº¦ (m)</label><div style="display:flex; gap:3px;"><input type="number" id="minElevation" placeholder="è‡ªå‹•" oninput="updateChartYAxis()" style="flex:1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"><button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="document.getElementById('minElevation').value=''; document.getElementById('minElevation').placeholder='è‡ªå‹•'; updateChartYAxis();">è‡ªå‹•</button></div></div>
<div style="flex:1; display:flex; flex-direction:column; gap:3px;"><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">æœ€å¤§é«˜åº¦ (m)</label><div style="display:flex; gap:3px;"><input type="number" id="maxElevation" placeholder="è‡ªå‹•" oninput="updateChartYAxis()" style="flex:1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"><button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="document.getElementById('maxElevation').value=''; document.getElementById('maxElevation').placeholder='è‡ªå‹•'; updateChartYAxis();">è‡ªå‹•</button></div></div>
</div>
<div style="display:flex; gap:10px; align-items:flex-start; margin-top:10px;">
<div style="flex:1; display:flex; flex-direction:column; gap:3px;"><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">èµ·å§‹è·é›¢ (é»)</label><div style="display:flex; gap:3px;"><input type="number" id="minDistance" placeholder="è‡ªå‹•" oninput="updateChartXAxis()" style="flex:1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"><button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="document.getElementById('minDistance').value=''; document.getElementById('minDistance').placeholder='è‡ªå‹•'; updateChartXAxis();">è‡ªå‹•</button></div></div>
<div style="flex:1; display:flex; flex-direction:column; gap:3px;"><label style="color:var(--label); font-size:15px; margin-bottom:1px; display:block;">çµæŸè·é›¢ (é»)</label><div style="display:flex; gap:3px;"><input type="number" id="maxDistance" placeholder="è‡ªå‹•" oninput="updateChartXAxis()" style="flex:1; padding:5px 8px; font-size:17px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);"><button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:5px 8px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:fit-content;" onclick="document.getElementById('maxDistance').value=''; document.getElementById('maxDistance').placeholder='è‡ªå‹•'; updateChartXAxis();">è‡ªå‹•</button></div></div>
</div>
</div>
<div style="margin-bottom:6px; padding:10px 8px; background:rgba(187, 102, 255, 0.08); border:1px solid var(--purple-accent); border-radius:6px;">
<label style="color:var(--label); font-size:15px; font-weight:700; display:block; margin-bottom:6px;">ğŸ“¡ é«˜åº¦è³‡æ–™ä¾†æº <span style="font-size:12px; font-weight:400; color:var(--muted);">ï¼ˆé€£ç¶²ä½¿ç”¨ï¼‰</span></label>
<select id="elevationApiSelector" style="width:100%; padding:6px 8px; font-size:15px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15); cursor:pointer;" onchange="toggleLocalFileUpload()">
<option value="taiwan-dsm" selected>ğŸ‡¹ğŸ‡¼ å…§æ”¿éƒ¨ DSM 20mï¼ˆå°ç£ï¼Œå«å»ºç‰©ï¼‰</option>
<option value="google-maps">ğŸ—ºï¸ Google Maps Elevation API</option>
<option value="open-elevation">ğŸ—» Open-Elevation SRTMï¼ˆ30mï¼‰</option>
<option value="openmeteo">ğŸŒ Open-Meteo APIï¼ˆ90mï¼‰</option>
<option value="astergdem">ğŸ”ï¸ ASTER GDEM v3ï¼ˆ30mï¼‰</option>
</select>
<span id="apiInfo" style="font-size:12px; color:var(--muted); margin-top:4px; display:block;"></span>
<div id="localFileUploadDiv" style="margin-top:8px; display:block;">
<label style="color:#ffd43b; font-size:14px; font-weight:700; display:block; margin-bottom:6px;">ğŸ“‚ é›¢ç·šæ¨¡å¼ï¼šé¸æ“‡æœ¬æ©Ÿ TIF æª”æ¡ˆ <span style="font-size:12px; font-weight:400; color:var(--muted);">ï¼ˆå„ªå…ˆä½¿ç”¨ï¼‰</span></label>

<div style="display:flex; gap:6px; align-items:center; margin-bottom:6px;">
<input type="file" id="localTifFile" accept=".tif,.tiff,*/*" style="display:none;" onchange="handleLocalTifFile(event)">
<button onclick="document.getElementById('localTifFile').click()" style="flex:1; padding:8px 12px; font-size:15px; color:#022; background:linear-gradient(90deg,#5ff0d5,#79a8ff); border:none; border-radius:6px; cursor:pointer; font-weight:700;">
ğŸ“‚ é¸æ“‡ TIF æª”æ¡ˆ
</button>
<button id="clearLocalTifBtn" onclick="clearLocalTifFile()" style="padding:8px 12px; font-size:14px; color:#fff; background:#dc3545; border:none; border-radius:6px; cursor:pointer; font-weight:700; display:none;">
âœ– æ¸…é™¤
</button>
</div>
<div id="currentDataSource" style="padding:8px 10px; background:rgba(255, 170, 0, 0.15); border:2px solid #ffaa00; border-radius:6px; margin-bottom:6px; display:block;">
<div style="font-size:13px; font-weight:700; color:#ffd43b; margin-bottom:3px;">ğŸ“Š ç›®å‰ä½¿ç”¨ï¼š</div>
<div id="currentSourceText" style="font-size:14px; font-weight:600; color:#5ff0d5;">âš ï¸ å°šæœªé¸æ“‡æœ¬æ©Ÿæª”æ¡ˆï¼ˆæœªé€£ç¶²å°‡å¤±æ•—ï¼‰</div>
</div>
<span id="localFileInfo" style="font-size:12px; color:var(--muted); margin-top:4px; display:block;"></span>
</div>
</div>
<div style="margin-bottom:6px; padding:10px 8px; background:rgba(255, 170, 0, 0.08); border:1px solid var(--orange-border); border-radius:6px; display:none;" id="nodataHandlingDiv">
<label style="color:#ffd43b; font-size:14px; font-weight:700; display:block; margin-bottom:6px;">âš ï¸ ç¼ºå¤±æ•¸æ“šè™•ç†æ–¹å¼</label>
<select id="nodataHandling" style="width:100%; padding:6px 8px; font-size:14px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15); cursor:pointer;">
<option value="google-api" selected>ğŸ—ºï¸ Google Map Elevation APIï¼ˆæ¨è–¦ï¼‰</option>
<option value="interpolate">ğŸ”„ æ™ºæ…§æ’å€¼ï¼ˆé„°è¿‘æœ‰æ•ˆå€¼ï¼‰</option>
<option value="zero">0ï¸âƒ£ è¨­ç‚º 0 ç±³</option>
<option value="skip">â­ï¸ æ¨™è¨˜ç„¡æ•ˆä¸¦è·³é</option>
</select>
<span style="font-size:11px; color:var(--muted); margin-top:4px; display:block;">è·¯å¾‘ç¶“éç„¡åœ–è³‡å€åŸŸæ™‚ä½¿ç”¨ï¼ˆå¦‚æ¨‚å±±é›·é”ç«™ï¼‰</span>
</div>
<button class="btn" style="background:linear-gradient(90deg,var(--accent1),var(--accent2)); border:0; padding:6px 12px; border-radius:6px; font-weight:700; font-size:18px; color:#022; cursor:pointer; width:100%; margin-bottom:4px;" onclick="runAnalysis()">ğŸŒ ç”Ÿæˆè·¯å¾‘å‰–é¢</button>
<div style="display:flex; gap:8px; margin-bottom:4px;">
<button id="toggleGreenPointsBtn" class="btn" style="background:linear-gradient(90deg,#6c757d,#5a6268); border:0; padding:6px 12px; border-radius:6px; font-weight:700; font-size:16px; color:#fff; cursor:pointer; width:100%;" onclick="toggleGreenPoints()">ğŸ‘ï¸ é¡¯ç¤ºç¯€é»</button>
</div>
<div id="summary" style="margin:4px 0; padding:6px; text-align:center; font-weight:bold; color:#79a8ff; font-size:14px;">è«‹è¼¸å…¥åº§æ¨™ä¸¦åŸ·è¡Œ</div>
<div style="position:relative; height:300px; width:100%; margin-bottom:20px; border:3px solid #4dabf7; border-radius:8px; padding:8px; background:rgba(77, 171, 247, 0.05);">
<canvas id="elevationChart"></canvas>
<button class="chart-zoom-btn" onclick="openChartFullscreen()" title="æ”¾å¤§åœ–è¡¨">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<circle cx="11" cy="11" r="8"></circle>
<path d="M21 21l-4.35-4.35"></path>
<path d="M11 8v6M8 11h6"></path>
</svg>
</button>
</div>
<div style="padding:12px; margin-bottom:0; background:rgba(255, 170, 0, 0.05); border-radius:8px; border:2px solid #ffaa00;">
<div style="display:flex; gap:8px; align-items:center; margin-bottom:4px; padding:6px 0;">
<label style="color:#ffd43b; font-size:15px; font-weight:700; flex-shrink:0;">ä½ç½®ï¼š</label>
<input type="number" id="selectedPointIndex" placeholder="é»æ“Šåœ–è¡¨é¸æ“‡é»" style="flex:1; padding:6px 8px; font-size:16px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15); text-align:center;" oninput="updatePointFromInput()">
<button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:6px 16px; border-radius:4px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="decrementSelectedPoint()">â¬…</button>
<button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:6px 16px; border-radius:4px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="incrementSelectedPoint()">â¡</button>
<button class="btn" style="background:linear-gradient(90deg, #4dabf7, #339af0); border:0; padding:6px 10px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="jumpToStartPoint()">Aé»</button>
<button class="btn" style="background:linear-gradient(90deg, #ff6b6b, #e03131); border:0; padding:6px 10px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="jumpToEndPoint()">Bé»</button>
</div>
<div style="display:flex; gap:8px; align-items:center; justify-content:center; margin-bottom:4px; padding:6px 0;">
<label style="color:#ffd43b; font-size:15px; font-weight:700; flex-shrink:0; margin-right:8px;">é«˜åº¦ï¼š</label>
<button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:6px 16px; border-radius:4px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="jumpToHigherPoint()" title="è·³åˆ°æ›´é«˜çš„é»">â¬†</button>
<button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:6px 16px; border-radius:4px; font-weight:700; font-size:16px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:34px;" onclick="jumpToLowerPoint()" title="è·³åˆ°æ›´ä½çš„é»">â¬‡</button>
<button class="btn" style="background:linear-gradient(90deg, #4dabf7, #339af0); border:0; padding:6px 12px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex:1; height:34px;" onclick="jumpToMinPoint()">æœ€ä½é»</button>
<button class="btn" style="background:linear-gradient(90deg, #ff6b6b, #e03131); border:0; padding:6px 12px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex:1; height:34px;" onclick="jumpToMaxPoint()">æœ€é«˜é»</button>
</div>
<div style="display:flex; gap:8px; align-items:center; justify-content:center; padding:6px 0;">
<label style="color:#ffd43b; font-size:15px; font-weight:700; flex-shrink:0; margin-right:8px;">é®è”½ï¼š</label>
<button class="btn" style="background:linear-gradient(90deg, #c92a2a, #a61e1e); border:0; padding:6px 14px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex:1; height:34px;" onclick="jumpToMaxObstruction()">ä¸»é®è”½</button>
<button class="btn" style="background:linear-gradient(90deg, #ff8fab, #ff6b8a); border:0; padding:6px 14px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex:1; height:34px;" onclick="jumpToFirstObstructionFromStart()">Aé»éšœç¤™</button>
<button class="btn" style="background:linear-gradient(90deg, #ff8fab, #ff6b8a); border:0; padding:6px 14px; border-radius:4px; font-weight:700; font-size:14px; color:#fff; cursor:pointer; white-space:nowrap; flex:1; height:34px;" onclick="jumpToFirstObstructionFromEnd()">Bé»éšœç¤™</button>
</div>
</div>
<div id="map-container" style="margin-top:5px; text-align:center; display:none; padding:0; border-top:none;">
<div id="map-details" style="width:100%; box-sizing:border-box; margin:0 0 15px 0; font-size:0.95em; color:#e8eef5; text-align:left; padding:12px; border:2px solid #79a8ff; border-radius:8px; background-color:rgba(121, 168, 255, 0.05);">è«‹é»æ“Šä¸Šæ–¹åœ–è¡¨çš„é»</div>
<iframe id="map-frame" style="border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.2); border:2px solid #5ff0d5; width:100%; height:450px;" src="" allowfullscreen loading="lazy"></iframe>
</div>
<div id="route-map-container" style="margin-top:5px; text-align:center; display:none; padding:0; border-top:none;">
<div id="route-map-details" style="width:100%; box-sizing:border-box; margin:0 0 15px 0; font-size:0.75em; color:#e8eef5; text-align:left; padding:10px; border:2px solid #79a8ff; border-radius:8px; background-color:rgba(121, 168, 255, 0.05);">
<strong><span style="color:#ffd43b;">è·¯å¾‘è³‡è¨Š</span></strong><br>
<span style="color:#4a90e2;">Aé»:</span> <span style="color:#5ff0d5;" id="route-start-info">-</span><br>
<span style="color:#ea4335;">Bé»:</span> <span style="color:#5ff0d5;" id="route-end-info">-</span><br>
<span style="color:#ffd43b;">ç›´ç·šè·é›¢:</span> <span style="color:#5ff0d5;" id="route-distance-info">-</span>
</div>
<button id="maximizeMapBtn" onclick="maximizeRouteMap()" style="background:linear-gradient(90deg, #4dabf7, #339af0); border:0; padding:5px 10px; border-radius:6px; font-weight:700; font-size:13px; color:#fff; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,0.3); display:inline-flex; align-items:center; gap:6px; margin-bottom:3px;">
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
</svg>
ğŸ” æœ€å¤§åŒ–åœ°åœ–
</button>
<div id="route-map" style="width:100%; height:450px; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.2); border:2px solid #5ff0d5;"></div>
</div>
</div>
</div>

<!-- æŒ‡åŒ—é‡åˆ†é  -->
<div id="compass-content" class="tab-content">
  <style>
  #compass-content.active {
    display: flex !important;
    justify-content: center;
    align-items: center;
    min-height: 80vh;
    padding: 20px;
  }

  .compass-wrapper {
    text-align: center;
    max-width: 400px;
    width: 100%;
    position: relative;
  }

  .compass-fullscreen-btn {
    position: absolute;
    top: 0;
    right: 0;
    width: 44px;
    height: 44px;
    background: linear-gradient(90deg, #9b59b6, #8e44ad);
    border: none;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(155, 89, 182, 0.4);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    z-index: 100;
  }

  .compass-fullscreen-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(155, 89, 182, 0.6);
  }

  .compass-fullscreen-btn:active {
    transform: scale(0.95);
  }

  .compass-fullscreen-btn svg {
    width: 24px;
    height: 24px;
    stroke: white;
  }

  .compass-degree-display {
    color: white;
    font-size: 56px;
    font-weight: 300;
    margin-bottom: 8px;
    text-shadow: 0 2px 10px rgba(0,0,0,0.3);
  }

  .compass-direction-display {
    color: #4fc3f7;
    font-size: 28px;
    font-weight: 500;
    margin-bottom: 30px;
    letter-spacing: 2px;
  }

  .compass-container {
    position: relative;
    width: 300px;
    height: 300px;
    margin: 0 auto;
  }

  .compass-outer {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: linear-gradient(145deg, #2c5282, #1a365d);
    box-shadow: 0 20px 60px rgba(0,0,0,0.5),
          inset 0 -2px 10px rgba(0,0,0,0.3);
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .compass-inner {
    width: 260px;
    height: 260px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #3a5a7a, #1e3a5f);
    position: relative;
    transition: transform 0.3s ease-out;
    box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
  }

  .compass-rose {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
  }

  .compass-cardinal {
    position: absolute;
    font-weight: bold;
    font-size: 22px;
    color: white;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    text-align: center;
    line-height: 1.3;
  }
  
  .compass-cardinal > div {
    line-height: 1.3;
  }

  .compass-north {
    top: 5px !important;  /* N åœ¨æ­£ä¸Šæ–¹ = 0Â° */
    left: 50% !important;
    transform: translateX(-50%) !important;
    color: #ef5350;
    font-size: 24px;
  }

  .compass-east {
    right: 5px !important;  /* E åœ¨æ­£å³æ–¹ = 90Â° */
    top: 50% !important;
    transform: translateY(-50%) !important;
  }

  .compass-south {
    bottom: 5px !important;  /* S åœ¨æ­£ä¸‹æ–¹ = 180Â° */
    left: 50% !important;
    transform: translateX(-50%) !important;
  }

  .compass-west {
    left: 5px !important;  /* W åœ¨æ­£å·¦æ–¹ = 270Â° */
    top: 50% !important;
    transform: translateY(-50%) !important;
  }

  .compass-needle-container {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .compass-needle {
    position: absolute;
    width: 6px;
    height: 110px;
    top: 50%;
    left: 50%;
    margin-left: -3px;
    margin-top: -55px;
  }

  .compass-needle-north {
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-bottom: 55px solid #ef5350;
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
  }

  .compass-needle-south {
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 55px solid #e0e0e0;
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
  }

  .compass-center-dot {
    position: absolute;
    width: 14px;
    height: 14px;
    background: #ffffff;
    border-radius: 50%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    z-index: 10;
  }

  .compass-degree-marks {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
  }

  .compass-mark {
    position: absolute;
    background: rgba(255,255,255,0.4);
    left: 50%;
    top: 6px;
    transform-origin: 0 124px;
  }

  .compass-mark-major {
    width: 2px;
    height: 10px;
    margin-left: -1px;
    background: rgba(255,255,255,0.6);
  }

  .compass-mark-minor {
    width: 1px;
    height: 5px;
    margin-left: -0.5px;
  }

  .compass-info-text {
    color: rgba(255,255,255,0.7);
    font-size: 13px;
    margin-top: 25px;
  }

  .compass-error-message {
    color: #ff6b6b;
    background: rgba(255,255,255,0.1);
    padding: 12px;
    border-radius: 6px;
    margin-top: 20px;
    font-size: 13px;
  }

  @keyframes compass-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  .compass-calibrating {
    animation: compass-pulse 1.5s infinite;
  }

  .compass-sensor-info {
    margin-top: 30px;
    background: rgba(255, 255, 255, 0.06);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  }

  .compass-sensor-title {
    color: #85c9ff;
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
    text-align: left;
  }

  .compass-sensor-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  .compass-sensor-item:last-child {
    border-bottom: none;
  }

  .compass-sensor-label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 14px;
  }

  .compass-sensor-value {
    color: #5ff0d5;
    font-size: 16px;
    font-weight: 500;
  }

  .compass-location-btn {
    background: linear-gradient(90deg, #ff9500, #ffcc00);
    border: 0;
    padding: 8px 16px;
    border-radius: 6px;
    font-weight: 700;
    font-size: 14px;
    color: #000;
    cursor: pointer;
    margin-bottom: 10px;
    flex: 1;
  }

  .compass-map-btn {
    background: linear-gradient(90deg, #5fb3ff, #3d8eff);
    border: 0;
    padding: 8px 16px;
    border-radius: 6px;
    font-weight: 700;
    font-size: 14px;
    color: #fff;
    cursor: pointer;
    margin-bottom: 10px;
    flex: 1;
  }

  .compass-button-row {
    display: flex;
    gap: 8px;
    margin-bottom: 10px;
  }

  .compass-loading {
    color: #ffd43b;
    font-style: italic;
  }
  </style>

  <div class="compass-wrapper">
    <!-- å³ä¸Šè§’å…¨è¢å¹•æŒ‰éˆ• -->
    <button class="compass-fullscreen-btn" onclick="lockScreenOrientation()" title="é–å®šå‚ç›´å…¨è¢å¹•">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
      </svg>
    </button>

    <div class="compass-degree-display" id="compassDegreeDisplay">0Â°</div>
    <div class="compass-direction-display" id="compassDirectionDisplay">åŒ—</div>

    <div class="compass-container">
      <div class="compass-outer">
        <div class="compass-inner" id="compassRoseInner">
          <!-- æ–¹ä½æ¨™è¨˜å±¤ -->
          <div class="compass-rose">
            <div class="compass-cardinal compass-north">
              <div style="transform: rotate(0deg); line-height: 1.3;">
                N<br><span style="font-size:18px;">åŒ—</span>
              </div>
            </div>
            <div class="compass-cardinal compass-east">
              <div style="transform: rotate(-90deg); line-height: 1.3;">
                <span style="display:inline-block; transform:rotate(180deg); font-size:18px;">æ±</span><br>
                <span style="display:inline-block; transform:rotate(180deg);">E</span>
              </div>
            </div>
            <div class="compass-cardinal compass-south">
              <div style="transform: rotate(180deg); line-height: 1.3;">
                S<br><span style="font-size:18px;">å—</span>
              </div>
            </div>
            <div class="compass-cardinal compass-west">
              <div style="transform: rotate(90deg); line-height: 1.3;">
                <span style="display:inline-block; transform:rotate(180deg); font-size:18px;">è¥¿</span><br>
                <span style="display:inline-block; transform:rotate(180deg);">W</span>
              </div>
            </div>
          </div>

          <!-- åˆ»åº¦æ¨™è¨˜å±¤ -->
          <div class="compass-degree-marks" id="compassDegreeMarks"></div>

          <!-- ä¸­å¿ƒé» -->
          <div class="compass-center-dot"></div>
        </div>
      </div>

      <!-- æŒ‡é‡ï¼ˆå›ºå®šä¸è½‰ï¼Œæ°¸é æŒ‡å‘æ­£ä¸Šæ–¹ï¼‰ -->
      <div class="compass-needle-container">
        <div class="compass-needle">
          <div class="compass-needle-north"></div>
          <div class="compass-needle-south"></div>
        </div>
      </div>
    </div>

    <div class="compass-info-text" id="compassInfoText" style="display:none;">æ­£åœ¨æ ¡æº–æŒ‡åŒ—é‡...</div>
    <div class="compass-error-message" id="compassErrorMessage" style="display:none;"></div>

    <!-- æ–°å¢:æ„Ÿæ¸¬å™¨è³‡è¨Šé¡¯ç¤ºå€åŸŸ -->
    <div class="compass-sensor-info">
      <div class="compass-sensor-item">
        <span class="compass-sensor-label">ä¿¯ä»°è§’ / æ©«æ»¾è§’</span>
        <span class="compass-sensor-value">
          <span id="compassPitch">--Â°</span> / <span id="compassRoll">--Â°</span>
        </span>
      </div>

      <div class="compass-button-row">
        <button class="compass-location-btn" onclick="getCompassLocation()">ğŸ“ å–å¾—å®šä½è³‡è¨Š</button>
        <button class="compass-map-btn" onclick="openCompassMapPickerUsingGPS()">ğŸ—ºï¸ æ‰‹å‹•é¸æ“‡å®šä½</button>
      </div>

      <div class="compass-sensor-item">
        <span class="compass-sensor-label">ç•¶å‰åº§æ¨™</span>
        <span class="compass-sensor-value" id="compassCoordinates">
          <span class="compass-loading">å°šæœªå®šä½</span>
        </span>
      </div>

      <div class="compass-sensor-item">
        <span class="compass-sensor-label">åœ°å½¢ / å»ºç‰© é«˜åº¦</span>
        <span class="compass-sensor-value">
          <span id="compassElevationTerrain">--</span> / <span id="compassElevationBuilding">--</span>
        </span>
      </div>
    </div>
  </div>

  <script>
  (function() {
    const compassRoseInner = document.getElementById('compassRoseInner');
    const compassDegreeDisplay = document.getElementById('compassDegreeDisplay');
    const compassDirectionDisplay = document.getElementById('compassDirectionDisplay');
    const compassInfoText = document.getElementById('compassInfoText');
    const compassErrorMessage = document.getElementById('compassErrorMessage');
    const compassDegreeMarks = document.getElementById('compassDegreeMarks');

    // æ–°å¢ï¼šæ„Ÿæ¸¬å™¨è³‡è¨Šå…ƒç´ 
    const compassPitch = document.getElementById('compassPitch');
    const compassRoll = document.getElementById('compassRoll');

    // å„²å­˜ç•¶å‰ä½ç½®è³‡è¨Š
    let currentLat = null;
    let currentLng = null;

    // å‘é‡å¹³å‡æ³•å¹³æ»‘æ•¸æ“šï¼ˆåƒè€ƒ 431.htmlï¼‰
    let samples = [];
    const MAX_SAMPLES = 15; // æ¡æ¨£è¦–çª—å¤§å°ï¼Œèª¿æ•´å¾Œæ›´å¿«åæ‡‰

    // ğŸ”§ ä¿®æ­£: è¿½è¹¤ç´¯ç©æ—‹è½‰è§’åº¦ï¼Œé¿å… 360Â°/0Â° åˆ‡æ›æ™‚è½‰ä¸€åœˆ
    let accumulatedRotation = 0; // ç´¯ç©çš„æ—‹è½‰è§’åº¦ï¼ˆå¯ä»¥è¶…é 360Â° æˆ–å°æ–¼ 0Â°ï¼‰
    let lastAngle = null; // ä¸Šä¸€æ¬¡çš„è§’åº¦

    // ç”Ÿæˆåˆ»åº¦æ¨™è¨˜ï¼ˆ0Â° ~ 355Â°ï¼Œæ¯ 5Â° ä¸€å€‹åˆ»åº¦ï¼‰
    // æ³¨æ„ï¼šä¸ç”Ÿæˆ 360Â° åˆ»åº¦ï¼Œå› ç‚º 360Â° = 0Â°ï¼ˆåŒä¸€æ–¹å‘ï¼‰
    for (let i = 0; i < 360; i += 5) {
    const mark = document.createElement('div');
    mark.className = i % 30 === 0 ? 'compass-mark compass-mark-major' : 'compass-mark compass-mark-minor';
    mark.style.transform = `translateX(-50%) rotate(${i}deg)`;
    
    // ğŸ¯ æ¸¬è©¦ï¼šåœ¨ 0Â° ä½ç½®åŠ ä¸Šç‰¹æ®Šæ¨™è¨˜ï¼Œç¢ºèªå°é½Š
    if (i === 0) {
      mark.style.background = '#ff0000';  // ç´…è‰²
      mark.style.width = '3px';
      mark.style.height = '15px';
      mark.style.marginLeft = '-1.5px';
    }
    
    compassDegreeMarks.appendChild(mark);
    }

    // æ–¹å‘å°ç…§è¡¨
    // æ³¨æ„ï¼šæŒ‡åŒ—é‡åªæœ‰ 0Â°ï½359Â°ï¼Œæ²’æœ‰ 360Â°ï¼ˆ360Â° = 0Â°ï¼‰
    const directions = [
    { name: 'åŒ—', range: [0, 22.5] },
    { name: 'æ±åŒ—', range: [22.5, 67.5] },
    { name: 'æ±', range: [67.5, 112.5] },
    { name: 'æ±å—', range: [112.5, 157.5] },
    { name: 'å—', range: [157.5, 202.5] },
    { name: 'è¥¿å—', range: [202.5, 247.5] },
    { name: 'è¥¿', range: [247.5, 292.5] },
    { name: 'è¥¿åŒ—', range: [292.5, 337.5] },
    { name: 'åŒ—', range: [337.5, 360] }  // 337.5Â° ~ 359.99...Â° é¡¯ç¤ºç‚ºã€ŒåŒ—ã€
    ];

    function getDirection(degree) {
    // ç¢ºä¿è§’åº¦åœ¨ 0-359.99... ç¯„åœå…§
    const normalizedDegree = ((degree % 360) + 360) % 360;
    
    for (let dir of directions) {
      if (normalizedDegree >= dir.range[0] && normalizedDegree < dir.range[1]) {
      return dir.name;
      }
    }
    return 'åŒ—';  // é è¨­è¿”å›åŒ—ï¼ˆæ¶µè“‹ 337.5Â° ä»¥ä¸Šçš„æƒ…æ³ï¼‰
    }

    function handleOrientation(event) {
    let heading = event.alpha;

    if (event.webkitCompassHeading) {
      // iOS è¨­å‚™ä½¿ç”¨ webkitCompassHeading (å·²ç¶“æ˜¯ç£åŒ—æ–¹å‘)
      heading = event.webkitCompassHeading;
    } else if (event.alpha !== null) {
      // Android è¨­å‚™ä½¿ç”¨ alpha (éœ€è¦è½‰æ›)
      heading = 360 - event.alpha;
    }

    if (heading !== null) {
      // å‘é‡å¹³å‡æ³•è™•ç†æŠ–å‹•
      const rad = heading * Math.PI / 180;
      samples.push({ x: Math.cos(rad), y: Math.sin(rad) });
      if (samples.length > MAX_SAMPLES) samples.shift();

      let sumX = 0, sumY = 0;
      samples.forEach(s => { sumX += s.x; sumY += s.y; });

      let avgRad = Math.atan2(sumY, sumX);
      let smoothedHeading = (avgRad * 180 / Math.PI + 360) % 360;
      
      // å››æ¨äº”å…¥
      let roundedHeading = Math.round(smoothedHeading);
      if (roundedHeading >= 360) {
        roundedHeading = 0;
      }

      // ğŸ¯ ä¿®æ­£ 0Â°/360Â° é‚Šç•Œå•é¡Œ
      if (lastAngle !== null) {
        // è¨ˆç®—è§’åº¦è®ŠåŒ–
        let delta = smoothedHeading - lastAngle;
        
        // é¸æ“‡æœ€çŸ­è·¯å¾‘ï¼ˆé¿å…è½‰ä¸€æ•´åœˆï¼‰
        if (delta > 180) {
          delta -= 360;
        } else if (delta < -180) {
          delta += 360;
        }
        
        // ç´¯ç©æ—‹è½‰è§’åº¦ï¼ˆå–è² å€¼ï¼Œå› ç‚ºç¾…ç›¤è¦åå‘æ—‹è½‰ï¼‰
        accumulatedRotation -= delta;
      } else {
        // é¦–æ¬¡é‹è¡Œï¼šç›´æ¥è¨­å®šç‚ºè² çš„ç•¶å‰è§’åº¦
        accumulatedRotation = -smoothedHeading;
      }
      
      lastAngle = smoothedHeading;
      
      // ä½¿ç”¨ç´¯ç©æ—‹è½‰è§’åº¦ï¼ˆé€™æ¨£å¯ä»¥å¹³æ»‘è·¨è¶Š 0Â°/360Â° é‚Šç•Œï¼‰
      compassRoseInner.style.transform = `rotate(${accumulatedRotation}deg)`;
      
      // é¡¯ç¤ºè§’åº¦
      compassDegreeDisplay.textContent = `${roundedHeading}Â°`;
      compassDirectionDisplay.textContent = getDirection(roundedHeading);

      // ç§»é™¤ã€ŒæŒ‡åŒ—é‡å·²å°±ç·’ã€æ–‡å­—é¡¯ç¤º
      if (compassInfoText.classList.contains('compass-calibrating')) {
      compassInfoText.classList.remove('compass-calibrating');
      compassInfoText.style.display = 'none';
      }
    }

    // æ–°å¢ï¼šæ›´æ–°ä¿¯ä»°è§’å’Œæ©«æ»¾è§’
    if (event.beta !== null && event.beta !== undefined) {
      const pitch = Math.round(event.beta);
      compassPitch.textContent = `${pitch}Â°`;
    }

    if (event.gamma !== null && event.gamma !== undefined) {
      const roll = Math.round(event.gamma);
      compassRoll.textContent = `${roll}Â°`;
    }
    }

    // æª¢æŸ¥è¨­å‚™æ–¹å‘æ”¯æ´
    if (window.DeviceOrientationEvent) {
    // iOS 13+ éœ€è¦è«‹æ±‚æ¬Šé™
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
      .then(permissionState => {
        if (permissionState === 'granted') {
        // iOS è¨­å‚™ä½¿ç”¨ deviceorientation (æœ‰ webkitCompassHeading)
        window.addEventListener('deviceorientation', handleOrientation);
        compassInfoText.classList.add('compass-calibrating');
        } else {
        compassErrorMessage.textContent = 'éœ€è¦è£ç½®æ–¹å‘æ¬Šé™æ‰èƒ½ä½¿ç”¨æŒ‡åŒ—é‡';
        compassErrorMessage.style.display = 'block';
        compassInfoText.style.display = 'none';
        }
      })
      .catch(error => {
        compassErrorMessage.textContent = 'ç„¡æ³•è«‹æ±‚è£ç½®æ–¹å‘æ¬Šé™';
        compassErrorMessage.style.display = 'block';
        compassInfoText.style.display = 'none';
      });
    } else {
      // é iOS è¨­å‚™ï¼šå„ªå…ˆä½¿ç”¨ deviceorientationabsolute (çµ•å°æ–¹å‘)
      window.addEventListener('deviceorientationabsolute', handleOrientation, true);
      compassInfoText.classList.add('compass-calibrating');
    }
    } else {
    compassErrorMessage.textContent = 'æ‚¨çš„è¨­å‚™ä¸æ”¯æ´æŒ‡åŒ—é‡åŠŸèƒ½';
    compassErrorMessage.style.display = 'block';
    compassInfoText.style.display = 'none';
    }

    // å°‡å‡½æ•¸æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
    window.getCompassLocation = getCompassLocation;
    window.currentCompassLat = null;
    window.currentCompassLng = null;
  })();

  // æ–°å¢ï¼šå–å¾—ç•¶å‰ä½ç½®çš„å‡½æ•¸
  async function getCompassLocation() {
    const coordsElement = document.getElementById('compassCoordinates');
    const elevTerrainElement = document.getElementById('compassElevationTerrain');
    const elevBuildingElement = document.getElementById('compassElevationBuilding');

    coordsElement.innerHTML = '<span class="compass-loading">å®šä½ä¸­...</span>';

    if (!navigator.geolocation) {
    coordsElement.innerHTML = '<span style="color:#ff6b6b;">ä¸æ”¯æ´å®šä½</span>';
    return;
    }

    try {
    const position = await new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(resolve, reject, {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
      });
    });

    const lat = position.coords.latitude;
    const lng = position.coords.longitude;

    // å„²å­˜åº§æ¨™
    window.currentCompassLat = lat;
    window.currentCompassLng = lng;

    // é¡¯ç¤ºåº§æ¨™ï¼ˆå–®è¡Œæ ¼å¼ï¼šç·¯åº¦,ç¶“åº¦ï¼‰
    coordsElement.textContent = `${lat.toFixed(6)}Â°, ${lng.toFixed(6)}Â°`;

    // å–å¾—åœ°å½¢é«˜åº¦ (Google Maps)
    elevTerrainElement.innerHTML = '<span class="compass-loading">è®€å–ä¸­...</span>';
    try {
      const terrainElev = await getElevationFromGoogleMapsForCompass(lat, lng);
      elevTerrainElement.textContent = `${Math.round(terrainElev)}m`;
    } catch (error) {
      elevTerrainElement.innerHTML = '<span style="color:#ff6b6b;">å¤±æ•—</span>';
    }

    // å–å¾—å»ºç‰©é«˜åº¦ (å…§æ”¿éƒ¨ DSMï¼Œåƒ…é™å°ç£ç¯„åœ)
    if (lat >= 21.5 && lat <= 25.5 && lng >= 119.5 && lng <= 122.5) {
      elevBuildingElement.innerHTML = '<span class="compass-loading">è®€å–ä¸­...</span>';
      try {
      const buildingElev = await getElevationFromDSMForCompass(lat, lng);
      elevBuildingElement.textContent = `${Math.round(buildingElev)}m`;
      } catch (error) {
      elevBuildingElement.innerHTML = '<span style="color:#ff6b6b;">å¤±æ•—</span>';
      }
    } else {
      elevBuildingElement.innerHTML = '<span style="color:#a8b3c3;">è¶…å‡ºç¯„åœ</span>';
    }

    } catch (error) {
    coordsElement.innerHTML = '<span style="color:#ff6b6b;">å®šä½å¤±æ•—</span>';

    if (error.code === 1) {
      coordsElement.innerHTML = '<span style="color:#ff6b6b;">éœ€è¦ä½ç½®æ¬Šé™</span>';
    } else if (error.code === 2) {
      coordsElement.innerHTML = '<span style="color:#ff6b6b;">å®šä½ä¸å¯ç”¨</span>';
    } else if (error.code === 3) {
      coordsElement.innerHTML = '<span style="color:#ff6b6b;">å®šä½é€¾æ™‚</span>';
    }
    }
  }

  // æ–°å¢ï¼šç‚ºæŒ‡åŒ—é‡é é¢å°ˆç”¨çš„ Google Maps é«˜åº¦æŸ¥è©¢å‡½æ•¸
  async function getElevationFromGoogleMapsForCompass(lat, lng) {
    const GOOGLE_API_KEY = 'AIzaSyBwd_GtAZq2eW6KgRRkro__aG7h5ZECJwo';

    if (!window.google || !window.google.maps) {
    await new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=geometry`;
      script.async = true;
      script.defer = true;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
    }

    const elevator = new google.maps.ElevationService();
    const result = await new Promise((resolve, reject) => {
    elevator.getElevationForLocations({
      locations: [{ lat: lat, lng: lng }]
    }, (results, status) => {
      if (status === 'OK' && results && results.length > 0) {
      resolve(results[0].elevation);
      } else {
      reject(new Error(`Google Maps API ç‹€æ…‹: ${status}`));
      }
    });
    });

    return result;
  }

  // æ–°å¢ï¼šç‚ºæŒ‡åŒ—é‡é é¢å°ˆç”¨çš„ Open-Elevation SRTM é«˜åº¦æŸ¥è©¢å‡½æ•¸
  async function getElevationFromOpenElevationForCompass(lat, lng) {
    const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({
        locations: [{
          latitude: lat,
          longitude: lng
        }]
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP éŒ¯èª¤: ${response.status}`);
    }

    const data = await response.json();

    if (!data.results || data.results.length === 0) {
      throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
    }

    const elevation = data.results[0].elevation;

    if (elevation === null || elevation === undefined) {
      throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
    }

    return elevation;
  }

  // æ–°å¢ï¼šç‚ºæŒ‡åŒ—é‡é é¢å°ˆç”¨çš„å…§æ”¿éƒ¨ DSM é«˜åº¦æŸ¥è©¢å‡½æ•¸
  async function getElevationFromDSMForCompass(lat, lng) {
    if (!window.GeoTIFF) {
    await loadGeoTIFFLibrary();
    }

    const cogFilename = 'taiwan_dsm_wgs84_cog.tif';
    let tiff = null;

    try {
    tiff = await GeoTIFF.fromUrl(cogFilename);
    } catch (err) {
    const githubUrl = 'https://sulapon.github.io/GPS/taiwan_dsm_wgs84_cog.tif';
    tiff = await GeoTIFF.fromUrl(githubUrl);
    }

    const image = await tiff.getImage();
    const bbox = image.getBoundingBox();
    const width = image.getWidth();
    const height = image.getHeight();

    const pixelX = Math.floor((lng - bbox[0]) / (bbox[2] - bbox[0]) * width);
    const pixelY = Math.floor((bbox[3] - lat) / (bbox[3] - bbox[1]) * height);

    if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
    const rasters = await image.readRasters({
      window: [pixelX, pixelY, pixelX + 1, pixelY + 1]
    });

    const elevation = rasters[0][0];

    if (elevation === null || elevation === undefined || isNaN(elevation)) {
      // DSM ç„¡æ•¸æ“šï¼Œä½¿ç”¨ Open-Elevation SRTM ä½œç‚ºå‚™ç”¨
      const openElev = await getElevationFromOpenElevationForCompass(lat, lng);
      return openElev;
    }

    // æª¢æŸ¥å¸¸è¦‹çš„ NoData å€¼
    const commonNoDataValues = [-32768, -32767, -9999, -99999, -12345, 32767, 65535, -3.4028235e+38];
    const isNoData = commonNoDataValues.some(noData => Math.abs(elevation - noData) < 0.01);

    if (isNoData || elevation < -500 || elevation > 9000) {
      // æª¢æ¸¬åˆ°ç„¡æ•ˆæ•¸æ“šï¼Œä½¿ç”¨ Open-Elevation SRTM å‚™ç”¨
      const openElev = await getElevationFromOpenElevationForCompass(lat, lng);
      return openElev;
    }

    return elevation;
    } else {
    // åº§æ¨™è¶…å‡ºç¯„åœï¼Œä½¿ç”¨ Open-Elevation SRTM å‚™ç”¨
    const openElev = await getElevationFromOpenElevationForCompass(lat, lng);
    return openElev;
    }
  }

  // æ–°å¢ï¼šç‚ºæŒ‡åŒ—é‡é é¢èª¿ç”¨GPSåˆ†é çš„åœ°åœ–é¸æ“‡å™¨
  function openCompassMapPickerUsingGPS() {

    const coordsElement = document.getElementById('compassCoordinates');
    const currentCoords = coordsElement.textContent.trim();

    // å˜—è©¦å¾ç¾æœ‰åº§æ¨™è§£æï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨å°åŒ—101é è¨­å€¼
    let currentLat = 25.0336;
    let currentLon = 121.5648;

    if (currentCoords && !currentCoords.includes('å°šæœªå®šä½') && !currentCoords.includes('å¤±æ•—')) {
    const coordMatch = currentCoords.match(/([\d.]+)Â°,\s*([\d.]+)Â°/);
    if (coordMatch) {
      currentLat = parseFloat(coordMatch[1]);
      currentLon = parseFloat(coordMatch[2]);
    }
    }

    // æš«å­˜ç•¶å‰åº§æ¨™åˆ°è‡¨æ™‚è®Šé‡ï¼Œä¾›GPSåœ°åœ–ä½¿ç”¨
    window.tempCompassLat = currentLat;
    window.tempCompassLng = currentLon;

    // èª¿ç”¨GPSåˆ†é çš„åœ°åœ–é¸æ“‡å™¨å‡½æ•¸ï¼Œå‚³å…¥'COMPASS'ä½œç‚ºç‰¹æ®Šæ¨™è¨˜
    openMapPicker('COMPASS');
  }

  // æ–°å¢ï¼šæ¥æ”¶GPSåœ°åœ–é¸æ“‡å™¨å›å‚³çš„åº§æ¨™ï¼ˆå°ˆç‚ºæŒ‡åŒ—é‡è¨­è¨ˆï¼‰
  window.receiveCompassMapCoordinates = async function(lat, lng, searchedName) {

    const coordsElement = document.getElementById('compassCoordinates');
    const elevTerrainElement = document.getElementById('compassElevationTerrain');
    const elevBuildingElement = document.getElementById('compassElevationBuilding');

    // æ›´æ–°åº§æ¨™é¡¯ç¤º
    coordsElement.textContent = `${lat.toFixed(6)}Â°, ${lng.toFixed(6)}Â°`;

    // å–å¾—åœ°å½¢é«˜åº¦ (Google Maps)
    elevTerrainElement.innerHTML = '<span class="compass-loading">è®€å–ä¸­...</span>';
    try {
    const terrainElev = await getElevationFromGoogleMapsForCompass(lat, lng);
    elevTerrainElement.textContent = `${Math.round(terrainElev)}m`;
    } catch (error) {
    elevTerrainElement.innerHTML = '<span style="color:#ff6b6b;">å¤±æ•—</span>';
    }

    // å–å¾—å»ºç‰©é«˜åº¦ (å…§æ”¿éƒ¨ DSM) - æ‰‹å‹•é¸æ“‡å®šä½æ™‚ä¹Ÿæœƒæ›´æ–°
    if (lat >= 21.5 && lat <= 25.5 && lng >= 119.5 && lng <= 122.5) {
    elevBuildingElement.innerHTML = '<span class="compass-loading">è®€å–ä¸­...</span>';
    try {
      const buildingElev = await getElevationFromDSMForCompass(lat, lng);
      elevBuildingElement.textContent = `${Math.round(buildingElev)}m`;
    } catch (error) {
      elevBuildingElement.innerHTML = '<span style="color:#ff6b6b;">å¤±æ•—</span>';
    }
    } else {
    elevBuildingElement.innerHTML = '<span style="color:#a8b3c3;">è¶…å‡ºç¯„åœ</span>';
    }
  };

  // æ–°å¢ï¼šé–å®šè¢å¹•æ–¹å‘ç‚ºå‚ç›´ä¸¦é€²å…¥çœŸæ­£çš„å…¨è¢å¹•ï¼ˆåƒè€ƒé«˜åº¦åœ–å¯¦ç¾ï¼‰
  let isCompassFullscreen = false;
  let originalCompassStyles = {};
  let compassExitBtn = null;

  async function lockScreenOrientation() {
    const compassContent = document.getElementById('compass-content');
    const fullscreenBtn = document.querySelector('.compass-fullscreen-btn');

    if (!compassContent) {
    return;
    }

    if (!isCompassFullscreen) {
    try {
      // é€²å…¥å…¨è¢å¹•
      if (compassContent.requestFullscreen) {
      await compassContent.requestFullscreen();
      } else if (compassContent.webkitRequestFullscreen) {
      await compassContent.webkitRequestFullscreen();
      } else if (compassContent.mozRequestFullScreen) {
      await compassContent.mozRequestFullScreen();
      } else if (compassContent.msRequestFullscreen) {
      await compassContent.msRequestFullscreen();
      }

      // éš±è—å…¨è¢å¹•æŒ‰éˆ•
      if (fullscreenBtn) {
      fullscreenBtn.style.display = 'none';
      }

      // ä¿å­˜åŸå§‹æ¨£å¼
      originalCompassStyles = {
      background: compassContent.style.background,
      padding: compassContent.style.padding,
      display: compassContent.style.display,
      minHeight: compassContent.style.minHeight
      };

      // è¨­ç½®å…¨è¢å¹•æ¨£å¼
      compassContent.style.background = '#050a16';
      compassContent.style.padding = '0';
      compassContent.style.display = 'flex';
      compassContent.style.justifyContent = 'center';
      compassContent.style.alignItems = 'center';
      compassContent.style.minHeight = '100vh';

      // å‰µå»ºé€€å‡ºæŒ‰éˆ•
      compassExitBtn = document.createElement('button');
      compassExitBtn.innerHTML = 'âœ•';
      compassExitBtn.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      background: rgba(220, 38, 38, 0.95);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      z-index: 999999;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      padding: 0;
      `;
      compassExitBtn.onclick = exitCompassFullscreen;
      compassContent.appendChild(compassExitBtn);

      isCompassFullscreen = true;

      // ç­‰å¾…ä¸€å°æ®µæ™‚é–“ç¢ºä¿å…¨è¢å¹•å·²å•Ÿå‹•
      await new Promise(resolve => setTimeout(resolve, 100));

      // é–å®šè¢å¹•æ–¹å‘ç‚ºå‚ç›´
      if (screen.orientation && screen.orientation.lock) {
      try {
        await screen.orientation.lock('portrait');
        showTemporaryMessage('âœ… å·²é–å®šç‚ºå‚ç›´å…¨è¢å¹•æ¨¡å¼');
      } catch (err) {
        showTemporaryMessage('âš ï¸ å·²é€²å…¥å…¨è¢å¹•');
      }
      } else {
      showTemporaryMessage('âœ… å·²é€²å…¥å…¨è¢å¹•');
      }

    } catch (error) {
      alert('âŒ ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼\nè«‹ç¢ºèªå·²æˆäºˆç¶²é å…¨è¢å¹•æ¬Šé™');
    }
    }
  }

  function exitCompassFullscreen() {
    if (document.exitFullscreen) {
    document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
    } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
    } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
    }
  }

  // ç›£è½å…¨è¢å¹•è®ŠåŒ–äº‹ä»¶
  document.addEventListener('fullscreenchange', handleCompassFullscreenChange);
  document.addEventListener('webkitfullscreenchange', handleCompassFullscreenChange);
  document.addEventListener('mozfullscreenchange', handleCompassFullscreenChange);
  document.addEventListener('MSFullscreenChange', handleCompassFullscreenChange);

  function handleCompassFullscreenChange() {
    const compassContent = document.getElementById('compass-content');
    const fullscreenBtn = document.querySelector('.compass-fullscreen-btn');

    if (!compassContent) return;

    const isFullscreen = !!(document.fullscreenElement ||
               document.webkitFullscreenElement ||
               document.mozFullScreenElement ||
               document.msFullscreenElement);

    if (!isFullscreen && isCompassFullscreen) {
    // æ¢å¾©é¡¯ç¤ºå…¨è¢å¹•æŒ‰éˆ•
    if (fullscreenBtn) {
      fullscreenBtn.style.display = 'flex';
    }

    // æ¢å¾©åŸå§‹æ¨£å¼
    if (originalCompassStyles) {
      compassContent.style.background = originalCompassStyles.background;
      compassContent.style.padding = originalCompassStyles.padding;
      compassContent.style.display = originalCompassStyles.display;
      compassContent.style.minHeight = originalCompassStyles.minHeight;
    }

    // ç§»é™¤é€€å‡ºæŒ‰éˆ•
    if (compassExitBtn && compassExitBtn.parentNode) {
      compassExitBtn.parentNode.removeChild(compassExitBtn);
      compassExitBtn = null;
    }

    isCompassFullscreen = false;

    // è§£é–è¢å¹•æ–¹å‘
    if (screen.orientation && screen.orientation.unlock) {
      try {
      screen.orientation.unlock();
      } catch (err) {
      }
    }
    }
  }

  // é¡¯ç¤ºè‡¨æ™‚è¨Šæ¯ï¼ˆä¸ç ´å£å…¨è¢å¹•é«”é©—ï¼‰
  function showTemporaryMessage(message) {
    const msgDiv = document.createElement('div');
    msgDiv.textContent = message;
    msgDiv.style.cssText = `
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 14px;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    document.body.appendChild(msgDiv);

    // 3ç§’å¾Œè‡ªå‹•ç§»é™¤
    setTimeout(() => {
    msgDiv.style.opacity = '0';
    msgDiv.style.transition = 'opacity 0.5s';
    setTimeout(() => msgDiv.remove(), 500);
    }, 3000);
  }
  </script>

</div>

<!-- å ±å‘ŠåŒ¯å‡ºåˆ†é  -->
<div id="report-content" class="tab-content">
  <div class="card">
    <h2 class="section-title" style="margin-top:0;">ğŸ“„ å ±å‘ŠåŒ¯å‡º</h2>

    <!-- å ±å‘Šè¨­å®š -->
    <div style="background:rgba(95, 240, 213, 0.05); border:2px solid var(--accent1); border-radius:8px; padding:15px; margin-bottom:15px;">
      <h3 style="color:var(--accent1); font-size:16px; margin:0 0 12px 0; font-weight:700;">âš™ï¸ å ±å‘Šè¨­å®š</h3>

      <div style="margin-bottom:10px;">
        <label style="color:var(--label); font-size:14px; display:block; margin-bottom:5px; font-weight:600;">å ±å‘Šæ¨™é¡Œ</label>
        <input type="text" id="report_title" value="ç„¡ç·šé›»é€šè¨Šè·¯å¾‘åˆ†æå ±å‘Š"
               style="width:100%; padding:8px; font-size:15px; color:var(--value); background:rgba(255,255,255,0.05); border-radius:6px; border:1px solid rgba(255,255,255,0.2);">
      </div>

      <div style="margin-bottom:10px;">
        <label style="color:var(--label); font-size:14px; display:block; margin-bottom:5px; font-weight:600;">å°ˆæ¡ˆåç¨± (é¸å¡«)</label>
        <input type="text" id="report_project" placeholder="ä¾‹å¦‚ï¼šå°åŒ—-æ–°ç«¹ UHF éˆè·¯è©•ä¼°"
               style="width:100%; padding:8px; font-size:15px; color:var(--value); background:rgba(255,255,255,0.05); border-radius:6px; border:1px solid rgba(255,255,255,0.2);">
      </div>

      <div>
        <label style="color:var(--label); font-size:14px; display:block; margin-bottom:5px; font-weight:600;">è£½ä½œè€… (é¸å¡«)</label>
        <input type="text" id="report_author" placeholder="æ‚¨çš„å§“åæˆ–å–®ä½"
               style="width:100%; padding:8px; font-size:15px; color:var(--value); background:rgba(255,255,255,0.05); border-radius:6px; border:1px solid rgba(255,255,255,0.2);">
      </div>

      <div style="margin-top:15px; padding-top:15px; border-top:1px solid rgba(95, 240, 213, 0.2);">
        <label style="color:var(--label); font-size:14px; display:block; margin-bottom:8px; font-weight:600;">
          ğŸ¨ PDF èƒŒæ™¯é¢¨æ ¼
        </label>
        <select id="pdf_theme_setting" 
                style="width:100%; padding:8px; font-size:14px; color:var(--value); background:rgba(255,255,255,0.05); border-radius:6px; border:1px solid rgba(255,255,255,0.2); cursor:pointer;">
          <option value="dark">ğŸŒ™ æ·±è‰²é¢¨æ ¼ï¼ˆé»‘è‰²èƒŒæ™¯ï¼‰- åŸå§‹è¨­è¨ˆ</option>
          <option value="light">â˜€ï¸ æ·ºè‰²é¢¨æ ¼ï¼ˆç™½è‰²èƒŒæ™¯ï¼‰- é©åˆåˆ—å°</option>
        </select>
        <div style="margin-top:6px; font-size:12px; color:#a8b3c3; line-height:1.4;">
          ğŸ’¡ æ·ºè‰²é¢¨æ ¼æ›´é©åˆåˆ—å°ï¼Œæ·±è‰²é¢¨æ ¼é©åˆè¢å¹•é–±è®€
        </div>
      </div>
    </div>

    <!-- åŒ¯å‡ºæŒ‰éˆ• -->
    <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:15px;">
      <button onclick="generateReportPDF()"
              style="flex:1; min-width:200px; background:linear-gradient(90deg, #ffd43b, #ffa94d); border:0; padding:12px 20px; border-radius:8px; font-weight:700; font-size:18px; color:#000; cursor:pointer; box-shadow:0 4px 12px rgba(255, 164, 77, 0.3); transition:all 0.3s;">
        ğŸš€ ç”Ÿæˆ PDF å ±å‘Š
      </button>
    </div>

    <!-- å ±å‘Šè³‡æ–™ä¾†æºèªªæ˜ -->
    <div style="background:rgba(95, 240, 213, 0.05); border:2px solid var(--accent1); border-radius:8px; padding:12px; margin-bottom:15px;">
      <h3 style="color:var(--accent1); font-size:16px; margin:0 0 8px 0; font-weight:700;">ğŸ“‹ å ±å‘Šè³‡æ–™ä¾†æºèªªæ˜</h3>

      <div style="margin-bottom:8px; padding:8px 12px; background:rgba(255, 212, 59, 0.1); border-radius:4px; font-size:14px; color:#ffd43b; line-height:1.5;">
        ğŸ’¡ æç¤ºï¼šå»ºè­°åœ¨ç”Ÿæˆå ±å‘Šå‰ç¢ºèªå„åˆ†é è³‡æ–™å·²æ­£ç¢ºå¡«å¯«
      </div>

      <div style="font-size:14px; color:#a8b3c3; line-height:1.8;">
        <div style="margin-bottom:4px;">
          <span style="color:#ffd43b;">â—</span> <span style="color:#e8eef5; font-weight:600;">RFå·¥å…·</span>ï¼šé€šè¨Šæ¨¡æ“¬ (Link Budget) è¨ˆç®—çµæœ
        </div>

        <div style="margin-bottom:4px;">
          <span style="color:#ffd43b;">â—</span> <span style="color:#e8eef5; font-weight:600;">GPS</span>ï¼šA/B å…©é»åº§æ¨™ã€æ–¹ä½è§’/ä¿¯ä»°è§’
        </div>

        <div style="margin-bottom:0;">
          <span style="color:#ffd43b;">â—</span> <span style="color:#e8eef5; font-weight:600;">é«˜åº¦åœ–</span>ï¼šæµ·æ‹”(å«å»ºç‰©)ã€å¤©ç·šé«˜åº¦ã€è·¯å¾‘å‰–é¢åœ–ã€é®è”½åˆ†æã€è²æ¶…çˆ¾å€
        </div>
      </div>
    </div>

    <!-- ç‹€æ…‹è¨Šæ¯ -->
    <div id="export_status" style="margin-top:15px; padding:10px; border-radius:6px; display:none; font-size:14px; font-weight:600;"></div>
  </div>
</div>

<script>
// ========================================
// ğŸ“„ PDF å ±å‘ŠåŒ¯å‡ºåŠŸèƒ½
// ========================================

/**
 * é è¦½å ±å‘Šå…§å®¹
 */

/**
 * ç”Ÿæˆ PDF å ±å‘Š
 */
/**
 * ç”Ÿæˆ PDF å ±å‘Š - å–®é A4ç‰ˆæœ¬
 * ä¸Šæ–¹ï¼šå‰–é¢åœ–
 * ä¸‹æ–¹ï¼šå·¦(Aé»+Aâ†’Bè§’åº¦)ã€ä¸­(RFè¨ˆç®—)ã€å³(Bé»+Bâ†’Aè§’åº¦)
 */
async function generateReportPDF() {
  const exportRF = true;
  const exportGPS = true;
  const exportElevation = true;

  // æª¢æŸ¥æ˜¯å¦éœ€è¦å‰–é¢åœ–ä½†æœªé–‹å•Ÿå…¨ç•«é¢æ¨¡å¼
  if (exportElevation) {
  const overlay = document.getElementById('chartFullscreenOverlay');
  const isFullscreen = overlay && overlay.classList.contains('active');

  if (!isFullscreen) {
    // ç§»é™¤ç¢ºèªå°è©±æ¡†ï¼Œç›´æ¥é–‹å•Ÿå…¨è¢å¹•
    if (typeof openChartFullscreen === 'function') {
    try {
      openChartFullscreen();

      // è¨­å®šæ¨™è¨˜ï¼šè¡¨ç¤ºæ­£åœ¨ç”Ÿæˆå ±å‘Š
      window.isGeneratingReport = true;

      showExportStatus('ğŸ”„ æ­£åœ¨é–‹å•Ÿå…¨ç•«é¢æ¨¡å¼...è«‹è¨­å®šå¥½åœ–è¡¨å¾Œé»æ“Šã€Œç¢ºèªæˆªåœ–ã€æŒ‰éˆ•', 'loading');
      await new Promise(resolve => setTimeout(resolve, 800));

      const overlayCheck = document.getElementById('chartFullscreenOverlay');
      if (!overlayCheck || !overlayCheck.classList.contains('active')) {
      alert('âš ï¸ å…¨ç•«é¢æ¨¡å¼é–‹å•Ÿç•°å¸¸ï¼Œå°‡ä½¿ç”¨ä¸€èˆ¬åœ–è¡¨ã€‚');
      window.isGeneratingReport = false;
      } else {
      // é¡¯ç¤ºã€Œç¢ºèªæˆªåœ–ã€æŒ‰éˆ•
      showReportConfirmButton();
      // ç­‰å¾…ç”¨æˆ¶é»æ“Šç¢ºèªæŒ‰éˆ•
      return;  // ä¸­æ–·åŸ·è¡Œï¼Œç­‰å¾…ç”¨æˆ¶ç¢ºèª
      }
    } catch (error) {
      alert('âŒ è‡ªå‹•é–‹å•Ÿå¤±æ•—\n\nè«‹æ‰‹å‹•æ“ä½œï¼š\n1. é»æ“Šå‰–é¢åœ–å³ä¸Šè§’çš„å…¨è¢å¹•æŒ‰éˆ• ğŸ“º\n2. å†æ¬¡é»æ“Šã€Œç”Ÿæˆ PDF å ±å‘Šã€');
      window.isGeneratingReport = false;
      return;
    }
    } else {
    alert('âŒ æ‰¾ä¸åˆ°å…¨ç•«é¢åŠŸèƒ½');
    return;
    }
  }
  }

  // ç¹¼çºŒç”Ÿæˆå ±å‘Šçš„é‚è¼¯
  await continueGenerateReport();
}

// æ–°å¢å‡½æ•¸ï¼šé¡¯ç¤ºç¢ºèªæˆªåœ–æŒ‰éˆ•
function showReportConfirmButton() {
  const overlay = document.getElementById('chartFullscreenOverlay');
  if (!overlay) return;

  // æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰æŒ‰éˆ•
  let confirmBtn = overlay.querySelector('#reportConfirmButton');
  if (confirmBtn) {
  confirmBtn.style.display = 'block';
  return;
  }

  // å‰µå»ºç¢ºèªæŒ‰éˆ•
  confirmBtn = document.createElement('button');
  confirmBtn.id = 'reportConfirmButton';
  confirmBtn.innerHTML = 'âœ… ç¢ºèªæˆªåœ–ç”Ÿæˆå ±å‘Š';
  confirmBtn.style.cssText = `
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 10005;
  background: linear-gradient(90deg, #36c74d, #28a745);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 6px;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  transition: all 0.3s ease;
  `;

  confirmBtn.onmouseover = function() {
  this.style.background = 'linear-gradient(90deg, #28a745, #1e7e34)';
  this.style.transform = 'scale(1.05)';
  };

  confirmBtn.onmouseout = function() {
  this.style.background = 'linear-gradient(90deg, #36c74d, #28a745)';
  this.style.transform = 'scale(1)';
  };

  confirmBtn.onclick = async function() {
  this.style.display = 'none';
  await continueGenerateReport();
  };

  overlay.appendChild(confirmBtn);
}

// æ–°å¢å‡½æ•¸ï¼šç¹¼çºŒç”Ÿæˆå ±å‘Šï¼ˆå¾æˆªåœ–é–‹å§‹ï¼‰
async function continueGenerateReport() {
  const exportRF = true;
  const exportGPS = true;
  const exportElevation = true;

  // ğŸ¯ è®€å–ä¸»é¡Œè¨­å®š
  const themeSetting = document.getElementById('pdf_theme_setting')?.value || 'dark';
  
  // ğŸ¯ å›ºå®šä½¿ç”¨é«˜å“è³ªè¨­å®š
  const qualityConfig = {
    titleScale: 1.5,
    titleQuality: 0.9,
    chartQuality: 0.85,     // å‰–é¢åœ–é«˜å“è³ª
    blockScale: 1.5,
    blockQuality: 0.9
  };

  // ğŸ¨ ä¸»é¡Œé…è‰²æ–¹æ¡ˆ
  const themeColors = themeSetting === 'light' ? {
    // â˜€ï¸ æ·ºè‰²ä¸»é¡Œé…è‰²ï¼ˆç™½è‰²èƒŒæ™¯ï¼‰
    background: '#ffffff',
    titleBg: '#f8f9fa',
    titleMain: '#1a5490',      // æ·±è—è‰²æ¨™é¡Œ
    titleSub: '#d97706',       // æ©™è‰²å‰¯æ¨™é¡Œ
    titleDate: '#4b5563',      // æ·±ç°è‰²æ—¥æœŸ
    blockBg: '#f8f9fa',
    blockBorder: '#e5e7eb',
    labelColor: '#374151',     // æ·±ç°è‰²æ¨™ç±¤
    valueColor: '#111827',     // æ¥è¿‘é»‘è‰²çš„æ•¸å€¼
    sectionTitle: '#1e40af',   // æ·±è—è‰²å€å¡Šæ¨™é¡Œ
    highlightValue: '#dc2626', // ç´…è‰²å¼·èª¿æ•¸å€¼
    chartBg: '#e0f2fe'         // æ·¡è—è‰²åœ–è¡¨èƒŒæ™¯
  } : {
    // ğŸŒ™ æ·±è‰²ä¸»é¡Œé…è‰²ï¼ˆé»‘è‰²èƒŒæ™¯ï¼‰- åŸå§‹è¨­è¨ˆ
    background: '#0b1526',
    titleBg: '#0b1526',
    titleMain: '#5ff0d5',
    titleSub: '#ffe58f',
    titleDate: '#a8b3c3',
    blockBg: '#0b1526',
    blockBorder: '#1e3a5f',
    labelColor: '#85c9ff',
    valueColor: '#e8eef5',
    sectionTitle: '#5ff0d5',
    highlightValue: '#ffd43b',
    chartBg: '#0b1526'
  };

  showExportStatus('ğŸ“ æ­£åœ¨ç”Ÿæˆå–®é å ±å‘Š...', 'loading');

  try {
  const { jsPDF } = window.jspdf;
  const title = document.getElementById('report_title').value || 'ç„¡ç·šé›»é€šè¨Šè·¯å¾‘åˆ†æå ±å‘Š';
  const project = document.getElementById('report_project').value;
  const author = document.getElementById('report_author').value;
  const date = new Date().toLocaleString('zh-TW', {
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit'
  });

  const pdf = new jsPDF('l', 'mm', 'a4');
  const pdfWidth = 297;
  const pdfHeight = 210;
  const margin = 8;

  // ä½¿ç”¨ä¸»é¡ŒèƒŒæ™¯è‰²
  if (themeSetting === 'light') {
    pdf.setFillColor(255, 255, 255);  // ç™½è‰²èƒŒæ™¯
  } else {
    pdf.setFillColor(11, 21, 38);     // é»‘è‰²èƒŒæ™¯ï¼ˆåŸå§‹ï¼‰
  }
  pdf.rect(0, 0, pdfWidth, pdfHeight, 'F');

  let yPos = 5;

  // === 1. å ±å‘Šæ¨™é¡Œ ===
  const titleDiv = document.createElement('div');
  titleDiv.style.cssText = `
    background: ${themeColors.titleBg};
    padding: 4px 15px;
    text-align: center;
    font-family: 'Microsoft JhengHei', sans-serif;
    width: ${(pdfWidth - 2 * margin) * 3.7795}px;
  `;
  titleDiv.innerHTML = `
    <div style="font-size:18px; color:${themeColors.titleMain}; font-weight:bold; margin-bottom:2px;">
    ${title}
    </div>
    ${project ? `<div style="font-size:13px; color:${themeColors.titleSub}; margin-bottom:1px;">${project}</div>` : ''}
    <div style="font-size:10px; color:${themeColors.titleDate};">
    ${date}${author ? ' | ' + author : ''}
    </div>
  `;
  document.body.appendChild(titleDiv);

  const titleCanvas = await html2canvas(titleDiv, {
    backgroundColor: themeColors.titleBg,
    scale: qualityConfig.titleScale  // ä½¿ç”¨å‹•æ…‹è§£æåº¦è¨­å®š
  });
  document.body.removeChild(titleDiv);

  const titleImgData = titleCanvas.toDataURL('image/jpeg', qualityConfig.titleQuality);  // ä½¿ç”¨å‹•æ…‹å“è³ªè¨­å®š
  const titleHeight = 14;
  pdf.addImage(titleImgData, 'PNG', margin, yPos, pdfWidth - 2 * margin, titleHeight);
  yPos += titleHeight + 2;

  // === 2. å‰–é¢åœ–å€åŸŸ ===
  if (exportElevation) {
    try {
    const overlay = document.getElementById('chartFullscreenOverlay');
    let chartImgData = null;
    let capturedCanvas = null;

    if (overlay && overlay.classList.contains('active') && typeof fullscreenChartInstance !== 'undefined' && fullscreenChartInstance && fullscreenChartInstance.canvas) {
      showExportStatus('ğŸ“¸ æ­£åœ¨æ“·å–å…¨ç•«é¢å‰–é¢åœ–...', 'loading');

      const controlsToHide = [
      overlay.querySelector('.chart-fullscreen-close'),
      overlay.querySelector('.chart-fullscreen-screenshot'),
      overlay.querySelector('.chart-fullscreen-rotate-toggle'),
      overlay.querySelector('.chart-fullscreen-info-toggle'),
      overlay.querySelector('.chart-fullscreen-obstruction-toggle'),
      overlay.querySelector('.chart-fullscreen-map-toggle'),
      overlay.querySelector('.chart-fullscreen-end-obstruction'),
      overlay.querySelector('.chart-fullscreen-max-obstruction'),
      overlay.querySelector('.chart-fullscreen-start-obstruction'),
      overlay.querySelector('.chart-fullscreen-point-control')
      ];

      const originalDisplayStates = controlsToHide.map(el => {
      if (el) {
        const display = el.style.display;
        el.style.display = 'none';
        return display;
      }
      return null;
      });

      // ğŸ¨ ç¢ºä¿ tooltip é¡¯ç¤ºï¼ˆå¦‚æœæœ‰ç•¶å‰é¸ä¸­çš„é»ï¼‰
      const tooltipEl = overlay.querySelector('#chartjs-tooltip-fullscreen');
      let tooltipWasHidden = false;
      let selectedIndex = window.currentSelectedPointIndex;
      
      // å¦‚æœæ²’æœ‰é¸ä¸­é»ï¼Œé è¨­é¸æ“‡ä¸­é–“é»ä¾†é¡¯ç¤º tooltip
      if ((selectedIndex === null || selectedIndex === undefined) && fullscreenChartInstance) {
        const dataset = fullscreenChartInstance.data.datasets.find(d => 
          d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
        );
        if (dataset && dataset.data && dataset.data.length > 0) {
          selectedIndex = Math.floor(dataset.data.length / 2); // ä¸­é–“é»
          
          // è§¸ç™¼åœ–è¡¨æ‡¸åœäº‹ä»¶ä»¥é¡¯ç¤º tooltip
          const meta = fullscreenChartInstance.getDatasetMeta(0);
          if (meta && meta.data && meta.data[selectedIndex]) {
            const element = meta.data[selectedIndex];
            const rect = fullscreenChartInstance.canvas.getBoundingClientRect();
            const x = element.x;
            const y = element.y;
            
            // æ¨¡æ“¬æ»‘é¼ ç§»å‹•äº‹ä»¶
            const evt = new MouseEvent('mousemove', {
              clientX: rect.left + x,
              clientY: rect.top + y,
              bubbles: true
            });
            fullscreenChartInstance.canvas.dispatchEvent(evt);
            
            // ç­‰å¾… tooltip æ¸²æŸ“
            await new Promise(resolve => setTimeout(resolve, 200));
          }
        }
      }
      
      if (tooltipEl) {
        tooltipWasHidden = tooltipEl.style.opacity === '0' || !tooltipEl.style.opacity;
        // ç¢ºä¿ tooltip å¯è¦‹
        if (tooltipEl.style.opacity !== '1') {
          tooltipEl.style.opacity = '1';
        }
      }

      // ğŸ¨ æ·ºè‰²ä¸»é¡Œï¼šè‡¨æ™‚ä¿®æ”¹åœ–è¡¨é…è‰²
      let originalChartColors = null;
      let originalLegendGenerator = null;
      if (themeSetting === 'light' && fullscreenChartInstance) {
        originalChartColors = {
          bgColor: fullscreenChartInstance.options.chartBackgroundColor,
          gridColor: fullscreenChartInstance.options.scales.y.grid.color,
          tickColor: fullscreenChartInstance.options.scales.y.ticks.color,
          xGridColor: fullscreenChartInstance.options.scales.x.grid.color,
          xTickColor: fullscreenChartInstance.options.scales.x.ticks.color,
          legendColor: fullscreenChartInstance.options.plugins.legend.labels.color,
          yTitleColor: fullscreenChartInstance.options.scales.y.title.color,
          xTitleColor: fullscreenChartInstance.options.scales.x.title.color
        };
        
        // ä¿å­˜åŸå§‹åœ–ä¾‹ç”Ÿæˆå™¨
        originalLegendGenerator = fullscreenChartInstance.options.plugins.legend.labels.generateLabels;
        
        // æ‡‰ç”¨æ·ºè‰²é…è‰² - æ·¡è—è‰²èƒŒæ™¯
        fullscreenChartInstance.options.chartBackgroundColor = '#e0f2fe';  // æ·¡è—è‰²èƒŒæ™¯
        fullscreenChartInstance.options.scales.y.grid.color = 'rgba(0,0,0,0.15)';
        fullscreenChartInstance.options.scales.y.ticks.color = '#1e40af';
        fullscreenChartInstance.options.scales.x.grid.color = 'rgba(0,0,0,0.15)';
        fullscreenChartInstance.options.scales.x.ticks.color = '#1e40af';
        fullscreenChartInstance.options.plugins.legend.labels.color = '#000000';  // é»‘è‰²
        fullscreenChartInstance.options.scales.y.title.color = '#0c4a6e';
        fullscreenChartInstance.options.scales.x.title.color = '#0c4a6e';
        
        // ğŸ¨ ä¿®æ”¹åœ–ä¾‹ç”Ÿæˆå™¨ï¼Œå°‡æ–‡å­—é¡è‰²æ”¹ç‚ºé»‘è‰²
        fullscreenChartInstance.options.plugins.legend.labels.generateLabels = function(chart) {
          const labels = originalLegendGenerator(chart);
          return labels.map(label => {
            // æ·ºè‰²é¢¨æ ¼ï¼šæª¢æŸ¥å¯¦éš›çš„éš±è—ç‹€æ…‹
            const meta = chart.getDatasetMeta(label.datasetIndex);
            const dataset = chart.data.datasets[label.datasetIndex];
            const isHidden = (meta && meta.hidden) || !!(dataset && dataset.hidden);
            
            if (isHidden) {
              label.fontColor = '#6b7280';  // æ·±ç°è‰²ï¼ˆéš±è—ç‹€æ…‹ï¼‰
            } else {
              label.fontColor = '#000000';  // é»‘è‰²ï¼ˆé¡¯ç¤ºç‹€æ…‹ï¼‰
            }
            return label;
          });
        };
        
        // ğŸ¨ ä¿®æ”¹ tooltip ç‚ºæ·±è—è‰²èƒŒæ™¯ï¼ˆPDF ç”Ÿæˆï¼‰
        const tooltipEl = document.getElementById('chartjs-tooltip-fullscreen');
        if (tooltipEl) {
          tooltipEl.style.background = 'rgba(30, 58, 138, 0.95)';  // æ·±è—è‰²èƒŒæ™¯
          tooltipEl.style.border = '2px solid #1e40af';  // æ·±è—è‰²é‚Šæ¡†
          tooltipEl.style.color = '#e0f2fe';  // æ·ºè‰²æ–‡å­—
        }
        
        fullscreenChartInstance.update('none');
      }

      await new Promise(resolve => setTimeout(resolve, 150));

      // ğŸ¨ è‡¨æ™‚ç§»é™¤ overlayã€container å’Œ wrapper çš„èƒŒæ™¯è‰²ï¼Œé¿å…é»‘æ¡†
      const originalOverlayBg = overlay.style.background;
      const container = overlay.querySelector('.chart-fullscreen-container');
      const wrapper = overlay.querySelector('.chart-fullscreen-canvas-wrapper');
      const originalContainerBg = container ? container.style.background : '';
      const originalWrapperBg = wrapper ? wrapper.style.background : '';
      
      overlay.style.background = 'transparent';
      if (container) container.style.background = 'transparent';
      if (wrapper) wrapper.style.background = 'transparent';

      // ğŸ¨ ä½¿ç”¨ html2canvas æˆªå–æ•´å€‹ overlayï¼ˆåŒ…å« tooltipï¼‰
      const selectedBgColor = themeSetting === 'light' ? '#e0f2fe' : '#0b1526';
      const canvasScreenshot = await html2canvas(overlay, {
        backgroundColor: selectedBgColor,
        scale: 2,
        logging: false,
        useCORS: true,
        allowTaint: true,
        foreignObjectRendering: false,
        imageTimeout: 0
      });
      
      // ğŸ¨ æ¢å¾© overlayã€container å’Œ wrapper çš„èƒŒæ™¯
      overlay.style.background = originalOverlayBg;
      if (container) container.style.background = originalContainerBg;
      if (wrapper) wrapper.style.background = originalWrapperBg;
      
      capturedCanvas = canvasScreenshot;
      chartImgData = canvasScreenshot.toDataURL('image/jpeg', qualityConfig.chartQuality);

      // ğŸ¨ æ¢å¾©åŸå§‹é…è‰²
      if (originalChartColors && fullscreenChartInstance) {
        fullscreenChartInstance.options.chartBackgroundColor = originalChartColors.bgColor;
        fullscreenChartInstance.options.scales.y.grid.color = originalChartColors.gridColor;
        fullscreenChartInstance.options.scales.y.ticks.color = originalChartColors.tickColor;
        fullscreenChartInstance.options.scales.x.grid.color = originalChartColors.xGridColor;
        fullscreenChartInstance.options.scales.x.ticks.color = originalChartColors.xTickColor;
        fullscreenChartInstance.options.plugins.legend.labels.color = originalChartColors.legendColor;
        fullscreenChartInstance.options.scales.y.title.color = originalChartColors.yTitleColor;
        fullscreenChartInstance.options.scales.x.title.color = originalChartColors.xTitleColor;
        
        // æ¢å¾©åŸå§‹åœ–ä¾‹ç”Ÿæˆå™¨
        if (originalLegendGenerator) {
          fullscreenChartInstance.options.plugins.legend.labels.generateLabels = originalLegendGenerator;
        }
        
        // ğŸ¨ æ¢å¾© tooltip åŸå§‹æ¨£å¼ï¼ˆPDF ç”Ÿæˆï¼‰
        const tooltipEl = document.getElementById('chartjs-tooltip-fullscreen');
        if (tooltipEl && themeSetting === 'light') {
          tooltipEl.style.background = 'rgba(13, 71, 161, 0.35)';  // æ¢å¾©åŸå§‹èƒŒæ™¯
          tooltipEl.style.border = '2px solid #4dabf7';  // æ¢å¾©åŸå§‹é‚Šæ¡†
          tooltipEl.style.color = 'white';  // æ¢å¾©åŸå§‹æ–‡å­—é¡è‰²
        }
        
        fullscreenChartInstance.update('none');
      }

      controlsToHide.forEach((el, index) => {
      if (el) el.style.display = originalDisplayStates[index] || '';
      });

    } else {
      const elevationChart = document.getElementById('elevationChart');
      if (elevationChart) {
      capturedCanvas = elevationChart;
      chartImgData = elevationChart.toDataURL('image/jpeg', qualityConfig.chartQuality);  // ä½¿ç”¨å‹•æ…‹å“è³ª
      }
    }

    if (chartImgData) {
      const pdfChartWidth = pdfWidth - 2 * margin;
      let chartHeight = 90;
      if (capturedCanvas && capturedCanvas.width && capturedCanvas.height) {
      const aspectRatio = capturedCanvas.height / capturedCanvas.width;
      chartHeight = pdfChartWidth * aspectRatio;
      if (chartHeight > 110) chartHeight = 110;
      if (chartHeight < 50) chartHeight = 50;
      }
      pdf.addImage(chartImgData, 'JPEG', margin, yPos, pdfChartWidth, chartHeight);
      yPos += chartHeight + 2;
    }

    } catch (e) {
    yPos += 5;
    }
  }

  // === 3. ä¸‰å€‹è³‡æ–™å€å¡Š (å·¦-ä¸­-å³) ===
  // è¨ˆç®—æ–¹ä½è§’å’Œä¿¯ä»°è§’
  function calculateAngles(lat1, lng1, alt1, lat2, lng2, alt2) {
    const toRad = deg => deg * Math.PI / 180;
    const toDeg = rad => rad * 180 / Math.PI;

    const Ï†1 = toRad(lat1);
    const Ï†2 = toRad(lat2);
    const Î”Î» = toRad(lng2 - lng1);

    // æ–¹ä½è§’ Aâ†’B
    const y = Math.sin(Î”Î») * Math.cos(Ï†2);
    const x = Math.cos(Ï†1) * Math.sin(Ï†2) - Math.sin(Ï†1) * Math.cos(Ï†2) * Math.cos(Î”Î»);
    let azimuthAtoB = toDeg(Math.atan2(y, x));
    azimuthAtoB = (azimuthAtoB + 360) % 360;

    // åæ–¹ä½è§’ Bâ†’A
    let azimuthBtoA = (azimuthAtoB + 180) % 360;

    // è·é›¢
    const R = 6371;
    const a = Math.sin((Ï†2 - Ï†1) / 2) ** 2 +
        Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î» / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;

    // ä¿¯ä»°è§’
    const heightDiff = alt2 - alt1;
    const distanceMeters = distance * 1000;
    const elevationAtoB = toDeg(Math.atan(heightDiff / distanceMeters));
    const elevationBtoA = -elevationAtoB;

    return { azimuthAtoB, azimuthBtoA, elevationAtoB, elevationBtoA, distance };
  }

  // è®€å–GPSè³‡æ–™
  const latA = parseFloat(document.getElementById('latA').value);
  const lonA = parseFloat(document.getElementById('lonA').value);
  // å„ªå…ˆä½¿ç”¨å‰–é¢åœ–çš„ç´”åœ°å½¢é«˜åº¦(ä¸å«å¤©ç·š)ï¼Œå¦å‰‡ fallback åˆ° GPS åˆ†é 
  const eleA = (window.terrainEleA !== undefined && !isNaN(window.terrainEleA))
    ? window.terrainEleA
    : parseFloat(document.getElementById('eleA').value || 0);
  const nameA = document.getElementById('nameA').value || 'Aé»';

  const latB = parseFloat(document.getElementById('latB').value);
  const lonB = parseFloat(document.getElementById('lonB').value);
  // å„ªå…ˆä½¿ç”¨å‰–é¢åœ–çš„ç´”åœ°å½¢é«˜åº¦(ä¸å«å¤©ç·š)ï¼Œå¦å‰‡ fallback åˆ° GPS åˆ†é 
  const eleB = (window.terrainEleB !== undefined && !isNaN(window.terrainEleB))
    ? window.terrainEleB
    : parseFloat(document.getElementById('eleB').value || 0);
  const nameB = document.getElementById('nameB').value || 'Bé»';

  // å„ªå…ˆä½¿ç”¨ GPS åˆ†é çš„è¨ˆç®—çµæœï¼ˆå«åœ°çƒæ›²ç‡ä¿®æ­£çš„ getBearing/getPitch ç²¾ç¢ºå€¼ï¼‰
  // è‹¥ GPS åˆ†é å°šæœªè¨ˆç®—ï¼Œå‰‡ fallback åˆ°å ±å‘Šå…§éƒ¨çš„ calculateAngles
  let angles = null;
  if (window.gpsCalcResult) {
    angles = {
      azimuthAtoB: window.gpsCalcResult.azimuthAtoB,
      azimuthBtoA: window.gpsCalcResult.azimuthBtoA,
      elevationAtoB: window.gpsCalcResult.pitchAtoB,
      elevationBtoA: window.gpsCalcResult.pitchBtoA,
      distance: window.gpsCalcResult.distKm
    };
  } else if (!isNaN(latA) && !isNaN(lonA) && !isNaN(latB) && !isNaN(lonB)) {
    angles = calculateAngles(latA, lonA, eleA, latB, lonB, eleB);
  }

  // è®€å–RFè³‡æ–™
  const freq = document.getElementById('link_freq_mhz').value;
  const dist = document.getElementById('link_dist_km').value;
  const linkBudgetOutput = document.getElementById('linkbudget_output');
  const rssiText = linkBudgetOutput ? linkBudgetOutput.textContent : '';

  // å‰µå»ºä¸‰å€‹å€å¡Šå®¹å™¨
  const threeBlocksDiv = document.createElement('div');
  threeBlocksDiv.style.cssText = `
    display: flex;
    gap: 6px;
    width: ${(pdfWidth - 2 * margin) * 3.7795}px;
    font-family: 'Microsoft JhengHei', sans-serif;
    background: ${themeSetting === 'light' ? '#ffffff' : '#0b1526'};
    padding: 2px;
  `;

  // ğŸ¨ æ ¹æ“šä¸»é¡Œè¨­å®šå€å¡Šæ¨£å¼
  const blockStyle = themeSetting === 'light' ? {
    background: '#f8f9fa',
    border: '2px solid #3b82f6',
    titleColor: '#1e40af',
    labelColor: '#374151',
    valueColor: '#0c4a6e',
    highlightBg: 'rgba(59, 130, 246, 0.1)',
    highlightBorder: '2px solid #60a5fa',
    highlightTitle: '#1e40af',
    orangeBorder: '#d97706',
    orangeTitle: '#ea580c',
    greenBg: 'rgba(34, 197, 94, 0.15)',
    greenBorder: '2px solid #22c55e',
    greenText: '#15803d',
    redText: '#dc2626',
    yellowBg: 'rgba(234, 179, 8, 0.15)',
    yellowText: '#a16207',
    lrTitle: '#000000',
    lrValue: '#1d4ed8'
  } : {
    background: 'rgba(20, 30, 50, 1)',
    border: '2px solid #ff9500',
    titleColor: '#ffa500',
    labelColor: '#f0f4f8',
    valueColor: '#60d6ff',
    highlightBg: 'rgba(95,240,213,0.2)',
    highlightBorder: '2px solid rgba(95,240,213,0.5)',
    highlightTitle: '#60d6ff',
    orangeBorder: '#ff9500',
    orangeTitle: '#ffa500',
    greenBg: 'rgba(95,240,213,0.25)',
    greenBorder: '2px solid #00e6b8',
    greenText: '#00e6b8',
    redText: '#ff6b6b',
    yellowBg: 'rgba(77,171,247,0.2)',
    yellowText: '#fef08a',
    lrTitle: '#fef08a',
    lrValue: '#93c5fd'
  };

  // === å·¦å´å€å¡Š:Aé» + Aâ†’Bè§’åº¦ + ç™¼å°„ç«¯RFåƒæ•¸ ===
  const leftBlock = document.createElement('div');
  leftBlock.style.cssText = `
    flex: 1;
    background: ${blockStyle.background};
    border: 1px solid ${themeSetting === 'light' ? '#1e3a8a' : blockStyle.orangeBorder};
    border-radius: 6px;
    padding: 12px;
  `;

  let leftContent = `
    <div style="font-size:22px; color:${blockStyle.lrTitle}; text-align:center; margin-bottom:8px; font-weight:bold;">
    ğŸ“ ${nameA}
    </div>
  `;

  if (!isNaN(latA) && !isNaN(lonA)) {
    leftContent += `
    <div style="font-size:17px; color:${blockStyle.lrTitle}; margin-bottom:3px;">
      åº§æ¨™: <span style="color:${blockStyle.lrValue}; font-weight:700;">${latA.toFixed(6)}Â°N, ${lonA.toFixed(6)}Â°E</span>
    </div>
    <div style="font-size:17px; color:${blockStyle.lrTitle}; margin-bottom:3px;">
      é«˜åº¦(å«å»ºç‰©): <span style="color:${blockStyle.lrValue}; font-weight:700;">${eleA.toFixed(1)} m</span>
    </div>
    `;
  }

  // è®€å–å¤©ç·šé«˜åº¦
  const antennaHeightA = document.getElementById('antennaHeightStart').value;
  if (antennaHeightA) {
    leftContent += `
    <div style="font-size:17px; color:${blockStyle.lrTitle}; margin-bottom:6px;">
      å¤©ç·šé«˜: <span style="color:${blockStyle.lrValue}; font-weight:700;">${antennaHeightA} m</span>
    </div>
    `;
  }

  if (angles) {
    leftContent += `
    <div style="background:${blockStyle.highlightBg}; padding:8px; border-radius:4px; margin-top:6px; border:${blockStyle.highlightBorder};">
      <div style="font-size:18px; color:${blockStyle.lrTitle}; margin-bottom:4px; font-weight:bold;">${nameA} â†’ ${nameB} æ–¹å‘</div>
      <div style="font-size:17px; color:${blockStyle.lrTitle}; margin-bottom:3px;">
      æ–¹ä½è§’: <span style="color:${blockStyle.lrValue}; font-weight:700;">${angles.azimuthAtoB.toFixed(1)}Â°</span>
      </div>
      <div style="font-size:17px; color:${blockStyle.lrTitle};">
      ä¿¯ä»°è§’: <span style="color:${blockStyle.lrValue}; font-weight:700;">${angles.elevationAtoB >= 0 ? '+' : ''}${angles.elevationAtoB.toFixed(2)}Â°</span>
      </div>
    </div>
    `;
  }

  // è®€å–ç™¼å°„ç«¯RFåƒæ•¸
  const txPower = document.getElementById('link_tx_power_input').value;
  const txPowerUnit = document.getElementById('link_tx_power_unit').value.toUpperCase();
  const txGain = document.getElementById('link_tx_gain_dbi').value;
  const txLoss = document.getElementById('link_tx_loss_db').value;

  if (txPower || txGain || txLoss) {
    leftContent += `
    <div style="background:${blockStyle.yellowBg}; padding:8px; border-radius:4px; margin-top:6px; border:${blockStyle.highlightBorder};">
      <div style="font-size:18px; color:${blockStyle.lrTitle}; margin-bottom:4px; font-weight:bold;">ç™¼å°„ç«¯ (Tx)</div>
    `;

    if (txPower) {
    leftContent += `
      <div style="font-size:17px; color:${blockStyle.lrTitle}; margin-bottom:3px;">
      ç™¼å°„åŠŸç‡: <span style="color:${blockStyle.lrValue}; font-weight:700;">${txPower} ${txPowerUnit}</span>
      </div>
    `;
    }

    if (txGain) {
    leftContent += `
      <div style="font-size:17px; color:${blockStyle.lrTitle}; margin-bottom:3px;">
      å¤©ç·šå¢ç›Š: <span style="color:${blockStyle.lrValue}; font-weight:700;">${txGain} dBi</span>
      </div>
    `;
    }

    if (txLoss) {
    leftContent += `
      <div style="font-size:17px; color:${blockStyle.lrTitle};">
      ç·šæ: <span style="color:${blockStyle.lrValue}; font-weight:700;">${txLoss} dB</span>
      </div>
    `;
    }

    leftContent += `</div>`;
  }

  leftBlock.innerHTML = leftContent;

  // === ä¸­é–“å€å¡Šï¼šRFè¨ˆç®— ===
  const centerBlock = document.createElement('div');
  centerBlock.style.cssText = `
    flex: 1;
    background: ${blockStyle.background};
    border: 1px solid ${themeSetting === 'light' ? '#1e3a8a' : '#5ff0d5'};
    border-radius: 6px;
    padding: 12px;
  `;

  let centerContent = `
    <div style="font-size:21px; color:${blockStyle.titleColor}; text-align:center; margin-bottom:8px; font-weight:bold;">
    ğŸ“¡ RFéˆè·¯è¨ˆç®—
    </div>
  `;

  if (freq) {
    centerContent += `
    <div style="font-size:17px; color:${blockStyle.labelColor}; margin-bottom:3px;">
      é »ç‡: <span style="color:${blockStyle.titleColor}; font-weight:700;">${freq} MHz</span>
    </div>
    `;
  }

  // è®€å–å‰–é¢åœ–è·é›¢æ•¸æ“šï¼ˆä½¿ç”¨ window.currentPathDataï¼‰
  let profileDistance = null;
  if (typeof window.currentPathData !== 'undefined' && window.currentPathData && window.currentPathData.length > 0) {
    const lastPoint = window.currentPathData[window.currentPathData.length - 1];
    if (lastPoint && lastPoint.dist !== undefined) {
    profileDistance = parseFloat(lastPoint.dist);
    }
  }

  // å„ªå…ˆä½¿ç”¨å‰–é¢åœ–è·é›¢ï¼Œå¦å‰‡ä½¿ç”¨RFå·¥å…·çš„è·é›¢
  const displayDistance = profileDistance !== null ? profileDistance.toFixed(2) : dist;

  if (displayDistance) {
    centerContent += `
    <div style="font-size:17px; color:${blockStyle.labelColor}; margin-bottom:6px;">
      è·é›¢: <span style="color:${blockStyle.titleColor}; font-weight:700;">${displayDistance} km</span>
    </div>
    `;
  }

  // è§£ææ¥æ”¶è¨Šè™Ÿå¼·åº¦
  const rssiMatch = rssiText.match(/æ¥æ”¶è¨Šè™Ÿå¼·åº¦:\s*([-+]?\d+\.?\d*)\s*dBm/);

  // å…ˆåˆ¤æ–·è·¯å¾‘æ˜¯å¦æœ‰é®è”½ï¼ˆä¾›è¨Šè™Ÿæ¨™é¡Œä½¿ç”¨ï¼‰
  let hasObstruction = false;
  let obstructionChecked = false;
  if (elevationData && elevationData.length > 0 && chartInstance && chartInstance.data.datasets[1]) {
    const losLineData = chartInstance.data.datasets[1].data;
    obstructionChecked = true;
    for (let i = 1; i < elevationData.length - 1; i++) {
      const terrainHeight = elevationData[i];
      const losHeight = losLineData[i];
      if (losHeight - terrainHeight < 0) {
        hasObstruction = true;
        break;
      }
    }
  }

  if (rssiMatch) {
    if (obstructionChecked) {
      if (hasObstruction) {
        // æœ‰é®è”½ï¼šç´…æ¡†ï¼Œé¡¯ç¤ºé®è”½ç‹€æ…‹ + LoSç†è«–å€¼
        centerContent += `
        <div style="background:rgba(220,38,38,0.15); border:2px solid ${blockStyle.redText}; border-radius:4px; padding:10px; text-align:center; margin-bottom:4px;">
          <div style="font-size:22px; color:${blockStyle.redText}; font-weight:bold; margin-bottom:4px;">âš ï¸ æœ‰é®è”½</div>
          <div style="font-size:12px; color:${blockStyle.redText}; opacity:0.85; margin-bottom:2px; font-weight:600;">LoS ç†è«–è¨Šè™Ÿå€¼ï¼ˆå¯¦éš›æ›´å·®ï¼‰</div>
          <div style="font-size:22px; color:${blockStyle.redText}; font-weight:bold;">${rssiMatch[1]} dBm</div>
        </div>
        `;
      } else {
        // ç„¡é®è”½ï¼šç¶ æ¡†ï¼Œé¡¯ç¤ºç„¡é®è”½ + è¨Šè™Ÿå€¼
        centerContent += `
        <div style="background:${blockStyle.greenBg}; border:${blockStyle.greenBorder}; border-radius:4px; padding:10px; text-align:center; margin-bottom:4px;">
          <div style="font-size:22px; color:${blockStyle.greenText}; font-weight:bold; margin-bottom:4px;">âœ“ ç„¡é®è”½</div>
          <div style="font-size:12px; color:${blockStyle.yellowText}; margin-bottom:2px; font-weight:600;">è¦–è·(LoS)è¨Šè™Ÿé ä¼°</div>
          <div style="font-size:22px; color:${blockStyle.greenText}; font-weight:bold;">${rssiMatch[1]} dBm</div>
        </div>
        `;
      }
    } else {
      // ç„¡æ³•åˆ¤æ–·é®è”½ï¼ˆæœªè¼‰å…¥å‰–é¢åœ–ï¼‰ï¼šåŸå§‹é¡¯ç¤º
      centerContent += `
      <div style="background:${blockStyle.greenBg}; border:${blockStyle.greenBorder}; border-radius:4px; padding:10px; text-align:center; margin-bottom:4px;">
        <div style="font-size:12px; color:${blockStyle.yellowText}; margin-bottom:2px; font-weight:700;">è¦–è·(LoS)è¨Šè™Ÿé ä¼°</div>
        <div style="font-size:22px; color:${blockStyle.greenText}; font-weight:bold;">${rssiMatch[1]} dBm</div>
      </div>
      `;
    }
  }

  centerBlock.innerHTML = centerContent;

  // === å³å´å€å¡Šï¼šBé» + Bâ†’Aè§’åº¦ + æ¥æ”¶ç«¯RFåƒæ•¸ ===
  const rightBlock = document.createElement('div');
  rightBlock.style.cssText = `
    flex: 1;
    background: ${blockStyle.background};
    border: 1px solid ${themeSetting === 'light' ? '#1e3a8a' : '#9945ff'};
    border-radius: 6px;
    padding: 12px;
  `;

  let rightContent = `
    <div style="font-size:22px; color:${blockStyle.lrTitle}; text-align:center; margin-bottom:8px; font-weight:bold;">
    ğŸ“ ${nameB}
    </div>
  `;

  if (!isNaN(latB) && !isNaN(lonB)) {
    rightContent += `
    <div style="font-size:17px; color:${blockStyle.lrTitle}; margin-bottom:3px;">
      åº§æ¨™: <span style="color:${blockStyle.lrValue}; font-weight:700;">${latB.toFixed(6)}Â°N, ${lonB.toFixed(6)}Â°E</span>
    </div>
    <div style="font-size:17px; color:${blockStyle.lrTitle}; margin-bottom:3px;">
      é«˜åº¦(å«å»ºç‰©): <span style="color:${blockStyle.lrValue}; font-weight:700;">${eleB.toFixed(1)} m</span>
    </div>
    `;
  }

  // è®€å–å¤©ç·šé«˜åº¦
  const antennaHeightB = document.getElementById('antennaHeightEnd').value;
  if (antennaHeightB) {
    rightContent += `
    <div style="font-size:17px; color:${blockStyle.lrTitle}; margin-bottom:6px;">
      å¤©ç·šé«˜: <span style="color:${blockStyle.lrValue}; font-weight:700;">${antennaHeightB} m</span>
    </div>
    `;
  }

  if (angles) {
    rightContent += `
    <div style="background:rgba(95,240,213,0.2); padding:8px; border-radius:4px; margin-top:6px; border:2px solid rgba(95,240,213,0.5);">
      <div style="font-size:18px; color:${blockStyle.lrTitle}; margin-bottom:4px; font-weight:bold;">${nameB} â†’ ${nameA} æ–¹å‘</div>
      <div style="font-size:17px; color:${blockStyle.lrTitle}; margin-bottom:3px;">
      æ–¹ä½è§’: <span style="color:${blockStyle.lrValue}; font-weight:700;">${angles.azimuthBtoA.toFixed(1)}Â°</span>
      </div>
      <div style="font-size:17px; color:${blockStyle.lrTitle};">
      ä¿¯ä»°è§’: <span style="color:${blockStyle.lrValue}; font-weight:700;">${angles.elevationBtoA >= 0 ? '+' : ''}${angles.elevationBtoA.toFixed(2)}Â°</span>
      </div>
    </div>
    `;
  }

  // è®€å–æ¥æ”¶ç«¯RFåƒæ•¸
  const rxGain = document.getElementById('link_rx_gain_dbi').value;
  const rxLoss = document.getElementById('link_rx_loss_db').value;

  if (rxGain || rxLoss) {
    rightContent += `
    <div style="background:${blockStyle.yellowBg}; padding:8px; border-radius:4px; margin-top:6px; border:2px solid rgba(77,171,247,0.5);">
      <div style="font-size:18px; color:${blockStyle.lrTitle}; margin-bottom:4px; font-weight:bold;">æ¥æ”¶ç«¯ (Rx)</div>
    `;

    if (rxGain) {
    rightContent += `
      <div style="font-size:17px; color:${blockStyle.lrTitle}; margin-bottom:3px;">
      å¤©ç·šå¢ç›Š: <span style="color:${blockStyle.lrValue}; font-weight:700;">${rxGain} dBi</span>
      </div>
    `;
    }

    if (rxLoss) {
    rightContent += `
      <div style="font-size:17px; color:${blockStyle.lrTitle};">
      ç·šæ: <span style="color:${blockStyle.lrValue}; font-weight:700;">${rxLoss} dB</span>
      </div>
    `;
    }

    rightContent += `</div>`;
  }

  rightBlock.innerHTML = rightContent;

  // çµ„åˆä¸‰å€‹å€å¡Š
  threeBlocksDiv.appendChild(leftBlock);
  threeBlocksDiv.appendChild(centerBlock);
  threeBlocksDiv.appendChild(rightBlock);

  // æ¸²æŸ“åˆ°PDF
  document.body.appendChild(threeBlocksDiv);

  const blocksCanvas = await html2canvas(threeBlocksDiv, {
    backgroundColor: themeSetting === 'light' ? '#ffffff' : '#0b1526',
    scale: qualityConfig.blockScale
  });

  document.body.removeChild(threeBlocksDiv);

  const blocksImgData = blocksCanvas.toDataURL('image/png');
  const blocksHeight = 72;
  pdf.addImage(blocksImgData, 'PNG', margin, yPos, pdfWidth - 2 * margin, blocksHeight);

  // å„²å­˜PDF
  const fileName = `RFåˆ†æå ±å‘Š_${new Date().getTime()}.pdf`;
  pdf.save(fileName);
  showExportStatus('âœ… å–®é PDFå ±å‘Šå·²æˆåŠŸä¸‹è¼‰ï¼', 'success');

  // ğŸ¯ è‡ªå‹•é—œé–‰å‰–é¢åœ–å…¨å±
  const overlay = document.getElementById('chartFullscreenOverlay');
  if (overlay && overlay.classList.contains('active')) {
    setTimeout(() => {
    closeChartFullscreen();
    }, 500);  // å»¶é² 0.5 ç§’å¾Œé—œé–‰ï¼Œè®“ä½¿ç”¨è€…çœ‹åˆ°æˆåŠŸè¨Šæ¯
  }

  } catch (error) {
  showExportStatus('âŒ PDF ç”Ÿæˆå¤±æ•—ï¼š' + error.message, 'error');
  }
}

function showExportStatus(message, type) {
  const status = document.getElementById('export_status');
  status.textContent = message;
  status.style.display = 'block';

  // è¨­å®šæ¨£å¼
  if (type === 'success') {
  status.style.background = 'rgba(39, 174, 96, 0.2)';
  status.style.color = '#27ae60';
  status.style.border = '1px solid #27ae60';
  } else if (type === 'error') {
  status.style.background = 'rgba(220, 53, 69, 0.2)';
  status.style.color = '#dc3545';
  status.style.border = '1px solid #dc3545';
  } else if (type === 'warning') {
  status.style.background = 'rgba(255, 193, 7, 0.2)';
  status.style.color = '#ffc107';
  status.style.border = '1px solid #ffc107';
  } else {
  status.style.background = 'rgba(255, 212, 59, 0.2)';
  status.style.color = '#ffd43b';
  status.style.border = '1px solid #ffd43b';
  }

  // æˆåŠŸæˆ–éŒ¯èª¤è¨Šæ¯ 3 ç§’å¾Œè‡ªå‹•æ¶ˆå¤±
  if (type === 'success' || type === 'error') {
  setTimeout(() => {
    status.style.display = 'none';
  }, 3000);
  }
}
</script>

<div id="archive-content" class="tab-content">
  <section class="card">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
      <h3 class="section-title" style="margin:0">ğŸ’¾ åƒæ•¸ä¿å­˜ / å‚™ä»½</h3>
      <div style="display:flex; gap:8px;">
        <button class="btn ghost" onclick="lsExport()" style="padding:5.6px 11.2px; font-size:16px; white-space:nowrap; flex-shrink:0;">åŒ¯å‡º</button>
        <button class="btn ghost" onclick="document.getElementById('ls_import').click()" style="padding:5.6px 11.2px; font-size:16px; white-space:nowrap; flex-shrink:0;">è®€å–</button>
        <input id="ls_import" type="file" accept="application/json" style="display:none" onchange="lsImport(event)">
      </div>
    </div>
    <div style="display:flex; gap:8px; margin-bottom:12px; align-items:center; flex-wrap:nowrap;">
      <div id="ls_name_container" style="flex:1; min-width:150px; position:relative; display:flex; align-items:center; justify-content:space-between; padding:8px 12px; font-size:16px; background:transparent; border-radius:6px; border:1px solid #ffffff;">
        <input id="ls_save_name" placeholder="è‡ªè¨‚åç¨±" style="border:none; background:transparent; outline:none; color:#ffffff; font-size:16px; padding:0; flex:1; min-width:60px;" oninput="updateNamePreview()">
        <span id="ls_name_suffix" style="color:rgba(255,255,255,0.5); font-size:16px; white-space:nowrap; margin-left:8px;"></span>
      </div>
    </div>
    <div style="display:flex; gap:8px; margin-bottom:12px; flex-wrap:nowrap;">
      <button class="btn" onclick="loadGpsNamesToArchive()" style="flex:1; padding:5.6px 11.2px; font-size:16px; white-space:nowrap; background:linear-gradient(90deg, #bb66ff, #9945ff); color:#fff;" title="å¾GPSåˆ†é è®€å–åœ°å">ğŸŒâ†”ï¸</button>
      <button id="los_toggle_btn" class="btn" onclick="toggleLosStatus()" style="flex:1; padding:5.6px 11.2px; font-size:16px; white-space:nowrap; background:linear-gradient(90deg, #95a5a6, #7f8c8d); color:#fff;" title="åˆ‡æ›ç‹€æ…‹ï¼šæœªæŒ‡å®š/è¦–è·/éè¦–è·">N/A</button>
      <button class="btn" onclick="lsSave()" style="flex:1; padding:5.6px 11.2px; font-size:16px; white-space:nowrap;" title="ä¿å­˜åƒæ•¸">ğŸ’¾</button>
    </div>
    <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px; flex-wrap:nowrap;">
      <label style="color:var(--label); font-size:15px; font-weight:600; white-space:nowrap;">ğŸ” æœå°‹ï¼š</label>
      <div style="flex:1; position:relative;">
        <input id="archive_search" type="text" placeholder="è¼¸å…¥å­˜æª”åç¨±..." oninput="lsLoadTable()" style="width:100%; padding:6px 30px 6px 10px; font-size:15px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);">
        <button onclick="clearArchiveSearch()" style="position:absolute; right:6px; top:50%; transform:translateY(-50%); background:none; border:none; color:rgba(255,255,255,0.4); cursor:pointer; font-size:18px; padding:0 4px; line-height:1;" title="æ¸…é™¤æœå°‹">Ã—</button>
      </div>
    </div>
    <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px; flex-wrap:nowrap;">
      <label style="color:var(--label); font-size:15px; font-weight:600; white-space:nowrap;">æ’åˆ—æ–¹å¼ï¼š</label>
      <select id="sort_order" onchange="lsLoadTable()" style="flex:1; padding:6px 10px; font-size:15px; color:var(--value); background:transparent; border-radius:6px; border:1px solid rgba(255,255,255,0.15);">
        <option value="time-new">æª”æ¡ˆ æ–° â®• èˆŠ</option>
        <option value="time-old">æª”æ¡ˆ èˆŠ â®• æ–°</option>
        <option value="name-az">åç¨± A â®• Z</option>
        <option value="name-za">åç¨± Z â®• A</option>
      </select>
    </div>
    <div style="overflow-x:auto;">
      <table style="width:100%; table-layout:fixed;">
        <thead>
          <tr>
            <th style="text-align:left; padding:8px 8px 8px 4px; width:75%;">åç¨±</th>
            <th style="text-align:center; padding:4px 2px; width:25%;">æ“ä½œ</th>
          </tr>
        </thead>
        <tbody id="ls_table"></tbody>
      </table>
    </div>
  </section>
</div>
</main>
<script>
const sectionIds = {
  'power': 'section-power',
  'matching': 'section-matching',
  'sensitivity': 'section-sensitivity',
  'los': 'section-los',
  'fspl': 'section-fspl',
  'linkbudget': 'section-linkbudget'
};
const defaultValues = {
  'section-power': {
    'power_input': '1',
    'power_unit': 'w',
  },
  'section-matching': {
    'matching_input_value': '20',
    'matching_unit': 'rl',
  },
  'section-sensitivity': {
    'sensitivity_bw': '1',
    'sensitivity_nf': '5',
    'sensitivity_sn': '10',
  },
  'section-los': {
    'los_g1': '0',
    'los_h1': '10',
    'los_g2': '0',
    'los_h2': '20',
  },
  'section-fspl': {
    'fspl_freq': '2400',
    'fspl_dist': '10',
  },
  'section-linkbudget': {
    'link_tx_power_input': '1',
    'link_tx_power_unit': 'w',
    'link_tx_loss_db': '3',
    'link_tx_gain_dbi': '20',
    'link_dist_km': '10',
    'link_freq_mhz': '2400',
    'link_rx_gain_dbi': '20',
    'link_rx_loss_db': '2',
  }
};
const calculationFunctions = {
  'section-power': 'calculateDbmWNew',
  'section-matching': 'calculateMatching',
  'section-sensitivity': 'calculateSensitivity',
  'section-los': 'calculateMaxLOS',
  'section-fspl': 'calculateFSPL',
  'section-linkbudget': 'calculateLinkBudget',
};
function getSectionControls(sectionId) {
  const sectionEl = document.getElementById(sectionId);
  if (!sectionEl) return [];
  const inputGroup = sectionEl.querySelector('.input-group-border');
  if (!inputGroup) return [];
  return Array.from(inputGroup.querySelectorAll('input, select')).filter(el => el.id);
}
function resetSection(sectionId) {
  const defaults = defaultValues[sectionId];
  if (defaults) {
    for (const id in defaults) {
      const element = document.getElementById(id);
      if (element) {
        element.value = defaults[id];
        if(element.tagName === 'INPUT') element.value = defaults[id];
      }
    }
  }
  const calcFunc = calculationFunctions[sectionId];
  if (calcFunc && typeof window[calcFunc] === 'function') {
    window[calcFunc]();
  }
}
function clearSection(sectionId) {
  const controls = getSectionControls(sectionId);
  const defaults = defaultValues[sectionId] || {};
  controls.forEach(element => {
    const id = element.id;
    if (element.tagName === 'INPUT') {
      element.value = '';
    } else if (element.tagName === 'SELECT') {
      if (defaults[id]) {
        element.value = defaults[id];
      } else {
        element.selectedIndex = 0;
      }
    }
  });
  const calcFunc = calculationFunctions[sectionId];
  if (calcFunc && typeof window[calcFunc] === 'function') {
    window[calcFunc]();
  }
}
function toggleSections() {
  const selector = document.getElementById('function_selector');
  const selectedValue = selector.value;
  const allSections = document.querySelectorAll('.section-item');
  allSections.forEach(section => {
    const sectionKey = Object.keys(sectionIds).find(key => sectionIds[key] === section.id);
    if (selectedValue === 'ALL') {
      section.style.display = 'block';
    } else if (sectionKey === selectedValue) {
      section.style.display = 'block';
    } else {
      section.style.display = 'none';
    }
  });
  if (selectedValue === 'ALL' || selectedValue === 'power') calculateDbmWNew();
  if (selectedValue === 'ALL' || selectedValue === 'matching') calculateMatching();
  if (selectedValue === 'ALL' || selectedValue === 'sensitivity') calculateSensitivity();
  if (selectedValue === 'ALL' || selectedValue === 'los') calculateMaxLOS();
  if (selectedValue === 'ALL' || selectedValue === 'fspl') calculateFSPL();
  if (selectedValue === 'ALL' || selectedValue === 'linkbudget') calculateLinkBudget();
}
function clearAndRecalculate(inputId, calcFunc) {
  const inputElement = document.getElementById(inputId);
  if (inputElement) {
    inputElement.value = '';
  }
  if (typeof window[calcFunc] === 'function') {
    window[calcFunc]();
  }
}
function convertPower(value, fromUnit, toUnit) {
  if (fromUnit === toUnit) return value;
  if (fromUnit === 'w' && toUnit === 'dbm') {
    return 10 * Math.log10(value * 1000);
  } else if (fromUnit === 'dbm' && toUnit === 'w') {
    return Math.pow(10, (value / 10) - 3);
  }
  return NaN;
}
let power_conv_last_unit = 'w';
function calculateDbmWNew() {
  const input = document.getElementById('power_input');
  const unit = document.getElementById('power_unit').value;
  const output = document.getElementById('power_output_result');
  const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
  const unit_color = getComputedStyle(document.body).color;
  const input_value = parseFloat(input.value);
  if (isNaN(input_value) || input.value.trim() === '') {
    output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">è«‹è¼¸å…¥æ•¸å€¼</span>`;
    return;
  }
  if (unit === 'w' && input_value < 0) {
    output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">åŠŸç‡ (W) å¿…é ˆ â‰¥ 0</span>`;
    return;
  }
  let result_value, result_unit;
  if (unit === 'w') {
    result_value = convertPower(input_value, 'w', 'dbm');
    result_unit = 'dBm';
    if (result_value === -Infinity) {
      output.innerHTML = `æ›ç®—çµæœ: <span class="result-value">-âˆ</span> <span style="color:${unit_color};">${result_unit}</span>`;
      return;
    }
  } else {
    result_value = convertPower(input_value, 'dbm', 'w');
    result_unit = 'W';
    if (result_value < 0) result_value = 0;
  }
  if (isNaN(result_value)) {
    output.innerHTML = `æ›ç®—çµæœ: <span style="color:${redColor};">è¼¸å…¥ç„¡æ•ˆ</span>`;
    return;
  } else {
    output.innerHTML = `æ›ç®—çµæœ: <span class="result-value">${result_value.toFixed(3)}</span> <span style="color:${unit_color};">${result_unit}</span>`;
  }
  power_conv_last_unit = unit;
}
function swapAndCalculate() {
  const input = document.getElementById('power_input');
  const current_unit = document.getElementById('power_unit').value;
  const input_value = parseFloat(input.value);
  if (!isNaN(input_value) && input.value.trim() !== '') {
    const new_value = convertPower(input_value, power_conv_last_unit, current_unit);
    if (!isNaN(new_value)) {
      if (current_unit === 'dbm' && new_value === -Infinity) {
      } else {
        input.value = new_value.toFixed(3);
      }
    } else {
    }
  }
  calculateDbmWNew();
}
let last_matching_unit = 'rl';
function getGammaFromValue(value, type) {
  if (type === 'rl') {
    if (value < 0) throw new Error("RL å¿…é ˆ â‰¥ 0 dB");
    return Math.pow(10, -value / 20);
  } else if (type === 'vswr') {
    if (value < 1) throw new Error("VSWR å¿…é ˆ â‰¥ 1");
    return (value - 1) / (value + 1);
  } else if (type === 'gamma') {
    if (value < 0 || value > 1) throw new Error("Î“ å¿…é ˆä»‹æ–¼ 0 åˆ° 1 ä¹‹é–“");
    return value;
  } else if (type === 'refl_pct') {
    if (value < 0 || value > 100) throw new Error("åå°„åŠŸç‡å¿…é ˆä»‹æ–¼ 0 åˆ° 100 ä¹‹é–“");
    return Math.sqrt(value / 100);
  } else if (type === 'pass_pct') {
    if (value < 0 || value > 100) throw new Error("é€šéåŠŸç‡å¿…é ˆä»‹æ–¼ 0 åˆ° 100 ä¹‹é–“");
    return Math.sqrt(1 - (value / 100));
  }
  return NaN;
}
function getValueFromGamma(gamma, type) {
  if (isNaN(gamma) || gamma === Infinity) return NaN;
  if (type === 'rl') {
    if (gamma === 0) return Infinity;
    return -20 * Math.log10(Math.abs(gamma));
  } else if (type === 'vswr') {
    if (gamma === 1) return Infinity;
    return (1 + Math.abs(gamma)) / (1 - Math.abs(gamma));
  } else if (type === 'gamma') {
    return Math.abs(gamma);
  } else if (type === 'refl_pct') {
    return Math.abs(gamma)**2 * 100;
  } else if (type === 'pass_pct') {
    return (1 - Math.abs(gamma)**2) * 100;
  }
  return NaN;
}
function swapAndConvertMatching() {
  const current_unit = document.getElementById('matching_unit').value;
  const input_element = document.getElementById('matching_input_value');
  const input_value = parseFloat(input_element.value);
  if (!isNaN(input_value) && input_element.value.trim() !== '') {
    let gamma_abs;
    try {
      gamma_abs = getGammaFromValue(input_value, last_matching_unit);
      if (!isNaN(gamma_abs)) {
        const new_value = getValueFromGamma(gamma_abs, current_unit);
        if (!isNaN(new_value) && new_value !== Infinity) {
          const precision = (current_unit === 'rl' || current_unit === 'refl_pct' || current_unit === 'pass_pct') ? 2 : 4;
          input_element.value = new_value.toFixed(precision);
        } else if (new_value === Infinity) {
          input_element.value = '1';
        } else {
          input_element.value = '';
        }
      } else {
        input_element.value = '';
      }
    } catch (error) {
       input_element.value = '';
    }
  }
  calculateMatching();
  last_matching_unit = current_unit;
}
function calculateMatching() {
  const input_type = document.getElementById('matching_unit').value;
  const input_element = document.getElementById('matching_input_value');
  const input_value = parseFloat(input_element.value);
  const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
  const unit_color = getComputedStyle(document.body).color;
  const output_elements = {
    rl: document.getElementById('rl_val'),
    vswr: document.getElementById('vswr_val'),
    gamma: document.getElementById('gamma_val'),
    refl_pct: document.getElementById('refl_percent'),
    pass_pct: document.getElementById('pass_percent')
  };
  const empty_output = `<span style="color:${redColor};font-size:17px;">è«‹è¼¸å…¥æ•¸å€¼</span>`;
  Object.values(output_elements).forEach(el => el.innerHTML = '');
  if (isNaN(input_value) || input_element.value.trim() === '') {
    output_elements.rl.innerHTML = empty_output;
    return;
  }
  let gamma_abs;
  try {
    gamma_abs = getGammaFromValue(input_value, input_type);
  } catch (error) {
    output_elements.rl.innerHTML = `<span style="color:${redColor};font-size:17px;">${error.message}</span>`;
    return;
  }
  const rl_val = getValueFromGamma(gamma_abs, 'rl');
  const vswr_val = getValueFromGamma(gamma_abs, 'vswr');
  const gamma_val = getValueFromGamma(gamma_abs, 'gamma');
  const refl_pct = getValueFromGamma(gamma_abs, 'refl_pct');
  const pass_pct = getValueFromGamma(gamma_abs, 'pass_pct');
  const formatOutput = (value, unit, precision=2) => {
    if (value === Infinity) return `<span class="result-value">âˆ</span> <span style="color:${unit_color};">${unit}</span>`;
    if (isNaN(value)) return `<span style="color:${redColor};font-size:17px;">è¨ˆç®—éŒ¯èª¤</span>`;
    return `<span class="result-value">${value.toFixed(precision)}</span> <span style="color:${unit_color};">${unit}</span>`;
  }
  output_elements.rl.innerHTML = formatOutput(rl_val, 'dB');
  output_elements.vswr.innerText = vswr_val === Infinity ? 'âˆ' : vswr_val.toFixed(3);
  output_elements.gamma.innerText = gamma_val.toFixed(4);
  output_elements.refl_pct.innerHTML = formatOutput(refl_pct, '%');
  output_elements.pass_pct.innerHTML = formatOutput(pass_pct, '%');
  last_matching_unit = input_type;
}
const BOLTZMANN_K_J = 1.380649e-23;
const T_KELVIN = 290;
function calculateSensitivity() {
  const bw_mhz = parseFloat(document.getElementById('sensitivity_bw').value);
  const nf_db = parseFloat(document.getElementById('sensitivity_nf').value);
  const sn_db = parseFloat(document.getElementById('sensitivity_sn').value);
  const output = document.getElementById('sensitivity_output');
  const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
  const unit_color = getComputedStyle(document.body).color;
  if (isNaN(bw_mhz) || isNaN(nf_db) || isNaN(sn_db) || bw_mhz <= 0 || nf_db < 0) {
    output.innerHTML = `æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity): <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å€¼ (BW > 0, NF â‰¥ 0)</span>`;
    return;
  }
  const noise_floor_dbm = -114 + (10 * Math.log10(bw_mhz)) + nf_db;
  const sensitivity_dbm = noise_floor_dbm + sn_db;
  output.innerHTML = `
    æ¥æ”¶å™¨éˆæ•åº¦ (Sensitivity): <span class="result-value">${sensitivity_dbm.toFixed(2)}</span> <span style="color:${unit_color};">dBm</span><br>
    <span class="result-value-small">ç†±é›œè¨Šåœ°æ¿ (Noise Floor) Pn: ${noise_floor_dbm.toFixed(2)} dBm</span>
  `;
}
const K_FACTOR = 4 / 3;
const R_EARTH_KM = 6371;
function calculateMaxLOS() {
  const g1 = parseFloat(document.getElementById('los_g1').value) || 0;
  const h1 = parseFloat(document.getElementById('los_h1').value) || 0;
  const g2 = parseFloat(document.getElementById('los_g2').value) || 0;
  const h2 = parseFloat(document.getElementById('los_h2').value) || 0;
  const output = document.getElementById('los_output');
  const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
  const unit_color = getComputedStyle(document.body).color;
  if (h1 < 0 || h2 < 0) {
    output.innerHTML = `æœ€å¤§é€šè¦–è·é›¢: <span style="color:${redColor};">å¤©ç·šé«˜åº¦å¿…é ˆ â‰¥ 0</span>`;
    return;
  }
  const a1 = g1 + h1;
  const a2 = g2 + h2;
  if (a1 <= 0 || a2 <= 0) {
    output.innerHTML = `æœ€å¤§é€šè¦–è·é›¢: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (å¤©ç·šçµ•å°é«˜åº¦ > 0) æ•¸å€¼</span>`;
    return;
  }
  const R_eff = K_FACTOR * R_EARTH_KM;
  const d1_km = Math.sqrt(2 * R_eff * a1 / 1000);
  const d2_km = Math.sqrt(2 * R_eff * a2 / 1000);
  const max_los_km = d1_km + d2_km;
  output.innerHTML = `
    æœ€å¤§é€šè¦–è·é›¢: <span class="result-value">${max_los_km.toFixed(2)}</span> <span style="color:${unit_color};">km</span><br>
    <span class="result-value-small">Aé»è¦–è·: ${d1_km.toFixed(2)} km; Bé»è¦–è·: ${d2_km.toFixed(2)} km</span>
  `;
}
function calculateFSPL() {
  const freq_mhz = parseFloat(document.getElementById('fspl_freq').value);
  const dist_km = parseFloat(document.getElementById('fspl_dist').value);
  const output = document.getElementById('fspl_output');
  const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
  const unit_color = getComputedStyle(document.body).color;
  if (isNaN(freq_mhz) || isNaN(dist_km) || freq_mhz <= 0 || dist_km <= 0) {
    output.innerHTML = `è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL): <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (é »ç‡ > 0, è·é›¢ > 0) æ•¸å€¼</span>`;
    return;
  }
  const fspl_db = 32.44 + (20 * Math.log10(freq_mhz)) + (20 * Math.log10(dist_km));
  output.innerHTML = `è‡ªç”±ç©ºé–“è¡°æ¸›é‡ (FSPL): <span class="result-value">${fspl_db.toFixed(2)}</span> <span style="color:${unit_color};">dB</span>`;
}
function calculateLinkBudget() {
  const freq_mhz = parseFloat(document.getElementById('link_freq_mhz').value);
  const dist_km = parseFloat(document.getElementById('link_dist_km').value);
  const tx_power_input = parseFloat(document.getElementById('link_tx_power_input').value);
  const tx_power_unit = document.getElementById('link_tx_power_unit').value;
  const tx_loss_db = parseFloat(document.getElementById('link_tx_loss_db').value) || 0;
  const tx_gain_dbi = parseFloat(document.getElementById('link_tx_gain_dbi').value) || 0;
  const rx_gain_dbi = parseFloat(document.getElementById('link_rx_gain_dbi').value) || 0;
  const rx_loss_db = parseFloat(document.getElementById('link_rx_loss_db').value) || 0;
  const output = document.getElementById('linkbudget_output');
  const redColor = getComputedStyle(document.documentElement).getPropertyValue('--red-clear');
  const unit_color = getComputedStyle(document.body).color;
  if (isNaN(freq_mhz) || isNaN(dist_km) || freq_mhz <= 0 || dist_km <= 0) {
    output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ (é »ç‡ > 0, è·é›¢ > 0) æ•¸å€¼</span>`;
    return;
  }
  if (isNaN(tx_power_input) || (tx_power_unit === 'w' && tx_power_input < 0)) {
     output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">è«‹è¼¸å…¥æœ‰æ•ˆçš„ç™¼å°„åŠŸç‡</span>`;
     return;
  }
  const tx_power_dbm = convertPower(tx_power_input, tx_power_unit, 'dbm');
  if (isNaN(tx_power_dbm)) {
     output.innerHTML = `æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span style="color:${redColor};">ç™¼å°„åŠŸç‡ (W) å¿…é ˆ > 0</span>`;
     return;
  }
  const fspl_db = 32.44 + (20 * Math.log10(freq_mhz)) + (20 * Math.log10(dist_km));
  const rx_power_dbm = tx_power_dbm - tx_loss_db + tx_gain_dbi - fspl_db + rx_gain_dbi - rx_loss_db;
  output.innerHTML = `
    æ¥æ”¶è¨Šè™Ÿå¼·åº¦: <span class="result-value">${rx_power_dbm.toFixed(2)}</span> <span style="color:${unit_color};">dBm</span><br>
    <span style="font-size:14px; color:var(--muted);">
      è·¯å¾‘æè€— (Path Loss): ${fspl_db.toFixed(2)} dB (FSPL) + ${(tx_loss_db + rx_loss_db).toFixed(2)} dB (ç·šæ) = ${(fspl_db + tx_loss_db + rx_loss_db).toFixed(2)} dB<br>
      ç™¼å°„ EIRP: ${(tx_power_dbm - tx_loss_db + tx_gain_dbi).toFixed(2)} dBm
    </span>
  `;
}
document.addEventListener('DOMContentLoaded', () => {
  window.elevationPointAName = 'Aé»';
  window.elevationPointBName = 'Bé»';
  toggleSections();
});
</script>  <script>
  function showTab(tabId) {
  document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
  const clickedButton = document.querySelector(`.tab-button[data-tab="${tabId}"]`);
  if(clickedButton) clickedButton.classList.add('active');
  const tabContent = document.getElementById(tabId + '-content');
  if(tabContent) tabContent.classList.add('active');
  if (tabId === 'rf') {
    compute();
  } else if (tabId === 'gps') {
    calculate();
  }
  }
  const cables = [
  { name: "LMR-600", a: 0.07555, b: 0.00026 },
  { name: "TCOM-600", a: 0.080075, b: 0.000256 },
  { name: "LMR-600-UF", a: 0.09066, b: 0.000312 },
  { name: "LMR-400", a: 0.12229, b: 0.00026 },
  { name: "LMR-400-UF", a: 0.146748, b: 0.000312 },
  { name: "M17/RG214", a: 0.21, b: 0.00126 },
  { name: "M17/RG142", a: 0.368, b: 0.0012 },
  { name: "LSSB-RG214", a: 0.191365, b: 0.001895 },
  { name: "LSSB-RG58", a: 0.444971, b: 0.003370 }
  ];
  let lastUnit = 'm';
  const FT_PER_METER = 3.28084;
  function calcAttenPer100ft(f,a,b){
  return a * Math.sqrt(f) + b * f;
  }
  function ftFromLength(len,unit){
  return unit === "ft" ? len : len * FT_PER_METER;
  }
  function convertLength() {
    const lenInput = document.getElementById("lenInput");
    let len = parseFloat(lenInput.value);
    const newUnit = document.getElementById("unit").value;
    if (isNaN(len) || len === 0) {
      lastUnit = newUnit;
      compute();
      return;
    }
    if (lastUnit === 'm' && newUnit === 'ft') {
      len *= FT_PER_METER;
    } else if (lastUnit === 'ft' && newUnit === 'm') {
      len /= FT_PER_METER;
    }
    lenInput.value = len.toFixed(2);
    lastUnit = newUnit;
    compute();
  }
  function powerPassPercent(db){
  return Math.pow(10, -db / 10) * 100;
  }
  function compute(){
  const f = parseFloat(document.getElementById("freq").value) || 0;
  const len = parseFloat(document.getElementById("lenInput").value) || 0;
  const unit = document.getElementById("unit").value || "m";
  const ftLen = ftFromLength(len, unit);
  const mLen = unit === "m" ? len : len / FT_PER_METER;
  let alternateDisplay;
  if (unit === "m") {
    alternateDisplay = `(${ftLen.toFixed(2)} ft)`;
  } else {
    alternateDisplay = `(${mLen.toFixed(2)} m)`;
  }
  document.getElementById("liveInputs").innerText =
    `${f} MHz â€¢ ${len.toFixed(2)} ${unit} ${alternateDisplay}`;
  lastUnit = unit;
  const results = cables.map(c=>{
    const per100 = calcAttenPer100ft(f, c.a, c.b);
    const total = per100 * (ftLen / 100);
    const pass = powerPassPercent(total);
    const loss = 100 - pass;
    return {
    name: c.name,
    total: Number(total.toFixed(6)),
    pass: pass,
    loss: loss
    };
  });
  results.sort((x,y)=> x.total - y.total);
  let html =
    "<table><thead><tr>" +
    "<th>ç·šæ</th>" +
    "<th>è¡°æ¸› (dB)</th>" +
    "<th>é€šéåŠŸç‡ (%)</th>" +
    "<th>è¡°æ¸›åŠŸç‡ (%)</th>" +
    "</tr></thead><tbody>";
  results.forEach(r=>{
    html += `
    <tr>
      <td class="name">${r.name}</td>
      <td class="value">${r.total.toFixed(3)}</td>
      <td class="percent">${r.pass.toFixed(1)}</td>
      <td class="percent">${r.loss.toFixed(1)}</td>
    </tr>`;
  });
  html += "</tbody></table>";
  document.getElementById("tableArea").innerHTML = html;
  }
  function clearRfInput(id) {
  document.getElementById(id).value = '';
  compute();
  }
  function resetRf(){
  document.getElementById("freq").value = 900;
  document.getElementById("lenInput").value = 10;
  document.getElementById("unit").value = "m";
  lastUnit = 'm';
  compute();
  }
  function clearRf(){
  document.getElementById("freq").value = "";
  document.getElementById("lenInput").value = "";
  document.getElementById("unit").value = "m";
  compute();
  }
  const R_KM = 6371;
  const tRad = a => a * (Math.PI / 180);
  const tDeg = r => r * (180 / Math.PI);
  const dToDMS = (id) => {
  const ddInput = document.getElementById(id);
  const dd = parseFloat(ddInput.value);
  if (isNaN(dd) || ddInput.value.trim() === '') {
    ['deg', 'min', 'sec'].forEach(s => document.getElementById(id + '_' + s).value = '');
    return;
  }
  const absDD = Math.abs(dd);
  const deg = Math.floor(absDD);
  let minFloat = (absDD - deg) * 60;
  const min = Math.floor(minFloat);
  let sec = (minFloat - min) * 60;
  sec = Number(sec.toFixed(2));
  let finalMin = min;
  let finalSec = sec;
  let finalDeg = deg;
  if (finalSec >= 60) {
    finalMin += Math.floor(finalSec / 60);
    finalSec = finalSec % 60;
    finalSec = Number(finalSec.toFixed(2));
  }
  if (finalMin >= 60) {
    finalDeg += Math.floor(finalMin / 60);
    finalMin = finalMin % 60;
  }
  document.getElementById(id + '_deg').value = (dd < 0 ? -finalDeg : finalDeg);
  document.getElementById(id + '_min').value = finalMin;
  document.getElementById(id + '_sec').value = finalSec.toFixed(2);
  };
  const dmsToD = (id, skipCalculate) => {
  const d = parseFloat(document.getElementById(id + '_deg').value);
  const m = parseFloat(document.getElementById(id + '_min').value) || 0;
  const s = parseFloat(document.getElementById(id + '_sec').value) || 0;
  if (isNaN(d) && !m && !s) { document.getElementById(id).value = ''; if (!skipCalculate) calculate(); return; }
  const sign = (d < 0) ? -1 : 1;
  const dd = sign * (Math.abs(d) + Math.abs(m) / 60 + Math.abs(s) / 3600);
  if (!isNaN(dd)) {
    document.getElementById(id).value = dd.toFixed(6);

    // ğŸ¯ è§¸ç™¼éŸ¿æ‡‰å¼æ•¸æ“šæ›´æ–°
    const point = id.includes('A') ? 'A' : 'B';
    const property = id.includes('lat') ? 'lat' : 'lng';
    updateFromInput(point, property);
    if (!skipCalculate) calculate();
  } else {
    document.getElementById(id).value = '';
    if (!skipCalculate) calculate();
  }
  };
  const clearCoord = (idPrefix) => {
  document.getElementById(idPrefix).value = '';
  ['deg', 'min', 'sec'].forEach(s => document.getElementById(idPrefix + '_' + s).value = '');
  calculate();
  };
  const clearElevation = (suffix) => {
  document.getElementById('ele' + suffix).value = '';
  calculate();
  };
  const clearNameOnly = (suffix) => {
  // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“š
  coordinateData[suffix].name = '';
  };
  const clearAllCoord = (suffix) => {
  // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“šï¼ˆæœƒè‡ªå‹•åŒæ­¥åˆ°æ‰€æœ‰è¦–åœ–ï¼‰
  coordinateData[suffix].lat = null;
  coordinateData[suffix].lng = null;
  coordinateData[suffix].ele = null;
  coordinateData[suffix].name = '';

  // æ‰‹å‹•æ¸…é™¤DMSæ¬„ä½
  const latPrefix = 'lat' + suffix;
  const lonPrefix = 'lon' + suffix;
  ['deg', 'min', 'sec'].forEach(s => {
    const elem = document.getElementById(latPrefix + '_' + s);
    if (elem) elem.value = '';
  });
  ['deg', 'min', 'sec'].forEach(s => {
    const elem = document.getElementById(lonPrefix + '_' + s);
    if (elem) elem.value = '';
  });

  calculate();
  };
  const resetGps = () => {
  // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“šï¼ˆæœƒè‡ªå‹•åŒæ­¥åˆ°æ‰€æœ‰è¦–åœ–ï¼‰
  coordinateData.A.lat = 24.164547;
  coordinateData.A.lng = 120.641258;
  coordinateData.A.ele = 50;
  coordinateData.A.name = 'åŒ—ä¸ƒè·¯';
  coordinateData.B.lat = 23.877521;
  coordinateData.B.lng = 120.360578;
  coordinateData.B.ele = 2000;
  coordinateData.B.name = 'ç«ç‡’å';

  const mode = document.getElementById('displayMode').value;
  if (mode === 'dms') {
    dToDMS('latA'); dToDMS('lonA'); dToDMS('latB'); dToDMS('lonB');
  }

  calculate();
  };
  const swapGpsCoordinates = () => {
  // ç›´æ¥å¾ DOM è¼¸å…¥æ¡†è®€å–ç•¶å‰å€¼ï¼ˆå«ç”¨æˆ¶æ‰‹å‹•è¼¸å…¥çš„é«˜åº¦ï¼‰
  const tempA = {
    lat: document.getElementById('latA').value,
    lng: document.getElementById('lonA').value,
    ele: document.getElementById('eleA').value,
    name: document.getElementById('nameA').value
  };
  const tempB = {
    lat: document.getElementById('latB').value,
    lng: document.getElementById('lonB').value,
    ele: document.getElementById('eleB').value,
    name: document.getElementById('nameB').value
  };

  // å¯«å› DOM
  document.getElementById('latA').value = tempB.lat;
  document.getElementById('lonA').value = tempB.lng;
  document.getElementById('eleA').value = tempB.ele;
  document.getElementById('nameA').value = tempB.name;

  document.getElementById('latB').value = tempA.lat;
  document.getElementById('lonB').value = tempA.lng;
  document.getElementById('eleB').value = tempA.ele;
  document.getElementById('nameB').value = tempA.name;

  // åŒæ­¥æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“š
  coordinateData.A.lat = parseFloat(tempB.lat) || null;
  coordinateData.A.lng = parseFloat(tempB.lng) || null;
  coordinateData.A.ele = parseFloat(tempB.ele) || null;
  coordinateData.A.name = tempB.name;
  coordinateData.B.lat = parseFloat(tempA.lat) || null;
  coordinateData.B.lng = parseFloat(tempA.lng) || null;
  coordinateData.B.ele = parseFloat(tempA.ele) || null;
  coordinateData.B.name = tempA.name;

  const mode = document.getElementById('displayMode').value;
  if (mode === 'dms') {
    dToDMS('latA');
    dToDMS('lonA');
    dToDMS('latB');
    dToDMS('lonB');
  }
  calculate();
  };
  const clearAllGps = () => {
  clearAllCoord('A');
  clearAllCoord('B');
  document.getElementById('gpsRes').innerHTML = "è¨ˆç®—ä¸­...";
  document.getElementById('gpsRes').classList.remove('gps-error');
  calculate();
  };
  const hDist = (lat1, lon1, lat2, lon2) => {
  const [rLat1, rLat2, dLat, dLon] = [tRad(lat1), tRad(lat2), tRad(lat2 - lat1), tRad(lon2 - lon1)];
  const a = Math.sin(dLat / 2)**2 + Math.cos(rLat1) * Math.cos(rLat2) * Math.sin(dLon / 2)**2;
  return R_KM * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  };
  const straightDist = (hD, eleA, eleB) => {
  const dH = (eleB - eleA) / 1000;
  return Math.sqrt(hD * hD + dH * dH);
  };
  const getBearing = (lat1, lon1, lat2, lon2) => {
  const [rL1, rL2, dLon] = [tRad(lat1), tRad(lat2), tRad(lon2 - lon1)];
  const y = Math.sin(dLon) * Math.cos(rL2);
  const x = Math.cos(rL1) * Math.sin(rL2) - Math.sin(rL1) * Math.cos(rL2) * Math.cos(dLon);
  return (tDeg(Math.atan2(y, x)) + 360) % 360;
  };
  const getPitch = (distKm, eleA, eleB) => {
  if (distKm === 0) return { pitchAB: 0, pitchBA: 0 };
  const [hA, hB] = [eleA / 1000, eleB / 1000];
  const offset = distKm**2 / (2 * R_KM);
  const H_AB = (hB - hA) - offset;
  const pitchAB = tDeg(Math.atan2(H_AB, distKm));
  const H_BA = (hA - hB) - offset;
  const pitchBA = tDeg(Math.atan2(H_BA, distKm));
  return { pitchAB, pitchBA };
  };
function showLoadingWithDots(elementId, message, eleInput = null) {
  if (eleInput) {
    const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
    const loadingSpan = document.getElementById(loadingId);
    if (loadingSpan) {
      loadingSpan.innerHTML = `${message}<span class="loading-dots"></span>`;
      loadingSpan.style.display = 'inline';
      eleInput.style.opacity = '0.5';
    }
  } else {
    const element = document.getElementById(elementId);
    element.innerHTML = `<span style="color:#ffd43b; font-weight:bold;">${message}<span class="loading-dots"></span></span>`;
    element.style.color = '#ffd43b';
    element.style.background = 'rgba(255, 215, 0, 0.1)';
  }
}
function getCurrentLocation(location) {
  if (!navigator.geolocation) {
    alert('âŒ æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´åœ°ç†å®šä½åŠŸèƒ½');
    return;
  }
  const latId = location === 'A' ? 'latA' : 'latB';
  const lonId = location === 'A' ? 'lonA' : 'lonB';
  const nameId = location === 'A' ? 'nameA' : 'nameB';
  const eleId = location === 'A' ? 'eleA' : 'eleB';
  const latInput = document.getElementById(latId);
  const lonInput = document.getElementById(lonId);
  const nameInput = document.getElementById(nameId);
  const eleInput = document.getElementById(eleId);
  const originalLatValue = latInput.value;
  const originalLonValue = lonInput.value;
  const originalNameValue = nameInput.value;
  const originalEleValue = eleInput.value;
  latInput.value = 'å®šä½ä¸­...';
  lonInput.value = 'å®šä½ä¸­...';
  nameInput.value = 'å–å¾—ä¸­...';
  eleInput.value = 'å–å¾—ä¸­...';
  latInput.disabled = true;
  lonInput.disabled = true;
  nameInput.disabled = true;
  eleInput.disabled = true;
  navigator.geolocation.getCurrentPosition(
    function(position) {
      const latitude = position.coords.latitude;
      const longitude = position.coords.longitude;

      // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“šï¼ˆæœƒè‡ªå‹•åŒæ­¥åˆ°æ‰€æœ‰è¦–åœ–ï¼‰
      coordinateData[location].lat = parseFloat(latitude.toFixed(6));
      coordinateData[location].lng = parseFloat(longitude.toFixed(6));
      calculate();

      latInput.disabled = false;
      lonInput.disabled = false;
      nameInput.disabled = false;
      eleInput.disabled = false;

      getLocationNameAndShowDialog(latitude, longitude, location, nameId, eleId);
    },
    function(error) {
      latInput.value = originalLatValue;
      lonInput.value = originalLonValue;
      nameInput.value = originalNameValue;
      eleInput.value = originalEleValue;
      latInput.disabled = false;
      lonInput.disabled = false;
      nameInput.disabled = false;
      eleInput.disabled = false;
      let errorMessage = 'âŒ ç„¡æ³•ç²å–ä½ç½®: ';
      switch(error.code) {
        case error.PERMISSION_DENIED:
          errorMessage += 'ä½¿ç”¨è€…æ‹’çµ•äº†åœ°ç†å®šä½è«‹æ±‚';
          break;
        case error.POSITION_UNAVAILABLE:
          errorMessage += 'ä½ç½®è³‡è¨Šä¸å¯ç”¨';
          break;
        case error.TIMEOUT:
          errorMessage += 'è«‹æ±‚è¶…æ™‚';
          break;
        default:
          errorMessage += 'æœªçŸ¥éŒ¯èª¤';
          break;
      }
      alert(errorMessage);
    },
    {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    }
  );
}
function openMapPicker(location) {

  // è™•ç†æŒ‡åŒ—é‡çš„ç‰¹æ®Šæƒ…æ³
  let currentLat, currentLon;
  if (location === 'COMPASS') {
    currentLat = window.tempCompassLat || 25.0336;
    currentLon = window.tempCompassLng || 121.5648;
  } else {
    const latId = location === 'A' ? 'latA' : 'latB';
    const lonId = location === 'A' ? 'lonA' : 'lonB';
    currentLat = document.getElementById(latId).value || 25.0336;
    currentLon = document.getElementById(lonId).value || 121.5648;
  }

  var mapPickerHTML = '<!DOCTYPE html><html><head><meta charset="utf-8">';
  mapPickerHTML += '<meta name="viewport" content="width=device-width, initial-scale=1">';
  mapPickerHTML += '<title>é¸æ“‡åœ°é» ' + (location === 'COMPASS' ? 'æŒ‡åŒ—é‡ä½ç½®' : location) + ' çš„åº§æ¨™</title>';
  mapPickerHTML += '<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />';
  mapPickerHTML += '<style>* { margin: 0; padding: 0; box-sizing: border-box; }';
  mapPickerHTML += 'body { font-family: Arial, sans-serif; overflow: hidden; }';
  mapPickerHTML += '#map { width: 100vw; height: calc(100vh - 130px); position: absolute; top: 130px; }';
  mapPickerHTML += '#info-bar { position: fixed; top: 0; left: 0; right: 0; height: 60px;';
  mapPickerHTML += 'background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: white;';
  mapPickerHTML += 'display: flex; align-items: center; justify-content: space-between;';
  mapPickerHTML += 'padding: 0 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 1000; }';
  mapPickerHTML += '#search-bar { position: fixed; top: 60px; left: 0; right: 0; height: 70px;';
  mapPickerHTML += 'background: #f8f9fa; display: flex; flex-direction: column; gap: 6px;';
  mapPickerHTML += 'padding: 8px 12px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 1000; }';
  mapPickerHTML += '.search-row { display: flex; gap: 8px; align-items: center; }';
  mapPickerHTML += '#search-input { flex: 1; padding: 8px 12px; border: 2px solid #ddd;';
  mapPickerHTML += 'border-radius: 6px; font-size: 14px; min-width: 0; }';
  mapPickerHTML += '.search-btn { background: linear-gradient(90deg, #ff9500, #ffcc00);';
  mapPickerHTML += 'border: none; padding: 8px 12px; border-radius: 6px; font-weight: bold;';
  mapPickerHTML += 'color: #000; cursor: pointer; font-size: 13px; white-space: nowrap; flex-shrink: 0; }';
  mapPickerHTML += '.layer-btn { background: linear-gradient(90deg, #9b59b6, #8e44ad);';
  mapPickerHTML += 'border: none; padding: 8px 12px; border-radius: 6px; font-weight: bold;';
  mapPickerHTML += 'color: #fff; cursor: pointer; font-size: 13px; white-space: nowrap; flex-shrink: 0; }';
  mapPickerHTML += '#coords { font-size: 12px; font-weight: bold; color: #5ff0d5; }';
  mapPickerHTML += '.btn { background: linear-gradient(90deg, #79a8ff, #5ff0d5); border: none;';
  mapPickerHTML += 'padding: 10px 16px; border-radius: 6px; font-weight: bold; color: #022;';
  mapPickerHTML += 'cursor: pointer; font-size: 14px; }';
  mapPickerHTML += '#instruction { position: fixed; top: 140px; left: 50%; transform: translateX(-50%);';
  mapPickerHTML += 'background: rgba(255, 255, 255, 0.95); padding: 8px 16px; border-radius: 8px;';
  mapPickerHTML += 'box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 1000; font-size: 12px;';
  mapPickerHTML += 'color: #333; font-weight: bold; max-width: 90%; text-align: center; }';
  mapPickerHTML += '#results-panel { position: fixed; top: 140px; right: 10px; width: 320px; max-width: calc(100vw - 20px);';
  mapPickerHTML += 'height: auto; max-height: calc(100vh - 160px); background: white; border-radius: 8px;';
  mapPickerHTML += 'box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 1001; display: none;';
  mapPickerHTML += 'flex-direction: column; }';
  mapPickerHTML += '#results-list { flex: 1; overflow-y: scroll; overflow-x: hidden; -webkit-overflow-scrolling: touch;';
  mapPickerHTML += 'min-height: 100px; max-height: calc(100vh - 220px); padding-bottom: 80px; }';
  mapPickerHTML += '.results-header { padding: 12px 15px; background: linear-gradient(90deg, #ff9500, #ffcc00);';
  mapPickerHTML += 'color: #000; font-weight: bold; font-size: 14px; display: flex;';
  mapPickerHTML += 'justify-content: space-between; align-items: center; border-radius: 8px 8px 0 0;';
  mapPickerHTML += 'flex-shrink: 0; }';
  mapPickerHTML += '.close-results { background: none; border: none; font-size: 20px; cursor: pointer;';
  mapPickerHTML += 'color: #000; padding: 0; width: 24px; height: 24px; }';
  mapPickerHTML += '.result-item { padding: 12px 15px; border-bottom: 1px solid #eee;';
  mapPickerHTML += 'cursor: pointer; transition: background 0.2s; touch-action: manipulation; }';
  mapPickerHTML += '.result-item:hover { background: #f0f8ff; }';
  mapPickerHTML += '.result-item:active { background: #d0e8ff; }';
  mapPickerHTML += '.result-item:last-child { border-bottom: none; padding-bottom: 20px; }';
  mapPickerHTML += '.result-name { font-weight: bold; color: #333; margin-bottom: 4px; font-size: 14px; }';
  mapPickerHTML += '.result-address { font-size: 12px; color: #666; line-height: 1.4; }';
  mapPickerHTML += '.no-results { padding: 20px; text-align: center; color: #999; margin-bottom: 60px; }';
  mapPickerHTML += '.leaflet-control-attribution { font-size: 10px; }</style></head><body>';
  mapPickerHTML += '<div id="info-bar"><div style="flex:1; min-width:0;">';
  mapPickerHTML += '<div style="font-size:15px; font-weight:bold; margin-bottom:2px;">' + (location === 'COMPASS' ? 'æŒ‡åŒ—é‡ä½ç½®' : 'åœ°é» ' + location) + '</div>';
  mapPickerHTML += '<div id="coords">ç·¯åº¦: -- | ç¶“åº¦: --</div>';
  mapPickerHTML += '<div id="elevation" style="color:#ffd43b; font-size:12px; margin-top:2px;">é«˜åº¦: -- m</div></div>';
  mapPickerHTML += '<button class="btn" onclick="confirmSelection()">âœ“ ç¢ºèª</button></div>';
  mapPickerHTML += '<div id="search-bar">';
  mapPickerHTML += '<div class="search-row">';
  mapPickerHTML += '<input type="text" id="search-input" placeholder="è¼¸å…¥åœ°å€æˆ–åœ°åï¼ˆä¾‹å¦‚ï¼šç«è»Šç«™ã€101ï¼‰">';
  mapPickerHTML += '<button class="search-btn" onclick="searchLocation()">ğŸ”</button></div>';
  mapPickerHTML += '<div class="search-row">';
  mapPickerHTML += '<button class="layer-btn" onclick="toggleLayer()" id="layer-toggle" style="flex:1;">ğŸ›©ï¸ èˆªç…§åœ–</button></div></div>';
  mapPickerHTML += '<div id="instruction">ğŸ‘† é»æ“Šåœ°åœ–æˆ–æœå°‹åœ°å€</div>';
  mapPickerHTML += '<div id="results-panel">';
  mapPickerHTML += '<div class="results-header">æœå°‹çµæœ <button class="close-results" onclick="closeResults()">Ã—</button></div>';
  mapPickerHTML += '<div id="results-list"></div></div>';
  mapPickerHTML += '<div id="map"></div>';
  mapPickerHTML += '<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"><\/script>';
  mapPickerHTML += '<script>';
  mapPickerHTML += 'var map, marker, currentLayer; var selectedLat = ' + currentLat + ', selectedLng = ' + currentLon + ', selectedName = null, selectedElevation = null;';
  mapPickerHTML += 'var center = [' + currentLat + ', ' + currentLon + '];';
  mapPickerHTML += 'map = L.map("map").setView(center, 15);';
  mapPickerHTML += 'document.getElementById("coords").innerHTML = "ç·¯åº¦: " + selectedLat.toFixed(6) + " | ç¶“åº¦: " + selectedLng.toFixed(6);';
  mapPickerHTML += 'fetchElevation(selectedLat, selectedLng);';
  mapPickerHTML += 'marker = L.marker([selectedLat, selectedLng]).addTo(map);';
  mapPickerHTML += 'document.getElementById("instruction").style.display = "none";';
  mapPickerHTML += 'var streetLayer = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {';
  mapPickerHTML += 'attribution: "Â© OpenStreetMap", maxZoom: 19 });';
  mapPickerHTML += 'var satelliteLayer = L.tileLayer("http://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", {';
  mapPickerHTML += 'attribution: "Â© Google Maps", maxZoom: 20, subdomains: ["0", "1", "2", "3"] });';
  mapPickerHTML += 'var earthLayer = L.tileLayer("http://mt{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}", {';
  mapPickerHTML += 'attribution: "Â© Google Earth", maxZoom: 20, subdomains: ["0", "1", "2", "3"] });';
  mapPickerHTML += 'var hybridLayer = L.layerGroup([';
  mapPickerHTML += 'L.tileLayer("http://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", {';
  mapPickerHTML += 'attribution: "Â© Google Maps", maxZoom: 20, subdomains: ["0", "1", "2", "3"] }),';
  mapPickerHTML += 'L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {';
  mapPickerHTML += 'opacity: 0.3, maxZoom: 19 })';
  mapPickerHTML += ']);';
  mapPickerHTML += 'var nlscLayer = L.tileLayer("https://wmts.nlsc.gov.tw/wmts/PHOTO2/default/GoogleMapsCompatible/{z}/{y}/{x}", {';
  mapPickerHTML += 'attribution: "Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ", maxZoom: 19 });';
  mapPickerHTML += 'currentLayer = "nlsc"; nlscLayer.addTo(map);';
  mapPickerHTML += 'document.getElementById("layer-toggle").innerHTML = "ğŸ›©ï¸ èˆªç…§åœ–";';
  mapPickerHTML += 'function toggleLayer() {';
  mapPickerHTML += 'var btn = document.getElementById("layer-toggle");';
  mapPickerHTML += 'if (currentLayer === "nlsc") {';
  mapPickerHTML += 'map.removeLayer(nlscLayer); streetLayer.addTo(map);';
  mapPickerHTML += 'currentLayer = "street"; btn.innerHTML = "ğŸ—ºï¸ è¡—é“åœ–";';
  mapPickerHTML += '} else if (currentLayer === "street") {';
  mapPickerHTML += 'map.removeLayer(streetLayer); satelliteLayer.addTo(map);';
  mapPickerHTML += 'currentLayer = "satellite"; btn.innerHTML = "ğŸ›°ï¸ è¡›æ˜Ÿåœ–";';
  mapPickerHTML += '} else if (currentLayer === "satellite") {';
  mapPickerHTML += 'map.removeLayer(satelliteLayer); earthLayer.addTo(map);';
  mapPickerHTML += 'currentLayer = "earth"; btn.innerHTML = "ğŸŒ åœ°å½¢åœ–";';
  mapPickerHTML += '} else if (currentLayer === "earth") {';
  mapPickerHTML += 'map.removeLayer(earthLayer); hybridLayer.addTo(map);';
  mapPickerHTML += 'currentLayer = "hybrid"; btn.innerHTML = "ğŸ”€ æ··åˆåœ–";';
  mapPickerHTML += '} else {';
  mapPickerHTML += 'map.removeLayer(hybridLayer); nlscLayer.addTo(map);';
  mapPickerHTML += 'currentLayer = "nlsc"; btn.innerHTML = "ğŸ›©ï¸ èˆªç…§åœ–";';
  mapPickerHTML += '} }';
  mapPickerHTML += 'map.on("click", function(e) {';
  mapPickerHTML += 'selectedLat = e.latlng.lat; selectedLng = e.latlng.lng; selectedName = null; selectedElevation = null;';
  mapPickerHTML += 'document.getElementById("coords").innerHTML = "ç·¯åº¦: " + selectedLat.toFixed(6) + " | ç¶“åº¦: " + selectedLng.toFixed(6);';
  mapPickerHTML += 'document.getElementById("elevation").innerHTML = "é«˜åº¦: <span style=\\"color:#ffd43b;\\">æŸ¥è©¢ä¸­...</span>";';
  mapPickerHTML += 'fetchElevation(selectedLat, selectedLng);';
  mapPickerHTML += 'if (marker) { map.removeLayer(marker); }';
  mapPickerHTML += 'marker = L.marker([selectedLat, selectedLng]).addTo(map);';
  mapPickerHTML += 'document.getElementById("instruction").style.display = "none"; });';
  mapPickerHTML += 'function searchLocation() {';
  mapPickerHTML += 'var query = document.getElementById("search-input").value.trim();';
  mapPickerHTML += 'if (!query) { alert("è«‹è¼¸å…¥åœ°å€æˆ–åœ°å"); return; }';
  mapPickerHTML += 'document.getElementById("instruction").style.display = "none";';
  mapPickerHTML += 'document.getElementById("results-list").innerHTML = "<div class=\\"no-results\\">ğŸ” æ™ºèƒ½æœå°‹ä¸­...<br><small>æ­£åœ¨ä½¿ç”¨å¤šå€‹è³‡æ–™ä¾†æº</small></div>";';
  mapPickerHTML += 'document.getElementById("results-panel").style.display = "flex";';
  mapPickerHTML += 'var allResults = [];';
  mapPickerHTML += 'var searchPromises = [];';
  mapPickerHTML += 'var isCommonPlace = /ç«è»Šç«™|è»Šç«™|æ©Ÿå ´|æ¸¯å£|ç¢¼é ­|é†«é™¢|å¤§å­¸|å…¬åœ’|å¤œå¸‚|è€è¡—/i.test(query);';
  mapPickerHTML += 'var limitPerQuery = isCommonPlace ? 10 : 5;';
  mapPickerHTML += 'var isTaiwanAddress = /[ç¸£å¸‚å€é„‰é®æ‘é‡Œè·¯è¡—æ®µå··å¼„è™Ÿ]/i.test(query);';
  mapPickerHTML += 'function cleanAddress(addr) {';
  mapPickerHTML += '  return addr.replace(/ç¬¬?\\d+é„°/g, "").replace(/[\\s]+/g, " ").trim();';
  mapPickerHTML += '}';
  mapPickerHTML += 'function generateAddressVariations(addr) {';
  mapPickerHTML += '  var variations = [addr];';
  mapPickerHTML += '  var cleaned = cleanAddress(addr);';
  mapPickerHTML += '  if (cleaned !== addr) variations.push(cleaned);';
  mapPickerHTML += '  var withoutHao = addr.replace(/è™Ÿ$/g, "");';
  mapPickerHTML += '  if (withoutHao !== addr) {';
  mapPickerHTML += '    variations.push(withoutHao);';
  mapPickerHTML += '    variations.push(cleanAddress(withoutHao));';
  mapPickerHTML += '  }';
  mapPickerHTML += '  var withHao = addr.match(/\\d+$/) ? addr + "è™Ÿ" : addr;';
  mapPickerHTML += '  if (withHao !== addr) {';
  mapPickerHTML += '    variations.push(withHao);';
  mapPickerHTML += '    variations.push(cleanAddress(withHao));';
  mapPickerHTML += '  }';
  mapPickerHTML += '  var normalized1 = addr.replace(/å°/g, "è‡º");';
  mapPickerHTML += '  var normalized2 = addr.replace(/è‡º/g, "å°");';
  mapPickerHTML += '  if (normalized1 !== addr) {';
  mapPickerHTML += '    variations.push(normalized1);';
  mapPickerHTML += '    variations.push(normalized1.replace(/è™Ÿ$/g, ""));';
  mapPickerHTML += '  }';
  mapPickerHTML += '  if (normalized2 !== addr) {';
  mapPickerHTML += '    variations.push(normalized2);';
  mapPickerHTML += '    variations.push(normalized2.replace(/è™Ÿ$/g, ""));';
  mapPickerHTML += '  }';
  mapPickerHTML += '  var cityMatch = addr.match(/^(.+?[ç¸£å¸‚])(.+)$/);';
  mapPickerHTML += '  if (cityMatch) {';
  mapPickerHTML += '    var remainder = cityMatch[2].trim();';
  mapPickerHTML += '    variations.push(remainder);';
  mapPickerHTML += '    variations.push(remainder.replace(/è™Ÿ$/g, ""));';
  mapPickerHTML += '    var districtMatch = cityMatch[2].match(/^(.+?[å€é„‰é®å¸‚])(.+)$/);';
  mapPickerHTML += '    if (districtMatch) {';
  mapPickerHTML += '      var street = districtMatch[2].trim();';
  mapPickerHTML += '      variations.push(cityMatch[1] + " " + districtMatch[1] + " " + street);';
  mapPickerHTML += '      variations.push(districtMatch[1] + " " + street);';
  mapPickerHTML += '      variations.push(street);';
  mapPickerHTML += '      variations.push(street.replace(/è™Ÿ$/g, ""));';
  mapPickerHTML += '      var streetOnly = districtMatch[2].match(/^([^0-9]+)/);';
  mapPickerHTML += '      if (streetOnly) {';
  mapPickerHTML += '        variations.push(streetOnly[1].trim());';
  mapPickerHTML += '        variations.push(streetOnly[1].trim().replace(/è™Ÿ$/g, ""));';
  mapPickerHTML += '      }';
  mapPickerHTML += '    }';
  mapPickerHTML += '  }';
  mapPickerHTML += '  var noNumbers = addr.replace(/\\d+è™Ÿ?/g, "").replace(/ç¬¬?\\d+é„°/g, "").trim();';
  mapPickerHTML += '  if (noNumbers !== addr && noNumbers.length > 3) variations.push(noNumbers);';
  mapPickerHTML += '  return [...new Set(variations)];';
  mapPickerHTML += '}';
  mapPickerHTML += 'var taiwanQueries = [];';
  mapPickerHTML += 'if (isTaiwanAddress) {';
  mapPickerHTML += '  taiwanQueries = generateAddressVariations(query);';
  mapPickerHTML += '} else {';
  mapPickerHTML += '  taiwanQueries = [query + ", å°ç£", query + ", Taiwan", query];';
  mapPickerHTML += '}';
  mapPickerHTML += 'taiwanQueries.slice(0, 3).forEach(function(searchQuery) {';
  mapPickerHTML += 'searchPromises.push(';
  mapPickerHTML += 'fetch("https://nominatim.openstreetmap.org/search?format=json&q=" + encodeURIComponent(searchQuery) + "&countrycodes=tw&limit=" + limitPerQuery + "&addressdetails=1&accept-language=zh-TW")';
  mapPickerHTML += '.then(r => r.json()).then(data => data.map(item => ({...item, source: "OSM"})))';
  mapPickerHTML += '.catch(e => [])';
  mapPickerHTML += '); });';
  mapPickerHTML += 'searchPromises.push(';
  mapPickerHTML += 'fetch("https://photon.komoot.io/api/?q=" + encodeURIComponent(query + " taiwan") + "&limit=" + (limitPerQuery * 2) + "&lang=zh")';
  mapPickerHTML += '.then(r => r.json()).then(data => {';
  mapPickerHTML += 'if (data.features) {';
  mapPickerHTML += 'return data.features.map(f => ({';
  mapPickerHTML += 'lat: f.geometry.coordinates[1],';
  mapPickerHTML += 'lon: f.geometry.coordinates[0],';
  mapPickerHTML += 'display_name: f.properties.name + (f.properties.city ? ", " + f.properties.city : "") + (f.properties.country ? ", " + f.properties.country : ""),';
  mapPickerHTML += 'type: f.properties.type || "place",';
  mapPickerHTML += 'source: "Photon"';
  mapPickerHTML += '})); }';
  mapPickerHTML += 'return []; }).catch(e => [])';
  mapPickerHTML += ');';
  mapPickerHTML += 'searchPromises.push(';
  mapPickerHTML += 'fetch("https://api.locationiq.com/v1/autocomplete.php?key=pk.0f147952a41c555a5b70614039fd148b&q=" + encodeURIComponent(query) + "&countrycodes=tw&limit=" + limitPerQuery + "&format=json&accept-language=zh")';
  mapPickerHTML += '.then(r => r.json()).then(data => data.map(item => ({...item, source: "LocationIQ"})))';
  mapPickerHTML += '.catch(e => [])';
  mapPickerHTML += ');';
  mapPickerHTML += 'if (isTaiwanAddress) {';
  mapPickerHTML += '  var addressVariations = generateAddressVariations(query);';
  mapPickerHTML += '  addressVariations.slice(0, 5).forEach(function(addr) {';
  mapPickerHTML += '    searchPromises.push(';
  mapPickerHTML += '      fetch("https://nominatim.openstreetmap.org/search?format=json&q=" + encodeURIComponent(addr) + "&countrycodes=tw&limit=8&addressdetails=1&accept-language=zh-TW")';
  mapPickerHTML += '      .then(r => r.json()).then(data => data.map(item => ({...item, source: "OSM-Address", searchVariant: addr})))';
  mapPickerHTML += '      .catch(e => [])';
  mapPickerHTML += '    );';
  mapPickerHTML += '  });';
  mapPickerHTML += '  var mainAddr = cleanAddress(query);';
  mapPickerHTML += '  searchPromises.push(';
  mapPickerHTML += '    fetch("https://nominatim.openstreetmap.org/search?format=json&street=" + encodeURIComponent(mainAddr) + "&country=taiwan&limit=10&addressdetails=1")';
  mapPickerHTML += '    .then(r => r.json()).then(data => data.map(item => ({...item, source: "OSM-Street"})))';
  mapPickerHTML += '    .catch(e => [])';
  mapPickerHTML += '  );';
  mapPickerHTML += '  var geocodeQueries = [query, mainAddr, query.replace(/å°/g, "è‡º"), query.replace(/è‡º/g, "å°")];';
  mapPickerHTML += '  geocodeQueries.slice(0, 2).forEach(function(geoQuery) {';
  mapPickerHTML += '    searchPromises.push(';
  mapPickerHTML += '      fetch("https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates?f=json&outFields=*&maxLocations=5&address=" + encodeURIComponent(geoQuery) + "&countryCode=TWN")';
  mapPickerHTML += '      .then(r => r.json()).then(data => {';
  mapPickerHTML += '        if (data.candidates && data.candidates.length > 0) {';
  mapPickerHTML += '          return data.candidates.map(c => ({';
  mapPickerHTML += '            lat: c.location.y,';
  mapPickerHTML += '            lon: c.location.x,';
  mapPickerHTML += '            display_name: c.address || geoQuery,';
  mapPickerHTML += '            type: "address",';
  mapPickerHTML += '            source: "ArcGIS",';
  mapPickerHTML += '            score: c.score || 0';
  mapPickerHTML += '          }));';
  mapPickerHTML += '        }';
  mapPickerHTML += '        return [];';
  mapPickerHTML += '      }).catch(e => [])';
  mapPickerHTML += '    );';
  mapPickerHTML += '  });';
  mapPickerHTML += '  searchPromises.push(';
  mapPickerHTML += '    fetch("https://api.nlsc.gov.tw/other/TownVillagePointQuery/" + encodeURIComponent(mainAddr) + "/4326/JSON")';
  mapPickerHTML += '    .then(r => r.json()).then(data => {';
  mapPickerHTML += '      if (data && Array.isArray(data) && data.length > 0) {';
  mapPickerHTML += '        return data.map(item => ({';
  mapPickerHTML += '          lat: parseFloat(item.y || item.Y),';
  mapPickerHTML += '          lon: parseFloat(item.x || item.X),';
  mapPickerHTML += '          display_name: query,';
  mapPickerHTML += '          type: "address",';
  mapPickerHTML += '          source: "NLSC-TW"';
  mapPickerHTML += '        }));';
  mapPickerHTML += '      }';
  mapPickerHTML += '      return [];';
  mapPickerHTML += '    }).catch(e => [])';
  mapPickerHTML += '  );';
  mapPickerHTML += '}';
  mapPickerHTML += 'Promise.all(searchPromises).then(function(results) {';
  mapPickerHTML += 'results.forEach(function(data) {';
  mapPickerHTML += 'if (data && Array.isArray(data)) {';
  mapPickerHTML += 'data.forEach(function(item) {';
  mapPickerHTML += 'if (!item.lat || !item.lon) return;';
  mapPickerHTML += 'var itemLat = parseFloat(item.lat);';
  mapPickerHTML += 'var itemLon = parseFloat(item.lon);';
  mapPickerHTML += 'if (isNaN(itemLat) || isNaN(itemLon)) return;';
  mapPickerHTML += 'var isDuplicate = allResults.some(function(existing) {';
  mapPickerHTML += 'return Math.abs(existing.lat - itemLat) < 0.0005 && Math.abs(existing.lon - itemLon) < 0.0005; });';
  mapPickerHTML += 'if (!isDuplicate) {';
  mapPickerHTML += 'allResults.push({';
  mapPickerHTML += 'lat: itemLat,';
  mapPickerHTML += 'lon: itemLon,';
  mapPickerHTML += 'display_name: item.display_name || item.name || "æœªçŸ¥åœ°é»",';
  mapPickerHTML += 'type: item.type || item.osm_type || "place",';
  mapPickerHTML += 'source: item.source || "Unknown"';
  mapPickerHTML += '}); }';
  mapPickerHTML += '}); }});';
  mapPickerHTML += 'allResults.sort(function(a, b) {';
  mapPickerHTML += 'var aScore = 0, bScore = 0;';
  mapPickerHTML += 'var queryLower = query.toLowerCase().trim();';
  mapPickerHTML += 'var aName = (a.name || a.display_name.split(",")[0]).toLowerCase().trim();';
  mapPickerHTML += 'var bName = (b.name || b.display_name.split(",")[0]).toLowerCase().trim();';
  mapPickerHTML += 'var aFullName = a.display_name.toLowerCase().trim();';
  mapPickerHTML += 'var bFullName = b.display_name.toLowerCase().trim();';
  mapPickerHTML += 'if (isTaiwanAddress) {';
  mapPickerHTML += '  if (a.source === "ArcGIS" && a.score > 90) aScore += 3500;';
  mapPickerHTML += '  if (b.source === "ArcGIS" && b.score > 90) bScore += 3500;';
  mapPickerHTML += '  if (a.source === "ArcGIS") aScore += 3000;';
  mapPickerHTML += '  if (b.source === "ArcGIS") bScore += 3000;';
  mapPickerHTML += '  if (a.source === "NLSC-TW") aScore += 2800;';
  mapPickerHTML += '  if (b.source === "NLSC-TW") bScore += 2800;';
  mapPickerHTML += '  if ((a.type === "house" || a.type === "building" || a.type === "address") && aFullName.includes(queryLower)) aScore += 2000;';
  mapPickerHTML += '  if ((b.type === "house" || b.type === "building" || b.type === "address") && bFullName.includes(queryLower)) bScore += 2000;';
  mapPickerHTML += '  if (a.source === "OSM-Street") aScore += 1800;';
  mapPickerHTML += '  if (b.source === "OSM-Street") bScore += 1800;';
  mapPickerHTML += '  if (a.source === "OSM-Address") aScore += 1500;';
  mapPickerHTML += '  if (b.source === "OSM-Address") bScore += 1500;';
  mapPickerHTML += '  if (a.searchVariant && a.searchVariant.length < query.length) aScore += 500;';
  mapPickerHTML += '  if (b.searchVariant && b.searchVariant.length < query.length) bScore += 500;';
  mapPickerHTML += '}';
  mapPickerHTML += 'if (aName === queryLower || aFullName === queryLower) aScore += 1000;';
  mapPickerHTML += 'if (bName === queryLower || bFullName === queryLower) bScore += 1000;';
  mapPickerHTML += 'if (aName.indexOf(queryLower) === 0 && aName.length - queryLower.length <= 5) aScore += 800;';
  mapPickerHTML += 'if (bName.indexOf(queryLower) === 0 && bName.length - queryLower.length <= 5) bScore += 800;';
  mapPickerHTML += 'if (aName.indexOf(queryLower) === 0) aScore += 500;';
  mapPickerHTML += 'if (bName.indexOf(queryLower) === 0) bScore += 500;';
  mapPickerHTML += 'if (aFullName.indexOf(queryLower) === 0) aScore += 300;';
  mapPickerHTML += 'if (bFullName.indexOf(queryLower) === 0) bScore += 300;';
  mapPickerHTML += 'var aWords = aName.split(/[\\s,()ï¼ˆï¼‰]+/);';
  mapPickerHTML += 'var bWords = bName.split(/[\\s,()ï¼ˆï¼‰]+/);';
  mapPickerHTML += 'for (var i = 0; i < aWords.length; i++) { if (aWords[i] === queryLower) { aScore += 700; break; } }';
  mapPickerHTML += 'for (var i = 0; i < bWords.length; i++) { if (bWords[i] === queryLower) { bScore += 700; break; } }';
  mapPickerHTML += 'if (aName.includes(queryLower)) aScore += 200;';
  mapPickerHTML += 'if (bName.includes(queryLower)) bScore += 200;';
  mapPickerHTML += 'if (aFullName.includes(queryLower)) aScore += 100;';
  mapPickerHTML += 'if (bFullName.includes(queryLower)) bScore += 100;';
  mapPickerHTML += 'if (a.type === "station" || a.type === "railway" || a.type === "railway_station") aScore += 50;';
  mapPickerHTML += 'if (b.type === "station" || b.type === "railway" || b.type === "railway_station") bScore += 50;';
  mapPickerHTML += 'if (a.type === "building" || a.type === "amenity" || a.type === "house" || a.type === "address") aScore += 30;';
  mapPickerHTML += 'if (b.type === "building" || b.type === "amenity" || b.type === "house" || b.type === "address") bScore += 30;';
  mapPickerHTML += 'if (a.type === "city" || a.type === "town" || a.type === "village") aScore += 10;';
  mapPickerHTML += 'if (b.type === "city" || b.type === "town" || b.type === "village") bScore += 10;';
  mapPickerHTML += 'if (aScore === bScore) {';
  mapPickerHTML += 'if (a.source === "OSM" && b.source !== "OSM") aScore += 5;';
  mapPickerHTML += 'if (b.source === "OSM" && a.source !== "OSM") bScore += 5;';
  mapPickerHTML += 'if (aName.length < bName.length) aScore += 3;';
  mapPickerHTML += 'if (bName.length < aName.length) bScore += 3;';
  mapPickerHTML += '}';
  mapPickerHTML += 'return bScore - aScore; });';
  mapPickerHTML += 'if (allResults.length === 0) {';
  mapPickerHTML += 'document.getElementById("results-list").innerHTML = ';
  mapPickerHTML += '"<div class=\\"no-results\\">æ‰¾ä¸åˆ° \\"" + query + "\\"<br><br>ğŸ’¡ æœå°‹å»ºè­°ï¼š<br>â€¢ å®Œæ•´åœ°å€æ ¼å¼ï¼š<br>ã€€å°åŒ—å¸‚ä¿¡ç¾©å€å¸‚åºœè·¯1è™Ÿ<br>â€¢ çœç•¥é„°è™Ÿå¾Œå†è©¦ï¼š<br>ã€€ç§»é™¤ã€Œç¬¬Xé„°ã€ç­‰æ–‡å­—<br>â€¢ åªè¼¸å…¥ä¸»è¦é“è·¯ï¼š<br>ã€€å¸‚åºœè·¯<br>â€¢ è©¦è©¦å°/è‡ºçš„ä¸åŒå¯«æ³•<br>â€¢ æˆ–ç›´æ¥åœ¨åœ°åœ–ä¸Šé»æ“Šä½ç½®</div>";';
  mapPickerHTML += 'return; }';
  mapPickerHTML += 'var html = "";';
  mapPickerHTML += 'var maxDisplay = isCommonPlace ? 20 : 15;';
  mapPickerHTML += 'var displayCount = Math.min(allResults.length, maxDisplay);';
  mapPickerHTML += 'for (var i = 0; i < displayCount; i++) {';
  mapPickerHTML += 'var item = allResults[i];';
  mapPickerHTML += 'var name = item.display_name.split(",")[0];';
  mapPickerHTML += 'var address = item.display_name;';
  mapPickerHTML += 'var typeLabel = "";';
  mapPickerHTML += 'if (item.type === "city") typeLabel = " ğŸ™ï¸";';
  mapPickerHTML += 'else if (item.type === "town") typeLabel = " ğŸ˜ï¸";';
  mapPickerHTML += 'else if (item.type === "village") typeLabel = " ğŸ¡";';
  mapPickerHTML += 'else if (item.type === "building") typeLabel = " ğŸ¢";';
  mapPickerHTML += 'else if (item.type === "amenity") typeLabel = " ğŸ“";';
  mapPickerHTML += 'var sourceBadge = "<small style=\\"color:#999;font-size:10px;\\"> [" + item.source + "]</small>";';
  mapPickerHTML += 'html += "<div class=\\"result-item\\" onclick=\\"selectResult(" + item.lat + "," + item.lon + ",\\047" + name.replace(/"/g, "&quot;").replace(/\'/g, "\\047") + "\\047)\\">";';
  mapPickerHTML += 'html += "<div class=\\"result-name\\">" + name + typeLabel + sourceBadge + "</div>";';
  mapPickerHTML += 'html += "<div class=\\"result-address\\">" + address + "</div></div>"; }';
  mapPickerHTML += 'if (allResults.length > displayCount) {';
  mapPickerHTML += 'html += "<div class=\\"no-results\\" style=\\"background:#f0f8ff;color:#333;padding:10px;\\">é¡¯ç¤ºå‰ " + displayCount + " å€‹çµæœï¼ˆå…±æ‰¾åˆ° " + allResults.length + " å€‹ï¼‰</div>"; }';
  mapPickerHTML += 'document.getElementById("results-list").innerHTML = html;';
  mapPickerHTML += '}).catch(function(e) {';
  mapPickerHTML += 'document.getElementById("results-list").innerHTML = "<div class=\\"no-results\\">âŒ æœå°‹å¤±æ•—<br><br>" + e.message + "</div>";';
  mapPickerHTML += '}); }';
  mapPickerHTML += 'function selectResult(lat, lng, name) {';
  mapPickerHTML += 'map.setView([lat, lng], 16);';
  mapPickerHTML += 'selectedLat = lat; selectedLng = lng; selectedName = name; selectedElevation = null;';
  mapPickerHTML += 'document.getElementById("coords").innerHTML = "ç·¯åº¦: " + lat.toFixed(6) + " | ç¶“åº¦: " + lng.toFixed(6);';
  mapPickerHTML += 'document.getElementById("elevation").innerHTML = "é«˜åº¦: <span style=\\"color:#ffd43b;\\">æŸ¥è©¢ä¸­...</span>";';
  mapPickerHTML += 'fetchElevation(lat, lng);';
  mapPickerHTML += 'if (marker) { map.removeLayer(marker); }';
  mapPickerHTML += 'marker = L.marker([lat, lng]).addTo(map).bindPopup(name).openPopup();';
  mapPickerHTML += 'closeResults(); }';
  mapPickerHTML += 'function closeResults() {';
  mapPickerHTML += 'document.getElementById("results-panel").style.display = "none"; }';
  mapPickerHTML += 'document.getElementById("search-input").addEventListener("keypress", function(e) {';
  mapPickerHTML += 'if (e.key === "Enter") { searchLocation(); } });';
  mapPickerHTML += 'async function fetchElevation(lat, lng) {';
  mapPickerHTML += '  var elevDiv = document.getElementById("elevation");';
  mapPickerHTML += '  if (lat < 21.5 || lat > 25.5 || lng < 119.5 || lng > 122.5) {';
  mapPickerHTML += '    elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#ff6b6b;\\">è¶…å‡ºç¯„åœ</span> <span style=\\"font-size:10px; color:#aaa;\\">(åƒ…æ”¯æ´å°ç£åœ°å€)</span>";';
  mapPickerHTML += '    return;';
  mapPickerHTML += '  }';
  mapPickerHTML += '  try {';
  mapPickerHTML += '    if (!window.GeoTIFF) {';
  mapPickerHTML += '      elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#ffd43b;\\">è¼‰å…¥ä¸­...</span>";';
  mapPickerHTML += '      var script = document.createElement("script");';
  mapPickerHTML += '      script.src = "https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.min.js";';
  mapPickerHTML += '      document.head.appendChild(script);';
  mapPickerHTML += '      await new Promise(function(resolve, reject) {';
  mapPickerHTML += '        script.onload = resolve;';
  mapPickerHTML += '        script.onerror = reject;';
  mapPickerHTML += '      });';
  mapPickerHTML += '    }';
  mapPickerHTML += '    elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#ffd43b;\\">æŸ¥è©¢ä¸­...</span>";';
  mapPickerHTML += '    var tiff = null;';
  mapPickerHTML += '    var cogFilename = "taiwan_dsm_wgs84_cog.tif";';
  mapPickerHTML += '    try {';
  mapPickerHTML += '      tiff = await GeoTIFF.fromUrl(cogFilename);';
  mapPickerHTML += '    } catch (err) {';
  mapPickerHTML += '      var githubUrl = "https://sulapon.github.io/GPS/taiwan_dsm_wgs84_cog.tif";';
  mapPickerHTML += '      tiff = await GeoTIFF.fromUrl(githubUrl);';
  mapPickerHTML += '    }';
  mapPickerHTML += '    var image = await tiff.getImage();';
  mapPickerHTML += '    var bbox = image.getBoundingBox();';
  mapPickerHTML += '    var width = image.getWidth();';
  mapPickerHTML += '    var height = image.getHeight();';
  mapPickerHTML += '    var pixelX = Math.floor((lng - bbox[0]) / (bbox[2] - bbox[0]) * width);';
  mapPickerHTML += '    var pixelY = Math.floor((bbox[3] - lat) / (bbox[3] - bbox[1]) * height);';
  mapPickerHTML += '    if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {';
  mapPickerHTML += '      var rasters = await image.readRasters({ window: [pixelX, pixelY, pixelX + 1, pixelY + 1] });';
  mapPickerHTML += '      var elevation = rasters[0][0];';
  mapPickerHTML += '      if (elevation === null || elevation === undefined || isNaN(elevation)) {';
  mapPickerHTML += '        throw new Error("è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨");';
  mapPickerHTML += '      }';
  mapPickerHTML += '      var commonNoDataValues = [-32768, -32767, -9999, -99999, -12345, 32767, 65535, -3.4028235e+38];';
  mapPickerHTML += '      var isNoData = commonNoDataValues.some(function(noData) { return Math.abs(elevation - noData) < 0.01; });';
  mapPickerHTML += '      if (isNoData || elevation < -500 || elevation > 9000) {';
  mapPickerHTML += '        throw new Error("æª¢æ¸¬åˆ°ç„¡åœ–è³‡å€åŸŸ");';
  mapPickerHTML += '      }';
  mapPickerHTML += '      selectedElevation = Math.round(parseFloat(elevation));';
  mapPickerHTML += '      elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#5ff0d5; font-weight:bold;\\">" + selectedElevation + " m</span> <span style=\\"font-size:10px; color:#aaa;\\">(å…§æ”¿éƒ¨ DSM 20m å«å»ºç‰©)</span>";';
  mapPickerHTML += '    } else {';
  mapPickerHTML += '      throw new Error("åº§æ¨™è¶…å‡º DSM è³‡æ–™ç¯„åœ");';
  mapPickerHTML += '    }';
  mapPickerHTML += '  } catch (error) {';
  mapPickerHTML += '    if (error.message.includes("ç„¡åœ–è³‡") || error.message.includes("ç¯„åœ") || error.message.includes("ä¸å¯ç”¨")) {';
  mapPickerHTML += '      elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#ffd43b;\\">ä½¿ç”¨ Open-Elevation SRTM å‚™ç”¨ä¸­...</span>";';
  mapPickerHTML += '      try {';
  mapPickerHTML += '        var response = await fetch("https://api.open-elevation.com/api/v1/lookup", {';
  mapPickerHTML += '          method: "POST",';
  mapPickerHTML += '          headers: { "Content-Type": "application/json", "Accept": "application/json" },';
  mapPickerHTML += '          body: JSON.stringify({ locations: [{ latitude: lat, longitude: lng }] })';
  mapPickerHTML += '        });';
  mapPickerHTML += '        if (!response.ok) throw new Error("HTTP error: " + response.status);';
  mapPickerHTML += '        var data = await response.json();';
  mapPickerHTML += '        if (data.results && data.results.length > 0) {';
  mapPickerHTML += '          selectedElevation = Math.round(data.results[0].elevation);';
  mapPickerHTML += '          elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#5ff0d5; font-weight:bold;\\">" + selectedElevation + " m</span> <span style=\\"font-size:10px; color:#aaa;\\">(Open-Elevation SRTM)</span>";';
  mapPickerHTML += '        } else {';
  mapPickerHTML += '          throw new Error("Open-Elevation API ç„¡æ•¸æ“š");';
  mapPickerHTML += '        }';
  mapPickerHTML += '      } catch (openElevErr) {';
  mapPickerHTML += '        selectedElevation = null;';
  mapPickerHTML += '        elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#ff6b6b;\\">ç„¡æ³•å–å¾—</span> <span style=\\"font-size:10px; color:#aaa;\\">(æ‰€æœ‰è³‡æ–™æºå¤±æ•—)</span>";';
  mapPickerHTML += '      }';
  mapPickerHTML += '    } else {';
  mapPickerHTML += '      selectedElevation = null;';
  mapPickerHTML += '      elevDiv.innerHTML = "é«˜åº¦: <span style=\\"color:#ff6b6b;\\">ç„¡æ³•å–å¾—</span> <span style=\\"font-size:10px; color:#aaa;\\">(è«‹ç¢ºèªç¶²è·¯é€£ç·š)</span>";';
  mapPickerHTML += '    }';
  mapPickerHTML += '  }';
  mapPickerHTML += '}';
  mapPickerHTML += 'function confirmSelection() {';
  mapPickerHTML += 'if (selectedLat === null || selectedLng === null) {';
  mapPickerHTML += 'alert("âŒ è«‹å…ˆé»æ“Šåœ°åœ–æˆ–æœå°‹ä½ç½®"); return; }';
  mapPickerHTML += 'if (window.opener && !window.opener.closed) {';
  mapPickerHTML += 'window.opener.receiveMapCoordinates("' + location + '", selectedLat, selectedLng, selectedName);';
  mapPickerHTML += 'window.close(); } else { alert("âŒ ç„¡æ³•èˆ‡ä¸»è¦–çª—é€šè¨Š"); } }';
  mapPickerHTML += '<\/script></body></html>';
  var width = Math.min(900, window.screen.width - 50);
  var height = Math.min(700, window.screen.height - 50);
  var left = (window.screen.width - width) / 2;
  var top = (window.screen.height - height) / 2;
  var mapPickerWindow = window.open('', 'mapPicker',
    'width=' + width + ',height=' + height + ',left=' + left + ',top=' + top + ',toolbar=no,location=no,menubar=no');
  if (mapPickerWindow) {
    mapPickerWindow.document.write(mapPickerHTML);
    mapPickerWindow.document.close();
  } else {
    alert('âŒ ç„¡æ³•æ‰“é–‹åœ°åœ–è¦–çª—ï¼Œè«‹å…è¨±å½ˆå‡ºè¦–çª—');
  }
}
function receiveMapCoordinates(location, lat, lng, searchedName) {

  // ç‰¹æ®Šè™•ç†ï¼šå¦‚æœæ˜¯æŒ‡åŒ—é‡èª¿ç”¨
  if (location === 'COMPASS') {
    if (window.receiveCompassMapCoordinates) {
      window.receiveCompassMapCoordinates(lat, lng, searchedName);
    }
    return;
  }

  // åŸæœ‰çš„GPSåˆ†é è™•ç†é‚è¼¯
  const latId = location === 'A' ? 'latA' : 'latB';
  const lonId = location === 'A' ? 'lonA' : 'lonB';
  const nameId = location === 'A' ? 'nameA' : 'nameB';
  const eleId = location === 'A' ? 'eleA' : 'eleB';

  // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“šï¼ˆæœƒè‡ªå‹•åŒæ­¥åˆ°æ‰€æœ‰è¦–åœ–ï¼‰
  coordinateData[location].lat = parseFloat(lat.toFixed(6));
  coordinateData[location].lng = parseFloat(lng.toFixed(6));
  calculate();

  if (searchedName && searchedName.trim() !== '') {
    let locationName = searchedName.trim();
    if (locationName.length > 5) {
      locationName = locationName.substring(0, 5);
    }
    // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“š
    coordinateData[location].name = locationName;

    showLocationUpdateDialog(location, lat, lng, locationName, eleId);
    setTimeout(() => {
      getElevationAutomatic(lat, lng, location, eleId);
    }, 100);
  } else {
    getLocationNameAndShowDialog(lat, lng, location, nameId, eleId);
  }
}
async function getLocationNameAndShowDialog(lat, lng, location, nameId, eleId) {
  const nameInput = document.getElementById(nameId);
  showLocationUpdateDialog(location, lat, lng, 'å–å¾—ä¸­...', eleId);
  try {
    const response = await fetch(
      `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=zh-TW`
    );
    if (!response.ok) {
      throw new Error('åå‘åœ°ç†ç·¨ç¢¼è«‹æ±‚å¤±æ•—');
    }
    const data = await response.json();
    if (data && data.address) {
      let locationName = '';
      if (data.name && data.name.trim() !== '' &&
        !data.name.match(/^[0-9\-]+$/) &&
        data.name.length <= 20) {
        locationName = data.name;
      }
      else if (data.address.building &&
           data.address.building.trim() !== '' &&
           !data.address.building.match(/^(yes|house|residential|commercial|retail|apartments|office)$/i)) {
        locationName = data.address.building;
      }
      else if (data.address.amenity) {
        locationName = data.address.amenity;
      }
      else if (data.address.road) {
        locationName = data.address.road;
      }
      else if (data.address.village || data.address.hamlet || data.address.suburb) {
        locationName = data.address.village || data.address.hamlet || data.address.suburb;
      }
      else if (data.address.town || data.address.city_district) {
        locationName = data.address.town || data.address.city_district;
      }
      else if (data.address.city || data.address.county || data.address.state) {
        locationName = data.address.city || data.address.county || data.address.state;
      }
      else if (data.display_name) {
        const parts = data.display_name.split(',');
        locationName = parts[0].trim();
      }
      if (locationName.length > 5) {
        locationName = locationName.substring(0, 5);
      }
      if (locationName) {
        // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“šï¼ˆæœƒè‡ªå‹•åŒæ­¥åˆ°æ‰€æœ‰è¦–åœ–ï¼‰
        coordinateData[location].name = locationName;
        updateDialogLocationName(locationName);
      } else {
        throw new Error('ç„¡æ³•å–å¾—åœ°å');
      }
    } else {
      throw new Error('åå‘åœ°ç†ç·¨ç¢¼ç„¡çµæœ');
    }
  } catch (error) {
    const simpleName = `é»${location}`;
    // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“š
    coordinateData[location].name = simpleName;
    updateDialogLocationName(`é»${location} (æœªå–å¾—åœ°å)`);
  }
  setTimeout(() => {
    getElevationAutomatic(lat, lng, location, eleId);
  }, 100);
}
function updateDialogLocationName(locationName) {
  if (currentUpdateDialog) {
    const span = currentUpdateDialog.querySelector('#dialog-location-name');
    if (span) {
      span.textContent = locationName;
    }
  }
}
function updateDMSFromDecimal(coordId) {
  const decimalInput = document.getElementById(coordId);
  const decimalValue = parseFloat(decimalInput.value);
  if (isNaN(decimalValue)) return;
  const isNegative = decimalValue < 0;
  const absValue = Math.abs(decimalValue);
  const degrees = Math.floor(absValue);
  const minutesDecimal = (absValue - degrees) * 60;
  const minutes = Math.floor(minutesDecimal);
  const seconds = (minutesDecimal - minutes) * 60;
  const degInput = document.getElementById(coordId + '_deg');
  const minInput = document.getElementById(coordId + '_min');
  const secInput = document.getElementById(coordId + '_sec');
  if (degInput) degInput.value = isNegative ? -degrees : degrees;
  if (minInput) minInput.value = minutes;
  if (secInput) secInput.value = seconds.toFixed(2);
}
async function getElevationFromSRTM(location) {
  const latId = location === 'A' ? 'latA' : 'latB';
  const lonId = location === 'A' ? 'lonA' : 'lonB';
  const eleId = location === 'A' ? 'eleA' : 'eleB';
  const latVal = document.getElementById(latId).value;
  const lonVal = document.getElementById(lonId).value;
  if (!latVal || !lonVal) {
    alert(`âŒ è«‹å…ˆè¼¸å…¥åœ°é»${location}çš„åº§æ¨™`);
    return;
  }
  const lat = parseFloat(latVal);
  const lon = parseFloat(lonVal);
  if (isNaN(lat) || isNaN(lon)) {
    alert(`âŒ åœ°é»${location}çš„åº§æ¨™ç„¡æ•ˆ`);
    return;
  }
  if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
    alert(`âŒ åº§æ¨™è¶…å‡ºæœ‰æ•ˆç¯„åœ\nç·¯åº¦: -90 ~ 90\nç¶“åº¦: -180 ~ 180`);
    return;
  }

  // â˜… å„ªå…ˆä½¿ç”¨é«˜åº¦åœ–åˆ†é å·²è¼‰å…¥çš„æœ¬åœ° TIF æª”æ¡ˆ
  if (typeof localTifFileData !== 'undefined' && localTifFileData && localTifFileData.tiff && localTifFileData.image) {
    const eleInput = document.getElementById(eleId);
    const loadingId = eleId + '-loading';
    const loadingSpan = document.getElementById(loadingId);
    if (loadingSpan) {
      loadingSpan.innerHTML = 'è®€å–TIF<span class="loading-dots"></span>';
      loadingSpan.style.display = 'inline';
      eleInput.style.opacity = '0.3';
    }
    eleInput.disabled = true;
    try {
      const image = localTifFileData.image;
      const bbox = image.getBoundingBox();
      const width = image.getWidth();
      const height = image.getHeight();
      const pixelX = Math.floor((lon - bbox[0]) / (bbox[2] - bbox[0]) * width);
      const pixelY = Math.floor((bbox[3] - lat) / (bbox[3] - bbox[1]) * height);
      if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
        const rasters = await image.readRasters({ window: [pixelX, pixelY, pixelX + 1, pixelY + 1] });
        const elevation = rasters[0][0];
        const commonNoDataValues = [-32768, -32767, -9999, -99999, -12345, 32767, 65535, -3.4028235e+38];
        const isNoData = commonNoDataValues.some(noData => Math.abs(elevation - noData) < 0.01);
        if (!isNoData && elevation >= -500 && elevation <= 9000 && !isNaN(elevation)) {
          eleInput.value = Math.round(parseFloat(elevation));
          eleInput.disabled = false;
          if (loadingSpan) { loadingSpan.style.display = 'none'; eleInput.style.opacity = '1'; }
          calculate();
          return;  // â˜… æˆåŠŸå–å¾—ï¼Œç›´æ¥è¿”å›
        }
      }
      // TIF ç¯„åœå…§ç„¡è³‡æ–™ï¼Œç¹¼çºŒç”¨åŸå§‹æ–¹å¼
    } catch (tifErr) {
      // TIF è®€å–å¤±æ•—ï¼Œç¹¼çºŒç”¨åŸå§‹æ–¹å¼
    } finally {
      eleInput.disabled = false;
      if (loadingSpan) { loadingSpan.style.display = 'none'; eleInput.style.opacity = '1'; }
    }
  }

  if (lat < 21.5 || lat > 25.5 || lon < 119.5 || lon > 122.5) {
    alert(`âš ï¸ è­¦å‘Šï¼šåº§æ¨™è¶…å‡ºå°ç£ç¯„åœ\nå…§æ”¿éƒ¨ DSM åƒ…æ¶µè“‹å°ç£åœ°å€\n\nå°‡å˜—è©¦ä½¿ç”¨ Open-Elevation SRTM ä½œç‚ºå‚™ç”¨è³‡æ–™æº`);
    await getElevationFromOpenElevation(location);
    return;
  }
  const eleInput = document.getElementById(eleId);
  const originalValue = eleInput.value;
  eleInput.disabled = true;
  // é¡¯ç¤º input æ¬„ä½æ—çš„ loading æŒ‡ç¤ºå™¨ï¼ˆä¸è¦†è“‹ gpsResï¼‰
  const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
  const loadingSpan = document.getElementById(loadingId);
  if (loadingSpan) {
    loadingSpan.innerHTML = 'è®€å–ä¸­<span class="loading-dots"></span>';
    loadingSpan.style.display = 'inline';
    eleInput.style.opacity = '0.3';
  }
  let success = false;
  try {
    if (!window.GeoTIFF) {
      await loadGeoTIFFLibrary();
    }
    const cogFilename = 'taiwan_dsm_wgs84_cog.tif';
    let tiff = null;
    try {
      tiff = await GeoTIFF.fromUrl(cogFilename);
    } catch (err) {
      const githubUrl = 'https://sulapon.github.io/GPS/taiwan_dsm_wgs84_cog.tif';
      try {
        tiff = await GeoTIFF.fromUrl(githubUrl);
      } catch (err2) {
        throw new Error(`ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆ: ${err2.message}`);
      }
    }
    if (!tiff) {
      throw new Error('ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆ');
    }
    const image = await tiff.getImage();
    const bbox = image.getBoundingBox();
    const width = image.getWidth();
    const height = image.getHeight();
    const pixelX = Math.floor((lon - bbox[0]) / (bbox[2] - bbox[0]) * width);
    const pixelY = Math.floor((bbox[3] - lat) / (bbox[3] - bbox[1]) * height);
    if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
      const rasters = await image.readRasters({
        window: [pixelX, pixelY, pixelX + 1, pixelY + 1]
      });
      const elevation = rasters[0][0];
      
      if (elevation === null || elevation === undefined || isNaN(elevation)) {
        throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨ï¼Œå°‡ä½¿ç”¨å‚™ç”¨è³‡æ–™æº');
      }
      
      const commonNoDataValues = [-32768, -32767, -9999, -99999, -12345, 32767, 65535, -3.4028235e+38];
      const isNoData = commonNoDataValues.some(noData => Math.abs(elevation - noData) < 0.01);
      
      if (isNoData || elevation < -500 || elevation > 9000) {
        await getElevationFromOpenElevation(location);
        return;
      }
      
      eleInput.value = Math.round(parseFloat(elevation));
      success = true;
      calculate();
    } else {
      throw new Error('åº§æ¨™è¶…å‡º DSM è³‡æ–™ç¯„åœ');
    }
  } catch (err) {
    if (err.message.includes('ä¸å¯ç”¨') || err.message.includes('ç¯„åœ') || err.message.includes('Open-Elevation') || err.message.includes('å‚™ç”¨')) {
      try {
        await getElevationFromOpenElevation(location);
        return;
      } catch (openElevErr) {
        eleInput.value = originalValue;
      }
    } else {
      eleInput.value = originalValue;
    }
  } finally {
    eleInput.disabled = false;
    if (loadingSpan) {
      loadingSpan.style.display = 'none';
      eleInput.style.opacity = '1';
    }
  }
}
async function getElevationFromGoogleMaps(location) {
  const latId = location === 'A' ? 'latA' : 'latB';
  const lonId = location === 'A' ? 'lonA' : 'lonB';
  const eleId = location === 'A' ? 'eleA' : 'eleB';
  const latVal = document.getElementById(latId).value;
  const lonVal = document.getElementById(lonId).value;
  const lat = parseFloat(latVal);
  const lon = parseFloat(lonVal);
  const eleInput = document.getElementById(eleId);
  const originalValue = eleInput.value;
  eleInput.disabled = true;
  const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
  const loadingSpan = document.getElementById(loadingId);
  if (loadingSpan) {
    loadingSpan.innerHTML = 'è®€å–ä¸­<span class="loading-dots"></span>';
    loadingSpan.style.display = 'inline';
    eleInput.style.opacity = '0.3';
  }
  const GOOGLE_API_KEY = 'AIzaSyBwd_GtAZq2eW6KgRRkro__aG7h5ZECJwo';
  try {
    if (!window.google || !window.google.maps) {
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=geometry`;
        script.async = true;
        script.defer = true;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    const elevator = new google.maps.ElevationService();
    const result = await new Promise((resolve, reject) => {
      elevator.getElevationForLocations({
        locations: [{lat: lat, lng: lon}]
      }, (results, status) => {
        if (status === 'OK' && results && results.length > 0) {
          resolve(results[0]);
        } else {
          reject(new Error(`Google Maps API ç‹€æ…‹: ${status}`));
        }
      });
    });
    const elevation = result.elevation;
    if (elevation === null || elevation === undefined) {
      throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
    }
    eleInput.value = Math.round(parseFloat(elevation));
    calculate();
  } catch (err) {
    eleInput.value = originalValue;
  } finally {
    eleInput.disabled = false;
    if (loadingSpan) {
      loadingSpan.style.display = 'none';
      eleInput.style.opacity = '1';
    }
  }
}

async function getElevationFromOpenElevation(location) {
  const latId = location === 'A' ? 'latA' : 'latB';
  const lonId = location === 'A' ? 'lonA' : 'lonB';
  const eleId = location === 'A' ? 'eleA' : 'eleB';
  const latVal = document.getElementById(latId).value;
  const lonVal = document.getElementById(lonId).value;
  const lat = parseFloat(latVal);
  const lon = parseFloat(lonVal);
  const eleInput = document.getElementById(eleId);
  const originalValue = eleInput.value;
  eleInput.disabled = true;
  const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
  const loadingSpan = document.getElementById(loadingId);
  if (loadingSpan) {
    loadingSpan.innerHTML = 'è®€å–ä¸­<span class="loading-dots"></span>';
    loadingSpan.style.display = 'inline';
    eleInput.style.opacity = '0.3';
  }
  
  try {
    const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({
        locations: [{
          latitude: lat,
          longitude: lon
        }]
      })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP éŒ¯èª¤: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (!data.results || data.results.length === 0) {
      throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
    }
    
    const elevation = data.results[0].elevation;
    
    if (elevation === null || elevation === undefined) {
      throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
    }
    
    eleInput.value = Math.round(parseFloat(elevation));
    calculate();
  } catch (err) {
    eleInput.value = originalValue;
  } finally {
    eleInput.disabled = false;
    if (loadingSpan) {
      loadingSpan.style.display = 'none';
      eleInput.style.opacity = '1';
    }
  }
}

let currentUpdateDialog = null;
function showLocationUpdateDialog(location, lat, lng, locationName, eleId) {
  if (currentUpdateDialog && currentUpdateDialog.parentNode) {
    currentUpdateDialog.parentNode.removeChild(currentUpdateDialog);
  }
  const dialog = document.createElement('div');
  dialog.id = 'location-update-dialog';
  dialog.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(40, 44, 52, 0.98);
    border: 2px solid #5ff0d5;
    border-radius: 12px;
    padding: 24px;
    min-width: 320px;
    max-width: 90vw;
    z-index: 999999;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
    color: #ffffff;
    font-size: 15px;
    line-height: 1.6;
  `;
  dialog.innerHTML = `
    <div style="font-size:18px; font-weight:bold; color:#5ff0d5; margin-bottom:16px; text-align:center;">
      sulapon.github.io é¡¯ç¤º
    </div>
    <div style="margin-bottom:12px;">
      <span style="color:#4ade80;">âœ“</span> åœ°é» ${location} å·²æ›´æ–°
    </div>
    <div style="margin-bottom:8px;">
      åº§æ¨™: <span style="color:#60a5fa;">${lat.toFixed(6)}, ${lng.toFixed(6)}</span>
    </div>
    <div style="margin-bottom:12px;">
      åœ°å: <span id="dialog-location-name" style="color:#fbbf24;">${locationName}</span>
    </div>
    <div id="elevation-status-${eleId}" style="color:#94a3b8;">
      æ­£åœ¨å–å¾—é«˜åº¦...
    </div>
    <div style="text-align:center; margin-top:20px;">
      <button onclick="confirmLocationUpdate()" style="background:linear-gradient(90deg, #fbbf24, #f59e0b); color:#000; border:none; padding:10px 32px; border-radius:6px; font-weight:bold; font-size:16px; cursor:pointer;">
        ç¢ºå®š
      </button>
    </div>
  `;
  document.body.appendChild(dialog);
  currentUpdateDialog = dialog;
  dialog.dataset.eleId = eleId;
  dialog.dataset.location = location;
  dialog.dataset.lat = lat;
  dialog.dataset.lng = lng;
}
function updateDialogElevationStatus(eleId, status, success = true) {
  const statusDiv = document.getElementById(`elevation-status-${eleId}`);
  if (statusDiv) {
    if (success) {
      statusDiv.innerHTML = `<span style="color:#4ade80;">âœ“</span> ${status}`;
      statusDiv.style.color = '#4ade80';
    } else {
      statusDiv.innerHTML = `<span style="color:#ef4444;">âœ—</span> ${status}`;
      statusDiv.style.color = '#ef4444';
    }
  }
}
async function confirmLocationUpdate() {
  if (!currentUpdateDialog) return;

  const location = currentUpdateDialog.dataset.location;
  const nameSpan = currentUpdateDialog.querySelector('#dialog-location-name');
  const currentName = nameSpan ? nameSpan.textContent.trim() : '';
  const needRetry = !currentName || currentName === 'å–å¾—ä¸­...' || currentName.includes('æœªå–å¾—åœ°å');

  if (needRetry && location) {
    // åœ°åé‚„æ²’å–å¾—æˆåŠŸï¼Œé‡æ–°å˜—è©¦ä¸€æ¬¡
    const lat = parseFloat(currentUpdateDialog.dataset.lat);
    const lng = parseFloat(currentUpdateDialog.dataset.lng);
    const confirmBtn = currentUpdateDialog.querySelector('button');
    if (confirmBtn) {
      confirmBtn.disabled = true;
      confirmBtn.textContent = 'å–å¾—ä¸­...';
    }
    if (nameSpan) nameSpan.textContent = 'é‡æ–°å–å¾—ä¸­...';

    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=zh-TW`
      );
      if (!response.ok) throw new Error('è«‹æ±‚å¤±æ•—');
      const data = await response.json();
      let locationName = '';
      if (data && data.address) {
        if (data.name && data.name.trim() !== '' && !data.name.match(/^[0-9\-]+$/) && data.name.length <= 20) {
          locationName = data.name;
        } else if (data.address.building && !data.address.building.match(/^(yes|house|residential|commercial|retail|apartments|office)$/i)) {
          locationName = data.address.building;
        } else if (data.address.amenity) {
          locationName = data.address.amenity;
        } else if (data.address.road) {
          locationName = data.address.road;
        } else if (data.address.village || data.address.hamlet || data.address.suburb) {
          locationName = data.address.village || data.address.hamlet || data.address.suburb;
        } else if (data.address.town || data.address.city_district) {
          locationName = data.address.town || data.address.city_district;
        } else if (data.address.city || data.address.county || data.address.state) {
          locationName = data.address.city || data.address.county || data.address.state;
        } else if (data.display_name) {
          locationName = data.display_name.split(',')[0].trim();
        }
        if (locationName.length > 5) locationName = locationName.substring(0, 5);
      }
      if (locationName) {
        if (nameSpan) nameSpan.textContent = locationName;
        const nameId = location === 'A' ? 'nameA' : 'nameB';
        const nameInput = document.getElementById(nameId);
        if (nameInput) nameInput.value = locationName;
        coordinateData[location].name = locationName;
      } else {
        // API å›æ‡‰äº†ä½†æ²’æœ‰æœ‰ç”¨åœ°åï¼Œç”¨ç°¡å
        const simpleName = `é»${location}`;
        if (nameSpan) nameSpan.textContent = simpleName;
        const nameId = location === 'A' ? 'nameA' : 'nameB';
        const nameInput = document.getElementById(nameId);
        if (nameInput) nameInput.value = simpleName;
        coordinateData[location].name = simpleName;
      }
    } catch (e) {
      // é‡è©¦ä¹Ÿå¤±æ•—ï¼Œç”¨ç°¡å
      const simpleName = `é»${location}`;
      if (nameSpan) nameSpan.textContent = simpleName;
      const nameId = location === 'A' ? 'nameA' : 'nameB';
      const nameInput = document.getElementById(nameId);
      if (nameInput) nameInput.value = simpleName;
      coordinateData[location].name = simpleName;
    }
  }

  // æœ€çµ‚åŒæ­¥åœ°ååˆ°è¼¸å…¥æ¡†ï¼Œç¢ºä¿è¬ç„¡ä¸€å¤±
  if (location) {
    const nameId = location === 'A' ? 'nameA' : 'nameB';
    const nameInput = document.getElementById(nameId);
    const finalName = nameSpan ? nameSpan.textContent.trim() : '';
    if (nameInput && finalName && finalName !== 'å–å¾—ä¸­...' && finalName !== 'é‡æ–°å–å¾—ä¸­...') {
      nameInput.value = finalName;
      coordinateData[location].name = finalName;
    }
  }

  closeLocationUpdateDialog();
  calculate();
}

function closeLocationUpdateDialog() {
  if (currentUpdateDialog && currentUpdateDialog.parentNode) {
    currentUpdateDialog.parentNode.removeChild(currentUpdateDialog);
    currentUpdateDialog = null;
  }
}
async function getElevationAutomatic(lat, lon, location, eleId) {
  const eleInput = document.getElementById(eleId);
  const originalValue = eleInput.value;
  const loadingId = eleInput.id === 'eleA' ? 'eleA-loading' : 'eleB-loading';
  const loadingSpan = document.getElementById(loadingId);
  if (loadingSpan) {
    loadingSpan.innerHTML = 'è®€å–ä¸­<span class="loading-dots"></span>';
    loadingSpan.style.display = 'inline';
    eleInput.style.opacity = '0.5';
  }
  const isInTaiwan = (lat >= 21.5 && lat <= 25.5 && lon >= 119.5 && lon <= 122.5);
  if (!isInTaiwan) {
    await getElevationAutomaticOpenElevation(lat, lon, location, eleId);
    return;
  }
  try {
    updateDialogElevationStatus(eleId, 'æ­£åœ¨é€£æ¥å…§æ”¿éƒ¨ DSM...', true);
    if (!window.GeoTIFF) {
      updateDialogElevationStatus(eleId, 'è¼‰å…¥ GeoTIFF å‡½å¼åº«...', true);
      await loadGeoTIFFLibrary();
    }
    updateDialogElevationStatus(eleId, 'é€£æ¥ DSM è³‡æ–™æª”æ¡ˆ...', true);
    const cogFilename = 'taiwan_dsm_wgs84_cog.tif';
    let tiff = null;
    try {
      tiff = await GeoTIFF.fromUrl(cogFilename);
    } catch (err) {
      const githubUrl = 'https://sulapon.github.io/GPS/taiwan_dsm_wgs84_cog.tif';
      try {
        tiff = await GeoTIFF.fromUrl(githubUrl);
      } catch (err2) {
        throw new Error(`ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆ: ${err2.message}`);
      }
    }
    if (!tiff) {
      throw new Error('ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆ');
    }
    updateDialogElevationStatus(eleId, 'æ­£åœ¨è§£æé«˜åº¦è³‡æ–™...', true);
    const image = await tiff.getImage();
    const bbox = image.getBoundingBox();
    const width = image.getWidth();
    const height = image.getHeight();
    const pixelX = Math.floor((lon - bbox[0]) / (bbox[2] - bbox[0]) * width);
    const pixelY = Math.floor((bbox[3] - lat) / (bbox[3] - bbox[1]) * height);
    if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
      const rasters = await image.readRasters({
        window: [pixelX, pixelY, pixelX + 1, pixelY + 1]
      });
      const elevation = rasters[0][0];
      
      if (elevation === null || elevation === undefined || isNaN(elevation)) {
        updateDialogElevationStatus(eleId, 'è©²ä½ç½®ç„¡ DSM æ•¸æ“šï¼Œåˆ‡æ›è‡³ Google Maps...', true);
        throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨ - åˆ‡æ›è‡³ Google Maps');
      }
      
      // æª¢æŸ¥å¸¸è¦‹çš„ NoData å€¼
      const commonNoDataValues = [-32768, -32767, -9999, -99999, -12345, 32767, 65535, -3.4028235e+38];
      const isNoData = commonNoDataValues.some(noData => Math.abs(elevation - noData) < 0.01);
      
      if (isNoData || elevation < -500 || elevation > 9000) {
        // æª¢æ¸¬åˆ°ç„¡æ•ˆæ•¸æ“šï¼Œä½¿ç”¨ Google Maps API å‚™ç”¨
        updateDialogElevationStatus(eleId, 'æª¢æ¸¬åˆ°ç„¡åœ–è³‡å€åŸŸ (NoData)ï¼Œåˆ‡æ›è‡³ Google Maps...', true);
        throw new Error('æª¢æ¸¬åˆ°ç„¡åœ–è³‡å€åŸŸ - åˆ‡æ›è‡³ Google Maps');
      }
      
      const elevationRounded = Math.round(parseFloat(elevation));
      eleInput.value = elevationRounded;
      updateDialogElevationStatus(eleId, `é«˜åº¦: ${elevationRounded} å…¬å°º (å…§æ”¿éƒ¨ DSM 20m å«å»ºç‰©)`, true);
      calculate();
    } else {
      throw new Error('åº§æ¨™è¶…å‡º DSM è³‡æ–™ç¯„åœ');
    }
  } catch (err) {
    updateDialogElevationStatus(eleId, 'åˆ‡æ›è‡³ Open-Elevation SRTM å‚™ç”¨...', true);
    await getElevationAutomaticOpenElevation(lat, lon, location, eleId);
  } finally {
    if (loadingSpan) {
      loadingSpan.style.display = 'none';
      eleInput.style.opacity = '1';
    }
  }
}
async function getElevationAutomaticGoogleMaps(lat, lon, location, eleId) {
  const eleInput = document.getElementById(eleId);
  const originalValue = eleInput.value;
  const GOOGLE_API_KEY = 'AIzaSyBwd_GtAZq2eW6KgRRkro__aG7h5ZECJwo';
  try {
    updateDialogElevationStatus(eleId, 'æ­£åœ¨é€£æ¥ Google Maps...', true);
    if (!window.google || !window.google.maps) {
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=geometry`;
        script.async = true;
        script.defer = true;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    updateDialogElevationStatus(eleId, 'æ­£åœ¨è§£æé«˜åº¦è³‡æ–™...', true);
    const elevator = new google.maps.ElevationService();
    const result = await new Promise((resolve, reject) => {
      elevator.getElevationForLocations({
        locations: [{lat: lat, lng: lon}]
      }, (results, status) => {
        if (status === 'OK' && results && results.length > 0) {
          resolve(results[0]);
        } else {
          reject(new Error(`Google Maps API ç‹€æ…‹: ${status}`));
        }
      });
    });
    const elevation = result.elevation;
    if (elevation === null || elevation === undefined) {
      throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
    }
    const elevationRounded = Math.round(parseFloat(elevation));
    eleInput.value = elevationRounded;
    updateDialogElevationStatus(eleId, `é«˜åº¦: ${elevationRounded} å…¬å°º (Google Maps)`, true);
    calculate();
  } catch (err) {
    updateDialogElevationStatus(eleId, 'é«˜åº¦å–å¾—å¤±æ•—', false);
    if (!originalValue || originalValue === 'å–å¾—ä¸­...') {
      eleInput.value = '';
    }
  }
}

async function getElevationAutomaticOpenElevation(lat, lon, location, eleId) {
  const eleInput = document.getElementById(eleId);
  const originalValue = eleInput.value;
  
  try {
    updateDialogElevationStatus(eleId, 'æ­£åœ¨é€£æ¥ Open-Elevation SRTM...', true);
    
    const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({
        locations: [{
          latitude: lat,
          longitude: lon
        }]
      })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP éŒ¯èª¤: ${response.status}`);
    }
    
    updateDialogElevationStatus(eleId, 'æ­£åœ¨è§£æé«˜åº¦è³‡æ–™...', true);
    
    const data = await response.json();
    
    if (!data.results || data.results.length === 0) {
      throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
    }
    
    const elevation = data.results[0].elevation;
    
    if (elevation === null || elevation === undefined) {
      throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
    }
    
    const elevationRounded = Math.round(parseFloat(elevation));
    eleInput.value = elevationRounded;
    updateDialogElevationStatus(eleId, `é«˜åº¦: ${elevationRounded} å…¬å°º (Open-Elevation SRTM)`, true);
    calculate();
  } catch (err) {
    updateDialogElevationStatus(eleId, 'é«˜åº¦å–å¾—å¤±æ•—', false);
    if (!originalValue || originalValue === 'å–å¾—ä¸­...') {
      eleInput.value = '';
    }
  }
}

function calculate() {
  const mode = document.getElementById('displayMode').value;
  if (mode === 'dms') {
    ['latA','lonA','latB','lonB'].forEach(id => { try{ dmsToD(id, true); }catch(e){} });
  }
  const [latA, lonA, latB, lonB, eleA, eleB] =
    ['latA', 'lonA', 'latB', 'lonB', 'eleA', 'eleB'].map(id => parseFloat(document.getElementById(id).value || 0));
  const [nameA, nameB] =
    ['nameA', 'nameB'].map(id => document.getElementById(id).value || (id === 'nameA' ? 'A' : 'B'));
  const resDiv = document.getElementById('gpsRes');
  if (isNaN(latA) || isNaN(lonA) || isNaN(latB) || isNaN(lonB)) {
    resDiv.innerHTML = "âŒ **è«‹è¼¸å…¥æœ‰æ•ˆçš„ GPS åº§æ¨™æ•¸å­—**";
    resDiv.classList.add('gps-error');
    return;
  }
  resDiv.classList.remove('gps-error');
  const hD = hDist(latA, lonA, latB, lonB);
  const sD = straightDist(hD, eleA, eleB);
  const bAB = getBearing(latA, lonA, latB, lonB);
  const bBA = getBearing(latB, lonB, latA, lonA);
  const pitch = getPitch(hD, eleA, eleB);
  // å„²å­˜ GPS è¨ˆç®—çµæœä¾› PDF å ±å‘Šä½¿ç”¨ï¼ˆå«åœ°çƒæ›²ç‡ä¿®æ­£çš„ç²¾ç¢ºå€¼ï¼‰
  window.gpsCalcResult = {
    azimuthAtoB: bAB,
    azimuthBtoA: bBA,
    pitchAtoB: pitch.pitchAB,
    pitchBtoA: pitch.pitchBA,
    distKm: hD,
    distStraight: sD
  };
  const fDist = sD < 1
    ? `<strong class="v-dist">${(sD * 1000).toFixed(2)}</strong> å…¬å°º`
    : `<strong class="v-dist">${sD.toFixed(2)}</strong> å…¬é‡Œ`;
  resDiv.innerHTML = `
    <p><span class="gps-label-title">âœ… å…©é»é–“çš„ç›´ç·šè·é›¢(å«é«˜åº¦å·®)</span>ï¼š${fDist}</p>
    <hr>
    <p><span class="gps-label-title">ğŸ§­ å¾ ${nameA} åˆ° ${nameB} çš„æ–¹ä½è§’</span>ï¼š<strong class="v-bearing">${bAB.toFixed(2)}Â°</strong></p>
    <p><span class="gps-label-title">â†©ï¸ å¾ ${nameB} åˆ° ${nameA} çš„æ–¹ä½è§’</span>ï¼š<strong class="v-bearing">${bBA.toFixed(2)}Â°</strong></p>
    <hr style="border:0; border-top:1px dashed rgba(255,255,255,0.06); margin:3px 0;">
    <p><span class="gps-label-title">â« ${nameA} å° ${nameB} çš„ä¿¯ä»°è§’</span>ï¼š<strong class="v-pitch-value">${pitch.pitchAB.toFixed(2)}Â°</strong></p>
    <p><span class="gps-label-title">â¬ ${nameB} å° ${nameA} çš„ä¿¯ä»°è§’</span>ï¼š<strong class="v-pitch-value">${pitch.pitchBA.toFixed(2)}Â°</strong></p>
  `;
  }
  const displayModeSelect = document.getElementById('displayMode');
  function updateDisplayMode(mode){
    if(!mode) mode = displayModeSelect ? displayModeSelect.value : 'decimal';
    const ids = ['latA','lonA','latB','lonB'];
    if(mode === 'dms'){
    document.querySelectorAll('.gps-dmsr').forEach(el => el.style.display = 'flex');
    document.querySelectorAll('.gps-ddr').forEach(el => el.style.display = 'none');
    ids.forEach(id => {
      try{ dToDMS(id); }catch(e){}
    });
    } else {
    document.querySelectorAll('.gps-dmsr').forEach(el => el.style.display = 'none');
    document.querySelectorAll('.gps-ddr').forEach(el => el.style.display = 'flex');
    ids.forEach(id => {
      const ddInput = document.getElementById(id);
      if (ddInput.value.trim() === '') {
        try{ dmsToD(id, true); }catch(e){}
      }
    });
    }
    calculate();
  }
  if(displayModeSelect){
    displayModeSelect.addEventListener('change', e => updateDisplayMode(e.target.value));
  }
  document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('unit').addEventListener('change', convertLength);
  if (document.getElementById('rf-content').classList.contains('active')) {
    compute();
  }
  resetGps();
  try { updateDisplayMode(document.getElementById('displayMode').value || 'decimal'); } catch(e){}
  });
</script>
<script>
let chartInstance = null;
let pathData = [];
let localTifFileData = null;  // æœ¬åœ°TIFæª”æ¡ˆè³‡æ–™
// ============================================================
// â˜… importFromGPS å‡½æ•¸å·²åœç”¨ - ç¾åœ¨ä½¿ç”¨è‡ªå‹•é›™å‘åŒæ­¥
// ============================================================
// æ­¤å‡½æ•¸å·²è¢«é›™å‘åŒæ­¥ç³»çµ±å–ä»£ï¼Œåº§æ¨™æœƒè‡ªå‹•åœ¨GPSåˆ†é å’Œé«˜åº¦åœ–åˆ†é ä¹‹é–“åŒæ­¥
// function importFromGPS() { ... }
// ============================================================

async function getPlaceNameFromCoords(lat, lon) {
  try {
    const response = await fetch(
      `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`,
      {
        headers: {
          'User-Agent': 'GPS Calculator App'
        }
      }
    );
    if (!response.ok) {
      throw new Error('APIè«‹æ±‚å¤±æ•—');
    }
    const data = await response.json();
    if (data.address) {
      const addr = data.address;
      return addr.road || addr.village || addr.town || addr.city ||
           addr.suburb || addr.neighbourhood || addr.hamlet ||
           addr.county || addr.state || 'æœªçŸ¥åœ°é»';
    }
    return 'æœªçŸ¥åœ°é»';
  } catch (error) {
    return 'æœªçŸ¥åœ°é»';
  }
}
async function updateElevationLabelsWithPlaceNames(latA, lonA, latB, lonB, nameA, nameB) {
  const labelALat = document.getElementById('labelALat');
  const labelALng = document.getElementById('labelALng');
  const labelBLat = document.getElementById('labelBLat');
  const labelBLng = document.getElementById('labelBLng');
  let placeNameA = nameA;
  let placeNameB = nameB;
  if (!placeNameA || placeNameA.trim() === '') {
    if (labelALat) labelALat.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
    if (labelALng) labelALng.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
    placeNameA = await getPlaceNameFromCoords(latA, lonA);
    await new Promise(resolve => setTimeout(resolve, 1000));
  }
  if (!placeNameB || placeNameB.trim() === '') {
    if (labelBLat) labelBLat.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
    if (labelBLng) labelBLng.innerHTML = '<span class="loading-dots">å–å¾—åœ°åä¸­</span>';
    placeNameB = await getPlaceNameFromCoords(latB, lonB);
  }
  if (labelALat) labelALat.innerHTML = `<span style="color:var(--title); font-weight:700;">${placeNameA}</span> ç·¯åº¦`;
  if (labelALng) labelALng.innerHTML = `<span style="color:var(--title); font-weight:700;">${placeNameA}</span> ç¶“åº¦`;
  if (labelBLat) labelBLat.innerHTML = `<span style="color:var(--title); font-weight:700;">${placeNameB}</span> ç·¯åº¦`;
  if (labelBLng) labelBLng.innerHTML = `<span style="color:var(--title); font-weight:700;">${placeNameB}</span> ç¶“åº¦`;
  window.elevationPointAName = placeNameA;
  window.elevationPointBName = placeNameB;
}
function dmsToDecimal(degrees, minutes, seconds) {
  const d = parseFloat(degrees) || 0;
  const m = parseFloat(minutes) || 0;
  const s = parseFloat(seconds) || 0;
  return d + m/60 + s/3600;
}
function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

/**
 * è¨ˆç®—åŒ…å«å¤©ç·šé«˜åº¦çš„3Dè·¯å¾‘ç¸½é•·åº¦ (è€ƒæ…®åœ°çƒæ›²åº¦)
 * @param {number} lat1 - Aé»ç·¯åº¦
 * @param {number} lon1 - Aé»ç¶“åº¦
 * @param {number} lat2 - Bé»ç·¯åº¦
 * @param {number} lon2 - Bé»ç¶“åº¦
 * @param {number} antennaHeight1 - Aé»å¤©ç·šé«˜åº¦ (å…¬å°º)
 * @param {number} antennaHeight2 - Bé»å¤©ç·šé«˜åº¦ (å…¬å°º)
 * @returns {number} 3Dç›´ç·šè·é›¢ (å…¬é‡Œ)
 */
function getDistance3D(lat1, lon1, lat2, lon2, antennaHeight1 = 0, antennaHeight2 = 0) {
  const R = 6371; // åœ°çƒåŠå¾‘ (å…¬é‡Œ)

  // å°‡ç¶“ç·¯åº¦è½‰æ›ç‚ºå¼§åº¦
  const lat1Rad = lat1 * Math.PI / 180;
  const lon1Rad = lon1 * Math.PI / 180;
  const lat2Rad = lat2 * Math.PI / 180;
  const lon2Rad = lon2 * Math.PI / 180;

  // è¨ˆç®—å…©é»å¾åœ°å¿ƒçš„è·é›¢ (åœ°çƒåŠå¾‘ + å¤©ç·šé«˜åº¦)
  const r1 = R + antennaHeight1 / 1000; // è½‰æ›å…¬å°ºç‚ºå…¬é‡Œ
  const r2 = R + antennaHeight2 / 1000;

  // å°‡çƒé¢åº§æ¨™è½‰æ›ç‚º3Dç›´è§’åº§æ¨™ç³» (åœ°å¿ƒç‚ºåŸé»)
  const x1 = r1 * Math.cos(lat1Rad) * Math.cos(lon1Rad);
  const y1 = r1 * Math.cos(lat1Rad) * Math.sin(lon1Rad);
  const z1 = r1 * Math.sin(lat1Rad);

  const x2 = r2 * Math.cos(lat2Rad) * Math.cos(lon2Rad);
  const y2 = r2 * Math.cos(lat2Rad) * Math.sin(lon2Rad);
  const z2 = r2 * Math.sin(lat2Rad);

  // è¨ˆç®—3Dç©ºé–“ä¸­çš„ç›´ç·šè·é›¢ (å¼¦é•·)
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dz = z2 - z1;
  const distance3D = Math.sqrt(dx * dx + dy * dy + dz * dz);

  return distance3D;
}
document.addEventListener('DOMContentLoaded', function() {
  const apiSelector = document.getElementById('elevationApiSelector');
  if (apiSelector) {
    apiSelector.addEventListener('change', function() {
      updateApiInfo();
    });
  }
});
function updateApiInfo() {
  const apiSelector = document.getElementById('elevationApiSelector');
  const apiInfo = document.getElementById('apiInfo');
  apiInfo.textContent = '';
}
async function runAnalysis() {
  const apiSelector = document.getElementById('elevationApiSelector');
  const selectedApi = apiSelector ? apiSelector.value : 'open-elevation';
  if (selectedApi === 'google-maps') {
    await runAnalysisWithGoogleMaps();
  } else if (selectedApi === 'taiwan-dsm') {
    await runAnalysisWithTaiwanDSM();
  } else {
    await runAnalysisWithOpenElevation();
  }
}
async function runAnalysisWithOpenElevation() {
  const sLat = parseFloat(document.getElementById('sLat').value);
  const sLng = parseFloat(document.getElementById('sLng').value);
  const eLat = parseFloat(document.getElementById('eLat').value);
  const eLng = parseFloat(document.getElementById('eLng').value);
  const numPoints = parseInt(document.getElementById('samples').value);
  if (isNaN(sLat) || isNaN(sLng) || isNaN(eLat) || isNaN(eLng)) {
    summary.innerText = 'âŒ è«‹è¼¸å…¥æ‰€æœ‰åº§æ¨™æ•¸å€¼';
    return;
  }
  const totalDist = getDistance(sLat, sLng, eLat, eLng);
  summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (åˆ†æä¸­<span class="loading-dots"></span>)</span>`;
  pathData = [];
  const locations = [];
  for (let i = 0; i < numPoints; i++) {
    const f = i / (numPoints - 1);
    const lat = sLat + (eLat - sLat) * f;
    const lng = sLng + (eLng - sLng) * f;
    locations.push({ latitude: lat, longitude: lng });
    pathData.push({ dist: (totalDist * f).toFixed(3), lat: lat.toFixed(6), lng: lng.toFixed(6), ele: null });
  }
  window.currentPathData = pathData;
  try {
    const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ locations })
    });
    if (!response.ok) {
      throw new Error(`API è¿”å›ç‹€æ…‹ ${response.status}`);
    }
    const result = await response.json();
    const elevations = result.results.map(r => r.elevation);
    // Store elevation in pathData
    elevations.forEach((ele, i) => {
      if (pathData[i]) {
        pathData[i].ele = ele;
      }
    });
    summary.innerText = `è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km`;
    renderChart(elevations);
  } catch (err) {
    summary.innerHTML = 'âŒ è³‡æ–™ç²å–å¤±æ•—<br><span style="color:#ffd43b; font-weight:bold;">ğŸŒ è©²åŠŸèƒ½éœ€é€£ç¶²</span><br>' + err.message;
  }
}
async function runAnalysisWithGoogleMaps() {
  const GOOGLE_API_KEY = 'AIzaSyBwd_GtAZq2eW6KgRRkro__aG7h5ZECJwo';
  const summary = document.getElementById('summary');
  const sLat = parseFloat(document.getElementById('sLat').value);
  const sLng = parseFloat(document.getElementById('sLng').value);
  const eLat = parseFloat(document.getElementById('eLat').value);
  const eLng = parseFloat(document.getElementById('eLng').value);
  const numPoints = parseInt(document.getElementById('samples').value);
  if (isNaN(sLat) || isNaN(sLng) || isNaN(eLat) || isNaN(eLng)) {
    summary.innerText = 'âŒ è«‹è¼¸å…¥æ‰€æœ‰åº§æ¨™æ•¸å€¼';
    return;
  }
  const totalDist = getDistance(sLat, sLng, eLat, eLng);
  summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (è¼‰å…¥ Google Maps API<span class="loading-dots"></span>)</span>`;
  pathData = [];
  const locations = [];
  for (let i = 0; i < numPoints; i++) {
    const f = i / (numPoints - 1);
    const lat = sLat + (eLat - sLat) * f;
    const lng = sLng + (eLng - sLng) * f;
    locations.push({ lat: lat, lng: lng });
    pathData.push({ dist: (totalDist * f).toFixed(3), lat: lat.toFixed(6), lng: lng.toFixed(6), ele: null });
  }
  window.currentPathData = pathData;
  try {
    if (!window.google || !window.google.maps) {
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=geometry`;
        script.async = true;
        script.defer = true;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (ä½¿ç”¨ Google Maps API åˆ†æä¸­<span class="loading-dots"></span>)</span>`;
    const elevator = new google.maps.ElevationService();
    const elevations = [];
    const batchSize = 512;
    const totalBatches = Math.ceil(locations.length / batchSize);
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const start = batchIndex * batchSize;
      const end = Math.min(start + batchSize, locations.length);
      const batch = locations.slice(start, end);
      summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (æ‰¹æ¬¡ ${batchIndex + 1}/${totalBatches}<span class="loading-dots"></span>)</span>`;
      const result = await new Promise((resolve, reject) => {
        elevator.getElevationForLocations({
          locations: batch
        }, (results, status) => {
          if (status === 'OK') {
            resolve(results);
          } else {
            reject(new Error(`Google Maps API ç‹€æ…‹: ${status}`));
          }
        });
      });
      const batchElevations = result.map(r => r.elevation);
      elevations.push(...batchElevations);
      if (batchIndex < totalBatches - 1) {
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }

    // è®€å–å¤©ç·šé«˜åº¦
    const antennaHeightStart = parseFloat(document.getElementById('antennaHeightStart').value) || 0;
    const antennaHeightEnd = parseFloat(document.getElementById('antennaHeightEnd').value) || 0;

    // è¨ˆç®—åŒ…å«å¤©ç·šé«˜åº¦çš„3Dç¸½è·é›¢
    const totalDist3D = getDistance3D(sLat, sLng, eLat, eLng, antennaHeightStart, antennaHeightEnd);
    const heightDiff = antennaHeightEnd - antennaHeightStart;

    let statusMessage = `<span style="color:#27ae60; font-weight:bold; font-size:14px;">âœ“ è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (Google Maps API)</span>`;

    // å¦‚æœæœ‰è¨­å®šå¤©ç·šé«˜åº¦,é¡¯ç¤º3Dè·é›¢
    if (antennaHeightStart > 0 || antennaHeightEnd > 0) {
      statusMessage += `<br><span style="color:#5ff0d5; font-size:13px;">ğŸ“¡ å«å¤©ç·šé«˜åº¦ 3D è·é›¢: ${totalDist3D.toFixed(3)} km</span>`;
      statusMessage += `<br><span style="color:#85c9ff; font-size:12px;">   (Aé»å¤©ç·š: ${antennaHeightStart}m, Bé»å¤©ç·š: ${antennaHeightEnd}m, é«˜åº¦å·®: ${heightDiff >= 0 ? '+' : ''}${heightDiff}m)</span>`;
    }

    summary.innerHTML = statusMessage;
    // Store elevation in pathData
    elevations.forEach((ele, i) => {
      if (pathData[i]) {
        pathData[i].ele = ele;
      }
    });
    renderChart(elevations);
  } catch (err) {
    summary.innerHTML = `âŒ Google Maps API è³‡æ–™ç²å–å¤±æ•—<br><span style="color:#ffd43b; font-weight:bold;">ğŸŒ è©²åŠŸèƒ½éœ€é€£ç¶²ä¸”éœ€æœ‰æ•ˆçš„ API é‡‘é‘°</span><br>${err.message}`;
  }
}
async function runAnalysisWithTaiwanDSM() {
  const summary = document.getElementById('summary');
  const sLat = parseFloat(document.getElementById('sLat').value);
  const sLng = parseFloat(document.getElementById('sLng').value);
  const eLat = parseFloat(document.getElementById('eLat').value);
  const eLng = parseFloat(document.getElementById('eLng').value);
  const numPoints = parseInt(document.getElementById('samples').value);
  if (isNaN(sLat) || isNaN(sLng) || isNaN(eLat) || isNaN(eLng)) {
    summary.innerText = 'âŒ è«‹è¼¸å…¥æ‰€æœ‰åº§æ¨™æ•¸å€¼';
    return;
  }
  if (sLat < 21.5 || sLat > 25.5 || sLng < 119.5 || sLng > 122.5 ||
    eLat < 21.5 || eLat > 25.5 || eLng < 119.5 || eLng > 122.5) {
    summary.innerHTML = 'âš ï¸ è­¦å‘Šï¼šåº§æ¨™è¶…å‡ºå°ç£ç¯„åœ<br>å…§æ”¿éƒ¨ DSM åƒ…æ¶µè“‹å°ç£åœ°å€';
  }
  const totalDist = getDistance(sLat, sLng, eLat, eLng);
  summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (ä½¿ç”¨å…§æ”¿éƒ¨ DSM 20m(å«å»ºç‰©) åˆ†æä¸­<span class="loading-dots"></span>)</span>`;
  pathData = [];
  const locations = [];
  for (let i = 0; i < numPoints; i++) {
    const f = i / (numPoints - 1);
    const lat = sLat + (eLat - sLat) * f;
    const lng = sLng + (eLng - sLng) * f;
    locations.push({ lat: lat, lng: lng });
    pathData.push({ dist: (totalDist * f).toFixed(3), lat: lat.toFixed(6), lng: lng.toFixed(6), ele: null });
  }
  window.currentPathData = pathData;
  try {
    if (!window.GeoTIFF) {
      summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è¼‰å…¥ GeoTIFF å‡½å¼åº«<span class="loading-dots"></span></span>`;
      await loadGeoTIFFLibrary();
    }
    summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (é€£æ¥ COG æª”æ¡ˆ<span class="loading-dots"></span>)</span>`;
    const cogFilename = 'taiwan_dsm_wgs84_cog.tif';
    let tiff = null;
    let image = null;

    // ğŸš€ å„ªåŒ–: ä½¿ç”¨å¿«å–ç³»çµ±
    if (localTifFileData && localTifFileData.tiff && localTifFileData.image) {
      summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (ä½¿ç”¨æœ¬åœ°æª”æ¡ˆ: ${localTifFileData.fileName}<span class="loading-dots"></span>)</span>`;

      // ä½¿ç”¨å¿«å–çš„æœ¬åœ°æª”æ¡ˆ
      const cached = await getCachedTiff(null, 'local');
      if (!cached.tiff) {
        // é¦–æ¬¡ä½¿ç”¨,å»ºç«‹å¿«å–
        cachedTiffData.local = localTifFileData.tiff;
        cachedImageData.local = localTifFileData.image;
        tiff = localTifFileData.tiff;
        image = localTifFileData.image;
      } else {
        tiff = cached.tiff;
        image = cached.image;
      }
    } else {
      // ğŸš€ å„ªåŒ–: ä½¿ç”¨å¿«å–çš„ GitHub æª”æ¡ˆ (ä¿æŒåŸæœ¬å„ªå…ˆé †åº: å…ˆåŒè³‡æ–™å¤¾,å¾Œ GitHub Pages)
      try {
        // å„ªå…ˆå˜—è©¦åŒè³‡æ–™å¤¾çš„æª”æ¡ˆ
        const cached = await getCachedTiff(cogFilename, 'github');
        tiff = cached.tiff;
        image = cached.image;
      } catch (err) {
        // å¤±æ•—æ‰å˜—è©¦ GitHub Pages
        const githubUrl = 'https://sulapon.github.io/GPS/taiwan_dsm_wgs84_cog.tif';
        try {
          const cached = await getCachedTiff(githubUrl, 'github');
          tiff = cached.tiff;
          image = cached.image;
        } catch (err2) {
          throw new Error(`ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆã€‚è«‹ç¢ºèª:\n1. æª”æ¡ˆ "${cogFilename}" å·²ä¸Šå‚³åˆ°æ­£ç¢ºä½ç½®\n2. GitHub Pages å·²å•Ÿç”¨\n3. æª”æ¡ˆåç¨±æ­£ç¢ºï¼ˆtaiwan_dsm_wgs84_cog.tifï¼‰\n\néŒ¯èª¤: ${err2.message}`);
        }
      }

      if (!tiff || !image) {
        throw new Error('ç„¡æ³•è¼‰å…¥ COG æª”æ¡ˆ');
      }

      summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (è®€å–å½±åƒè³‡è¨Š<span class="loading-dots"></span>)</span>`;
    }
    const bbox = image.getBoundingBox();
    const width = image.getWidth();
    const height = image.getHeight();
    summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (è®€å–é«˜åº¦æ•¸æ“š<span class="loading-dots"></span>)</span>`;
    const nodataHandling = document.getElementById('nodataHandling')?.value || 'interpolate';
    const elevations = [];
    let invalidDataCount = 0;
    const missingDataIndices = [];  // è¨˜éŒ„ç¼ºå¤±æ•¸æ“šçš„ç´¢å¼•
    const batchSize = 100;  // ğŸš€ å„ªåŒ–: å¢åŠ æ‰¹æ¬¡å¤§å°ä»¥æé«˜æ•ˆç‡
    
    // === ç¬¬ä¸€éšæ®µï¼šå¾ DSM è®€å–æ•¸æ“šï¼Œæ¨™è¨˜ç¼ºå¤±é» ===
    for (let batchStart = 0; batchStart < locations.length; batchStart += batchSize) {
      const batchEnd = Math.min(batchStart + batchSize, locations.length);
      const batch = locations.slice(batchStart, batchEnd);
      for (let i = 0; i < batch.length; i++) {
        const loc = batch[i];
        const globalIndex = batchStart + i;
        const pixelX = Math.floor((loc.lng - bbox[0]) / (bbox[2] - bbox[0]) * width);
        const pixelY = Math.floor((bbox[3] - loc.lat) / (bbox[3] - bbox[1]) * height);
        if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
          try {
            const rasters = await image.readRasters({
              window: [pixelX, pixelY, pixelX + 1, pixelY + 1]
            });
            const elevation = rasters[0][0];
            let validElevation = 0;
            let isInvalidData = false;
            if (elevation !== null && elevation !== undefined && !isNaN(elevation) && isFinite(elevation)) {
              const commonNoDataValues = [-32768, -9999, -99999, -12345, 32767, 65535, -3.4028235e+38];
              const isNoData = commonNoDataValues.some(noData => Math.abs(elevation - noData) < 0.01);
              if (!isNoData && elevation >= -500 && elevation <= 4000) {
                validElevation = elevation;
              } else {
                isInvalidData = true;
                invalidDataCount++;
                missingDataIndices.push(globalIndex);  // è¨˜éŒ„ç¼ºå¤±é»ç´¢å¼•
                if (nodataHandling === 'interpolate') {
                  if (elevations.length > 0) {
                    validElevation = elevations[elevations.length - 1];
                  } else {
                    validElevation = 0;
                  }
                } else if (nodataHandling === 'zero') {
                  validElevation = 0;
                } else if (nodataHandling === 'skip') {
                  validElevation = null;
                } else if (nodataHandling === 'google-api') {
                  validElevation = null;  // æš«æ™‚æ¨™è¨˜ç‚º nullï¼Œç¨å¾Œæ‰¹æ¬¡è™•ç†
                }
              }
            } else {
              isInvalidData = true;
              invalidDataCount++;
              missingDataIndices.push(globalIndex);  // è¨˜éŒ„ç¼ºå¤±é»ç´¢å¼•
              if (nodataHandling === 'interpolate') {
                if (elevations.length > 0) {
                  validElevation = elevations[elevations.length - 1];
                }
              } else if (nodataHandling === 'zero') {
                validElevation = 0;
              } else if (nodataHandling === 'skip') {
                validElevation = null;
              } else if (nodataHandling === 'google-api') {
                validElevation = null;  // æš«æ™‚æ¨™è¨˜ç‚º nullï¼Œç¨å¾Œæ‰¹æ¬¡è™•ç†
              }
            }
            elevations.push(validElevation);
          } catch (readErr) {
            invalidDataCount++;
            missingDataIndices.push(globalIndex);  // è¨˜éŒ„ç¼ºå¤±é»ç´¢å¼•
            let fallbackValue = 0;
            if (nodataHandling === 'interpolate' && elevations.length > 0) {
              fallbackValue = elevations[elevations.length - 1];
            } else if (nodataHandling === 'skip') {
              fallbackValue = null;
            } else if (nodataHandling === 'google-api') {
              fallbackValue = null;  // æš«æ™‚æ¨™è¨˜ç‚º nullï¼Œç¨å¾Œæ‰¹æ¬¡è™•ç†
            }
            elevations.push(fallbackValue);
          }
        } else {
          invalidDataCount++;
          missingDataIndices.push(globalIndex);  // è¨˜éŒ„ç¼ºå¤±é»ç´¢å¼•
          let fallbackValue = 0;
          if (nodataHandling === 'interpolate' && elevations.length > 0) {
            fallbackValue = elevations[elevations.length - 1];
          } else if (nodataHandling === 'skip') {
            fallbackValue = null;
          } else if (nodataHandling === 'google-api') {
            fallbackValue = null;  // æš«æ™‚æ¨™è¨˜ç‚º nullï¼Œç¨å¾Œæ‰¹æ¬¡è™•ç†
          }
          elevations.push(fallbackValue);
        }
      }
      const progress = Math.round((batchEnd) / locations.length * 100);
      summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (è™•ç†ä¸­ ${progress}%<span class="loading-dots"></span>)</span>`;
    }

    // === ç¬¬äºŒéšæ®µï¼šä½¿ç”¨ Google API æ‰¹æ¬¡è™•ç†ç¼ºå¤±é» ===
    if (nodataHandling === 'google-api' && missingDataIndices.length > 0) {
      summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (ä½¿ç”¨ Google API è£œå…… ${missingDataIndices.length} å€‹ç¼ºå¤±é»<span class="loading-dots"></span>)</span>`;
      
      try {
        // æ”¶é›†æ‰€æœ‰ç¼ºå¤±é»çš„åº§æ¨™
        const missingLocations = missingDataIndices.map(idx => locations[idx]);
        
        // æ‰¹æ¬¡å‘¼å« Google API (æ¯æ‰¹æœ€å¤š 512 é»)
        const googleElevations = await getBatchElevationFromGoogleAPI(missingLocations, summary, totalDist);
        
        // å°‡ Google API çš„çµæœå¡«å›å°æ‡‰ä½ç½®
        for (let i = 0; i < missingDataIndices.length; i++) {
          const idx = missingDataIndices[i];
          elevations[idx] = googleElevations[i];
          // ğŸ¯ ç«‹å³åŒæ­¥æ›´æ–°åˆ° pathData
          if (pathData[idx]) {
            pathData[idx].ele = googleElevations[i];
          }
        }
        
        summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (å·²è£œå…… ${missingDataIndices.length} å€‹ç¼ºå¤±é»<span class="loading-dots"></span>)</span>`;
      } catch (apiErr) {
        // Google API å¤±æ•—æ™‚ï¼Œä½¿ç”¨æ’å€¼æ³•å¡«è£œ
        summary.innerHTML = `<span style="color:#ff6b6b; font-weight:bold; font-size:14px;">âš ï¸ Google API å¤±æ•—ï¼Œæ”¹ç”¨æ’å€¼æ³•è™•ç†ç¼ºå¤±é»<span class="loading-dots"></span></span>`;
        for (let i = 0; i < missingDataIndices.length; i++) {
          const idx = missingDataIndices[i];
          let fallbackValue = 0;
          if (idx > 0 && elevations[idx - 1] !== null) {
            fallbackValue = elevations[idx - 1];
          }
          elevations[idx] = fallbackValue;
          // ğŸ¯ ç«‹å³åŒæ­¥æ›´æ–°åˆ° pathData
          if (pathData[idx]) {
            pathData[idx].ele = fallbackValue;
          }
        }
      }
    }

    // è®€å–å¤©ç·šé«˜åº¦
    const antennaHeightStart = parseFloat(document.getElementById('antennaHeightStart').value) || 0;
    const antennaHeightEnd = parseFloat(document.getElementById('antennaHeightEnd').value) || 0;

    // è¨ˆç®—åŒ…å«å¤©ç·šé«˜åº¦çš„3Dç¸½è·é›¢
    const totalDist3D = getDistance3D(sLat, sLng, eLat, eLng, antennaHeightStart, antennaHeightEnd);
    const heightDiff = antennaHeightEnd - antennaHeightStart;

    let statusMessage = `<span style="color:#27ae60; font-weight:bold; font-size:14px;">âœ“ è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (å…§æ”¿éƒ¨ DSM 20m å«å»ºç‰©)</span>`;

    // å¦‚æœæœ‰è¨­å®šå¤©ç·šé«˜åº¦,é¡¯ç¤º3Dè·é›¢
    if (antennaHeightStart > 0 || antennaHeightEnd > 0) {
      statusMessage += `<br><span style="color:#5ff0d5; font-size:13px;">ğŸ“¡ å«å¤©ç·šé«˜åº¦ 3D è·é›¢: ${totalDist3D.toFixed(3)} km</span>`;
      statusMessage += `<br><span style="color:#85c9ff; font-size:12px;">   (Aé»å¤©ç·š: ${antennaHeightStart}m, Bé»å¤©ç·š: ${antennaHeightEnd}m, é«˜åº¦å·®: ${heightDiff >= 0 ? '+' : ''}${heightDiff}m)</span>`;
    }

    if (invalidDataCount > 0) {
      const invalidPercent = ((invalidDataCount / elevations.length) * 100).toFixed(1);
      statusMessage += `<br><span style="color:#ffd43b; font-size:12px;">âš ï¸ æª¢æ¸¬åˆ° ${invalidDataCount} å€‹ç„¡æ•ˆæ•¸æ“šé» (${invalidPercent}%) - å·²ä½¿ç”¨ã€Œ${
        nodataHandling === 'interpolate' ? 'æ™ºæ…§æ’å€¼' :
        nodataHandling === 'zero' ? 'è¨­ç‚º0ç±³' :
        nodataHandling === 'google-api' ? 'Google API' :
        'æ¨™è¨˜ç„¡æ•ˆ'
      }ã€è™•ç†</span>`;
    }
    summary.innerHTML = statusMessage;
    // Store elevation in pathData
    elevations.forEach((ele, i) => {
      if (pathData[i]) {
        pathData[i].ele = ele;
      }
    });
    renderChart(elevations);
  } catch (err) {
    let errorMsg = `âŒ å…§æ”¿éƒ¨ DSM è³‡æ–™ç²å–å¤±æ•—<br><br>`;
    if (err.message.includes('Invalid byte order') || err.message.includes('GitHub Pages')) {
      errorMsg += `<div style="text-align:left; padding:10px; background:rgba(255,170,0,0.1); border-radius:6px; margin:10px 0;">
        <strong style="color:#ffd43b;">ğŸ“‹ è¨­å®š GitHub Pages æ­¥é©Ÿ:</strong><br>
        1ï¸âƒ£ é–‹å•Ÿ <a href="https://github.com/sulapon/GPS/settings/pages" target="_blank" style="color:#5ff0d5;">GitHub å°ˆæ¡ˆè¨­å®š</a><br>
        2ï¸âƒ£ åœ¨ Pages é¸é …ä¸­é¸æ“‡ "main" åˆ†æ”¯<br>
        3ï¸âƒ£ ç­‰å¾… 1-2 åˆ†é˜éƒ¨ç½²å®Œæˆ<br>
        4ï¸âƒ£ é‡æ–°åŸ·è¡Œåˆ†æ<br><br>
        <span style="color:#a8b3c3; font-size:12px;">æˆ–ä½¿ç”¨å…¶ä»–è³‡æ–™æºå¦‚ Google Maps API</span>
      </div>`;
    } else {
      errorMsg += `<span style="color:#ffd43b; font-weight:bold;">ğŸŒ è«‹ç¢ºèª:</span><br>
        â€¢ ç¶²è·¯é€£ç·šæ­£å¸¸<br>
        â€¢ GitHub Pages å·²å•Ÿç”¨<br>
        â€¢ COG æª”æ¡ˆå¯æ­£å¸¸è¨ªå•<br><br>
        <span style="font-size:12px; color:#a8b3c3;">éŒ¯èª¤è©³æƒ…: ${err.message}</span>`;
    }
    summary.innerHTML = errorMsg;
  }
}

/**
 * ä½¿ç”¨ Google Maps Elevation API æ‰¹æ¬¡ç²å–å¤šé»é«˜åº¦
 * ç”¨æ–¼ç¼ºå¤±æ•¸æ“šè™•ç†æ™‚çš„å‚™ç”¨é«˜åº¦ä¾†æº
 * @param {Array} locations - åº§æ¨™é™£åˆ— [{lat, lng}, ...]
 * @param {Element} summary - ç‹€æ…‹é¡¯ç¤ºå…ƒç´ 
 * @param {Number} totalDist - ç¸½è·é›¢ï¼ˆç”¨æ–¼é¡¯ç¤ºç‹€æ…‹ï¼‰
 * @returns {Array} é«˜åº¦é™£åˆ—
 */
async function getBatchElevationFromGoogleAPI(locations, summary, totalDist) {
  const GOOGLE_API_KEY = 'AIzaSyBwd_GtAZq2eW6KgRRkro__aG7h5ZECJwo';
  
  // ç¢ºä¿ Google Maps API å·²è¼‰å…¥
  if (!window.google || !window.google.maps) {
    if (summary) {
      summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è¼‰å…¥ Google Maps API<span class="loading-dots"></span></span>`;
    }
    await new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=geometry`;
      script.async = true;
      script.defer = true;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  
  const elevator = new google.maps.ElevationService();
  const elevations = [];
  const batchSize = 512;  // Google API æ¯æ‰¹æœ€å¤š 512 é»
  const totalBatches = Math.ceil(locations.length / batchSize);
  
  for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
    const start = batchIndex * batchSize;
    const end = Math.min(start + batchSize, locations.length);
    const batch = locations.slice(start, end);
    
    if (summary && totalDist) {
      summary.innerHTML = `<span style="color:#ffd43b; font-weight:bold; font-size:14px;">è·¯å¾‘ç¸½é•·åº¦: ${totalDist.toFixed(3)} km (Google API æ‰¹æ¬¡ ${batchIndex + 1}/${totalBatches}ï¼Œè™•ç† ${batch.length} å€‹ç¼ºå¤±é»<span class="loading-dots"></span>)</span>`;
    }
    
    const result = await new Promise((resolve, reject) => {
      elevator.getElevationForLocations({
        locations: batch
      }, (results, status) => {
        if (status === 'OK') {
          resolve(results);
        } else {
          reject(new Error(`Google Maps API ç‹€æ…‹: ${status}`));
        }
      });
    });
    
    const batchElevations = result.map(r => r.elevation);
    elevations.push(...batchElevations);
    
    // æ‰¹æ¬¡é–“å»¶é²ï¼Œé¿å…è¶…å‡ºé€Ÿç‡é™åˆ¶
    if (batchIndex < totalBatches - 1) {
      await new Promise(resolve => setTimeout(resolve, 200));
    }
  }
  
  return elevations;
}

/**
 * ä½¿ç”¨ Google Maps Elevation API ç²å–å–®é»é«˜åº¦ï¼ˆä¿ç•™ç”¨æ–¼å…¶ä»–åŠŸèƒ½ï¼‰
 */
async function getElevationFromGoogleAPI(lat, lng) {
  const result = await getBatchElevationFromGoogleAPI([{lat, lng}], null, null);
  return result[0];
}

async function loadGeoTIFFLibrary() {
  if (window.GeoTIFF) return;

  // å˜—è©¦ä¾åºå¾å¤šå€‹ä¾†æºè¼‰å…¥
  const sources = [
    'geotiff.js',                                                          // åŒç›®éŒ„æœ¬åœ°æª”æ¡ˆï¼ˆé›¢ç·šå„ªå…ˆï¼‰
    'https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js', // CDN 1
    'https://unpkg.com/geotiff@2.0.7/dist-browser/geotiff.js',            // CDN 2
  ];

  function tryLoad(src) {
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = src;
      s.async = true;
      s.onload = () => { if (window.GeoTIFF) resolve(); else reject(new Error('GeoTIFF æœªå®šç¾©')); };
      s.onerror = () => reject(new Error('ç„¡æ³•è¼‰å…¥: ' + src));
      document.head.appendChild(s);
    });
  }

  for (const src of sources) {
    try {
      await tryLoad(src);
      return; // æˆåŠŸå°±çµæŸ
    } catch (e) {
      // ç¹¼çºŒè©¦ä¸‹ä¸€å€‹
    }
  }

  throw new Error(
    'âŒ ç„¡æ³•è¼‰å…¥ GeoTIFF å‡½å¼åº«\n\n' +
    'ã€é›¢ç·šè§£æ±ºæ–¹æ³•ã€‘è«‹å°‡ geotiff.js æ”¾åˆ°èˆ‡ index.html ç›¸åŒç›®éŒ„\n\n' +
    'ä¸‹è¼‰ç¶²å€ï¼ˆæœ‰ç¶²è·¯æ™‚å…ˆä¸‹è¼‰å­˜æª”ï¼‰ï¼š\nhttps://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js'
  );
}
function renderChart(elevations) {
  const labelALat = document.getElementById('labelALat');
  const labelBLat = document.getElementById('labelBLat');
  if (labelALat && labelALat.innerHTML) {
    const matchA = labelALat.innerHTML.match(/<span[^>]*>([^<]+)<\/span>/);
    if (matchA && matchA[1]) {
      window.elevationPointAName = matchA[1].trim();
    }
  }
  if (labelBLat && labelBLat.innerHTML) {
    const matchB = labelBLat.innerHTML.match(/<span[^>]*>([^<]+)<\/span>/);
    if (matchB && matchB[1]) {
      window.elevationPointBName = matchB[1].trim();
    }
  }
  if (!window.elevationPointAName) {
    window.elevationPointAName = 'Aé»';
  }
  if (!window.elevationPointBName) {
    window.elevationPointBName = 'Bé»';
  }
  const antennaHeightStart = parseFloat(document.getElementById('antennaHeightStart').value) || 0;
  const antennaHeightEnd = parseFloat(document.getElementById('antennaHeightEnd').value) || 0;
  const adjustedElevations = elevations.map((elev, i) => {
    if (i === 0) {
      return elev + antennaHeightStart;
    } else if (i === elevations.length - 1) {
      return elev + antennaHeightEnd;
    }
    return elev;
  });
  elevationData = adjustedElevations;
  // å„²å­˜ç´”åœ°å½¢é«˜åº¦ï¼ˆä¸å«å¤©ç·šï¼‰ä¾› PDF å ±å‘Šä½¿ç”¨
  window.terrainEleA = elevations[0];
  window.terrainEleB = elevations[elevations.length - 1];
  const ctx = document.getElementById('elevationChart');
  if (!ctx) {
    return;
  }
  const pointColors = adjustedElevations.map((_, i) => '#059669');
  const losLine = adjustedElevations.map((_, i) =>
    adjustedElevations[0] + (adjustedElevations[adjustedElevations.length-1] - adjustedElevations[0]) * (i / (adjustedElevations.length-1))
  );
  const R = 6371000;
  const sLat = parseFloat(document.getElementById('sLat').value);
  const sLng = parseFloat(document.getElementById('sLng').value);
  const eLat = parseFloat(document.getElementById('eLat').value);
  const eLng = parseFloat(document.getElementById('eLng').value);
  const totalDist = getDistance(sLat, sLng, eLat, eLng);
  const totalDistM = totalDist * 1000;

  // ğŸ¯ åŒæ­¥æ›´æ–°RFå·¥å…·çš„Link Budgetè·é›¢ (ä½¿ç”¨åŒ…å«å¤©ç·šé«˜åº¦çš„3Dè·é›¢)
  const linkDistInput = document.getElementById('link_dist_km');
  if (linkDistInput) {
    // è¨ˆç®—åŒ…å«å¤©ç·šé«˜åº¦çš„3Dè·é›¢
    const totalDist3D = getDistance3D(sLat, sLng, eLat, eLng, antennaHeightStart, antennaHeightEnd);

    // ä½¿ç”¨3Dè·é›¢æ›´æ–°Link Budget
    linkDistInput.value = totalDist3D.toFixed(3);

    // è§¸ç™¼Link Budgeté‡æ–°è¨ˆç®—
    if (typeof calculateLinkBudget === 'function') {
      calculateLinkBudget();
    }

  }
  const losLineWithCurvature = adjustedElevations.map((_, i) => {
    const f = i / (adjustedElevations.length - 1);
    const distFromStart = totalDistM * f;
    const straightLineHeight = adjustedElevations[0] + (adjustedElevations[adjustedElevations.length-1] - adjustedElevations[0]) * f;
    const d1 = distFromStart;
    const d2 = totalDistM - distFromStart;
    const earthDrop = (d1 * d2) / (2 * R);
    return straightLineHeight - earthDrop;
  });

  // è¨ˆç®—è²æ¶…çˆ¾åŠå¾‘æ‰€éœ€çš„æ³¢é•·
  const freqMHz = parseFloat(document.getElementById('link_freq_mhz')?.value) || 2400;
  const freqHz = freqMHz * 1e6; // è½‰æ›ç‚º Hz
  const c = 299792458; // å…‰é€Ÿ m/s
  const lambda = c / freqHz; // æ³¢é•·
  if (chartInstance) {
    chartInstance.destroy();
  }
  if (typeof window.labelAOffset === 'undefined') {
    window.labelAOffset = { x: 0, y: -40 };
  }
  if (typeof window.labelBOffset === 'undefined') {
    window.labelBOffset = { x: 0, y: -40 };
  }
  if (typeof window.draggingLabel === 'undefined') {
    window.draggingLabel = null;
    window.dragStartX = 0;
    window.dragStartY = 0;
    window.dragStartOffsetX = 0;
    window.dragStartOffsetY = 0;
  }
  if (typeof window.labelTextVertical === 'undefined') {
    window.labelTextVertical = {
      A: false,
      B: false
    };
  }
  const pointLabelPlugin = {
    id: 'pointLabelPlugin',
    afterDatasetsDraw: (chart) => {
      const ctx = chart.ctx;
      const xAxis = chart.scales.x;
      const yAxis = chart.scales.y;
      const chartArea = chart.chartArea;
      const nameA = window.elevationPointAName || 'Aé»';
      const nameB = window.elevationPointBName || 'Bé»';
      const datasetIndex = 0;
      const dataset = chart.data.datasets[datasetIndex];
      if (dataset.data.length > 0) {
        const xA = xAxis.getPixelForValue(0);
        const yA = yAxis.getPixelForValue(dataset.data[0]);
        ctx.save();
        ctx.font = 'bold 14px Inter, sans-serif';
        const textWidthA = ctx.measureText(nameA).width;
        const paddingA = 8;
        const boxWidthA = textWidthA + paddingA * 2;
        const boxHeightA = 24;
        let labelXA = xA + window.labelAOffset.x;
        let labelYA = yA + window.labelAOffset.y;
        const halfBoxWidth = boxWidthA / 2;
        if (labelXA - halfBoxWidth < chartArea.left) {
          labelXA = chartArea.left + halfBoxWidth + 2;
        }
        if (labelXA + halfBoxWidth > chartArea.right) {
          labelXA = chartArea.right - halfBoxWidth - 2;
        }
        const halfBoxHeight = boxHeightA / 2;
        if (labelYA - halfBoxHeight < chartArea.top) {
          labelYA = chartArea.top + halfBoxHeight + 2;
        }
        if (labelYA + halfBoxHeight > chartArea.bottom) {
          labelYA = chartArea.bottom - halfBoxHeight - 2;
        }
        const boxY = labelYA - halfBoxHeight;
        const boxX = labelXA - halfBoxWidth;
        window.labelABounds = {
          x: boxX,
          y: boxY,
          width: boxWidthA,
          height: boxHeightA,
          centerX: labelXA,
          centerY: labelYA
        };
        if (window.draggingLabel === 'A') {
          ctx.fillStyle = 'rgba(255, 229, 143, 1)';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
          ctx.shadowBlur = 10;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 2;
        } else {
          ctx.fillStyle = 'rgba(255, 229, 143, 0.95)';
        }
        ctx.beginPath();
        ctx.roundRect(boxX, boxY, boxWidthA, boxHeightA, 5);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 200, 100, 1)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#022';
        if (window.labelTextVertical.A) {
          ctx.save();
          const chars = nameA.split('');
          const charHeight = boxHeightA / (chars.length + 1);
          chars.forEach((char, i) => {
            ctx.fillText(char, labelXA, boxY + charHeight * (i + 1));
          });
          ctx.restore();
        } else {
          ctx.fillText(nameA, labelXA, boxY + boxHeightA / 2);
        }
        ctx.fillStyle = 'rgba(0, 34, 34, 0.3)';
        ctx.beginPath();
        ctx.arc(boxX + 6, boxY + boxHeightA / 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(boxX + boxWidthA - 6, boxY + boxHeightA / 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      if (dataset.data.length > 0) {
        const lastIndex = dataset.data.length - 1;
        const xB = xAxis.getPixelForValue(lastIndex);
        const yB = yAxis.getPixelForValue(dataset.data[lastIndex]);
        ctx.save();
        ctx.font = 'bold 14px Inter, sans-serif';
        const textWidthB = ctx.measureText(nameB).width;
        const paddingB = 8;
        const boxWidthB = textWidthB + paddingB * 2;
        const boxHeightB = 24;
        let labelXB = xB + window.labelBOffset.x;
        let labelYB = yB + window.labelBOffset.y;
        const halfBoxWidth = boxWidthB / 2;
        if (labelXB - halfBoxWidth < chartArea.left) {
          labelXB = chartArea.left + halfBoxWidth + 2;
        }
        if (labelXB + halfBoxWidth > chartArea.right) {
          labelXB = chartArea.right - halfBoxWidth - 2;
        }
        const halfBoxHeight = boxHeightB / 2;
        if (labelYB - halfBoxHeight < chartArea.top) {
          labelYB = chartArea.top + halfBoxHeight + 2;
        }
        if (labelYB + halfBoxHeight > chartArea.bottom) {
          labelYB = chartArea.bottom - halfBoxHeight - 2;
        }
        const boxY = labelYB - halfBoxHeight;
        const boxX = labelXB - halfBoxWidth;
        window.labelBBounds = {
          x: boxX,
          y: boxY,
          width: boxWidthB,
          height: boxHeightB,
          centerX: labelXB,
          centerY: labelYB
        };
        if (window.draggingLabel === 'B') {
          ctx.fillStyle = 'rgba(255, 229, 143, 1)';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
          ctx.shadowBlur = 10;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 2;
        } else {
          ctx.fillStyle = 'rgba(255, 229, 143, 0.95)';
        }
        ctx.beginPath();
        ctx.roundRect(boxX, boxY, boxWidthB, boxHeightB, 5);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 200, 100, 1)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#022';
        if (window.labelTextVertical.B) {
          ctx.save();
          const chars = nameB.split('');
          const charHeight = boxHeightB / (chars.length + 1);
          chars.forEach((char, i) => {
            ctx.fillText(char, labelXB, boxY + charHeight * (i + 1));
          });
          ctx.restore();
        } else {
          ctx.fillText(nameB, labelXB, boxY + boxHeightB / 2);
        }
        ctx.fillStyle = 'rgba(0, 34, 34, 0.3)';
        ctx.beginPath();
        ctx.arc(boxX + 6, boxY + boxHeightB / 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(boxX + boxWidthB - 6, boxY + boxHeightB / 2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
  };
  const totalDistancePlugin = {
    id: 'totalDistance',
    afterDraw(chart) {
      const ctx = chart.ctx;
      const xAxis = chart.scales.x;
      const yAxis = chart.scales.y;
      const totalDist = pathData[pathData.length - 1].dist;
      ctx.save();
      ctx.font = '12px Arial';
      ctx.fillStyle = '#ffd43b';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'top';
      const text = `ç¸½è·é›¢: ${parseFloat(totalDist).toFixed(2)} km`;
      const x = xAxis.right + 2;  // å¾ -5 æ”¹ç‚º +2ï¼ˆå³ç§»ç´„7åƒç´ ï¼‰
      const y = yAxis.bottom + 28;  // å¾35æ”¹ç‚º28ï¼ˆä¸Šç§»7åƒç´ ï¼‰
      ctx.fillStyle = '#ffe58f';
      ctx.fillText(text, x, y);
      ctx.restore();
    }
  };
  // é »ç‡é¡¯ç¤ºæ’ä»¶
  const frequencyDisplayPlugin = {
    id: 'frequencyDisplay',
    afterDraw(chart) {
      // æª¢æŸ¥è²æ¶…çˆ¾å€æ˜¯å¦é¡¯ç¤ºï¼ˆindex 2 æ˜¯è²æ¶…çˆ¾å€ä¸Šç•Œï¼‰
      const fresnelMeta = chart.getDatasetMeta(2);

      // å¦‚æœè²æ¶…çˆ¾å€éš±è—(hidden=true)æˆ–æœªå®šç¾©æ™‚é è¨­ç‚ºtrueï¼Œå‰‡ä¸é¡¯ç¤ºé »ç‡
      const isHidden = fresnelMeta.hidden !== false;  // é è¨­è¦–ç‚ºéš±è—
      if (isHidden) return;

      const ctx = chart.ctx;
      const xAxis = chart.scales.x;
      const yAxis = chart.scales.y;

      // å–å¾—ç•¶å‰é »ç‡
      const freqMHz = parseFloat(document.getElementById('link_freq_mhz')?.value) || 2400;

      ctx.save();
      ctx.font = '12px Arial';  // èˆ‡ç¸½è·é›¢ç›¸åŒçš„å­—é«”
      ctx.fillStyle = '#ffe58f';  // èˆ‡ç¸½è·é›¢ç›¸åŒçš„é¡è‰²
      ctx.textAlign = 'right';  // æ”¹ç‚ºå³å°é½Š
      ctx.textBaseline = 'top';

      const text = `é »ç‡: ${freqMHz} MHz`;
      const x = xAxis.right + 2;  // å¾ -5 æ”¹ç‚º +2ï¼ˆå³ç§»ç´„7åƒç´ ï¼Œèˆ‡ç¸½è·é›¢å°é½Šï¼‰
      const y = yAxis.bottom + 43;  // å¾50æ”¹ç‚º43ï¼ˆä¸Šç§»7åƒç´ ï¼‰

      ctx.fillText(text, x, y);
      ctx.restore();
    }
  };
  window.currentSelectedPointIndex = -1;
  const pointRadiusArray = adjustedElevations.map((_, i) => 3);
  const pointHoverRadiusArray = adjustedElevations.map((_, i) => 8);
  const pointColorArray = adjustedElevations.map((_, i) => '#059669');
  chartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      labels: pathData.map(p => Math.round(parseFloat(p.dist)).toString()),
      datasets: [
        {
          label: 'åœ°å½¢æµ·æ‹” (m)',
          data: adjustedElevations,
          borderColor: '#059669',
          backgroundColor: 'rgba(5, 150, 105, 0.2)',
          fill: true,
          tension: 0.4,
          pointRadius: pointRadiusArray,
          pointHoverRadius: pointHoverRadiusArray,
          pointBackgroundColor: pointColorArray,
          pointBorderWidth: 0,
          order: 2,
          cubicInterpolationMode: 'monotone'
        },
        {
          label: 'è¦–è·é€£ç·š (è€ƒæ…®åœ°çƒæ›²åº¦)',
          data: losLineWithCurvature,
          borderColor: '#dc3545',
          borderDash: [5, 5],
          fill: false,
          pointRadius: 0,
          order: 3,
          tension: 0.4,
          cubicInterpolationMode: 'monotone'
        },
        {
          label: 'è²æ¶…çˆ¾å€ (60%)',
          data: losLineWithCurvature.map((losVal, i) => {
            // åœ¨èµ·é»å’Œçµ‚é»ï¼Œè²æ¶…çˆ¾å€åŠå¾‘æ‡‰è©²ç‚º 0
            if (i === 0 || i === adjustedElevations.length - 1) {
              return losVal;
            }

            const f = i / (adjustedElevations.length - 1);
            const distFromStartKm = totalDist * f;  // km
            const d1 = distFromStartKm;  // km
            const d2 = totalDist - distFromStartKm;  // km

            // é¡å¤–æª¢æŸ¥ï¼šå¦‚æœè·é›¢ç«¯é»å¤ªè¿‘ï¼ˆ< 0.1 kmï¼‰ï¼Œä¹Ÿè¿”å›è¦–è·ç·šå€¼
            if (d1 < 0.1 || d2 < 0.1) {
              return losVal;
            }

            // ä½¿ç”¨å·¥ç¨‹å…¬å¼è¨ˆç®—ç¬¬ä¸€è²æ¶…çˆ¾å€åŠå¾‘ (ç±³)
            // râ‚ = 17.3 Ã— âˆš(d1 Ã— d2 / (f Ã— D))
            const freqGHz = freqMHz / 1000;  // è½‰æ›ç‚º GHz
            const D = totalDist;  // ç¸½è·é›¢ km
            const fresnelRadius = 17.3 * Math.sqrt((d1 * d2) / (freqGHz * D));

            return losVal + fresnelRadius * 0.6;
          }),
          borderColor: 'rgba(255, 193, 7, 0.6)',
          borderDash: [3, 3],
          fill: false,
          pointRadius: 0,
          order: 4,
          tension: 0.4,
          cubicInterpolationMode: 'monotone',
          hidden: true  // é è¨­éš±è—
        },
        {
          label: 'è²æ¶…çˆ¾å€ä¸‹ç•Œ',
          data: losLineWithCurvature.map((losVal, i) => {
            // åœ¨èµ·é»å’Œçµ‚é»ï¼Œè²æ¶…çˆ¾å€åŠå¾‘æ‡‰è©²ç‚º 0
            if (i === 0 || i === adjustedElevations.length - 1) {
              return losVal;
            }

            const f = i / (adjustedElevations.length - 1);
            const distFromStartKm = totalDist * f;  // km
            const d1 = distFromStartKm;  // km
            const d2 = totalDist - distFromStartKm;  // km

            // é¡å¤–æª¢æŸ¥ï¼šå¦‚æœè·é›¢ç«¯é»å¤ªè¿‘ï¼ˆ< 0.1 kmï¼‰ï¼Œä¹Ÿè¿”å›è¦–è·ç·šå€¼
            if (d1 < 0.1 || d2 < 0.1) {
              return losVal;
            }

            const freqGHz = freqMHz / 1000;
            const D = totalDist;
            const fresnelRadius = 17.3 * Math.sqrt((d1 * d2) / (freqGHz * D));

            return losVal - fresnelRadius * 0.6;
          }),
          borderColor: 'rgba(255, 193, 7, 0.6)',
          borderDash: [3, 3],
          fill: false,
          pointRadius: 0,
          order: 4,
          tension: 0.4,
          cubicInterpolationMode: 'monotone',
          hidden: true  // é è¨­éš±è—
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: {
          left: 10,
          right: 20,
          top: 5,
          bottom: 5
        }
      },
      onClick: (event, elements) => {
        selectedPointsInCurrentHeight.clear();
        if (elements.length > 0) {
          const idx = elements[0].index;
          for (let i = 0; i < pointColorArray.length; i++) {
            if (i === idx) {
              pointColorArray[i] = '#ffd43b';
              pointRadiusArray[i] = 6;
              pointHoverRadiusArray[i] = 10;
            } else {
              pointColorArray[i] = '#059669';
              if (typeof greenPointsVisible !== 'undefined' && !greenPointsVisible) {
                pointRadiusArray[i] = 0;
                pointHoverRadiusArray[i] = 0;
              } else {
                pointRadiusArray[i] = 3;
                pointHoverRadiusArray[i] = 8;
              }
            }
          }
          window.currentSelectedPointIndex = idx;
          chartInstance.data.datasets[0].pointBackgroundColor = pointColorArray;
          chartInstance.data.datasets[0].pointRadius = pointRadiusArray;
          chartInstance.data.datasets[0].pointHoverRadius = pointHoverRadiusArray;
          chartInstance.update();
          // ğŸ¯ ä¿®å¾©ï¼šä½¿ç”¨ getElevationForIndex è€Œä¸æ˜¯ç›´æ¥ä½¿ç”¨ elevations
          showMap(idx, getElevationForIndex(idx));
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: (ctx) => `é«˜åº¦: ${ctx.parsed.y} m | è·é›¢: ${pathData[ctx.dataIndex].dist} km`
          }
        },
        legend: {
          labels: {
            color: '#e8eef5',
            font: { size: 14 },
            boxWidth: 15,
            boxHeight: 15,
            padding: 10,
            usePointStyle: false,
            filter: function(legendItem, chartData) {
              // éš±è—ã€Œè²æ¶…çˆ¾å€ä¸‹ç•Œã€åœ–ä¾‹é …ç›®
              return legendItem.text !== 'è²æ¶…çˆ¾å€ä¸‹ç•Œ';
            },
            generateLabels: function(chart) {
              const datasets = chart.data.datasets;
              return datasets
                .map((dataset, i) => {
                  const meta = chart.getDatasetMeta(i);
                  if (dataset.label === 'è²æ¶…çˆ¾å€ä¸‹ç•Œ') return null;
                  const isHidden = meta.hidden || !!dataset.hidden;
                  return {
                    text: dataset.label,
                    fillStyle: isHidden ? 'rgba(120,120,120,0.3)' : (dataset.backgroundColor || dataset.borderColor),
                    strokeStyle: isHidden ? 'rgba(120,120,120,0.4)' : dataset.borderColor,
                    lineWidth: dataset.borderWidth || 2,
                    hidden: false,
                    index: i,
                    datasetIndex: i,
                    fontColor: isHidden ? '#555e6a' : '#e8eef5',
                    lineDash: dataset.borderDash || []
                  };
                })
                .filter(item => item !== null);
            }
          },
          display: true,
          position: 'top',
          align: 'center',
          onClick: function(e, legendItem, legend) {
            const index = legendItem.datasetIndex;
            const chart = legend.chart;
            const meta = chart.getDatasetMeta(index);

            // å¦‚æœé»æ“Šçš„æ˜¯è²æ¶…çˆ¾å€ï¼ŒåŒæ™‚åˆ‡æ›ä¸Šç•Œå’Œä¸‹ç•Œ
            if (legendItem.text === 'è²æ¶…çˆ¾å€ (60%)') {
              const upperMeta = chart.getDatasetMeta(index);
              const lowerMeta = chart.getDatasetMeta(index + 1);

              // åˆ¤æ–·ç›®å‰ç‹€æ…‹ï¼ˆåŒæ™‚è€ƒæ…® meta å’Œ datasetï¼‰
              const currentHidden = upperMeta.hidden || !!chart.data.datasets[index].hidden;
              const newState = !currentHidden;
              upperMeta.hidden = newState;
              lowerMeta.hidden = newState;
              // åŒæ­¥æ¸…é™¤ dataset.hidden
              chart.data.datasets[index].hidden = newState;
              chart.data.datasets[index + 1].hidden = newState;
            } else {
              // åˆ¤æ–·ç›®å‰ç‹€æ…‹ï¼ˆåŒæ™‚è€ƒæ…® meta å’Œ datasetï¼‰
              const currentHidden = meta.hidden || !!chart.data.datasets[index].hidden;
              meta.hidden = !currentHidden;
              // åŒæ­¥æ¸…é™¤ dataset.hidden
              chart.data.datasets[index].hidden = !currentHidden;
            }

            chart.update();
          }
        }
      },
      scales: {
        x: {
          ticks: { color: '#e8eef5', font: { size: 12 }, maxRotation: 0, minRotation: 0 },
          grid: { color: 'rgba(255, 255, 255, 0.1)' },
          title: { display: true, text: 'è·é›¢ (km)', color: '#e8eef5' },
          min: isNaN(parseFloat(document.getElementById('minDistance').value)) ? undefined : parseFloat(document.getElementById('minDistance').value),
          max: isNaN(parseFloat(document.getElementById('maxDistance').value)) ? undefined : parseFloat(document.getElementById('maxDistance').value)
        },
        y: {
          ticks: { color: '#e8eef5', font: { size: 12 } },
          grid: { color: 'rgba(255, 255, 255, 0.1)' },
          title: { display: true, text: 'é«˜åº¦ (m)', color: '#e8eef5' },
          min: isNaN(parseFloat(document.getElementById('minElevation').value)) ? undefined : parseFloat(document.getElementById('minElevation').value),
          max: isNaN(parseFloat(document.getElementById('maxElevation').value)) ? undefined : parseFloat(document.getElementById('maxElevation').value)
        }
      }
    },
    plugins: [pointLabelPlugin, totalDistancePlugin, frequencyDisplayPlugin]
  });
  const canvas = document.getElementById('elevationChart');
  function isPointInLabel(x, y, labelBounds) {
    if (!labelBounds) return false;
    return x >= labelBounds.x &&
         x <= labelBounds.x + labelBounds.width &&
         y >= labelBounds.y &&
         y <= labelBounds.y + labelBounds.height;
  }
  function getMousePos(canvas, evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: evt.clientX - rect.left,
      y: evt.clientY - rect.top
    };
  }
  canvas.addEventListener('mousedown', function(e) {
    const pos = getMousePos(canvas, e);
    window.clickStartTime = Date.now();
    window.clickStartPos = { x: pos.x, y: pos.y };
    if (isPointInLabel(pos.x, pos.y, window.labelABounds)) {
      window.draggingLabel = 'A';
      window.dragStartX = pos.x;
      window.dragStartY = pos.y;
      window.dragStartOffsetX = window.labelAOffset.x;
      window.dragStartOffsetY = window.labelAOffset.y;
      canvas.style.cursor = 'grabbing';
      e.preventDefault();
    } else if (isPointInLabel(pos.x, pos.y, window.labelBBounds)) {
      window.draggingLabel = 'B';
      window.dragStartX = pos.x;
      window.dragStartY = pos.y;
      window.dragStartOffsetX = window.labelBOffset.x;
      window.dragStartOffsetY = window.labelBOffset.y;
      canvas.style.cursor = 'grabbing';
      e.preventDefault();
    }
  });
  canvas.addEventListener('mousemove', function(e) {
    const pos = getMousePos(canvas, e);
    if (window.draggingLabel) {
      const deltaX = pos.x - window.dragStartX;
      const deltaY = pos.y - window.dragStartY;
      if (window.draggingLabel === 'A') {
        window.labelAOffset.x = window.dragStartOffsetX + deltaX;
        window.labelAOffset.y = window.dragStartOffsetY + deltaY;
      } else if (window.draggingLabel === 'B') {
        window.labelBOffset.x = window.dragStartOffsetX + deltaX;
        window.labelBOffset.y = window.dragStartOffsetY + deltaY;
      }
      chartInstance.update('none');
      e.preventDefault();
    } else {
      if (isPointInLabel(pos.x, pos.y, window.labelABounds) ||
        isPointInLabel(pos.x, pos.y, window.labelBBounds)) {
        canvas.style.cursor = 'grab';
      } else {
        canvas.style.cursor = 'default';
      }
    }
  });
  canvas.addEventListener('mouseup', function(e) {
    const pos = getMousePos(canvas, e);
    const clickDuration = Date.now() - (window.clickStartTime || 0);
    const moveDistance = window.clickStartPos ?
      Math.sqrt(Math.pow(pos.x - window.clickStartPos.x, 2) + Math.pow(pos.y - window.clickStartPos.y, 2)) : 0;
    const isClick = clickDuration < 300 && moveDistance < 5;
    if (window.draggingLabel && isClick) {
      const label = window.draggingLabel;
      window.labelTextVertical[label] = !window.labelTextVertical[label];
    }
    if (window.draggingLabel) {
      window.draggingLabel = null;
      canvas.style.cursor = 'default';
      chartInstance.update();
    }
  });
  canvas.addEventListener('mouseleave', function(e) {
    if (window.draggingLabel) {
      window.draggingLabel = null;
      canvas.style.cursor = 'default';
      chartInstance.update();
    }
  });
  canvas.addEventListener('touchstart', function(e) {
    if (e.touches.length === 1) {
      const touch = e.touches[0];
      const pos = getMousePos(canvas, touch);
      if (isPointInLabel(pos.x, pos.y, window.labelABounds)) {
        window.draggingLabel = 'A';
        window.dragStartX = pos.x;
        window.dragStartY = pos.y;
        window.dragStartOffsetX = window.labelAOffset.x;
        window.dragStartOffsetY = window.labelAOffset.y;
        e.preventDefault();
      } else if (isPointInLabel(pos.x, pos.y, window.labelBBounds)) {
        window.draggingLabel = 'B';
        window.dragStartX = pos.x;
        window.dragStartY = pos.y;
        window.dragStartOffsetX = window.labelBOffset.x;
        window.dragStartOffsetY = window.labelBOffset.y;
        e.preventDefault();
      }
    }
  });
  canvas.addEventListener('touchmove', function(e) {
    if (window.draggingLabel && e.touches.length === 1) {
      const touch = e.touches[0];
      const pos = getMousePos(canvas, touch);
      const deltaX = pos.x - window.dragStartX;
      const deltaY = pos.y - window.dragStartY;
      if (window.draggingLabel === 'A') {
        window.labelAOffset.x = window.dragStartOffsetX + deltaX;
        window.labelAOffset.y = window.dragStartOffsetY + deltaY;
      } else if (window.draggingLabel === 'B') {
        window.labelBOffset.x = window.dragStartOffsetX + deltaX;
        window.labelBOffset.y = window.dragStartOffsetY + deltaY;
      }
      chartInstance.update('none');
      e.preventDefault();
    }
  });
  canvas.addEventListener('touchend', function(e) {
    if (window.draggingLabel) {
      window.draggingLabel = null;
      chartInstance.update();
    }
  });
  const selectedPointInput = document.getElementById('selectedPointIndex');
  let currentSelectedIndex = 0;
  if (selectedPointInput && selectedPointInput.value) {
    currentSelectedIndex = parseInt(selectedPointInput.value) - 1;
    if (currentSelectedIndex < 0 || currentSelectedIndex >= adjustedElevations.length) {
      currentSelectedIndex = 0;
    }
  } else if (isFirstProfileGeneration) {
    if (selectedPointInput) {
      selectedPointInput.value = 1;
    }
    currentSelectedIndex = 0;
  }
  // ğŸ¯ ä¿®å¾©ï¼šä½¿ç”¨ getElevationForIndex è€Œä¸æ˜¯ç›´æ¥ä½¿ç”¨ adjustedElevations
  showMap(currentSelectedIndex, getElevationForIndex(currentSelectedIndex));
  if (isFirstProfileGeneration) {
    isFirstProfileGeneration = false;
  }
  showRouteMap();
}
let greenPointsVisible = false;
function toggleGreenPoints() {
  if (!chartInstance || !chartInstance.data.datasets[0]) {
    alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  const btn = document.getElementById('toggleGreenPointsBtn');
  const pointRadiusArray = chartInstance.data.datasets[0].pointRadius;
  const pointHoverRadiusArray = chartInstance.data.datasets[0].pointHoverRadius;
  const currentSelectedIndex = window.currentSelectedPointIndex || -1;
  greenPointsVisible = !greenPointsVisible;
  if (greenPointsVisible) {
    btn.innerHTML = 'ğŸ‘ï¸ éš±è—ç¯€é»';
    btn.style.background = 'linear-gradient(90deg,#28a745,#20c997)';
    for (let i = 0; i < pointRadiusArray.length; i++) {
      if (i === currentSelectedIndex) {
        pointRadiusArray[i] = 6;
        pointHoverRadiusArray[i] = 10;
      } else {
        pointRadiusArray[i] = 3;
        pointHoverRadiusArray[i] = 8;
      }
    }
  } else {
    btn.innerHTML = 'ğŸ‘ï¸ é¡¯ç¤ºç¯€é»';
    btn.style.background = 'linear-gradient(90deg,#6c757d,#5a6268)';
    for (let i = 0; i < pointRadiusArray.length; i++) {
      if (i === currentSelectedIndex) {
        pointRadiusArray[i] = 6;
        pointHoverRadiusArray[i] = 10;
      } else {
        pointRadiusArray[i] = 0;
        pointHoverRadiusArray[i] = 0;
      }
    }
  }
  chartInstance.data.datasets[0].pointRadius = pointRadiusArray;
  chartInstance.data.datasets[0].pointHoverRadius = pointHoverRadiusArray;
  chartInstance.update();
}
function updateChartYAxis() {
  const minValue = parseFloat(document.getElementById('minElevation').value);
  const maxValue = parseFloat(document.getElementById('maxElevation').value);
  if (chartInstance) {
    chartInstance.options.scales.y.min = isNaN(minValue) ? undefined : minValue;
    chartInstance.options.scales.y.max = isNaN(maxValue) ? undefined : maxValue;
    chartInstance.update();
  }
  if (fullscreenChartInstance) {
    fullscreenChartInstance.options.scales.y.min = isNaN(minValue) ? undefined : minValue;
    fullscreenChartInstance.options.scales.y.max = isNaN(maxValue) ? undefined : maxValue;
    fullscreenChartInstance.update();
  }
}
function updateChartXAxis() {
  const minValue = parseFloat(document.getElementById('minDistance').value);
  const maxValue = parseFloat(document.getElementById('maxDistance').value);
  if (chartInstance) {
    chartInstance.options.scales.x.min = isNaN(minValue) ? undefined : minValue;
    chartInstance.options.scales.x.max = isNaN(maxValue) ? undefined : maxValue;
    chartInstance.update();
  }
  if (fullscreenChartInstance) {
    fullscreenChartInstance.options.scales.x.min = isNaN(minValue) ? undefined : minValue;
    fullscreenChartInstance.options.scales.x.max = isNaN(maxValue) ? undefined : maxValue;
    fullscreenChartInstance.update();
  }
}
let fullscreenChartInstance = null;
let fullscreenLabelAOffset = { x: 0, y: -30 };
let fullscreenLabelBOffset = { x: 0, y: -30 };
let fullscreenDraggingLabel = null;
let fullscreenIgnoreNextClick = false;
let tooltipDraggingFullscreen = false;
let tooltipOffsetX = 0;
let tooltipOffsetY = -100;

// å¼·åˆ¶ç¶å®štooltipæ‹–æ›³åŠŸèƒ½çš„å‡½æ•¸
function makeTooltipDraggable(tooltipEl) {

  let isDragging = false;
  let startX = 0;
  let startY = 0;
  let startOffsetX = 0;
  let startOffsetY = 0;

  // æ»‘é¼ æŒ‰ä¸‹
  tooltipEl.addEventListener('mousedown', function(e) {
    isDragging = true;
    tooltipDraggingFullscreen = true;

    startX = e.clientX;
    startY = e.clientY;
    startOffsetX = tooltipOffsetX;
    startOffsetY = tooltipOffsetY;

    tooltipEl.style.transition = 'none';
    tooltipEl.style.border = '2px solid #ffd43b';
    tooltipEl.style.cursor = 'grabbing';

    e.preventDefault();
    e.stopPropagation();
  });

  // æ»‘é¼ ç§»å‹•ï¼ˆå…¨å±€ç›£è½ï¼‰
  document.addEventListener('mousemove', function(e) {
    if (!isDragging) return;

    const deltaX = e.clientX - startX;
    const deltaY = e.clientY - startY;

    tooltipOffsetX = startOffsetX + deltaX;
    tooltipOffsetY = startOffsetY + deltaY;

    // ç›´æ¥æ›´æ–°ä½ç½®
    if (window.currentSelectedPointIndex !== undefined && fullscreenChartInstance) {
      const canvas = document.getElementById('elevationChartFullscreen');
      if (canvas) {
        const xScale = fullscreenChartInstance.scales.x;
        const yScale = fullscreenChartInstance.scales.y;
        const dataset = fullscreenChartInstance.data.datasets.find(d =>
          d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
        );

        if (dataset && dataset.data[window.currentSelectedPointIndex] !== undefined) {
          const pixelX = xScale.getPixelForValue(window.currentSelectedPointIndex);
          const pixelY = yScale.getPixelForValue(dataset.data[window.currentSelectedPointIndex]);
          const rect = canvas.getBoundingClientRect();

          tooltipEl.style.left = (rect.left + pixelX + tooltipOffsetX) + 'px';
          tooltipEl.style.top = (rect.top + pixelY + tooltipOffsetY) + 'px';
        }
      }
    }

    e.preventDefault();
  });

  // æ»‘é¼ æ”¾é–‹ï¼ˆå…¨å±€ç›£è½ï¼‰
  document.addEventListener('mouseup', function() {
    if (!isDragging) return;

    isDragging = false;
    tooltipDraggingFullscreen = false;

    tooltipEl.style.transition = 'all .1s ease';
    tooltipEl.style.border = '2px solid #4dabf7';
    tooltipEl.style.cursor = 'move';

    // ğŸ¯ ä¿å­˜ tooltip åç§»é‡
    if (window.lastFullscreenState) {
      window.lastFullscreenState.tooltipOffsetX = tooltipOffsetX;
      window.lastFullscreenState.tooltipOffsetY = tooltipOffsetY;
    }
  });

  // è§¸æ§æ”¯æ´
  tooltipEl.addEventListener('touchstart', function(e) {
    isDragging = true;
    tooltipDraggingFullscreen = true;

    const touch = e.touches[0];
    startX = touch.clientX;
    startY = touch.clientY;
    startOffsetX = tooltipOffsetX;
    startOffsetY = tooltipOffsetY;

    tooltipEl.style.transition = 'none';
    tooltipEl.style.border = '2px solid #ffd43b';

    e.preventDefault();
    e.stopPropagation();
  });

  document.addEventListener('touchmove', function(e) {
    if (!isDragging || e.touches.length !== 1) return;

    const touch = e.touches[0];
    const deltaX = touch.clientX - startX;
    const deltaY = touch.clientY - startY;

    tooltipOffsetX = startOffsetX + deltaX;
    tooltipOffsetY = startOffsetY + deltaY;

    // ç›´æ¥æ›´æ–°ä½ç½®
    if (window.currentSelectedPointIndex !== undefined && fullscreenChartInstance) {
      const canvas = document.getElementById('elevationChartFullscreen');
      if (canvas) {
        const xScale = fullscreenChartInstance.scales.x;
        const yScale = fullscreenChartInstance.scales.y;
        const dataset = fullscreenChartInstance.data.datasets.find(d =>
          d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
        );

        if (dataset && dataset.data[window.currentSelectedPointIndex] !== undefined) {
          const pixelX = xScale.getPixelForValue(window.currentSelectedPointIndex);
          const pixelY = yScale.getPixelForValue(dataset.data[window.currentSelectedPointIndex]);
          const rect = canvas.getBoundingClientRect();

          tooltipEl.style.left = (rect.left + pixelX + tooltipOffsetX) + 'px';
          tooltipEl.style.top = (rect.top + pixelY + tooltipOffsetY) + 'px';
        }
      }
    }

    e.preventDefault();
  }, { passive: false });

  document.addEventListener('touchend', function() {
    if (!isDragging) return;

    isDragging = false;
    tooltipDraggingFullscreen = false;

    tooltipEl.style.transition = 'all .1s ease';
    tooltipEl.style.border = '2px solid #4dabf7';

    // ğŸ¯ ä¿å­˜ tooltip åç§»é‡
    if (window.lastFullscreenState) {
      window.lastFullscreenState.tooltipOffsetX = tooltipOffsetX;
      window.lastFullscreenState.tooltipOffsetY = tooltipOffsetY;
    }
  });
}
function openChartFullscreen() {
  // ğŸ¯ è¨˜éŒ„é€²å…¥å…¨å±å‰çš„ç‹€æ…‹
  const fullscreenState = {
    infoVisible: fullscreenInfoVisible,
    obstructionEnabled: obstructionColorEnabled,
    selectedPointIndex: window.currentSelectedPointIndex,
    tooltipOffsetX: tooltipOffsetX,
    tooltipOffsetY: tooltipOffsetY,
    labelAOffset: fullscreenLabelAOffset ? {...fullscreenLabelAOffset} : { x: 0, y: -30 },
    labelBOffset: fullscreenLabelBOffset ? {...fullscreenLabelBOffset} : { x: 0, y: -30 }
  };
  // ä¿å­˜åˆ°å…¨å±€è®Šæ•¸
  window.lastFullscreenState = fullscreenState;

  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    || (window.innerWidth <= 768 && window.innerHeight <= 768)
    || ('ontouchstart' in window);
  fullscreenInfoVisible = true;
  obstructionColorEnabled = false;
  if (!chartInstance || !chartInstance.data) {
    alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  const overlay = document.getElementById('chartFullscreenOverlay');
  overlay.classList.add('active');
  document.body.style.overflow = 'hidden';
  fullscreenLabelAOffset = { x: 0, y: -30 };
  fullscreenLabelBOffset = { x: 0, y: -30 };
  const elem = overlay;
  const enterFullscreen = () => {
    if (elem.requestFullscreen) {
      return elem.requestFullscreen({ navigationUI: "hide" });
    } else if (elem.webkitRequestFullscreen) {
      return elem.webkitRequestFullscreen();
    } else if (elem.mozRequestFullScreen) {
      return elem.mozRequestFullScreen();
    } else if (elem.msRequestFullscreen) {
      return elem.msRequestFullscreen();
    }
    return Promise.reject(new Error('ä¸æ”¯æ´å…¨è¢å¹•'));
  };
  enterFullscreen().then(() => {
    setTimeout(() => {
      if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('landscape').then(() => {
        }).catch(err => {
          if (screen.lockOrientation) {
            screen.lockOrientation('landscape');
          } else if (screen.mozLockOrientation) {
            screen.mozLockOrientation('landscape');
          } else if (screen.msLockOrientation) {
            screen.msLockOrientation('landscape');
          }
        });
      }
    }, 300);
  }).catch(err => {
  });
  setTimeout(() => {
    const ctx = document.getElementById('elevationChartFullscreen');
    if (fullscreenChartInstance) {
      fullscreenChartInstance.destroy();
    }
    const originalData = chartInstance.data;
    const originalOptions = chartInstance.options;
    const fullscreenLabelPlugin = {
      id: 'fullscreenLabelPlugin',
      beforeDraw: (chart) => {
        const ctx = chart.ctx;
        ctx.save();
        // ğŸ¨ æ ¹æ“šä¸»é¡Œè¨­å®šèƒŒæ™¯è‰²
        const bgColor = chart.options.chartBackgroundColor || '#000000';
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, chart.width, chart.height);
        ctx.restore();
      },
      afterDatasetsDraw: (chart) => {
        const ctx = chart.ctx;
        const xAxis = chart.scales.x;
        const yAxis = chart.scales.y;
        const chartArea = chart.chartArea;
        const nameA = window.elevationPointAName || 'Aé»';
        const nameB = window.elevationPointBName || 'Bé»';
        const datasetIndex = 0;
        const dataset = chart.data.datasets[datasetIndex];
        if (dataset.data.length > 0) {
          const xA = xAxis.getPixelForValue(0);
          const yA = yAxis.getPixelForValue(dataset.data[0]);
          ctx.save();
          ctx.font = 'bold 13px Inter, sans-serif';
          const textWidthA = ctx.measureText(nameA).width;
          const paddingA = 6;
          const boxWidthA = textWidthA + paddingA * 2;
          const boxHeightA = 22;
          let labelXA = xA + fullscreenLabelAOffset.x;
          let labelYA = yA + fullscreenLabelAOffset.y;
          const halfBoxWidth = boxWidthA / 2;
          if (labelXA - halfBoxWidth < chartArea.left) {
            labelXA = chartArea.left + halfBoxWidth + 2;
          }
          if (labelXA + halfBoxWidth > chartArea.right) {
            labelXA = chartArea.right - halfBoxWidth - 2;
          }
          const halfBoxHeight = boxHeightA / 2;
          if (labelYA - halfBoxHeight < chartArea.top) {
            labelYA = chartArea.top + halfBoxHeight + 2;
          }
          if (labelYA + halfBoxHeight > chartArea.bottom) {
            labelYA = chartArea.bottom - halfBoxHeight - 2;
          }
          const boxY = labelYA - halfBoxHeight;
          const boxX = labelXA - halfBoxWidth;
          window.fullscreenLabelABounds = {
            x: boxX, y: boxY,
            width: boxWidthA, height: boxHeightA,
            centerX: labelXA, centerY: labelYA
          };
          if (fullscreenDraggingLabel === 'A') {
            ctx.fillStyle = 'rgba(255, 229, 143, 1)';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 10;
          } else {
            ctx.fillStyle = 'rgba(255, 229, 143, 0.95)';
          }
          ctx.beginPath();
          ctx.roundRect(boxX, boxY, boxWidthA, boxHeightA, 5);
          ctx.fill();
          ctx.strokeStyle = 'rgba(255, 200, 100, 1)';
          ctx.lineWidth = 1.5;
          ctx.stroke();
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = '#022';
          ctx.fillText(nameA, labelXA, boxY + boxHeightA / 2);
          ctx.fillStyle = 'rgba(0, 34, 34, 0.3)';
          ctx.beginPath();
          ctx.arc(boxX + 6, boxY + boxHeightA / 2, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(boxX + boxWidthA - 6, boxY + boxHeightA / 2, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        if (dataset.data.length > 0) {
          const lastIndex = dataset.data.length - 1;
          const xB = xAxis.getPixelForValue(lastIndex);
          const yB = yAxis.getPixelForValue(dataset.data[lastIndex]);
          ctx.save();
          ctx.font = 'bold 13px Inter, sans-serif';
          const textWidthB = ctx.measureText(nameB).width;
          const paddingB = 6;
          const boxWidthB = textWidthB + paddingB * 2;
          const boxHeightB = 22;
          let labelXB = xB + fullscreenLabelBOffset.x;
          let labelYB = yB + fullscreenLabelBOffset.y;
          const halfBoxWidth = boxWidthB / 2;
          if (labelXB - halfBoxWidth < chartArea.left) {
            labelXB = chartArea.left + halfBoxWidth + 2;
          }
          if (labelXB + halfBoxWidth > chartArea.right) {
            labelXB = chartArea.right - halfBoxWidth - 2;
          }
          const halfBoxHeight = boxHeightB / 2;
          if (labelYB - halfBoxHeight < chartArea.top) {
            labelYB = chartArea.top + halfBoxHeight + 2;
          }
          if (labelYB + halfBoxHeight > chartArea.bottom) {
            labelYB = chartArea.bottom - halfBoxHeight - 2;
          }
          const boxY = labelYB - halfBoxHeight;
          const boxX = labelXB - halfBoxWidth;
          window.fullscreenLabelBBounds = {
            x: boxX, y: boxY,
            width: boxWidthB, height: boxHeightB,
            centerX: labelXB, centerY: labelYB
          };
          if (fullscreenDraggingLabel === 'B') {
            ctx.fillStyle = 'rgba(255, 229, 143, 1)';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 10;
          } else {
            ctx.fillStyle = 'rgba(255, 229, 143, 0.95)';
          }
          ctx.beginPath();
          ctx.roundRect(boxX, boxY, boxWidthB, boxHeightB, 5);
          ctx.fill();
          ctx.strokeStyle = 'rgba(255, 200, 100, 1)';
          ctx.lineWidth = 1.5;
          ctx.stroke();
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = '#022';
          ctx.fillText(nameB, labelXB, boxY + boxHeightB / 2);
          ctx.fillStyle = 'rgba(0, 34, 34, 0.3)';
          ctx.beginPath();
          ctx.arc(boxX + 6, boxY + boxHeightB / 2, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(boxX + boxWidthB - 6, boxY + boxHeightB / 2, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }
    };
    const fullscreenTotalDistancePlugin = {
      id: 'fullscreenTotalDistance',
      afterDraw(chart) {
        const ctx = chart.ctx;
        const xAxis = chart.scales.x;
        const yAxis = chart.scales.y;
        if (!window.currentPathData || window.currentPathData.length === 0) return;
        const pathData = window.currentPathData;
        const totalDist = pathData[pathData.length - 1].dist;

        // ğŸ¨ æ ¹æ“šèƒŒæ™¯è‰²æ±ºå®šæ–‡å­—é¡è‰²
        const bgColor = chart.options.chartBackgroundColor || '#0b1526';
        const textColor = bgColor === '#e0f2fe' ? '#0c4a6e' : '#ffe58f';  // æ·¡è—åº•ç”¨æ·±è—æ–‡å­—ï¼Œé»‘åº•ç”¨é»ƒæ–‡å­—

        // é¡¯ç¤ºç¸½è·é›¢ï¼ˆå³ä¸‹ï¼‰
        ctx.save();
        ctx.font = '13px Arial';
        ctx.fillStyle = textColor;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        const text = `ç¸½è·é›¢: ${parseFloat(totalDist).toFixed(2)} km`;
        const x = xAxis.right - 1;  // å¾ -8 æ”¹ç‚º -1ï¼ˆå³ç§»ç´„7åƒç´ ï¼‰
        const y = yAxis.bottom + 30;  // å¾38æ”¹ç‚º30ï¼ˆä¸Šç§»8åƒç´ ï¼‰
        ctx.fillText(text, x, y);
        ctx.restore();

        // é¡¯ç¤ºé »ç‡ï¼ˆå³ä¸‹ï¼Œç¸½è·é›¢ä¸‹æ–¹ï¼‰- åªåœ¨è²æ¶…çˆ¾å€é¡¯ç¤ºæ™‚æ‰é¡¯ç¤º
        // æª¢æŸ¥è²æ¶…çˆ¾å€æ˜¯å¦é¡¯ç¤ºï¼ˆindex 2 æ˜¯è²æ¶…çˆ¾å€ä¸Šç•Œï¼‰
        const fresnelMeta = chart.getDatasetMeta(2);

        // å¦‚æœè²æ¶…çˆ¾å€éš±è—(hidden=true)æˆ–æœªå®šç¾©æ™‚é è¨­ç‚ºtrueï¼Œå‰‡ä¸é¡¯ç¤ºé »ç‡
        const isHidden = fresnelMeta.hidden !== false;  // é è¨­è¦–ç‚ºéš±è—
        if (!isHidden) {
          const freqMHz = parseFloat(document.getElementById('link_freq_mhz')?.value) || 2400;
          ctx.save();
          ctx.font = '13px Arial';  // èˆ‡ç¸½è·é›¢ç›¸åŒçš„å­—é«”
          ctx.fillStyle = textColor;  // ğŸ¨ ä½¿ç”¨ç›¸åŒçš„å‹•æ…‹é¡è‰²
          ctx.textAlign = 'right';  // æ”¹ç‚ºå³å°é½Š
          ctx.textBaseline = 'top';
          const freqText = `é »ç‡: ${freqMHz} MHz`;
          const freqX = xAxis.right - 1;  // å¾ -8 æ”¹ç‚º -1ï¼ˆå³ç§»ç´„7åƒç´ ï¼Œèˆ‡ç¸½è·é›¢å°é½Šï¼‰
          const freqY = yAxis.bottom + 45;  // å¾53æ”¹ç‚º45ï¼ˆä¸Šç§»8åƒç´ ï¼‰
          ctx.fillText(freqText, freqX, freqY);
          ctx.restore();
        }
      }
    };
    fullscreenChartInstance = new Chart(ctx, {
      type: 'line',
      data: {
        labels: originalData.labels,
        datasets: originalData.datasets.map((dataset, index) => {
          const dataLength = dataset.data.length;
          const pointBgColor = Array.isArray(dataset.pointBackgroundColor)
            ? dataset.pointBackgroundColor.slice()
            : new Array(dataLength).fill(dataset.pointBackgroundColor || 'transparent');
          const pointBColor = Array.isArray(dataset.pointBorderColor)
            ? dataset.pointBorderColor.slice()
            : new Array(dataLength).fill(dataset.pointBorderColor || 'transparent');
          const pointR = Array.isArray(dataset.pointRadius)
            ? dataset.pointRadius.slice()
            : new Array(dataLength).fill(dataset.pointRadius || 0);
          const pointHR = Array.isArray(dataset.pointHoverRadius)
            ? dataset.pointHoverRadius.slice()
            : new Array(dataLength).fill(dataset.pointHoverRadius || 6);

          // ç‚ºå…¨è¢å¹•æ¨¡å¼ç°¡åŒ–æ¨™ç±¤æ–‡å­—
          let displayLabel = dataset.label;
          if (dataset.label === 'åœ°å½¢æµ·æ‹” (m)') {
            displayLabel = 'æµ·æ‹”';
          } else if (dataset.label === 'è¦–è·é€£ç·š (è€ƒæ…®åœ°çƒæ›²åº¦)') {
            displayLabel = 'è¦–è· (å«åœ°çƒæ›²åº¦)';
          } else if (dataset.label === 'è²æ¶…çˆ¾å€ (60%)') {
            displayLabel = 'è²æ¶…çˆ¾60%å€';
          }

          // æ±ºå®š hidden ç‹€æ…‹ï¼šå„ªå…ˆä½¿ç”¨ä¿å­˜çš„ç‹€æ…‹ï¼Œå¦å‰‡ä½¿ç”¨åŸå§‹åœ–è¡¨çš„ç‹€æ…‹
          let hiddenState = dataset.hidden;
          if (window.lastFullscreenState && window.lastFullscreenState.datasetHiddenStates) {
            if (window.lastFullscreenState.datasetHiddenStates.hasOwnProperty(index)) {
              hiddenState = window.lastFullscreenState.datasetHiddenStates[index];
            }
          }

          return {
            label: displayLabel,
            data: dataset.data,
            borderColor: dataset.borderColor,
            backgroundColor: dataset.backgroundColor,
            tension: dataset.tension || 0.4,
            fill: dataset.fill,
            borderWidth: dataset.borderWidth || 2,
            pointRadius: pointR,
            pointBackgroundColor: pointBgColor,
            pointBorderColor: pointBColor,
            pointHoverRadius: pointHR,
            pointHoverBackgroundColor: dataset.pointHoverBackgroundColor,
            pointHoverBorderColor: dataset.pointHoverBorderColor,
            pointHoverBorderWidth: dataset.pointHoverBorderWidth || 2,
            borderDash: dataset.borderDash,
            order: dataset.order,
            hidden: hiddenState  // ä½¿ç”¨æ±ºå®šå¾Œçš„ hidden ç‹€æ…‹
          };
        })
      },
      options: {
        chartBackgroundColor: '#0b1526',  // ğŸ¨ é è¨­èƒŒæ™¯è‰²ï¼ˆæ·±è‰²ï¼‰
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'nearest',
          axis: 'x',
          intersect: false
        },
        layout: {
          padding: {
            left: 10,
            right: 20,
            top: 5,
            bottom: 5
          }
        },
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: {
              color: '#e8eef5',
              font: { size: 12 },
              padding: 5,
              boxWidth: 15,
              boxHeight: 15,
              filter: function(legendItem, chartData) {
                // éš±è—ã€Œè²æ¶…çˆ¾å€ä¸‹ç•Œã€åœ–ä¾‹é …ç›®
                return legendItem.text !== 'è²æ¶…çˆ¾å€ä¸‹ç•Œ';
              },
              generateLabels: function(chart) {
                const datasets = chart.data.datasets;
                return datasets
                  .map((dataset, i) => {
                    const meta = chart.getDatasetMeta(i);
                    if (dataset.label === 'è²æ¶…çˆ¾å€ä¸‹ç•Œ') return null;
                    const isHidden = meta.hidden || !!dataset.hidden;
                    return {
                      text: dataset.label,
                      fillStyle: isHidden ? 'rgba(120,120,120,0.3)' : (dataset.backgroundColor || dataset.borderColor),
                      strokeStyle: isHidden ? 'rgba(120,120,120,0.4)' : dataset.borderColor,
                      lineWidth: dataset.borderWidth || 2,
                      hidden: false,
                      index: i,
                      datasetIndex: i,
                      fontColor: isHidden ? '#555e6a' : '#e8eef5',
                      lineDash: dataset.borderDash || []
                    };
                  })
                  .filter(item => item !== null);
              }
            },
            align: 'start',
            onClick: function(e, legendItem, legend) {
              const index = legendItem.datasetIndex;
              const chart = legend.chart;
              const meta = chart.getDatasetMeta(index);

              // å¦‚æœé»æ“Šçš„æ˜¯è²æ¶…çˆ¾å€ï¼ŒåŒæ™‚åˆ‡æ›ä¸Šç•Œå’Œä¸‹ç•Œ
              if (legendItem.text === 'è²æ¶…çˆ¾60%å€') {
                const upperMeta = chart.getDatasetMeta(index);
                const lowerMeta = chart.getDatasetMeta(index + 1);

                // åˆ¤æ–·ç›®å‰ç‹€æ…‹ï¼ˆåŒæ™‚è€ƒæ…® meta å’Œ datasetï¼‰
                const currentHidden = upperMeta.hidden || !!chart.data.datasets[index].hidden;
                const newState = !currentHidden;
                upperMeta.hidden = newState;
                lowerMeta.hidden = newState;
                // åŒæ­¥æ¸…é™¤ dataset.hidden
                chart.data.datasets[index].hidden = newState;
                chart.data.datasets[index + 1].hidden = newState;
              } else {
                // åˆ¤æ–·ç›®å‰ç‹€æ…‹ï¼ˆåŒæ™‚è€ƒæ…® meta å’Œ datasetï¼‰
                const currentHidden = meta.hidden || !!chart.data.datasets[index].hidden;
                meta.hidden = !currentHidden;
                // åŒæ­¥æ¸…é™¤ dataset.hidden
                chart.data.datasets[index].hidden = !currentHidden;
              }

              chart.update();
            }
          },
          tooltip: {
            enabled: false,
            position: 'nearest',
            mode: 'index',
            intersect: false,
            external: function(context) {
              if (typeof fullscreenInfoVisible !== 'undefined' && !fullscreenInfoVisible) {
                return;
              }
              const fullscreenContainer = document.getElementById('chartFullscreenOverlay');
              let tooltipEl = fullscreenContainer ? fullscreenContainer.querySelector('#chartjs-tooltip-fullscreen') : null;
              if (!tooltipEl) {
                tooltipEl = document.createElement('div');
                tooltipEl.id = 'chartjs-tooltip-fullscreen';
                tooltipEl.style.background = 'rgba(13, 71, 161, 0.35)';
                tooltipEl.style.borderRadius = '8px';
                tooltipEl.style.color = 'white';
                tooltipEl.style.opacity = '0';
                tooltipEl.style.pointerEvents = 'auto';
                tooltipEl.style.position = 'fixed';
                tooltipEl.style.transform = 'translate(-50%, -120%)';
                tooltipEl.style.transition = 'all .1s ease';
                tooltipEl.style.padding = '10px 12px';
                tooltipEl.style.border = '2px solid #4dabf7';
                tooltipEl.style.fontSize = '13px';
                tooltipEl.style.lineHeight = '1.5';
                tooltipEl.style.zIndex = '10002';
                tooltipEl.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                tooltipEl.style.whiteSpace = 'nowrap';
                tooltipEl.style.cursor = 'move';
                if (fullscreenContainer) {
                  fullscreenContainer.appendChild(tooltipEl);
                  makeTooltipDraggable(tooltipEl);
                }
              }
              const tooltipModel = context.tooltip;
              if (tooltipModel.opacity === 0) {
                tooltipEl.style.opacity = '0';
                return;
              }
              if (tooltipModel.body && tooltipModel.dataPoints && tooltipModel.dataPoints.length > 0) {
                const index = tooltipModel.dataPoints[0].dataIndex;
                const dataset = tooltipModel.dataPoints[0].dataset;
                const dataValue = dataset.data[index];
                const totalPoints = dataset.data.length;
                const sLat = parseFloat(document.getElementById('sLat').value);
                const sLng = parseFloat(document.getElementById('sLng').value);
                const eLat = parseFloat(document.getElementById('eLat').value);
                const eLng = parseFloat(document.getElementById('eLng').value);
                const totalDistance = getDistance(sLat, sLng, eLat, eLng);
                const distanceFromStart = (index / (totalPoints - 1)) * totalDistance;
                const distanceFromEnd = totalDistance - distanceFromStart;
                const fraction = index / (totalPoints - 1);
                const currentLat = sLat + (eLat - sLat) * fraction;
                const currentLng = sLng + (eLng - sLng) * fraction;
                const startName = window.elevationPointAName || 'Aé»';
                const endName = window.elevationPointBName || 'Bé»';
                let clearanceValue = 0;
                let clearanceText = '';
                let obstructionStatus = '';
                const losDataset = context.chart.data.datasets.find(d => d.label && (d.label.includes('è¦–è·é€£ç·š') || d.label.includes('è¦–è·')));
                if (losDataset && losDataset.data[index] !== undefined) {
                  const losHeight = losDataset.data[index];
                  clearanceValue = losHeight - dataValue;
                  if (clearanceValue > 0) {
                    clearanceText = `+${clearanceValue.toFixed(2)} m`;
                    obstructionStatus = 'ç„¡é®è”½';
                  } else if (clearanceValue < 0) {
                    clearanceText = `${clearanceValue.toFixed(2)} m`;
                    obstructionStatus = 'æœ‰é®è”½';
                  } else {
                    clearanceText = '0.00 m';
                    obstructionStatus = 'ç„¡é®è”½';
                  }
                }
                const clearanceColor = clearanceValue >= 0 ? '#4caf50' : '#ff4444';
                const innerHTML = `
                  <div class="tooltip-drag-handle" style="position:absolute; top:2px; right:2px; width:24px; height:24px; cursor:move; display:flex; align-items:center; justify-content:center; opacity:0.7; font-size:16px; user-select:none;" title="æ‹–æ›³ç§»å‹•">â ¿</div>
                  <div style="font-weight:bold; margin-bottom:5px; font-size:14px;">ä½ç½®è³‡è¨Š: ${index + 1}</div>
                  <div>è·é›¢${startName}: ${distanceFromStart.toFixed(3)} km</div>
                  <div>è·é›¢${endName}: ${distanceFromEnd.toFixed(3)} km</div>
                  <div>æµ·æ‹”é«˜åº¦: ${dataValue.toFixed(0)} m</div>
                  <div>åº§æ¨™: ${currentLat.toFixed(6)}, ${currentLng.toFixed(6)}</div>
                  <div style="color: ${clearanceColor}; font-weight: bold;">${obstructionStatus}: ${clearanceText}</div>
                `;
                tooltipEl.innerHTML = innerHTML;
              }
              const position = context.chart.canvas.getBoundingClientRect();
              let tooltipX = position.left + tooltipModel.caretX;
              let tooltipY = position.top + tooltipModel.caretY;
              tooltipEl.style.opacity = '0';
              tooltipEl.style.left = tooltipX + 'px';
              tooltipEl.style.top = tooltipY + 'px';
              tooltipEl.style.transform = 'translate(-50%, -120%)';
              const tooltipRect = tooltipEl.getBoundingClientRect();
              const tooltipWidth = tooltipRect.width;
              const tooltipHeight = tooltipRect.height;
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              let transformX = '-50%';
              let transformY = '-120%';
              const spaceAbove = tooltipY;
              const spaceBelow = viewportHeight - tooltipY;
              if (spaceAbove < tooltipHeight + 30) {
                if (spaceBelow > tooltipHeight + 30) {
                  transformY = '20%';
                } else {
                  if (spaceAbove > spaceBelow) {
                    transformY = '-50%';
                    tooltipY = Math.min(tooltipY, spaceAbove - tooltipHeight/2);
                  } else {
                    transformY = '-50%';
                    tooltipY = Math.max(tooltipY, tooltipHeight/2);
                  }
                }
              }
              const spaceLeft = tooltipX;
              const spaceRight = viewportWidth - tooltipX;
              if (tooltipX - tooltipWidth / 2 < 20) {
                transformX = '0%';
                tooltipX = Math.max(20, tooltipX);
              } else if (tooltipX + tooltipWidth / 2 > viewportWidth - 20) {
                transformX = '-100%';
                tooltipX = Math.min(viewportWidth - 20, tooltipX);
              }
              if (tooltipManualPosition) {
                tooltipEl.style.left = tooltipManualPosition.x + 'px';
                tooltipEl.style.top = tooltipManualPosition.y + 'px';
                tooltipEl.style.transform = 'translate(-50%, -50%)';
                tooltipEl.style.opacity = '1';
              } else {
                tooltipEl.style.transform = `translate(${transformX}, ${transformY})`;
                tooltipEl.style.left = tooltipX + 'px';
                tooltipEl.style.top = tooltipY + 'px';
                tooltipEl.style.opacity = '1';
              }
            }
          }
        },
        scales: {
          y: {
            ticks: {
              color: '#a8b3c3',
              font: { size: 11 },
              padding: 5
            },
            grid: { color: 'rgba(255,255,255,0.1)' },
            title: {
              display: true,
              text: 'é«˜åº¦ (m)',
              color: '#85c9ff',
              font: { size: 13 },
              padding: { bottom: 5 }
            },
            min: isNaN(parseFloat(document.getElementById('minElevation').value)) ? undefined : parseFloat(document.getElementById('minElevation').value),
            max: isNaN(parseFloat(document.getElementById('maxElevation').value)) ? undefined : parseFloat(document.getElementById('maxElevation').value)
          },
          x: {
            ticks: {
              color: '#a8b3c3',
              font: { size: 11 },
              maxRotation: 0,
              minRotation: 0,
              autoSkip: true,
              maxTicksLimit: 15
            },
            grid: { color: 'rgba(255,255,255,0.1)' },
            title: {
              display: true,
              text: 'è·é›¢ (km)',
              color: '#85c9ff',
              font: { size: 13 },
              padding: { top: 5 }
            },
            min: isNaN(parseFloat(document.getElementById('minDistance').value)) ? undefined : parseFloat(document.getElementById('minDistance').value),
            max: isNaN(parseFloat(document.getElementById('maxDistance').value)) ? undefined : parseFloat(document.getElementById('maxDistance').value)
          }
        },
        onClick: (event, elements, chart) => {

          // ========== å„ªå…ˆåº¦1: æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°è—è‰²è¨Šæ¯æ¡† ==========
          const fullscreenContainer = document.getElementById('chartFullscreenOverlay');
          const tooltipEl = fullscreenContainer ? fullscreenContainer.querySelector('#chartjs-tooltip-fullscreen') : null;
          if (tooltipEl && event.native) {
            const target = event.native.target || event.native.srcElement;
            if (tooltipEl.contains(target) || tooltipEl === target) {
              return;
            }
          }

          // ========== å„ªå…ˆåº¦2: æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°åœ°åæ¨™ç±¤ ==========
          if (event.native) {
            const canvas = chart.canvas;
            const rect = canvas.getBoundingClientRect();
            const clickX = event.native.clientX - rect.left;
            const clickY = event.native.clientY - rect.top;

            // æª¢æŸ¥é»æ˜¯å¦åœ¨æ¨™ç±¤å…§
            const checkPointInLabel = (x, y, bounds) => {
              if (!bounds) return false;
              const inBounds = x >= bounds.x && x <= bounds.x + bounds.width &&
                       y >= bounds.y && y <= bounds.y + bounds.height;
              return inBounds;
            };

            if (checkPointInLabel(clickX, clickY, window.fullscreenLabelABounds)) {
              return;
            }

            if (checkPointInLabel(clickX, clickY, window.fullscreenLabelBBounds)) {
              return;
            }
          }

          // ========== å„ªå…ˆåº¦3: æ­£å¸¸æ›´æ–°å°é»ƒé»ä½ç½® ==========
          const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
          let idx = -1;
          if (elements.length > 0) {
            idx = elements[0].index;
          } else {
            const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
            if (dataX !== null && dataX !== undefined) {
              const labels = chart.data.labels;
              let minDist = Infinity;
              let closestIdx = 0;
              for (let i = 0; i < labels.length; i++) {
                const dist = Math.abs(i - dataX);
                if (dist < minDist) {
                  minDist = dist;
                  closestIdx = i;
                }
              }
              if (minDist < 2) {
                idx = closestIdx;
              }
            }
          }
          if (idx >= 0) {
            if (typeof fullscreenInfoVisible === 'undefined' || !fullscreenInfoVisible) {
              return;
            }
            window.currentSelectedPointIndex = idx;
            const fullscreenPointInput = document.getElementById('fullscreenPointInput');
            if (fullscreenPointInput) {
              fullscreenPointInput.value = idx + 1;
              fullscreenPointInput.style.display = 'none';
              fullscreenPointInput.offsetHeight;
              fullscreenPointInput.style.display = '';
            }
            if (typeof chartInstance !== 'undefined' && chartInstance) {
              const mainDataset = chartInstance.data.datasets[0];
              if (mainDataset && typeof pointColorArray !== 'undefined') {
                for (let i = 0; i < pointColorArray.length; i++) {
                  if (i === idx) {
                    pointColorArray[i] = '#ffd43b';
                    pointRadiusArray[i] = 6;
                    pointHoverRadiusArray[i] = 10;
                  } else {
                    pointColorArray[i] = '#059669';
                    if (typeof greenPointsVisible !== 'undefined' && !greenPointsVisible) {
                      pointRadiusArray[i] = 0;
                      pointHoverRadiusArray[i] = 0;
                    } else {
                      pointRadiusArray[i] = 3;
                      pointHoverRadiusArray[i] = 8;
                    }
                  }
                }
                mainDataset.pointBackgroundColor = pointColorArray.slice();
                mainDataset.pointRadius = pointRadiusArray.slice();
                mainDataset.pointHoverRadius = pointHoverRadiusArray.slice();
                chartInstance.update('none');
              }
            }
            const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
              d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
            );
            if (fullscreenDataset && fullscreenDataset.data) {
              const fullscreenPointColors = new Array(fullscreenDataset.data.length);
              const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
              const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
              const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);
              for (let i = 0; i < fullscreenDataset.data.length; i++) {
                if (i === idx) {
                  fullscreenPointColors[i] = '#ffd43b';
                  fullscreenPointRadius[i] = 8;
                  fullscreenPointHoverRadius[i] = 12;
                  fullscreenPointBorderColor[i] = '#fff';
                } else {
                  fullscreenPointColors[i] = 'transparent';
                  fullscreenPointRadius[i] = 0;
                  fullscreenPointHoverRadius[i] = 6;
                  fullscreenPointBorderColor[i] = 'transparent';
                }
              }
              fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
              fullscreenDataset.pointRadius = fullscreenPointRadius;
              fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
              fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
              fullscreenDataset.pointBorderWidth = 2;
              fullscreenChartInstance.update('none');

              // ğŸ¯ æ›´æ–°ä¿å­˜çš„ç‹€æ…‹
              if (window.lastFullscreenState) {
                window.lastFullscreenState.selectedPointIndex = idx;
              }
            }
            const selectedPointInput = document.getElementById('selectedPointIndex');
            if (selectedPointInput) {
              selectedPointInput.value = idx + 1;
            }
            if (typeof elevations !== 'undefined' && elevations[idx] !== undefined) {
              showMap(idx, getElevationForIndex(idx));
            }
          } else {
            if (fullscreenChartInstance.tooltip) {
              fullscreenChartInstance.tooltip.setActiveElements([], {x: 0, y: 0});
              fullscreenChartInstance.update('none');
            }
          }
        },
        onHover: (event, elements, chart) => {
          if (preventHoverUpdate) {
            return;
          }
          if (typeof fullscreenInfoVisible === 'undefined' || !fullscreenInfoVisible) {
            return;
          }
          let idx = -1;
          if (elements.length > 0) {
            idx = elements[0].index;
          }
          if (idx >= 0 && idx !== window.currentSelectedPointIndex) {
            window.currentSelectedPointIndex = idx;
            const fullscreenPointInput = document.getElementById('fullscreenPointInput');
            if (fullscreenPointInput) {
              fullscreenPointInput.value = idx + 1;
              fullscreenPointInput.style.display = 'none';
              fullscreenPointInput.offsetHeight;
              fullscreenPointInput.style.display = '';
            }
            const selectedPointInput = document.getElementById('selectedPointIndex');
            if (selectedPointInput) {
              selectedPointInput.value = idx + 1;
            }
            const fullscreenDataset = chart.data.datasets.find(d =>
              d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
            );
            if (fullscreenDataset && fullscreenDataset.data) {
              const fullscreenPointColors = new Array(fullscreenDataset.data.length);
              const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
              const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
              const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);
              for (let i = 0; i < fullscreenDataset.data.length; i++) {
                if (i === idx) {
                  fullscreenPointColors[i] = '#ffd43b';
                  fullscreenPointRadius[i] = 8;
                  fullscreenPointHoverRadius[i] = 12;
                  fullscreenPointBorderColor[i] = '#fff';
                } else {
                  fullscreenPointColors[i] = 'transparent';
                  fullscreenPointRadius[i] = 0;
                  fullscreenPointHoverRadius[i] = 6;
                  fullscreenPointBorderColor[i] = 'transparent';
                }
              }
              fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
              fullscreenDataset.pointRadius = fullscreenPointRadius;
              fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
              fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
              fullscreenDataset.pointBorderWidth = 2;
              chart.update('none');
            }
            const canvas = document.getElementById('elevationChartFullscreen');
            const fullscreenContainer = document.getElementById('chartFullscreenOverlay');
            if (canvas && fullscreenContainer && fullscreenChartInstance) {
              const xScale = fullscreenChartInstance.scales.x;
              const yScale = fullscreenChartInstance.scales.y;
              const dataset = fullscreenChartInstance.data.datasets.find(d =>
                d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
              );
              if (dataset && dataset.data[idx] !== undefined) {
                const pixelX = xScale.getPixelForValue(idx);
                const pixelY = yScale.getPixelForValue(dataset.data[idx]);
                let tooltipEl = fullscreenContainer.querySelector('#chartjs-tooltip-fullscreen');
                if (!tooltipEl) {
                  tooltipEl = document.createElement('div');
                  tooltipEl.id = 'chartjs-tooltip-fullscreen';
                  tooltipEl.style.background = 'rgba(13, 71, 161, 0.35)';
                  tooltipEl.style.borderRadius = '8px';
                  tooltipEl.style.color = 'white';
                  tooltipEl.style.opacity = '0';
                  tooltipEl.style.pointerEvents = 'auto';
                  tooltipEl.style.position = 'fixed';
                  tooltipEl.style.transform = 'translate(-50%, -120%)';
                  tooltipEl.style.transition = 'all .1s ease';
                  tooltipEl.style.padding = '10px 12px';
                  tooltipEl.style.border = '2px solid #4dabf7';
                  tooltipEl.style.fontSize = '13px';
                  tooltipEl.style.lineHeight = '1.5';
                  tooltipEl.style.zIndex = '10002';
                  tooltipEl.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
                  tooltipEl.style.whiteSpace = 'nowrap';
                  tooltipEl.style.cursor = 'move';
                  fullscreenContainer.appendChild(tooltipEl);
                  makeTooltipDraggable(tooltipEl);
                }
                const dataValue = dataset.data[idx];
                const totalPoints = dataset.data.length;
                const sLat = parseFloat(document.getElementById('sLat').value);
                const sLng = parseFloat(document.getElementById('sLng').value);
                const eLat = parseFloat(document.getElementById('eLat').value);
                const eLng = parseFloat(document.getElementById('eLng').value);
                const totalDistance = getDistance(sLat, sLng, eLat, eLng);
                const distanceFromStart = (idx / (totalPoints - 1)) * totalDistance;
                const distanceFromEnd = totalDistance - distanceFromStart;
                const fraction = idx / (totalPoints - 1);
                const currentLat = sLat + (eLat - sLat) * fraction;
                const currentLng = sLng + (eLng - sLng) * fraction;
                const startName = window.elevationPointAName || 'Aé»';
                const endName = window.elevationPointBName || 'Bé»';
                let clearanceValue = 0;
                let clearanceText = '';
                let obstructionStatus = '';
                const losDataset = fullscreenChartInstance.data.datasets.find(d => d.label && (d.label.includes('è¦–è·é€£ç·š') || d.label.includes('è¦–è·')));
                if (losDataset && losDataset.data[idx] !== undefined) {
                  const losHeight = losDataset.data[idx];
                  clearanceValue = losHeight - dataValue;
                  if (clearanceValue > 0) {
                    clearanceText = `+${clearanceValue.toFixed(2)} m`;
                    obstructionStatus = 'ç„¡é®è”½';
                  } else if (clearanceValue < 0) {
                    clearanceText = `${clearanceValue.toFixed(2)} m`;
                    obstructionStatus = 'æœ‰é®è”½';
                  } else {
                    clearanceText = '0.00 m';
                    obstructionStatus = 'ç„¡é®è”½';
                  }
                }
                const clearanceColor = clearanceValue >= 0 ? '#4caf50' : '#ff4444';
                const innerHTML = `
                  <div class="tooltip-drag-handle" style="position:absolute; top:2px; right:2px; width:24px; height:24px; cursor:move; display:flex; align-items:center; justify-content:center; opacity:0.7; font-size:16px; user-select:none;" title="æ‹–æ›³ç§»å‹•">â ¿</div>
                  <div style="font-weight:bold; margin-bottom:5px; font-size:14px;">ä½ç½®è³‡è¨Š: ${idx + 1}</div>
                  <div>è·é›¢${startName}: ${distanceFromStart.toFixed(3)} km</div>
                  <div>è·é›¢${endName}: ${distanceFromEnd.toFixed(3)} km</div>
                  <div>æµ·æ‹”é«˜åº¦: ${dataValue.toFixed(0)} m</div>
                  <div>åº§æ¨™: ${currentLat.toFixed(6)}, ${currentLng.toFixed(6)}</div>
                  <div style="color: ${clearanceColor}; font-weight: bold;">${obstructionStatus}: ${clearanceText}</div>
                `;
                tooltipEl.innerHTML = innerHTML;
                const rect = canvas.getBoundingClientRect();
                let tooltipX = rect.left + pixelX;
                let tooltipY = rect.top + pixelY;
                tooltipEl.style.left = tooltipX + 'px';
                tooltipEl.style.top = tooltipY + 'px';
                tooltipEl.style.opacity = '0';
                tooltipEl.style.display = 'block';
                const tooltipRect = tooltipEl.getBoundingClientRect();
                const tooltipWidth = tooltipRect.width;
                const tooltipHeight = tooltipRect.height;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                let transformX = '-50%';
                let transformY = '-120%';
                const spaceAbove = tooltipY;
                const spaceBelow = viewportHeight - tooltipY;
                if (spaceAbove < tooltipHeight + 30) {
                  if (spaceBelow > tooltipHeight + 30) {
                    transformY = '20%';
                  } else {
                    transformY = '-50%';
                    tooltipY = spaceAbove > spaceBelow
                      ? Math.min(tooltipY, spaceAbove - tooltipHeight/2)
                      : Math.max(tooltipY, tooltipHeight/2);
                  }
                }
                const spaceLeft = tooltipX;
                const spaceRight = viewportWidth - tooltipX;
                if (spaceLeft < tooltipWidth/2 + 10) {
                  transformX = '10%';
                  tooltipX = Math.max(tooltipX, tooltipWidth/2 + 10);
                } else if (spaceRight < tooltipWidth/2 + 10) {
                  transformX = '-110%';
                  tooltipX = Math.min(tooltipX, viewportWidth - tooltipWidth/2 - 10);
                }
                tooltipEl.style.left = tooltipX + 'px';
                tooltipEl.style.top = tooltipY + 'px';
                tooltipEl.style.transform = `translate(${transformX}, ${transformY})`;
                tooltipEl.style.opacity = '1';

                // ğŸ¯ æ›´æ–°ä¿å­˜çš„ç‹€æ…‹
                if (window.lastFullscreenState) {
                  window.lastFullscreenState.selectedPointIndex = idx;
                }
              }
            }
          }
        }
      },
      plugins: [fullscreenLabelPlugin, fullscreenTotalDistancePlugin]
    });
    if (typeof window.currentSelectedPointIndex !== 'undefined' && window.currentSelectedPointIndex !== null && window.currentSelectedPointIndex >= 0) {
      const selectedIdx = window.currentSelectedPointIndex;
      const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
        d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
      );
      if (fullscreenDataset && fullscreenDataset.data) {
        const fullscreenPointColors = new Array(fullscreenDataset.data.length);
        const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
        const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
        const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);
        for (let i = 0; i < fullscreenDataset.data.length; i++) {
          if (i === selectedIdx) {
            fullscreenPointColors[i] = '#ffd43b';
            fullscreenPointRadius[i] = 8;
            fullscreenPointHoverRadius[i] = 12;
            fullscreenPointBorderColor[i] = '#fff';
          } else {
            fullscreenPointColors[i] = 'transparent';
            fullscreenPointRadius[i] = 0;
            fullscreenPointHoverRadius[i] = 6;
            fullscreenPointBorderColor[i] = 'transparent';
          }
        }
        fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
        fullscreenDataset.pointRadius = fullscreenPointRadius;
        fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
        fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
        fullscreenDataset.pointBorderWidth = 2;
        fullscreenChartInstance.update('none');
      }
    }
    const canvas = document.getElementById('elevationChartFullscreen');
    const isPointInLabel = (x, y, labelBounds) => {
      if (!labelBounds) return false;
      return x >= labelBounds.x && x <= labelBounds.x + labelBounds.width &&
           y >= labelBounds.y && y <= labelBounds.y + labelBounds.height;
    };
    const getMousePos = (canvas, evt) => {
      const rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      };
    };
    const getTouchPos = (canvas, evt) => {
      const rect = canvas.getBoundingClientRect();
      return {
        x: evt.touches[0].clientX - rect.left,
        y: evt.touches[0].clientY - rect.top
      };
    };
    canvas.addEventListener('mousedown', function(e) {
      const pos = getMousePos(canvas, e);
      if (isPointInLabel(pos.x, pos.y, window.fullscreenLabelABounds)) {
        fullscreenDraggingLabel = 'A';
        fullscreenIgnoreNextClick = true;
        window.fullscreenDragStartX = pos.x;
        window.fullscreenDragStartY = pos.y;
        window.fullscreenDragStartOffsetX = fullscreenLabelAOffset.x;
        window.fullscreenDragStartOffsetY = fullscreenLabelAOffset.y;
        e.preventDefault();
        e.stopPropagation();
      } else if (isPointInLabel(pos.x, pos.y, window.fullscreenLabelBBounds)) {
        fullscreenDraggingLabel = 'B';
        fullscreenIgnoreNextClick = true;
        window.fullscreenDragStartX = pos.x;
        window.fullscreenDragStartY = pos.y;
        window.fullscreenDragStartOffsetX = fullscreenLabelBOffset.x;
        window.fullscreenDragStartOffsetY = fullscreenLabelBOffset.y;
        e.preventDefault();
        e.stopPropagation();
      } else {
        fullscreenIgnoreNextClick = false;
      }
    });
    canvas.addEventListener('click', function(e) {
      const pos = getMousePos(canvas, e);
      if (isPointInLabel(pos.x, pos.y, window.fullscreenLabelABounds) ||
        isPointInLabel(pos.x, pos.y, window.fullscreenLabelBBounds)) {
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
    canvas.addEventListener('mousemove', function(e) {
      if (fullscreenDraggingLabel) {
        const pos = getMousePos(canvas, e);
        const deltaX = pos.x - window.fullscreenDragStartX;
        const deltaY = pos.y - window.fullscreenDragStartY;
        if (fullscreenDraggingLabel === 'A') {
          fullscreenLabelAOffset.x = window.fullscreenDragStartOffsetX + deltaX;
          fullscreenLabelAOffset.y = window.fullscreenDragStartOffsetY + deltaY;
        } else if (fullscreenDraggingLabel === 'B') {
          fullscreenLabelBOffset.x = window.fullscreenDragStartOffsetX + deltaX;
          fullscreenLabelBOffset.y = window.fullscreenDragStartOffsetY + deltaY;
        }
        fullscreenChartInstance.update('none');
        e.preventDefault();
      }
    });
    canvas.addEventListener('mouseup', function(e) {
      if (fullscreenDraggingLabel) {
        fullscreenDraggingLabel = null;
        fullscreenChartInstance.update();

        // ğŸ¯ ä¿å­˜æ¨™ç±¤åç§»é‡
        if (window.lastFullscreenState) {
          window.lastFullscreenState.labelAOffset = {...fullscreenLabelAOffset};
          window.lastFullscreenState.labelBOffset = {...fullscreenLabelBOffset};
        }
      }
    });
    canvas.addEventListener('touchstart', function(e) {
      const pos = getTouchPos(canvas, e);
      if (isPointInLabel(pos.x, pos.y, window.fullscreenLabelABounds)) {
        fullscreenDraggingLabel = 'A';
        window.fullscreenDragStartX = pos.x;
        window.fullscreenDragStartY = pos.y;
        window.fullscreenDragStartOffsetX = fullscreenLabelAOffset.x;
        window.fullscreenDragStartOffsetY = fullscreenLabelAOffset.y;
        e.preventDefault();
      } else if (isPointInLabel(pos.x, pos.y, window.fullscreenLabelBBounds)) {
        fullscreenDraggingLabel = 'B';
        window.fullscreenDragStartX = pos.x;
        window.fullscreenDragStartY = pos.y;
        window.fullscreenDragStartOffsetX = fullscreenLabelBOffset.x;
        window.fullscreenDragStartOffsetY = fullscreenLabelBOffset.y;
        e.preventDefault();
      }
    });
    canvas.addEventListener('touchmove', function(e) {
      if (fullscreenDraggingLabel) {
        const pos = getTouchPos(canvas, e);
        const deltaX = pos.x - window.fullscreenDragStartX;
        const deltaY = pos.y - window.fullscreenDragStartY;
        if (fullscreenDraggingLabel === 'A') {
          fullscreenLabelAOffset.x = window.fullscreenDragStartOffsetX + deltaX;
          fullscreenLabelAOffset.y = window.fullscreenDragStartOffsetY + deltaY;
        } else if (fullscreenDraggingLabel === 'B') {
          fullscreenLabelBOffset.x = window.fullscreenDragStartOffsetX + deltaX;
          fullscreenLabelBOffset.y = window.fullscreenDragStartOffsetY + deltaY;
        }
        fullscreenChartInstance.update('none');
        e.preventDefault();
      }
    });
    canvas.addEventListener('touchend', function(e) {
      if (fullscreenDraggingLabel) {
        fullscreenDraggingLabel = null;
        fullscreenChartInstance.update();

        // ğŸ¯ ä¿å­˜æ¨™ç±¤åç§»é‡
        if (window.lastFullscreenState) {
          window.lastFullscreenState.labelAOffset = {...fullscreenLabelAOffset};
          window.lastFullscreenState.labelBOffset = {...fullscreenLabelBOffset};
        }
      }
    });
    const pointControl = document.querySelector('.chart-fullscreen-point-control');
    if (pointControl) {
      pointControl.style.display = fullscreenInfoVisible ? 'flex' : 'none';
    }

    // ğŸ¯ æ¢å¾©ä¸Šæ¬¡ä¿å­˜çš„ç‹€æ…‹
    setTimeout(() => {
      if (window.lastFullscreenState) {
        const state = window.lastFullscreenState;

        // æ¢å¾©è¨Šæ¯æ¡†é¡¯ç¤ºç‹€æ…‹
        if (state.infoVisible !== fullscreenInfoVisible) {
          toggleFullscreenInfo();
        }

        // æ¢å¾©é®è”½ç·šé¡è‰²ç‹€æ…‹
        if (state.obstructionEnabled !== obstructionColorEnabled) {
          toggleObstructionColor();
        }

        // æ¢å¾©å°é»ƒé»ä½ç½®
        if (state.selectedPointIndex !== undefined && state.selectedPointIndex >= 0) {
          window.currentSelectedPointIndex = state.selectedPointIndex;

          // æ›´æ–°å°é»ƒé»é¡¯ç¤º
          const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
            d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
          );
          if (fullscreenDataset && fullscreenDataset.data) {
            const fullscreenPointColors = new Array(fullscreenDataset.data.length);
            const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
            const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
            const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);

            for (let i = 0; i < fullscreenDataset.data.length; i++) {
              if (i === state.selectedPointIndex) {
                fullscreenPointColors[i] = '#ffd43b';
                fullscreenPointRadius[i] = 8;
                fullscreenPointHoverRadius[i] = 12;
                fullscreenPointBorderColor[i] = '#fff';
              } else {
                fullscreenPointColors[i] = 'transparent';
                fullscreenPointRadius[i] = 0;
                fullscreenPointHoverRadius[i] = 6;
                fullscreenPointBorderColor[i] = 'transparent';
              }
            }

            fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
            fullscreenDataset.pointRadius = fullscreenPointRadius;
            fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
            fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
            fullscreenDataset.pointBorderWidth = 2;
          }

          // æ¢å¾©è—è‰²è¨Šæ¯æ¡†å…§å®¹å’Œä½ç½®
          if (fullscreenInfoVisible && pathData && elevationData) {
            const idx = state.selectedPointIndex;
            const overlay = document.getElementById('chartFullscreenOverlay');
            let tooltipEl = overlay ? overlay.querySelector('#chartjs-tooltip-fullscreen') : null;

            if (tooltipEl && idx < pathData.length && idx < elevationData.length) {
              const currentLat = pathData[idx].lat;
              const currentLng = pathData[idx].lng;
              const dataValue = elevationData[idx];
              const losValue = losLineData ? losLineData[idx] : null;

              let clearanceText = 'N/A';
              let clearanceColor = '#a8b3c3';
              let obstructionStatus = '';
              let clearanceValue = '';
              if (losValue !== null && !isNaN(losValue)) {
                const clearance = losValue - dataValue;
                if (clearance >= 0) {
                  clearanceValue = `+${clearance.toFixed(1)} m`;
                  clearanceColor = '#36c74d';
                  obstructionStatus = 'ç„¡é®è”½';
                } else {
                  clearanceValue = `${clearance.toFixed(1)} m`;
                  clearanceColor = '#ff4444';
                  obstructionStatus = 'æœ‰é®è”½';
                }
                clearanceText = `${clearanceValue}`;
              }

              const innerHTML = `
                <div>è·é›¢èµ·é»: ${(idx * (totalPathDistance / (elevationData.length - 1))).toFixed(2)} km</div>
                <div>æµ·æ‹”é«˜åº¦: ${dataValue.toFixed(0)} m</div>
                <div>åº§æ¨™: ${currentLat.toFixed(6)}, ${currentLng.toFixed(6)}</div>
                <div style="color: ${clearanceColor}; font-weight: bold;">${obstructionStatus}: ${clearanceText}</div>
              `;
              tooltipEl.innerHTML = innerHTML;

              // æ¢å¾© tooltip åç§»é‡
              tooltipOffsetX = state.tooltipOffsetX || 0;
              tooltipOffsetY = state.tooltipOffsetY || 0;

              tooltipEl.style.opacity = '1';
              tooltipEl.style.display = 'block';
            }
          }
        }

        // æ¢å¾©æ¨™ç±¤åç§»é‡
        if (state.labelAOffset) {
          fullscreenLabelAOffset = {...state.labelAOffset};
        }
        if (state.labelBOffset) {
          fullscreenLabelBOffset = {...state.labelBOffset};
        }

        // æ¢å¾©åœ–ä¾‹çš„é¡¯ç¤º/éš±è—ç‹€æ…‹
        if (state.datasetHiddenStates && fullscreenChartInstance) {
          Object.keys(state.datasetHiddenStates).forEach(indexStr => {
            const index = parseInt(indexStr);
            const hidden = state.datasetHiddenStates[index];
            const meta = fullscreenChartInstance.getDatasetMeta(index);
            if (meta) {
              meta.hidden = hidden;
            }
          });
        }

        // æ›´æ–°åœ–è¡¨
        if (fullscreenChartInstance) {
          fullscreenChartInstance.update('none');
        }

      }
    }, 500);

  }, 300);
}
function closeChartFullscreen() {
  // è‹¥ AB åœ– panel æ­£åœ¨é¡¯ç¤ºï¼Œå…ˆæŠŠ route-map é‚„åŸ
  const _abPanel = document.getElementById('ab-inline-panel');
  if (_abPanel && _abPanel.style.display !== 'none') {
    closeABMapFromFullscreen();
  }
  // ğŸ¯ ä¿å­˜é—œé–‰å‰çš„ç‹€æ…‹ï¼Œä¾›ä¸‹æ¬¡é–‹å•Ÿæ™‚ä½¿ç”¨

  // ä¿å­˜åœ–ä¾‹çš„é¡¯ç¤º/éš±è—ç‹€æ…‹
  const datasetHiddenStates = {};
  if (fullscreenChartInstance && fullscreenChartInstance.data && fullscreenChartInstance.data.datasets) {
    fullscreenChartInstance.data.datasets.forEach((dataset, index) => {
      const meta = fullscreenChartInstance.getDatasetMeta(index);
      datasetHiddenStates[index] = meta.hidden;
    });
  }

  const fullscreenState = {
    infoVisible: fullscreenInfoVisible,
    obstructionEnabled: obstructionColorEnabled,
    selectedPointIndex: window.currentSelectedPointIndex,
    tooltipOffsetX: tooltipOffsetX,
    tooltipOffsetY: tooltipOffsetY,
    labelAOffset: fullscreenLabelAOffset ? {...fullscreenLabelAOffset} : { x: 0, y: -30 },
    labelBOffset: fullscreenLabelBOffset ? {...fullscreenLabelBOffset} : { x: 0, y: -30 },
    datasetHiddenStates: datasetHiddenStates  // åŠ å…¥åœ–ä¾‹ç‹€æ…‹
  };
  window.lastFullscreenState = fullscreenState;

  const overlay = document.getElementById('chartFullscreenOverlay');
  overlay.classList.remove('active');
  const tooltipEl = overlay.querySelector('#chartjs-tooltip-fullscreen');
  if (tooltipEl) {
    tooltipEl.remove();
  }

  // éš±è—å ±å‘Šç¢ºèªæŒ‰éˆ•
  const confirmBtn = overlay.querySelector('#reportConfirmButton');
  if (confirmBtn) {
    confirmBtn.style.display = 'none';
  }
  window.isGeneratingReport = false;

  if (screen.orientation && screen.orientation.unlock) {
    screen.orientation.unlock();
  }
  if (document.exitFullscreen) {
    document.exitFullscreen().catch(()=>{});
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen().catch(()=>{});
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen().catch(()=>{});
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen().catch(()=>{});
  }
  document.body.style.overflow = '';
  if (typeof window.currentSelectedPointIndex !== 'undefined' &&
    window.currentSelectedPointIndex !== null &&
    window.currentSelectedPointIndex >= 0 &&
    pathData &&
    pathData[window.currentSelectedPointIndex]) {
    const selectedIdx = window.currentSelectedPointIndex;
    if (elevationData && elevationData[selectedIdx] !== undefined) {
      showMap(selectedIdx, getElevationForIndex(selectedIdx));
    }
  }
  if (fullscreenChartInstance) {
    fullscreenChartInstance.destroy();
    fullscreenChartInstance = null;
  }
  fullscreenDraggingLabel = null;
}

// ğŸ¨ é¡¯ç¤ºä¸»é¡Œé¸æ“‡å°è©±æ¡†ï¼ˆä¸é›¢é–‹å…¨è¢å¹•ï¼‰
function showThemeChoiceDialog() {
  return new Promise((resolve) => {
    const overlay = document.getElementById('chartFullscreenOverlay');
    if (!overlay) {
      resolve(null);
      return;
    }

    // å‰µå»ºé¸æ“‡å°è©±æ¡† - æ·»åŠ åˆ° overlay å…§éƒ¨ï¼Œä½¿ç”¨æ¥µé«˜çš„ z-index
    const dialog = document.createElement('div');
    dialog.style.cssText = `
      position: fixed !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      background: rgba(0, 0, 0, 0.95) !important;
      border: 2px solid #5ff0d5 !important;
      border-radius: 12px !important;
      padding: 30px !important;
      z-index: 999999 !important;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8) !important;
      display: block !important;
      visibility: visible !important;
    `;

    dialog.innerHTML = `
      <div style="text-align: center; color: #ffe58f; font-size: 20px; font-weight: bold; margin-bottom: 20px;">
        é¸æ“‡æˆªåœ–é¢¨æ ¼
      </div>
      <div style="display: flex; gap: 15px; justify-content: center;">
        <button id="themeLightBtn" style="
          background: linear-gradient(135deg, #e0f2fe, #bae6fd);
          border: 3px solid #0ea5e9;
          color: #0c4a6e;
          padding: 15px 30px;
          border-radius: 8px;
          font-size: 18px;
          font-weight: bold;
          cursor: pointer;
          transition: all 0.3s;
          min-width: 160px;
        ">
          â˜€ï¸ æ·ºè‰²é¢¨æ ¼
        </button>
        <button id="themeDarkBtn" style="
          background: linear-gradient(135deg, #1e293b, #0f172a);
          border: 3px solid #5ff0d5;
          color: #5ff0d5;
          padding: 15px 30px;
          border-radius: 8px;
          font-size: 18px;
          font-weight: bold;
          cursor: pointer;
          transition: all 0.3s;
          min-width: 160px;
        ">
          ğŸŒ™ æ·±è‰²é¢¨æ ¼
        </button>
      </div>
      <div style="text-align: center; margin-top: 15px;">
        <button id="themeCancelBtn" style="
          background: transparent;
          border: 1px solid #666;
          color: #999;
          padding: 8px 20px;
          border-radius: 6px;
          font-size: 14px;
          cursor: pointer;
        ">
          å–æ¶ˆ
        </button>
      </div>
    `;

    // æ·»åŠ åˆ° overlay å…§éƒ¨
    overlay.appendChild(dialog);

    // åªé˜»æ­¢å°è©±æ¡†èƒŒæ™¯çš„é»æ“Šå†’æ³¡ï¼Œä¸é˜»æ­¢æŒ‰éˆ•é»æ“Š
    dialog.addEventListener('click', (e) => {
      // åªæœ‰é»æ“Šå°è©±æ¡†æœ¬èº«ï¼ˆä¸æ˜¯æŒ‰éˆ•ï¼‰æ™‚æ‰é˜»æ­¢å†’æ³¡
      if (e.target === dialog) {
        e.stopPropagation();
        e.preventDefault();
      }
    });

    // æ·»åŠ æ‡¸åœæ•ˆæœ
    const lightBtn = dialog.querySelector('#themeLightBtn');
    const darkBtn = dialog.querySelector('#themeDarkBtn');
    const cancelBtn = dialog.querySelector('#themeCancelBtn');

    lightBtn.onmouseenter = () => {
      lightBtn.style.transform = 'scale(1.05)';
      lightBtn.style.boxShadow = '0 4px 20px rgba(14, 165, 233, 0.5)';
    };
    lightBtn.onmouseleave = () => {
      lightBtn.style.transform = 'scale(1)';
      lightBtn.style.boxShadow = 'none';
    };

    darkBtn.onmouseenter = () => {
      darkBtn.style.transform = 'scale(1.05)';
      darkBtn.style.boxShadow = '0 4px 20px rgba(95, 240, 213, 0.5)';
    };
    darkBtn.onmouseleave = () => {
      darkBtn.style.transform = 'scale(1)';
      darkBtn.style.boxShadow = 'none';
    };

    // æŒ‰éˆ•äº‹ä»¶ - åŒæ™‚æ”¯æ´é»æ“Šå’Œè§¸æ‘¸ï¼Œä¸¦é˜»æ­¢å†’æ³¡
    const handleLightClick = (e) => {
      e.stopPropagation();
      e.preventDefault();
      dialog.remove();
      resolve(true);  // æ·ºè‰²é¢¨æ ¼
    };
    
    const handleDarkClick = (e) => {
      e.stopPropagation();
      e.preventDefault();
      dialog.remove();
      resolve(false);  // æ·±è‰²é¢¨æ ¼
    };
    
    const handleCancelClick = (e) => {
      e.stopPropagation();
      e.preventDefault();
      dialog.remove();
      resolve(null);  // å–æ¶ˆ
    };

    lightBtn.addEventListener('click', handleLightClick);
    lightBtn.addEventListener('touchend', handleLightClick);
    
    darkBtn.addEventListener('click', handleDarkClick);
    darkBtn.addEventListener('touchend', handleDarkClick);
    
    cancelBtn.addEventListener('click', handleCancelClick);
    cancelBtn.addEventListener('touchend', handleCancelClick);
  });
}

async function generateChartImage() {
  try {
    if (!fullscreenChartInstance) {
      alert('âŒ æ‰¾ä¸åˆ°å…¨è¢å¹•å‰–é¢åœ–ï¼Œè«‹å…ˆé€²å…¥å…¨è¢å¹•æ¨¡å¼');
      return;
    }

    // ğŸ¨ åˆ¤æ–·èƒŒæ™¯è‰²é¸æ“‡æ–¹å¼
    let bgChoice;
    if (window.isGeneratingReport) {
      // å¦‚æœæ­£åœ¨ç”Ÿæˆå ±å‘Šï¼Œè‡ªå‹•æ ¹æ“š pdf_theme_setting é¸æ“‡
      const themeSetting = document.getElementById('pdf_theme_setting')?.value || 'dark';
      bgChoice = themeSetting === 'light';
    } else {
      // å¦‚æœæ˜¯æ‰‹å‹•æˆªåœ–ï¼Œé¡¯ç¤ºè‡ªå®šç¾©é¸æ“‡ä»‹é¢ï¼ˆä¸é›¢é–‹å…¨è¢å¹•ï¼‰
      bgChoice = await showThemeChoiceDialog();
      if (bgChoice === null) {
        // ç”¨æˆ¶å–æ¶ˆäº†é¸æ“‡
        return;
      }
    }
    
    const selectedBgColor = bgChoice ? '#e0f2fe' : '#0b1526';
    const selectedTextColor = bgChoice ? '#0c4a6e' : '#ffe58f';

    // æš«å­˜åŸå§‹é…è‰²
    const originalBgColor = fullscreenChartInstance.options.chartBackgroundColor;
    const originalGridColor = fullscreenChartInstance.options.scales.y.grid.color;
    const originalTickColor = fullscreenChartInstance.options.scales.y.ticks.color;
    const originalXGridColor = fullscreenChartInstance.options.scales.x.grid.color;
    const originalXTickColor = fullscreenChartInstance.options.scales.x.ticks.color;
    const originalLegendColor = fullscreenChartInstance.options.plugins.legend.labels.color;
    const originalYTitleColor = fullscreenChartInstance.options.scales.y.title.color;
    const originalXTitleColor = fullscreenChartInstance.options.scales.x.title.color;
    const originalLegendGenerator = fullscreenChartInstance.options.plugins.legend.labels.generateLabels;

    // ğŸ¨ å¥—ç”¨é¸æ“‡çš„é…è‰²
    if (bgChoice) {
      // æ·ºè‰²èƒŒæ™¯
      fullscreenChartInstance.options.chartBackgroundColor = '#e0f2fe';
      fullscreenChartInstance.options.scales.y.grid.color = 'rgba(0,0,0,0.15)';
      fullscreenChartInstance.options.scales.y.ticks.color = '#1e40af';
      fullscreenChartInstance.options.scales.x.grid.color = 'rgba(0,0,0,0.15)';
      fullscreenChartInstance.options.scales.x.ticks.color = '#1e40af';
      fullscreenChartInstance.options.plugins.legend.labels.color = '#000000';
      fullscreenChartInstance.options.scales.y.title.color = '#0c4a6e';
      fullscreenChartInstance.options.scales.x.title.color = '#0c4a6e';
      
      // ğŸ¨ ä¿®æ”¹åœ–ä¾‹ç”Ÿæˆå™¨ï¼Œå°‡æ–‡å­—é¡è‰²æ”¹ç‚ºé»‘è‰²
      const originalGenerator = fullscreenChartInstance.options.plugins.legend.labels.generateLabels;
      fullscreenChartInstance.options.plugins.legend.labels.generateLabels = function(chart) {
        const labels = originalGenerator(chart);
        return labels.map(label => {
          // æ·ºè‰²é¢¨æ ¼ï¼šéš±è—æ™‚ç”¨æ·±ç°è‰²ï¼Œé¡¯ç¤ºæ™‚ç”¨é»‘è‰²
          if (label.hidden || (chart.getDatasetMeta(label.datasetIndex) && chart.getDatasetMeta(label.datasetIndex).hidden)) {
            label.fontColor = '#6b7280';  // æ·±ç°è‰²ï¼ˆéš±è—ç‹€æ…‹ï¼‰
          } else {
            label.fontColor = '#000000';  // é»‘è‰²ï¼ˆé¡¯ç¤ºç‹€æ…‹ï¼‰
          }
          return label;
        });
      };
      
      // ğŸ¨ ä¿®æ”¹ tooltip ç‚ºæ·±è—è‰²èƒŒæ™¯
      const tooltipEl = document.getElementById('chartjs-tooltip-fullscreen');
      if (tooltipEl) {
        tooltipEl.style.background = 'rgba(30, 58, 138, 0.95)';  // æ·±è—è‰²èƒŒæ™¯
        tooltipEl.style.border = '2px solid #1e40af';  // æ·±è—è‰²é‚Šæ¡†
        tooltipEl.style.color = '#e0f2fe';  // æ·ºè‰²æ–‡å­—
      }
      
      fullscreenChartInstance.update('none');
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    const button = document.querySelector('.chart-fullscreen-screenshot');
    if (button) {
      button.textContent = 'â³';
      button.style.background = 'rgba(255, 193, 7, 1)';
    }
    const overlay = document.getElementById('chartFullscreenOverlay');
    if (!overlay) {
      alert('âŒ æ‰¾ä¸åˆ°å…¨è¢å¹•å®¹å™¨');
      if (button) {
        button.textContent = 'ğŸ“·';
        button.style.background = '';
      }
      return;
    }
    const controlsToHide = [
      overlay.querySelector('.chart-fullscreen-close'),
      overlay.querySelector('.chart-fullscreen-screenshot'),
      overlay.querySelector('.chart-fullscreen-rotate-toggle'),
      overlay.querySelector('.chart-fullscreen-info-toggle'),
      overlay.querySelector('.chart-fullscreen-obstruction-toggle'),
      overlay.querySelector('.chart-fullscreen-map-toggle'),
      overlay.querySelector('.chart-fullscreen-end-obstruction'),
      overlay.querySelector('.chart-fullscreen-max-obstruction'),
      overlay.querySelector('.chart-fullscreen-start-obstruction'),
      overlay.querySelector('.chart-fullscreen-point-control')
    ];
    const originalDisplayStates = controlsToHide.map(el => {
      if (el) {
        const display = el.style.display;
        el.style.display = 'none';
        return display;
      }
      return null;
    });
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // ğŸ¨ è‡¨æ™‚ç§»é™¤ overlayã€container å’Œ wrapper çš„èƒŒæ™¯è‰²ï¼Œé¿å…é»‘æ¡†
    const originalOverlayBg = overlay.style.background;
    const container = overlay.querySelector('.chart-fullscreen-container');
    const wrapper = overlay.querySelector('.chart-fullscreen-canvas-wrapper');
    const originalContainerBg = container ? container.style.background : '';
    const originalWrapperBg = wrapper ? wrapper.style.background : '';
    
    overlay.style.background = 'transparent';
    if (container) container.style.background = 'transparent';
    if (wrapper) wrapper.style.background = 'transparent';
    
    const canvas = await html2canvas(overlay, {
      backgroundColor: selectedBgColor,  // ğŸ¨ ä½¿ç”¨é¸æ“‡çš„èƒŒæ™¯è‰²
      scale: 2,
      logging: false,
      useCORS: true,
      allowTaint: true,
      foreignObjectRendering: false,
      imageTimeout: 0
    });
    
    // ğŸ¨ æ¢å¾© overlayã€container å’Œ wrapper çš„èƒŒæ™¯
    overlay.style.background = originalOverlayBg;
    if (container) container.style.background = originalContainerBg;
    if (wrapper) wrapper.style.background = originalWrapperBg;
    
    controlsToHide.forEach((el, index) => {
      if (el) {
        el.style.display = originalDisplayStates[index] || '';
      }
    });

    // ğŸ¨ æ¢å¾©åŸå§‹é…è‰²
    fullscreenChartInstance.options.chartBackgroundColor = originalBgColor;
    fullscreenChartInstance.options.scales.y.grid.color = originalGridColor;
    fullscreenChartInstance.options.scales.y.ticks.color = originalTickColor;
    fullscreenChartInstance.options.scales.x.grid.color = originalXGridColor;
    fullscreenChartInstance.options.scales.x.ticks.color = originalXTickColor;
    fullscreenChartInstance.options.plugins.legend.labels.color = originalLegendColor;
    fullscreenChartInstance.options.scales.y.title.color = originalYTitleColor;
    fullscreenChartInstance.options.plugins.legend.labels.generateLabels = originalLegendGenerator;
    
    // ğŸ¨ æ¢å¾© tooltip åŸå§‹æ¨£å¼
    const tooltipEl = document.getElementById('chartjs-tooltip-fullscreen');
    if (tooltipEl && bgChoice) {
      tooltipEl.style.background = 'rgba(13, 71, 161, 0.35)';  // æ¢å¾©åŸå§‹èƒŒæ™¯
      tooltipEl.style.border = '2px solid #4dabf7';  // æ¢å¾©åŸå§‹é‚Šæ¡†
      tooltipEl.style.color = 'white';  // æ¢å¾©åŸå§‹æ–‡å­—é¡è‰²
    }
    fullscreenChartInstance.options.scales.x.title.color = originalXTitleColor;
    fullscreenChartInstance.update('none');

    const imageUrl = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const nameA = window.elevationPointAName || 'Aé»';
    const nameB = window.elevationPointBName || 'Bé»';
    link.download = `å‰–é¢åœ–_${nameA}_åˆ°_${nameB}_${timestamp}.png`;
    link.href = imageUrl;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    if (button) {
      const originalText = 'ğŸ“·';
      button.textContent = 'âœ“';
      button.style.background = 'rgba(76, 175, 80, 1)';
      setTimeout(() => {
        button.textContent = originalText;
        button.style.background = '';
      }, 1500);
    }
  } catch (error) {
    alert('âŒ ç”Ÿæˆåœ–ç‰‡å¤±æ•—: ' + error.message);
    const button = document.querySelector('.chart-fullscreen-screenshot');
    if (button) {
      button.textContent = 'ğŸ“·';
      button.style.background = '';
    }
  }
}
function toggleLandscapeFullscreen() {
  const overlay = document.getElementById('chartFullscreenOverlay');
  const elem = overlay;
  if (elem.requestFullscreen) {
    elem.requestFullscreen().catch(err => {
      alert('ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨æ¬Šé™è¨­å®š');
    });
  } else if (elem.webkitRequestFullscreen) {
    elem.webkitRequestFullscreen().catch(err => {
      alert('ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨æ¬Šé™è¨­å®š');
    });
  } else if (elem.mozRequestFullScreen) {
    elem.mozRequestFullScreen().catch(err => {
      alert('ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨æ¬Šé™è¨­å®š');
    });
  } else if (elem.msRequestFullscreen) {
    elem.msRequestFullscreen().catch(err => {
      alert('ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨æ¬Šé™è¨­å®š');
    });
  }
  if (screen.orientation && screen.orientation.lock) {
    screen.orientation.lock('landscape').catch(err => {
      screen.orientation.lock('landscape-primary').catch(err => {
        screen.orientation.lock('landscape-secondary').catch(err => {
        });
      });
    });
  }
}
let fullscreenInfoVisible = true;
let preventHoverUpdate = false;
function forceSync(targetIndex) {
  window.currentSelectedPointIndex = targetIndex;
  const selectedPointInput = document.getElementById('selectedPointIndex');
  if (selectedPointInput) {
    selectedPointInput.value = targetIndex + 1;
  }
  const fullscreenPointInput = document.getElementById('fullscreenPointInput');
  if (fullscreenPointInput) {
    fullscreenPointInput.value = targetIndex + 1;
  }
  const overlay = document.getElementById('chartFullscreenOverlay');
  const isInFullscreen = overlay && overlay.classList.contains('active');
  if (isInFullscreen && fullscreenChartInstance) {
    syncFullscreenChartAfterButtonClick(targetIndex);
  }
}
function syncFullscreenChartAfterButtonClick(targetIndex) {
  preventHoverUpdate = true;
  const overlay = document.getElementById('chartFullscreenOverlay');
  if (!overlay || !overlay.classList.contains('active')) {
    preventHoverUpdate = false;
    return;
  }
  if (!fullscreenChartInstance) {
    preventHoverUpdate = false;
    return;
  }
  window.currentSelectedPointIndex = targetIndex;
  const fullscreenPointInput = document.getElementById('fullscreenPointInput');
  if (fullscreenPointInput) {
    fullscreenPointInput.value = targetIndex + 1;
  }
  const selectedPointInput = document.getElementById('selectedPointIndex');
  if (selectedPointInput) {
    selectedPointInput.value = targetIndex + 1;
  }
  if (!fullscreenInfoVisible) {
    fullscreenInfoVisible = true;
    const toggleBtn = document.querySelector('.chart-fullscreen-info-toggle');
    if (toggleBtn) {
      toggleBtn.classList.remove('disabled');
      toggleBtn.style.opacity = '1';
    }
  }
  const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
    d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
  );
  if (fullscreenDataset && fullscreenDataset.data) {
    const pointCount = fullscreenDataset.data.length;
    const fullscreenPointColors = new Array(pointCount);
    const fullscreenPointRadius = new Array(pointCount);
    const fullscreenPointHoverRadius = new Array(pointCount);
    const fullscreenPointBorderColor = new Array(pointCount);
    for (let i = 0; i < pointCount; i++) {
      if (i === targetIndex) {
        fullscreenPointColors[i] = '#ffd43b';
        fullscreenPointRadius[i] = 8;
        fullscreenPointHoverRadius[i] = 12;
        fullscreenPointBorderColor[i] = '#fff';
      } else {
        fullscreenPointColors[i] = 'transparent';
        fullscreenPointRadius[i] = 0;
        fullscreenPointHoverRadius[i] = 6;
        fullscreenPointBorderColor[i] = 'transparent';
      }
    }
    fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
    fullscreenDataset.pointRadius = fullscreenPointRadius;
    fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
    fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
    fullscreenDataset.pointBorderWidth = 2;
    fullscreenChartInstance.update('none');
  }
  const canvas = document.getElementById('elevationChartFullscreen');
  const fullscreenContainer = document.getElementById('chartFullscreenOverlay');
  if (canvas && fullscreenContainer && fullscreenChartInstance) {
    const xScale = fullscreenChartInstance.scales.x;
    const yScale = fullscreenChartInstance.scales.y;
    const dataset = fullscreenChartInstance.data.datasets.find(d =>
      d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
    );
    if (dataset && dataset.data[targetIndex] !== undefined) {
      const pixelX = xScale.getPixelForValue(targetIndex);
      const pixelY = yScale.getPixelForValue(dataset.data[targetIndex]);
      let tooltipEl = fullscreenContainer.querySelector('#chartjs-tooltip-fullscreen');
      if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.id = 'chartjs-tooltip-fullscreen';
        tooltipEl.style.background = 'rgba(13, 71, 161, 0.35)';
        tooltipEl.style.borderRadius = '8px';
        tooltipEl.style.color = 'white';
        tooltipEl.style.opacity = '0';
        tooltipEl.style.pointerEvents = 'auto';
        tooltipEl.style.position = 'fixed';
        tooltipEl.style.transform = 'translate(-50%, -120%)';
        tooltipEl.style.transition = 'all .1s ease';
        tooltipEl.style.padding = '10px 12px';
        tooltipEl.style.border = '2px solid #4dabf7';
        tooltipEl.style.fontSize = '13px';
        tooltipEl.style.lineHeight = '1.5';
        tooltipEl.style.zIndex = '10002';
        tooltipEl.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
        tooltipEl.style.whiteSpace = 'nowrap';
        tooltipEl.style.cursor = 'move';
        fullscreenContainer.appendChild(tooltipEl);

        // ç«‹å³ç¶å®šæ‹–æ›³åŠŸèƒ½
        makeTooltipDraggable(tooltipEl);
      }
      const dataValue = dataset.data[targetIndex];
      const totalPoints = dataset.data.length;
      const sLat = parseFloat(document.getElementById('sLat').value);
      const sLng = parseFloat(document.getElementById('sLng').value);
      const eLat = parseFloat(document.getElementById('eLat').value);
      const eLng = parseFloat(document.getElementById('eLng').value);
      const totalDistance = getDistance(sLat, sLng, eLat, eLng);
      const distanceFromStart = (targetIndex / (totalPoints - 1)) * totalDistance;
      const distanceFromEnd = totalDistance - distanceFromStart;
      const fraction = targetIndex / (totalPoints - 1);
      const currentLat = sLat + (eLat - sLat) * fraction;
      const currentLng = sLng + (eLng - sLng) * fraction;
      const startName = window.elevationPointAName || 'Aé»';
      const endName = window.elevationPointBName || 'Bé»';
      let clearanceValue = 0;
      let clearanceText = '';
      let obstructionStatus = '';
      const losDataset = fullscreenChartInstance.data.datasets.find(d => d.label && (d.label.includes('è¦–è·é€£ç·š') || d.label.includes('è¦–è·')));
      if (losDataset && losDataset.data[targetIndex] !== undefined) {
        const losHeight = losDataset.data[targetIndex];
        clearanceValue = losHeight - dataValue;
        if (clearanceValue > 0) {
          clearanceText = `+${clearanceValue.toFixed(2)} m`;
          obstructionStatus = 'ç„¡é®è”½';
        } else if (clearanceValue < 0) {
          clearanceText = `${clearanceValue.toFixed(2)} m`;
          obstructionStatus = 'æœ‰é®è”½';
        } else {
          clearanceText = '0.00 m';
          obstructionStatus = 'ç„¡é®è”½';
        }
      }
      const clearanceColor = clearanceValue >= 0 ? '#4caf50' : '#ff4444';
      const innerHTML = `
        <div class="tooltip-drag-handle" style="position:absolute; top:2px; right:2px; width:24px; height:24px; cursor:move; display:flex; align-items:center; justify-content:center; opacity:0.7; font-size:16px; user-select:none;" title="æ‹–æ›³ç§»å‹•">â ¿</div>
        <div style="font-weight:bold; margin-bottom:5px; font-size:14px;">ä½ç½®è³‡è¨Š: ${targetIndex + 1}</div>
        <div>è·é›¢${startName}: ${distanceFromStart.toFixed(3)} km</div>
        <div>è·é›¢${endName}: ${distanceFromEnd.toFixed(3)} km</div>
        <div>æµ·æ‹”é«˜åº¦: ${dataValue.toFixed(0)} m</div>
        <div>åº§æ¨™: ${currentLat.toFixed(6)}, ${currentLng.toFixed(6)}</div>
        <div style="color: ${clearanceColor}; font-weight: bold;">${obstructionStatus}: ${clearanceText}</div>
      `;
      tooltipEl.innerHTML = innerHTML;
      const rect = canvas.getBoundingClientRect();
      let tooltipX = rect.left + pixelX;
      let tooltipY = rect.top + pixelY;
      tooltipEl.style.left = tooltipX + 'px';
      tooltipEl.style.top = tooltipY + 'px';
      tooltipEl.style.opacity = '0';
      tooltipEl.style.display = 'block';
      const tooltipRect = tooltipEl.getBoundingClientRect();
      const tooltipWidth = tooltipRect.width;
      const tooltipHeight = tooltipRect.height;
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      let transformX = '-50%';
      let transformY = '-120%';
      const spaceAbove = tooltipY;
      const spaceBelow = viewportHeight - tooltipY;
      if (spaceAbove < tooltipHeight + 30) {
        if (spaceBelow > tooltipHeight + 30) {
          transformY = '20%';
        } else {
          transformY = '-50%';
          tooltipY = spaceAbove > spaceBelow
            ? Math.min(tooltipY, spaceAbove - tooltipHeight/2)
            : Math.max(tooltipY, tooltipHeight/2);
        }
      }
      const spaceLeft = tooltipX;
      const spaceRight = viewportWidth - tooltipX;
      if (spaceLeft < tooltipWidth/2 + 10) {
        transformX = '10%';
        tooltipX = Math.max(tooltipX, tooltipWidth/2 + 10);
      } else if (spaceRight < tooltipWidth/2 + 10) {
        transformX = '-110%';
        tooltipX = Math.min(tooltipX, viewportWidth - tooltipWidth/2 - 10);
      }
      tooltipEl.style.left = tooltipX + 'px';
      tooltipEl.style.top = tooltipY + 'px';
      tooltipEl.style.transform = `translate(${transformX}, ${transformY})`;
      tooltipEl.style.opacity = '1';
    }
  }
  setTimeout(() => {
    preventHoverUpdate = false;
  }, 200);
}
function toggleFullscreenInfo() {
  fullscreenInfoVisible = !fullscreenInfoVisible;
  const toggleBtn = document.querySelector('.chart-fullscreen-info-toggle');
  const fullscreenContainer = document.getElementById('chartFullscreenOverlay');
  let tooltipEl = fullscreenContainer ? fullscreenContainer.querySelector('#chartjs-tooltip-fullscreen') : null;
  if (!tooltipEl && fullscreenContainer) {
    tooltipEl = document.createElement('div');
    tooltipEl.id = 'chartjs-tooltip-fullscreen';
    tooltipEl.style.background = 'rgba(13, 71, 161, 0.35)';
    tooltipEl.style.borderRadius = '8px';
    tooltipEl.style.color = 'white';
    tooltipEl.style.opacity = '0';
    tooltipEl.style.pointerEvents = 'auto';
    tooltipEl.style.position = 'fixed';
    tooltipEl.style.transform = 'translate(-50%, -120%)';
    tooltipEl.style.transition = 'all .1s ease';
    tooltipEl.style.padding = '10px 12px';
    tooltipEl.style.border = '2px solid #4dabf7';
    tooltipEl.style.fontSize = '13px';
    tooltipEl.style.lineHeight = '1.5';
    tooltipEl.style.zIndex = '10002';
    tooltipEl.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
    tooltipEl.style.whiteSpace = 'nowrap';
    tooltipEl.style.cursor = 'move';
    fullscreenContainer.appendChild(tooltipEl);
    makeTooltipDraggable(tooltipEl);
  }
  if (fullscreenInfoVisible) {
    toggleBtn.classList.remove('disabled');
    toggleBtn.style.opacity = '1';
    const pointControl = document.querySelector('.chart-fullscreen-point-control');
    if (pointControl) {
      pointControl.style.display = 'flex';
    }
  } else {
    toggleBtn.classList.add('disabled');
    toggleBtn.style.opacity = '0.6';
    const pointControl = document.querySelector('.chart-fullscreen-point-control');
    if (pointControl) {
      pointControl.style.display = 'none';
    }
    if (tooltipEl) {
      tooltipEl.style.opacity = '0';
      tooltipEl.style.display = 'none';
    }
    if (fullscreenChartInstance) {
      const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
        d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
      );
      if (fullscreenDataset && fullscreenDataset.data) {
        const fullscreenPointColors = new Array(fullscreenDataset.data.length);
        const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
        const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
        const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);
        for (let i = 0; i < fullscreenDataset.data.length; i++) {
          fullscreenPointColors[i] = 'transparent';
          fullscreenPointRadius[i] = 0;
          fullscreenPointHoverRadius[i] = 0;
          fullscreenPointBorderColor[i] = 'transparent';
        }
        fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
        fullscreenDataset.pointRadius = fullscreenPointRadius;
        fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
        fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
        fullscreenChartInstance.update('none');
      }
    }
  }
  if (fullscreenInfoVisible) {
    if (tooltipEl) {
      tooltipEl.style.display = 'block';
    }
    if (typeof window.currentSelectedPointIndex !== 'undefined' &&
      window.currentSelectedPointIndex !== null && window.currentSelectedPointIndex >= 0) {
      const selectedIdx = window.currentSelectedPointIndex;
      if (fullscreenChartInstance) {
        const fullscreenDataset = fullscreenChartInstance.data.datasets.find(d =>
          d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
        );
        if (fullscreenDataset && fullscreenDataset.data) {
          const fullscreenPointColors = new Array(fullscreenDataset.data.length);
          const fullscreenPointRadius = new Array(fullscreenDataset.data.length);
          const fullscreenPointHoverRadius = new Array(fullscreenDataset.data.length);
          const fullscreenPointBorderColor = new Array(fullscreenDataset.data.length);
          for (let i = 0; i < fullscreenDataset.data.length; i++) {
            if (i === selectedIdx) {
              fullscreenPointColors[i] = '#ffd43b';
              fullscreenPointRadius[i] = 8;
              fullscreenPointHoverRadius[i] = 12;
              fullscreenPointBorderColor[i] = '#fff';
            } else {
              fullscreenPointColors[i] = 'transparent';
              fullscreenPointRadius[i] = 0;
              fullscreenPointHoverRadius[i] = 6;
              fullscreenPointBorderColor[i] = 'transparent';
            }
          }
          fullscreenDataset.pointBackgroundColor = fullscreenPointColors;
          fullscreenDataset.pointRadius = fullscreenPointRadius;
          fullscreenDataset.pointHoverRadius = fullscreenPointHoverRadius;
          fullscreenDataset.pointBorderColor = fullscreenPointBorderColor;
          fullscreenDataset.pointBorderWidth = 2;
          fullscreenChartInstance.update('none');
          if (tooltipEl && fullscreenDataset.data[selectedIdx] !== undefined) {
            const dataValue = fullscreenDataset.data[selectedIdx];
            const totalPoints = fullscreenDataset.data.length;
            const sLat = parseFloat(document.getElementById('sLat').value);
            const sLng = parseFloat(document.getElementById('sLng').value);
            const eLat = parseFloat(document.getElementById('eLat').value);
            const eLng = parseFloat(document.getElementById('eLng').value);
            const totalDistance = getDistance(sLat, sLng, eLat, eLng);
            const distanceFromStart = (selectedIdx / (totalPoints - 1)) * totalDistance;
            const distanceFromEnd = totalDistance - distanceFromStart;
            const fraction = selectedIdx / (totalPoints - 1);
            const currentLat = sLat + (eLat - sLat) * fraction;
            const currentLng = sLng + (eLng - sLng) * fraction;
            const startName = window.elevationPointAName || 'Aé»';
            const endName = window.elevationPointBName || 'Bé»';
            let clearanceValue = 0;
            let clearanceText = '';
            let obstructionStatus = '';
            const losDataset = fullscreenChartInstance.data.datasets.find(d => d.label && (d.label.includes('è¦–è·é€£ç·š') || d.label.includes('è¦–è·')));
            if (losDataset && losDataset.data[selectedIdx] !== undefined) {
              const losHeight = losDataset.data[selectedIdx];
              clearanceValue = losHeight - dataValue;
              if (clearanceValue > 0) {
                clearanceText = `+${clearanceValue.toFixed(2)} m`;
                obstructionStatus = 'ç„¡é®è”½';
              } else if (clearanceValue < 0) {
                clearanceText = `${clearanceValue.toFixed(2)} m`;
                obstructionStatus = 'æœ‰é®è”½';
              } else {
                clearanceText = '0.00 m';
                obstructionStatus = 'ç„¡é®è”½';
              }
            }
            const clearanceColor = clearanceValue >= 0 ? '#4caf50' : '#ff4444';
            tooltipEl.innerHTML = `
              <div class="tooltip-drag-handle" style="position:absolute; top:2px; right:2px; width:24px; height:24px; cursor:move; display:flex; align-items:center; justify-content:center; opacity:0.7; font-size:16px; user-select:none;" title="æ‹–æ›³ç§»å‹•">â ¿</div>
              <div style="font-weight:bold; margin-bottom:5px; font-size:14px;">ä½ç½®è³‡è¨Š: ${selectedIdx + 1}</div>
              <div>è·é›¢${startName}: ${distanceFromStart.toFixed(3)} km</div>
              <div>è·é›¢${endName}: ${distanceFromEnd.toFixed(3)} km</div>
              <div>æµ·æ‹”é«˜åº¦: ${dataValue.toFixed(0)} m</div>
              <div>åº§æ¨™: ${currentLat.toFixed(6)}, ${currentLng.toFixed(6)}</div>
              <div style="color: ${clearanceColor}; font-weight: bold;">${obstructionStatus}: ${clearanceText}</div>
            `;
            const chartArea = fullscreenChartInstance.chartArea;
            const xScale = fullscreenChartInstance.scales.x;
            const yScale = fullscreenChartInstance.scales.y;
            if (xScale && yScale) {
              const xPos = xScale.getPixelForValue(selectedIdx);
              const yPos = yScale.getPixelForValue(dataValue);
              const canvas = fullscreenChartInstance.canvas;
              const canvasRect = canvas.getBoundingClientRect();
              tooltipEl.style.opacity = '1';
              tooltipEl.style.left = (canvasRect.left + xPos) + 'px';
              tooltipEl.style.top = (canvasRect.top + yPos) + 'px';
              setTimeout(() => {
                const tooltipRect = tooltipEl.getBoundingClientRect();
                const tooltipWidth = tooltipRect.width;
                const tooltipHeight = tooltipRect.height;
                const tooltipX = canvasRect.left + xPos;
                const tooltipY = canvasRect.top + yPos;
                const canvasWidth = canvasRect.width;
                const canvasHeight = canvasRect.height;
                let transformX = '-50%';
                let transformY = '-120%';
                const offsetY = 30;
                const spaceAbove = tooltipY - canvasRect.top;
                const spaceBelow = (canvasRect.top + canvasHeight) - tooltipY;
                if (spaceAbove < tooltipHeight + offsetY) {
                  if (spaceBelow > tooltipHeight + offsetY) {
                    transformY = '20%';
                  } else {
                    transformY = '-50%';
                  }
                }
                const spaceLeft = tooltipX - canvasRect.left;
                const spaceRight = (canvasRect.left + canvasWidth) - tooltipX;
                const horizontalMargin = 10;
                if (spaceLeft < tooltipWidth/2 + horizontalMargin) {
                  transformX = '10%';
                } else if (spaceRight < tooltipWidth/2 + horizontalMargin) {
                  transformX = '-110%';
                }
                tooltipEl.style.transform = `translate(${transformX}, ${transformY})`;
              }, 10);
            }
          }
        }
      }
    } else {
    }
  }

  // ğŸ¯ æ›´æ–°ä¿å­˜çš„ç‹€æ…‹
  if (window.lastFullscreenState) {
    window.lastFullscreenState.infoVisible = fullscreenInfoVisible;
  }
}
let obstructionColorEnabled = false;
function toggleObstructionColor() {
  obstructionColorEnabled = !obstructionColorEnabled;
  const toggleBtn = document.querySelector('.chart-fullscreen-obstruction-toggle');
  if (!fullscreenChartInstance) {
    return;
  }
  const terrainDataset = fullscreenChartInstance.data.datasets.find(d =>
    d.label && (d.label.includes('åœ°å½¢æµ·æ‹”') || d.label.includes('æµ·æ‹”'))
  );
  const losDataset = fullscreenChartInstance.data.datasets.find(d =>
    d.label && (d.label.includes('è¦–è·é€£ç·š') || d.label.includes('è¦–è·'))
  );
  if (!terrainDataset || !losDataset) {
    return;
  }
  if (obstructionColorEnabled) {
    toggleBtn.classList.remove('disabled');
    toggleBtn.style.opacity = '1';
    const segmentColors = [];
    const terrainData = terrainDataset.data;
    const losData = losDataset.data;
    for (let i = 0; i < terrainData.length - 1; i++) {
      const isObstructed = terrainData[i] > losData[i] || terrainData[i + 1] > losData[i + 1];
      segmentColors.push({
        borderColor: isObstructed ? '#ff4444' : '#059669',
        backgroundColor: isObstructed ? 'rgba(255, 68, 68, 0.1)' : 'rgba(5, 150, 105, 0.2)'
      });
    }
    terrainDataset.segment = {
      borderColor: (ctx) => {
        const idx = ctx.p0DataIndex;
        if (idx < segmentColors.length) {
          return segmentColors[idx].borderColor;
        }
        return '#059669';
      },
      backgroundColor: (ctx) => {
        const idx = ctx.p0DataIndex;
        if (idx < segmentColors.length) {
          return segmentColors[idx].backgroundColor;
        }
        return 'rgba(5, 150, 105, 0.2)';
      }
    };
    terrainDataset.borderColor = '#ff8866';
    terrainDataset.backgroundColor = 'rgba(255, 136, 102, 0.1)';
  } else {
    toggleBtn.classList.add('disabled');
    toggleBtn.style.opacity = '0.6';
    delete terrainDataset.segment;
    terrainDataset.borderColor = '#059669';
    terrainDataset.backgroundColor = 'rgba(5, 150, 105, 0.2)';
  }
  fullscreenChartInstance.update();

  // ğŸ¯ æ›´æ–°ä¿å­˜çš„ç‹€æ…‹
  if (window.lastFullscreenState) {
    window.lastFullscreenState.obstructionEnabled = obstructionColorEnabled;
  }
}
// ===== åœ¨å‰–é¢åœ–å…¨å±å…§é¡¯ç¤º AB åœ– =====
let _abPanelOriginalParent = null;  // è¨˜ä½ route-map åŸæœ¬çš„çˆ¶ç¯€é»
let _abPanelOriginalNextSibling = null;  // è¨˜ä½ route-map åŸæœ¬çš„ä½ç½®

function openABMapFromFullscreen() {
  if (!pathData || pathData.length < 2) {
    alert('âŒ å°šæœªç”Ÿæˆè·¯å¾‘å‰–é¢ï¼Œè«‹å…ˆè¨ˆç®—è·¯å¾‘');
    return;
  }

  // ç¢ºä¿ route-map-container å’Œ Leaflet å¯¦ä¾‹å·²å­˜åœ¨
  const routeMapContainer = document.getElementById('route-map-container');
  if (!routeMapInstance || !routeMapContainer ||
    routeMapContainer.style.display === 'none' || routeMapContainer.style.display === '') {
    showRouteMap();
  }

  const overlay = document.getElementById('chartFullscreenOverlay');
  const routeMapDiv = document.getElementById('route-map');
  if (!overlay || !routeMapDiv) return;

  // å»ºç«‹ï¼ˆæˆ–å–å‡ºï¼‰åŒ…è¦† panel
  let panel = overlay.querySelector('#ab-inline-panel');
  if (!panel) {
    panel = document.createElement('div');
    panel.id = 'ab-inline-panel';
    panel.style.cssText = [
      'position:absolute', 'top:0', 'left:0', 'width:100%', 'height:100%',
      'background:#000', 'z-index:10003', 'display:none', 'overflow:hidden'
    ].join(';');

    // é—œé–‰æŒ‰éˆ•
    const closeBtn = document.createElement('button');
    closeBtn.innerHTML = 'âœ•';
    closeBtn.style.cssText = [
      'position:absolute', 'top:10px', 'right:10px', 'z-index:10010',
      'width:36px', 'height:36px',
      'background:rgba(220,38,38,0.95)', 'color:#fff',
      'border:2px solid rgba(255,255,255,0.3)', 'border-radius:50%',
      'font-size:20px', 'font-weight:bold', 'cursor:pointer',
      'display:flex', 'align-items:center', 'justify-content:center',
      'box-shadow:0 4px 12px rgba(0,0,0,0.5)', 'line-height:1'
    ].join(';');
    closeBtn.title = 'é—œé–‰åœ°åœ–';
    closeBtn.onclick = closeABMapFromFullscreen;
    panel.appendChild(closeBtn);

    overlay.appendChild(panel);
  }

  // æŠŠ route-map ç¯€é»æ¬é€² panelï¼ˆè¨˜ä½åŸä½ç½®ä»¥ä¾¿é‚„åŸï¼‰
  _abPanelOriginalParent = routeMapDiv.parentNode;
  _abPanelOriginalNextSibling = routeMapDiv.nextSibling;
  routeMapDiv.style.width = '100%';
  routeMapDiv.style.height = '100%';
  routeMapDiv.style.borderRadius = '0';
  routeMapDiv.style.border = 'none';
  routeMapDiv.style.boxSizing = 'border-box';
  panel.appendChild(routeMapDiv);
  panel.style.display = 'block';

  // é€šçŸ¥ Leaflet é‡æ–°è¨ˆç®—å°ºå¯¸ï¼Œå®Œæˆå¾ŒåŒæ­¥ç›®å‰é¸ä¸­é»
  setTimeout(() => {
    if (routeMapInstance) {
      routeMapInstance.invalidateSize();
    }
    // åŒæ­¥å‰–é¢åœ–ç›®å‰é»åˆ°åœ°åœ–çš„é»æ§åˆ¶åˆ—
    const mapPointInput = document.getElementById('mapPointInput');
    const currentIdx = (typeof window.currentSelectedPointIndex !== 'undefined' &&
              window.currentSelectedPointIndex !== null &&
              window.currentSelectedPointIndex >= 0)
               ? window.currentSelectedPointIndex : 0;
    if (mapPointInput) {
      mapPointInput.value = currentIdx + 1;
      mapPointInput.max = pathData.length;
    }
    // è·³åˆ°è©²é»ä¸¦é¡¯ç¤ºæ¨™è¨˜
    mapJumpToPoint(currentIdx);
  }, 100);
}

function closeABMapFromFullscreen() {
  const overlay = document.getElementById('chartFullscreenOverlay');
  const panel = overlay ? overlay.querySelector('#ab-inline-panel') : null;
  const routeMapDiv = document.getElementById('route-map');
  if (!panel || !routeMapDiv) return;

  // æŠŠ route-map é‚„åŸåˆ°åŸä½
  if (_abPanelOriginalParent) {
    if (_abPanelOriginalNextSibling && _abPanelOriginalNextSibling.parentNode === _abPanelOriginalParent) {
      _abPanelOriginalParent.insertBefore(routeMapDiv, _abPanelOriginalNextSibling);
    } else {
      _abPanelOriginalParent.appendChild(routeMapDiv);
    }
  }
  // é‚„åŸåŸæœ¬æ¨£å¼
  routeMapDiv.style.width = '100%';
  routeMapDiv.style.height = '450px';
  routeMapDiv.style.borderRadius = '8px';
  routeMapDiv.style.border = '2px solid #5ff0d5';
  routeMapDiv.style.boxSizing = '';

  panel.style.display = 'none';
  _abPanelOriginalParent = null;
  _abPanelOriginalNextSibling = null;

  // é€šçŸ¥ Leaflet é‚„åŸå°ºå¯¸
  setTimeout(() => {
    if (routeMapInstance) {
      routeMapInstance.invalidateSize();
    }
  }, 80);
}

function openGoogleMapForYellowPoint() {
  if (typeof window.currentSelectedPointIndex === 'undefined' ||
    window.currentSelectedPointIndex === null ||
    window.currentSelectedPointIndex < 0) {
    alert('âŒ è«‹å…ˆé»æ“Šåœ–è¡¨ä¸Šçš„ä»»ä¸€é»ä»¥é¸æ“‡ä½ç½®');
    return;
  }
  if (!pathData || pathData.length === 0) {
    alert('âŒ æ‰¾ä¸åˆ°è·¯å¾‘æ•¸æ“šï¼Œè«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  const index = window.currentSelectedPointIndex;
  if (index >= pathData.length) {
    alert('âŒ é¸ä¸­çš„é»ç´¢å¼•ç„¡æ•ˆ');
    return;
  }
  const point = pathData[index];
  const lat = point.lat;
  const lng = point.lng;
  const overlay = document.getElementById('chartFullscreenOverlay');
  let mapContainer = overlay.querySelector('#embedded-map-container');
  if (!mapContainer) {
    mapContainer = document.createElement('div');
    mapContainer.id = 'embedded-map-container';
    mapContainer.style.position = 'fixed';
    mapContainer.style.top = '0';
    mapContainer.style.left = '0';
    mapContainer.style.width = '100%';
    mapContainer.style.height = '100%';
    mapContainer.style.background = '#1a1a1a';
    mapContainer.style.zIndex = '10004';
    mapContainer.style.display = 'none';
    mapContainer.style.padding = '0';
    mapContainer.style.overflow = 'hidden';
    const titleBar = document.createElement('div');
    titleBar.style.background = 'rgba(13, 71, 161, 0.9)';
    titleBar.style.backdropFilter = 'blur(10px)';
    titleBar.style.color = 'white';
    titleBar.style.padding = '8px 12px';
    titleBar.style.fontWeight = 'bold';
    titleBar.style.fontSize = '14px';
    titleBar.style.display = 'flex';
    titleBar.style.justifyContent = 'flex-start';
    titleBar.style.alignItems = 'center';
    titleBar.style.gap = '10px';
    titleBar.style.position = 'absolute';
    titleBar.style.top = '10px';
    titleBar.style.right = '10px';
    titleBar.style.left = 'auto';
    titleBar.style.width = 'auto';
    titleBar.style.borderRadius = '8px';
    titleBar.style.border = '2px solid #4dabf7';
    titleBar.style.boxShadow = '0 4px 12px rgba(0,0,0,0.6)';
    titleBar.style.zIndex = '10005';
    titleBar.innerHTML = `
      <span style="font-size:13px;">ğŸ“ é»</span>
      <div style="display:flex; gap:4px; align-items:center;">
        <button onclick="decrementMapPoint()" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); color:#022; border:none; padding:3px 8px; border-radius:4px; cursor:pointer; font-weight:bold; font-size:14px; height:26px; min-width:32px;">â—€</button>
        <input type="number" id="mapPointInput" value="${index + 1}" min="1" max="${pathData.length}" style="width:70px; padding:3px 6px; font-size:14px; color:#5ff0d5; background:rgba(0,0,0,0.7); border:2px solid rgba(95,240,213,0.3); border-radius:4px; text-align:center; height:26px; font-weight:bold;" oninput="updateMapPointFromInput()">
        <button onclick="incrementMapPoint()" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); color:#022; border:none; padding:3px 8px; border-radius:4px; cursor:pointer; font-weight:bold; font-size:14px; height:26px; min-width:32px;">â–¶</button>
      </div>
      <div style="display:flex; gap:6px;">
        <button onclick="openInNewTabFromEmbedded()" style="background:rgba(255,255,255,0.95); color:#1971c2; border:none; padding:5px 10px; border-radius:5px; cursor:pointer; font-weight:bold; font-size:13px; white-space:nowrap;">ğŸ”— é–‹å•Ÿ</button>
        <button onclick="closeEmbeddedMap()" style="background:rgba(255,68,68,0.95); color:white; border:none; padding:5px 10px; border-radius:5px; cursor:pointer; font-weight:bold; font-size:14px;">âœ•</button>
      </div>
    `;
    mapContainer.appendChild(titleBar);
    const iframeWrapper = document.createElement('div');
    iframeWrapper.style.width = '100%';
    iframeWrapper.style.height = '100%';
    iframeWrapper.style.background = '#1a1a1a';
    const iframe = document.createElement('iframe');
    iframe.id = 'embedded-map-iframe';
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.style.border = 'none';
    iframe.allowFullscreen = true;
    iframeWrapper.appendChild(iframe);
    mapContainer.appendChild(iframeWrapper);
    overlay.appendChild(mapContainer);
  }
  const iframe = mapContainer.querySelector('#embedded-map-iframe');
  const googleMapUrl = `https://maps.google.com/maps?q=${lat},${lng}&t=k&z=17&output=embed`;
  iframe.src = googleMapUrl;
  window.currentMapCoords = { lat, lng };
  const titleSpan = mapContainer.querySelector('span');
  if (titleSpan) {
    titleSpan.innerHTML = `ğŸ“ é»`;
  }
  const mapPointInput = mapContainer.querySelector('#mapPointInput');
  if (mapPointInput) {
    mapPointInput.value = index + 1;
    mapPointInput.max = pathData.length;
  }
  mapContainer.style.display = 'block';
}
function closeEmbeddedMap() {
  const overlay = document.getElementById('chartFullscreenOverlay');
  const mapContainer = overlay.querySelector('#embedded-map-container');
  if (mapContainer) {
    mapContainer.style.display = 'none';
    const iframe = mapContainer.querySelector('#embedded-map-iframe');
    if (iframe) {
      iframe.src = 'about:blank';
    }
  }
}
function openInNewTabFromEmbedded() {
  if (window.currentMapCoords) {
    const { lat, lng } = window.currentMapCoords;
    const googleMapUrl = `https://www.google.com/maps?q=${lat},${lng}&t=k&z=17`;
    window.open(googleMapUrl, '_blank');
  }
}
function decrementMapPoint() {
  if (typeof window.currentSelectedPointIndex === 'undefined' || window.currentSelectedPointIndex === null) {
    return;
  }
  if (!pathData || pathData.length === 0) {
    return;
  }
  let newIndex = window.currentSelectedPointIndex - 1;
  if (newIndex < 0) {
    newIndex = pathData.length - 1;
  }
  window.currentSelectedPointIndex = newIndex;
  const point = pathData[newIndex];
  const lat = parseFloat(point.lat);
  const lng = parseFloat(point.lng);
  
  // ğŸ¯ é—œéµä¿®æ”¹ï¼šæ›´æ–°ã€Œä½ç½®è³‡è¨Šã€å€å¡Š
  showMap(newIndex, getElevationForIndex(newIndex));
  
  const overlay = document.getElementById('chartFullscreenOverlay');
  const mapContainer = overlay ? overlay.querySelector('#embedded-map-container') : null;
  if (mapContainer) {
    const iframe = mapContainer.querySelector('#embedded-map-iframe');
    const googleMapUrl = `https://maps.google.com/maps?q=${lat},${lng}&t=k&z=17&output=embed`;
    iframe.src = googleMapUrl;
    window.currentMapCoords = { lat, lng };
    const mapPointInput = mapContainer.querySelector('#mapPointInput');
    if (mapPointInput) {
      mapPointInput.value = newIndex + 1;
    }
  }
  const fullscreenPointInput = document.getElementById('fullscreenPointInput');
  if (fullscreenPointInput) {
    fullscreenPointInput.value = newIndex + 1;
  }
  const selectedPointInput = document.getElementById('selectedPointIndex');
  if (selectedPointInput) {
    selectedPointInput.value = newIndex + 1;
  }
  syncFullscreenChartAfterButtonClick(newIndex);
}
function incrementMapPoint() {
  if (typeof window.currentSelectedPointIndex === 'undefined' || window.currentSelectedPointIndex === null) {
    return;
  }
  if (!pathData || pathData.length === 0) {
    return;
  }
  let newIndex = window.currentSelectedPointIndex + 1;
  if (newIndex >= pathData.length) {
    newIndex = 0;
  }
  window.currentSelectedPointIndex = newIndex;
  const point = pathData[newIndex];
  const lat = parseFloat(point.lat);
  const lng = parseFloat(point.lng);
  
  // ğŸ¯ é—œéµä¿®æ”¹ï¼šæ›´æ–°ã€Œä½ç½®è³‡è¨Šã€å€å¡Š
  showMap(newIndex, getElevationForIndex(newIndex));
  
  const overlay = document.getElementById('chartFullscreenOverlay');
  const mapContainer = overlay ? overlay.querySelector('#embedded-map-container') : null;
  if (mapContainer) {
    const iframe = mapContainer.querySelector('#embedded-map-iframe');
    const googleMapUrl = `https://maps.google.com/maps?q=${lat},${lng}&t=k&z=17&output=embed`;
    iframe.src = googleMapUrl;
    window.currentMapCoords = { lat, lng };
    const mapPointInput = mapContainer.querySelector('#mapPointInput');
    if (mapPointInput) {
      mapPointInput.value = newIndex + 1;
    }
  }
  const fullscreenPointInput = document.getElementById('fullscreenPointInput');
  if (fullscreenPointInput) {
    fullscreenPointInput.value = newIndex + 1;
  }
  const selectedPointInput = document.getElementById('selectedPointIndex');
  if (selectedPointInput) {
    selectedPointInput.value = newIndex + 1;
  }
  syncFullscreenChartAfterButtonClick(newIndex);
}
function updateMapPointFromInput() {
  const mapPointInput = document.getElementById('mapPointInput');
  if (!mapPointInput) {
    return;
  }
  const value = parseInt(mapPointInput.value);
  if (isNaN(value) || value < 1 || !pathData || value > pathData.length) {
    return;
  }
  const newIndex = value - 1;
  window.currentSelectedPointIndex = newIndex;
  const point = pathData[newIndex];
  const lat = parseFloat(point.lat);
  const lng = parseFloat(point.lng);
  
  // ğŸ¯ æ›´æ–°ã€Œä½ç½®è³‡è¨Šã€å€å¡Šå’Œåœ–è¡¨
  showMap(newIndex, getElevationForIndex(newIndex));
  
  // æ›´æ–°åµŒå…¥å¼åœ°åœ–ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
  const overlay = document.getElementById('chartFullscreenOverlay');
  const mapContainer = overlay ? overlay.querySelector('#embedded-map-container') : null;
  if (mapContainer) {
    const iframe = mapContainer.querySelector('#embedded-map-iframe');
    const googleMapUrl = `https://maps.google.com/maps?q=${lat},${lng}&t=k&z=17&output=embed`;
    iframe.src = googleMapUrl;
    window.currentMapCoords = { lat, lng };
  }
  
  // åŒæ­¥å…¶ä»–è¼¸å…¥æ¡†
  const fullscreenPointInput = document.getElementById('fullscreenPointInput');
  if (fullscreenPointInput) {
    fullscreenPointInput.value = newIndex + 1;
  }
  const selectedPointInput = document.getElementById('selectedPointIndex');
  if (selectedPointInput) {
    selectedPointInput.value = newIndex + 1;
  }
  
  // åŒæ­¥åœ–è¡¨
  syncFullscreenChartAfterButtonClick(newIndex);
}
function showMap(index, height) {
  tooltipManualPosition = null;
  const p = pathData[index];
  const mapContainer = document.getElementById('map-container');
  const mapFrame = document.getElementById('map-frame');
  const mapDetails = document.getElementById('map-details');
  const selectedPointInput = document.getElementById('selectedPointIndex');
  const fullscreenPointInput = document.getElementById('fullscreenPointInput');
  if (!mapContainer || !mapFrame || !mapDetails) {
    return;
  }
  
  // ğŸ” æª¢æŸ¥é«˜åº¦æ˜¯å¦ç‚º NoData å€¼
  const commonNoDataValues = [-32768, -32767, -9999, -99999, -12345, 32767, 65535, -3.4028235e+38];
  const isNoData = commonNoDataValues.some(noData => Math.abs(height - noData) < 0.01);
  const isInvalidHeight = isNoData || height < -500 || height > 9000 || height === null || height === undefined || isNaN(height);
  
  // å¦‚æœæ˜¯ç„¡æ•ˆé«˜åº¦ï¼Œæ¨™è¨˜ç‚ºå¾…å–å¾—
  let displayHeight = height;
  let heightStatus = '';
  if (isInvalidHeight) {
    displayHeight = '???';
    heightStatus = ' <span style="color:#ffd43b; font-size:11px;">(ç„¡åœ–è³‡)</span>';
  }
  
  if (selectedPointInput) {
    selectedPointInput.value = index + 1;
  }
  if (fullscreenPointInput) {
    fullscreenPointInput.value = index + 1;
  }
  if (chartInstance && chartInstance.data.datasets[0].pointBackgroundColor) {
    const pointColors = chartInstance.data.datasets[0].pointBackgroundColor;
    const pointRadius = chartInstance.data.datasets[0].pointRadius;
    const pointHoverRadius = chartInstance.data.datasets[0].pointHoverRadius;
    for (let i = 0; i < pointColors.length; i++) {
      if (i === index) {
        pointColors[i] = '#ffd43b';
        pointRadius[i] = 6;
        pointHoverRadius[i] = 10;
      } else {
        pointColors[i] = '#059669';
        if (typeof greenPointsVisible !== 'undefined' && !greenPointsVisible) {
          pointRadius[i] = 0;
          pointHoverRadius[i] = 0;
        } else {
          pointRadius[i] = 3;
          pointHoverRadius[i] = 8;
        }
      }
    }
    chartInstance.update();
  }
  window.currentSelectedPointIndex = index;
  const nameA = window.elevationPointAName || 'Aé»';
  const nameB = window.elevationPointBName || 'Bé»';
  const totalDistance = pathData[pathData.length - 1].dist;
  const distanceToB = (totalDistance - parseFloat(p.dist)).toFixed(3);
  let obstructionInfo = '';
  if (elevationData && elevationData.length > 0 && chartInstance && chartInstance.data.datasets[1]) {
    const losLineData = chartInstance.data.datasets[1].data;
    if (losLineData && losLineData[index] !== undefined) {
      const losHeight = losLineData[index];
      const terrainHeight = elevationData[index];
      const clearance = losHeight - terrainHeight;
      const isStartPoint = (index === 0);
      const isEndPoint = (index === elevationData.length - 1);
      if (clearance > 0) {
        obstructionInfo = `<br><span style="color:#ffd43b;">ç„¡é®è”½:</span> <span style="color:#51cf66; font-weight:bold;">+${clearance.toFixed(2)} m</span>`;
      } else if (clearance === 0 && (isStartPoint || isEndPoint)) {
        obstructionInfo = `<br><span style="color:#ffd43b;">ç„¡é®è”½:</span> <span style="color:#51cf66; font-weight:bold;">0.00 m</span>`;
      } else {
        obstructionInfo = `<br><span style="color:#ffd43b;">æœ‰é®è”½:</span> <span style="color:#ff6b6b; font-weight:bold;">${clearance.toFixed(2)} m</span>`;
      }
    }
  }
  mapContainer.style.display = 'block';
  mapDetails.innerHTML = `<strong><span style="color:#ffd43b;">ä½ç½®è³‡è¨Š:</span> <span style="color:#5ff0d5;">${index + 1}</span></strong><br><span style="color:#ffd43b;">è·é›¢${nameA}:</span> <span style="color:#5ff0d5;">${p.dist} km</span><br><span style="color:#ffd43b;">è·é›¢${nameB}:</span> <span style="color:#5ff0d5;">${distanceToB} km</span><br><span style="color:#ffd43b;">æµ·æ‹”+å¤©ç·šé«˜åº¦:</span> <span style="color:#5ff0d5;">${displayHeight} m${heightStatus}</span><br><span style="color:#ffd43b;">åº§æ¨™:</span> <span style="color:#5ff0d5;">${p.lat}, ${p.lng}</span>${obstructionInfo}`;
  const mapUrl = `https://maps.google.com/maps?q=${p.lat},${p.lng}&t=k&z=17&output=embed`;
  mapFrame.src = mapUrl;

  // ğŸ”— é€£å‹•è·¯å¾‘åœ°åœ–ï¼šæ›´æ–°åœ°åœ–ä¸Šçš„æ¨™è¨˜ä½ç½®
  if (routeMapInstance && pathData && pathData[index]) {
    const pointLat = parseFloat(p.lat);
    const pointLng = parseFloat(p.lng);

    // ç§»é™¤èˆŠæ¨™è¨˜
    if (clickMarker) {
      routeMapInstance.removeLayer(clickMarker);
    }
    if (clickPopup) {
      routeMapInstance.closePopup(clickPopup);
    }

    // å‰µå»ºæ–°æ¨™è¨˜
    const markerIcon = L.divIcon({
      className: 'click-marker',
      html: '<div style="background:#FFA500; width:20px; height:20px; border-radius:50%; border:2px solid white; box-shadow:0 2px 6px rgba(0,0,0,0.4);"></div>',
      iconSize: [20, 20],
      iconAnchor: [10, 10]
    });

    clickMarker = L.marker([pointLat, pointLng], { icon: markerIcon }).addTo(routeMapInstance);

    // ğŸ¯ æ›´æ–°åœ°åœ–é»æ§åˆ¶å–®å…ƒçš„æ•¸å€¼
    const mapPointInput = document.getElementById('mapPointInput');
    if (mapPointInput) {
      mapPointInput.value = index + 1;
    }

    // æº–å‚™é®è”½è³‡è¨Š
    let clearanceInfo = '';
    if (elevationData && elevationData.length > 0 && chartInstance && chartInstance.data.datasets[1]) {
      const losLineData = chartInstance.data.datasets[1].data;
      if (losLineData && losLineData[index] !== undefined) {
        const losHeight = losLineData[index];
        const terrainHeight = elevationData[index];
        const clearance = losHeight - terrainHeight;

        const clearanceColor = clearance >= 0 ? '#4caf50' : '#ff4444';
        let clearanceText = '';
        let obstructionStatus = '';
        if (clearance > 0) {
          clearanceText = `+${clearance.toFixed(2)} m`;
          obstructionStatus = 'ç„¡é®è”½';
        } else if (clearance < 0) {
          clearanceText = `${clearance.toFixed(2)} m`;
          obstructionStatus = 'æœ‰é®è”½';
        } else {
          clearanceText = '0.00 m';
          obstructionStatus = 'ç„¡é®è”½';
        }

        clearanceInfo = `<div style="color: ${clearanceColor}; font-weight: bold; font-size: 13px; margin-top: 2px;">${obstructionStatus}: ${clearanceText}</div>`;
      }
    }

    // ğŸ¯ å„ªå…ˆä½¿ç”¨ pathData ä¸­çš„é«˜åº¦ï¼ˆä¾†è‡ªå‰–é¢åœ–ï¼‰ï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨å‚³å…¥çš„ height åƒæ•¸
    const elevationFromPath = pathData[index]?.ele;
    const elevationToDisplay = (elevationFromPath !== null && elevationFromPath !== undefined) ? elevationFromPath : height;
    
    // ğŸ” æª¢æŸ¥é«˜åº¦æ˜¯å¦ç‚º NoData å€¼
    const commonNoDataValues = [-32768, -32767, -9999, -99999, -12345, 32767, 65535, -3.4028235e+38];
    const isNoData = commonNoDataValues.some(noData => Math.abs(elevationToDisplay - noData) < 0.01);
    const isInvalidHeight = isNoData || elevationToDisplay < -500 || elevationToDisplay > 9000 || elevationToDisplay === null || elevationToDisplay === undefined || isNaN(elevationToDisplay);

    // å‰µå»ºå½ˆçª—å…§å®¹ï¼ˆæ”¾å¤§æ–‡å­—,å«æ‹–æ›³æç¤ºåˆ—ï¼‰
    const popupContent = `
      <div class="popup-drag-bar">â ¿ ğŸ“ é» ${index + 1}</div>
      <div class="popup-body">
        <div>
          <span style="color:#555;">ç·¯ï¼š</span><span style="color:#000; font-weight:600;">${pointLat.toFixed(6)}Â°</span>
        </div>
        <div>
          <span style="color:#555;">ç¶“ï¼š</span><span style="color:#000; font-weight:600;">${pointLng.toFixed(6)}Â°</span>
        </div>
        <div>
          <span style="color:#555;">é«˜åº¦ï¼š</span><span style="color:${isInvalidHeight ? '#ffd43b' : '#FF6B00'}; font-weight:700; font-size:15px;">${isInvalidHeight ? '???' : elevationToDisplay.toFixed(1)} m</span>${isInvalidHeight ? '<span style="color:#ffd43b; font-size:10px;"> (ç„¡åœ–è³‡)</span>' : ''}
        </div>
        ${clearanceInfo}
      </div>
    `;

    // é¡¯ç¤ºå½ˆçª—ï¼ˆæ”¾å¤§ç‰ˆ,æ”¯æ´æ‹–æ›³ï¼‰
    clickPopup = L.popup({
      maxWidth: 240,
      minWidth: 150,
      className: 'custom-popup-compact',
      autoPan: false,
      offset: [popupRelOffset.x, popupRelOffset.y]
    })
      .setLatLng([pointLat, pointLng])
      .setContent(popupContent)
      .openOn(routeMapInstance);

    // æ‡‰ç”¨ç•¶å‰é¡¯ç¤ºæ¨¡å¼ä¸¦æ·»åŠ æ‹–æ›³åŠŸèƒ½
    setTimeout(() => {
      const popupElement = clickPopup.getElement();

      if (popupElement) {
        if (popupDisplayMode === 'hide') {
          popupElement.style.opacity = '0';
          popupElement.style.pointerEvents = 'none';
        } else {
          popupElement.style.opacity = '1';
          popupElement.style.pointerEvents = 'auto';
        }

        // æ·»åŠ æ‹–æ›³åŠŸèƒ½
        enablePopupDragging(popupElement);
      } else {
      }
    }, 100);

    // å°‡åœ°åœ–ä¸­å¿ƒç§»å‹•åˆ°è©²é»ï¼ˆå¯é¸ï¼Œå¦‚æœéœ€è¦çš„è©±ï¼‰
    // routeMapInstance.panTo([pointLat, pointLng]);

  }
}
let routeMapInstance = null;
let routeCurrentLayer = null;
let routeStreetLayer = null;
let routeSatelliteLayer = null;
let routeHybridLayer = null;
let routeLayerControl = null;
let clickMarker = null;
let clickPopup = null;
let popupDisplayMode = 'show'; // 'show', 'hide'
let popupRelOffset = { x: 0, y: -60 }; // â˜… å…¨åŸŸï¼špopup ç›¸å°æ¨™è¨˜çš„åƒç´ åç§»ï¼ˆæ‹–æ›³å¾Œæ›´æ–°ï¼Œæ–°é»æ²¿ç”¨ï¼‰
let isDraggingPopup = false;
let dragStartPos = { x: 0, y: 0 };
function showRouteMap() {
  if (!pathData || pathData.length < 2) {
    return;
  }
  const routeMapContainer = document.getElementById('route-map-container');
  const routeMapDiv = document.getElementById('route-map');
  const routeStartInfo = document.getElementById('route-start-info');
  const routeEndInfo = document.getElementById('route-end-info');
  const routeDistanceInfo = document.getElementById('route-distance-info');
  if (!routeMapContainer || !routeMapDiv) {
    return;
  }
  const startPoint = pathData[0];
  const endPoint = pathData[pathData.length - 1];
  const nameA = window.elevationPointAName || 'Aé»';
  const nameB = window.elevationPointBName || 'Bé»';
  const distance = endPoint.dist;

  // ğŸ”„ å¾é«˜åº¦åœ–åˆ†é çš„è¼¸å…¥æ¡†è®€å–åŸå§‹ABé»åº§æ¨™ï¼ˆèˆ‡GPSåˆ†é åŒæ­¥ï¼‰
  const sLatInput = document.getElementById('sLat');
  const sLngInput = document.getElementById('sLng');
  const eLatInput = document.getElementById('eLat');
  const eLngInput = document.getElementById('eLng');

  // ä½¿ç”¨åŸå§‹è¼¸å…¥çš„åº§æ¨™è€ŒépathDataä¸­çš„åº§æ¨™
  const originalStartLat = sLatInput && sLatInput.value ? parseFloat(sLatInput.value) : parseFloat(startPoint.lat);
  const originalStartLng = sLngInput && sLngInput.value ? parseFloat(sLngInput.value) : parseFloat(startPoint.lng);
  const originalEndLat = eLatInput && eLatInput.value ? parseFloat(eLatInput.value) : parseFloat(endPoint.lat);
  const originalEndLng = eLngInput && eLngInput.value ? parseFloat(eLngInput.value) : parseFloat(endPoint.lng);

  if (routeStartInfo) {
    routeStartInfo.textContent = `${nameA} (${originalStartLat.toFixed(6)}, ${originalStartLng.toFixed(6)})`;
  }
  if (routeEndInfo) {
    routeEndInfo.textContent = `${nameB} (${originalEndLat.toFixed(6)}, ${originalEndLng.toFixed(6)})`;
  }
  if (routeDistanceInfo) {
    routeDistanceInfo.textContent = `${distance} km`;
  }
  routeMapContainer.style.display = 'block';
  const startLat = originalStartLat;
  const startLng = originalStartLng;
  const endLat = originalEndLat;
  const endLng = originalEndLng;

  // è¨ˆç®— Aã€B ç·šæ®µçš„æ–¹å‘ï¼ˆä¾›å¾ŒçºŒæ¨™è¨˜ä½ç½®ä½¿ç”¨ï¼‰
  const latDiff = endLat - startLat;
  const lngDiff = endLng - startLng;
  const lineLength = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
  const unitLat = latDiff / lineLength;
  const unitLng = lngDiff / lineLength;

  const centerLat = (startLat + endLat) / 2;
  const centerLng = (startLng + endLng) / 2;
  const absDiff = Math.abs(startLat - endLat);
  const lngAbsDiff = Math.abs(startLng - endLng);
  const maxDiff = Math.max(absDiff, lngAbsDiff);
  let zoom = 13;
  if (maxDiff > 0.1) zoom = 11;
  if (maxDiff > 0.5) zoom = 9;
  if (maxDiff > 1) zoom = 8;
  if (maxDiff > 2) zoom = 7;
  routeMapDiv.innerHTML = '';
  if (typeof L === 'undefined') {
    routeMapDiv.innerHTML = '<div style="padding:20px; color:#ff6b6b; text-align:center;">åœ°åœ–è¼‰å…¥ä¸­...</div>';
    return;
  }
  if (routeMapInstance) {
    routeMapInstance.remove();
    routeMapInstance = null;
  }
  routeStreetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap',
    maxZoom: 19
  });
  routeSatelliteLayer = L.tileLayer('http://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
    attribution: 'Â© Google Maps',
    maxZoom: 20,
    subdomains: ['0', '1', '2', '3']
  });
  routeEarthLayer = L.tileLayer('http://mt{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}', {
    attribution: 'Â© Google Earth',
    maxZoom: 20,
    subdomains: ['0', '1', '2', '3']
  });
  routeHybridLayer = L.layerGroup([
    L.tileLayer('http://mt{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
      attribution: 'Â© Google Maps',
      maxZoom: 20,
      subdomains: ['0', '1', '2', '3']
    }),
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      opacity: 0.3,
      maxZoom: 19
    })
  ]);
  routeNlscLayer = L.tileLayer('https://wmts.nlsc.gov.tw/wmts/PHOTO2/default/GoogleMapsCompatible/{z}/{y}/{x}', {
    attribution: 'Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ',
    maxZoom: 19
  });
  routeMapInstance = L.map(routeMapDiv, {
    center: [centerLat, centerLng],
    zoom: zoom,
    layers: [routeSatelliteLayer]
  });
  routeCurrentLayer = 'satellite';

  // å„²å­˜åŸå§‹åº§æ¨™ä¾›å‹•æ…‹æ›´æ–°ä½¿ç”¨
  // ä½¿ç”¨windowå…¨åŸŸè®Šæ•¸ä»¥ä¾¿éŸ¿æ‡‰å¼ç³»çµ±è¨ªå•
  window.startMarker = null;
  window.endMarker = null;

  // å‹•æ…‹æ›´æ–° Aã€B æ¨™è¨˜ä½ç½®çš„å‡½æ•¸
  function updateMarkerPositions() {
    const currentZoom = routeMapInstance.getZoom();

    // æ ¹æ“šç¸®æ”¾ç´šåˆ¥è¨ˆç®—å»¶ä¼¸è·é›¢ï¼ˆåƒç´ è½‰ç¶“ç·¯åº¦ï¼‰
    // zoom è¶Šå¤§ï¼Œéœ€è¦çš„å»¶ä¼¸ç¶“ç·¯åº¦è¶Šå°
    const pixelToDegree = 0.00015 / Math.pow(2, currentZoom - 13);
    const extendDistance = 19 * pixelToDegree;

    // è¨ˆç®— Aã€B ç·šæ®µçš„æ–¹å‘
    const latDiff = endLat - startLat;
    const lngDiff = endLng - startLng;
    const lineLength = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);

    // è¨ˆç®—å–®ä½å‘é‡
    const unitLat = latDiff / lineLength;
    const unitLng = lngDiff / lineLength;

    // A é»å‘èµ·é»æ–¹å‘å»¶ä¼¸
    const extendedStartLat = startLat - unitLat * extendDistance;
    const extendedStartLng = startLng - unitLng * extendDistance;

    // B é»å‘çµ‚é»æ–¹å‘å»¶ä¼¸
    const extendedEndLat = endLat + unitLat * extendDistance;
    const extendedEndLng = endLng + unitLng * extendDistance;

    // æ›´æ–°æ¨™è¨˜ä½ç½®
    if (startMarker) {
      startMarker.setLatLng([extendedStartLat, extendedStartLng]);
    }
    if (endMarker) {
      endMarker.setLatLng([extendedEndLat, extendedEndLng]);
    }
  }

  const layerControlHTML = `
    <div style="position:absolute; top:10px; right:10px; z-index:1000; background:rgba(0,0,0,0.7); border-radius:8px; padding:8px; display:flex; flex-direction:column; gap:6px;">
      <button id="route-layer-toggle" style="background:linear-gradient(90deg, #9b59b6, #8e44ad); border:none; padding:8px 12px; border-radius:6px; font-weight:bold; color:#fff; cursor:pointer; font-size:13px; white-space:nowrap;">ğŸ›°ï¸ è¡›æ˜Ÿåœ–</button>
    </div>
  `;
  const controlDiv = document.createElement('div');
  controlDiv.innerHTML = layerControlHTML;
  controlDiv.style.cssText = 'position: absolute; top: 10px; right: 10px; z-index: 1000;';
  routeMapDiv.appendChild(controlDiv);
  const toggleButton = document.getElementById('route-layer-toggle');
  if (toggleButton) {
    toggleButton.onclick = function() {
      if (routeCurrentLayer === 'street') {
        routeMapInstance.removeLayer(routeStreetLayer);
        routeSatelliteLayer.addTo(routeMapInstance);
        routeCurrentLayer = 'satellite';
        this.innerHTML = 'ğŸ›°ï¸ è¡›æ˜Ÿåœ–';
      } else if (routeCurrentLayer === 'satellite') {
        routeMapInstance.removeLayer(routeSatelliteLayer);
        routeEarthLayer.addTo(routeMapInstance);
        routeCurrentLayer = 'earth';
        this.innerHTML = 'ğŸŒ åœ°å½¢åœ–';
      } else if (routeCurrentLayer === 'earth') {
        routeMapInstance.removeLayer(routeEarthLayer);
        routeHybridLayer.addTo(routeMapInstance);
        routeCurrentLayer = 'hybrid';
        this.innerHTML = 'ğŸ”€ æ··åˆåœ–';
      } else if (routeCurrentLayer === 'hybrid') {
        routeMapInstance.removeLayer(routeHybridLayer);
        routeNlscLayer.addTo(routeMapInstance);
        routeCurrentLayer = 'nlsc';
        this.innerHTML = 'ğŸ›©ï¸ èˆªç…§åœ–';
      } else {
        routeMapInstance.removeLayer(routeNlscLayer);
        routeStreetLayer.addTo(routeMapInstance);
        routeCurrentLayer = 'street';
        this.innerHTML = 'ğŸ—ºï¸ è¡—é“åœ–';
      }
      // â˜… åˆ‡æ›åœ–å±¤å¾Œï¼Œè‹¥æœ‰å½ˆçª—å‰‡é‡æ–°æ›å›åœ°åœ–ï¼ˆLeaflet åˆ‡æ›åœ–å±¤æœƒé—œé–‰ popupï¼‰
      setTimeout(() => {
        if (clickPopup && clickMarker) {
          const latlng = clickMarker.getLatLng();
          // popupRelOffset ç‚ºå…¨åŸŸï¼ŒopenOn æ™‚ç›´æ¥å¥—ç”¨å³å¯
          clickPopup.options.offset = [popupRelOffset.x, popupRelOffset.y];
          clickPopup.setLatLng(latlng).openOn(routeMapInstance);
          const el = clickPopup.getElement();
          if (el) {
            enablePopupDragging(el);
            if (popupDisplayMode === 'hide') {
              el.style.opacity = '0';
              el.style.pointerEvents = 'none';
            }
          }
        }
      }, 80);
    };
  }

  // ç›£è½åœ°åœ–ç¸®æ”¾äº‹ä»¶ï¼Œå‹•æ…‹æ›´æ–°æ¨™è¨˜ä½ç½®
  routeMapInstance.on('zoomend', updateMarkerPositions);

  const startIcon = L.divIcon({
    className: 'custom-marker',
    html: '<div style="background:#0066FF; width:32px; height:32px; border-radius:50%; border:3px solid white; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white; font-size:18px; box-shadow:0 2px 8px rgba(0,0,0,0.4);">A</div>',
    iconSize: [32, 32],
    iconAnchor: [16, 16]
  });
  const endIcon = L.divIcon({
    className: 'custom-marker',
    html: '<div style="background:#FF0000; width:32px; height:32px; border-radius:50%; border:3px solid white; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white; font-size:18px; box-shadow:0 2px 8px rgba(0,0,0,0.4);">B</div>',
    iconSize: [32, 32],
    iconAnchor: [16, 16]
  });

  // åˆå§‹è¨ˆç®—å»¶ä¼¸åº§æ¨™
  const currentZoom = routeMapInstance.getZoom();
  const pixelToDegree = 0.00015 / Math.pow(2, currentZoom - 13);
  const extendDistance = 19 * pixelToDegree;
  // ä½¿ç”¨ä¹‹å‰è¨ˆç®—çš„ latDiff, lngDiff, lineLength, unitLat, unitLng
  const initialStartLat = startLat - unitLat * extendDistance;
  const initialStartLng = startLng - unitLng * extendDistance;
  const initialEndLat = endLat + unitLat * extendDistance;
  const initialEndLng = endLng + unitLng * extendDistance;

  // å‰µå»ºæ¨™è¨˜ï¼ˆä½¿ç”¨åˆå§‹å»¶ä¼¸åº§æ¨™ï¼Œè¨­ç½®ç‚ºå¯æ‹–æ›³ï¼‰
  window.startMarker = L.marker([initialStartLat, initialStartLng], {
    icon: startIcon,
    draggable: true  // ğŸ”„ å•Ÿç”¨æ‹–æ›³
  }).addTo(routeMapInstance);
  window.startMarker.bindPopup(`<div style="color:#000; padding:5px;"><strong>${nameA}</strong><br>èµ·é»<br>${startLat.toFixed(6)}, ${startLng.toFixed(6)}</div>`);

  window.endMarker = L.marker([initialEndLat, initialEndLng], {
    icon: endIcon,
    draggable: true  // ğŸ”„ å•Ÿç”¨æ‹–æ›³
  }).addTo(routeMapInstance);
  window.endMarker.bindPopup(`<div style="color:#000; padding:5px;"><strong>${nameB}</strong><br>çµ‚é»<br>${endLat.toFixed(6)}, ${endLng.toFixed(6)}</div>`);

  // ğŸ”„ Aé»æ‹–æ›³çµæŸäº‹ä»¶ï¼šæ›´æ–°åº§æ¨™åˆ°GPSå’Œé«˜åº¦åœ–åˆ†é 
  window.startMarker.on('dragend', async function(event) {
    const newLatLng = event.target.getLatLng();
    const newLat = newLatLng.lat;
    const newLng = newLatLng.lng;

    // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“šï¼ˆæœƒè‡ªå‹•åŒæ­¥åˆ°æ‰€æœ‰è¦–åœ–ï¼‰
    coordinateData.A.lat = parseFloat(newLat.toFixed(6));
    coordinateData.A.lng = parseFloat(newLng.toFixed(6));

    // ç²å–æ–°åœ°åä¸¦æ›´æ–°
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${newLat}&lon=${newLng}&zoom=18&addressdetails=1&accept-language=zh-TW`
      );
      if (response.ok) {
        const data = await response.json();
        let locationName = '';

        // å˜—è©¦ç²å–åœ°åï¼ˆèˆ‡GPSåˆ†é é‚è¼¯ä¸€è‡´ï¼‰
        if (data && data.address) {
          if (data.name && data.name.trim() !== '' && !data.name.match(/^[0-9\-]+$/) && data.name.length <= 20) {
            locationName = data.name;
          } else if (data.address.building && data.address.building.trim() !== '' &&
                 !data.address.building.match(/^(yes|house|residential|commercial|retail|apartments|office)$/i)) {
            locationName = data.address.building;
          } else if (data.address.amenity) {
            locationName = data.address.amenity;
          } else if (data.address.road) {
            locationName = data.address.road;
          } else if (data.address.village || data.address.hamlet || data.address.suburb) {
            locationName = data.address.village || data.address.hamlet || data.address.suburb;
          } else if (data.address.town || data.address.city_district) {
            locationName = data.address.town || data.address.city_district;
          } else if (data.address.city || data.address.county || data.address.state) {
            locationName = data.address.city || data.address.county || data.address.state;
          }

          if (locationName && locationName.length > 5) {
            locationName = locationName.substring(0, 5);
          }
        }

        if (locationName) {
          // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“š
          coordinateData.A.name = locationName;
        }
      }
    } catch (error) {
    }

  });

  // ğŸ”„ Bé»æ‹–æ›³çµæŸäº‹ä»¶ï¼šæ›´æ–°åº§æ¨™åˆ°GPSå’Œé«˜åº¦åœ–åˆ†é 
  window.endMarker.on('dragend', async function(event) {
    const newLatLng = event.target.getLatLng();
    const newLat = newLatLng.lat;
    const newLng = newLatLng.lng;

    // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“šï¼ˆæœƒè‡ªå‹•åŒæ­¥åˆ°æ‰€æœ‰è¦–åœ–ï¼‰
    coordinateData.B.lat = parseFloat(newLat.toFixed(6));
    coordinateData.B.lng = parseFloat(newLng.toFixed(6));

    // åŒæ­¥åˆ°é«˜åº¦åœ–åˆ†é 
    if (typeof syncGpsToElevation === 'function') {
      syncGpsToElevation('B');
    }

    // ç²å–æ–°åœ°åä¸¦æ›´æ–°
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${newLat}&lon=${newLng}&zoom=18&addressdetails=1&accept-language=zh-TW`
      );
      if (response.ok) {
        const data = await response.json();
        let locationName = '';

        // å˜—è©¦ç²å–åœ°åï¼ˆèˆ‡GPSåˆ†é é‚è¼¯ä¸€è‡´ï¼‰
        if (data && data.address) {
          if (data.name && data.name.trim() !== '' && !data.name.match(/^[0-9\-]+$/) && data.name.length <= 20) {
            locationName = data.name;
          } else if (data.address.building && data.address.building.trim() !== '' &&
                 !data.address.building.match(/^(yes|house|residential|commercial|retail|apartments|office)$/i)) {
            locationName = data.address.building;
          } else if (data.address.amenity) {
            locationName = data.address.amenity;
          } else if (data.address.road) {
            locationName = data.address.road;
          } else if (data.address.village || data.address.hamlet || data.address.suburb) {
            locationName = data.address.village || data.address.hamlet || data.address.suburb;
          } else if (data.address.town || data.address.city_district) {
            locationName = data.address.town || data.address.city_district;
          } else if (data.address.city || data.address.county || data.address.state) {
            locationName = data.address.city || data.address.county || data.address.state;
          }

          if (locationName && locationName.length > 5) {
            locationName = locationName.substring(0, 5);
          }
        }

        if (locationName) {
          // ğŸ¯ æ›´æ–°éŸ¿æ‡‰å¼æ•¸æ“š
          coordinateData.B.name = locationName;
        }
      }
    } catch (error) {
    }

  });

  // ç¹ªè£½åˆ†æ®µé¡è‰²çš„è·¯å¾‘ç·š

  if (elevationData && elevationData.length > 0 && chartInstance && chartInstance.data.datasets[1] && pathData && pathData.length > 1) {
    const losLineData = chartInstance.data.datasets[1].data;

    // ç¹ªè£½æ¯å€‹ç·šæ®µï¼Œæ ¹æ“šé®è”½ç‹€æ…‹è¨­å®šé¡è‰²
    for (let i = 0; i < pathData.length - 1; i++) {
    const point1 = pathData[i];
    const point2 = pathData[i + 1];

    // åˆ¤æ–·é€™å€‹å€æ®µæ˜¯å¦æœ‰é®è”½
    let segmentColor = '#00BFFF'; // è—è‰²ï¼ˆç„¡é®è”½ï¼‰- Deep Sky Blue
    let segmentWeight = 3; // é è¨­ç·šå¯¬

    if (i < elevationData.length - 1) {
      const terrainHeight = elevationData[i];
      const losHeight = losLineData[i];
      const clearance = losHeight - terrainHeight;

      if (clearance < 0) {
      segmentColor = '#FF0000'; // äº®ç´…è‰²ï¼ˆæœ‰é®è”½ï¼‰- ç´”ç´…
      segmentWeight = 6; // ç´…è‰²ç·šåŠ ç²—ï¼Œæ›´æ˜é¡¯
      }
    }

    // ç¹ªè£½ç·šæ®µ
    L.polyline([
      [parseFloat(point1.lat), parseFloat(point1.lng)],
      [parseFloat(point2.lat), parseFloat(point2.lng)]
    ], {
      color: segmentColor,
      weight: segmentWeight,
      opacity: 1.0
    }).addTo(routeMapInstance);
    }

    // ğŸ¯ åœ¨æ¯å€‹å–æ¨£é»ä¸Šç¹ªè£½åœ“é»

    // å…ˆç¹ªè£½ç„¡é®è”½çš„è—è‰²é»
    pathData.forEach((point, index) => {
    const pointLat = parseFloat(point.lat);
    const pointLng = parseFloat(point.lng);

    // åˆ¤æ–·é€™å€‹é»æ˜¯å¦æœ‰é®è”½
    let hasObstruction = false;
    if (index < elevationData.length) {
      const terrainHeight = elevationData[index];
      const losHeight = losLineData[index];
      const clearance = losHeight - terrainHeight;

      if (clearance < 0) {
      hasObstruction = true;
      }
    }

    // åªç¹ªè£½ç„¡é®è”½çš„è—è‰²é»
    if (!hasObstruction) {
      L.circleMarker([pointLat, pointLng], {
      radius: 3,
      fillColor: '#00BFFF',
      color: '#FFFFFF',
      weight: 1,
      opacity: 1,
      fillOpacity: 0.9,
      zIndexOffset: 0
      }).addTo(routeMapInstance);
    }
    });

    // å†ç¹ªè£½æœ‰é®è”½çš„ç´…è‰²é»(é¡¯ç¤ºåœ¨æœ€ä¸Šå±¤)
    pathData.forEach((point, index) => {
    const pointLat = parseFloat(point.lat);
    const pointLng = parseFloat(point.lng);

    // åˆ¤æ–·é€™å€‹é»æ˜¯å¦æœ‰é®è”½
    let hasObstruction = false;
    if (index < elevationData.length) {
      const terrainHeight = elevationData[index];
      const losHeight = losLineData[index];
      const clearance = losHeight - terrainHeight;

      if (clearance < 0) {
      hasObstruction = true;
      }
    }

    // åªç¹ªè£½æœ‰é®è”½çš„ç´…è‰²é»,å…¨ç´…è‰²ä¸”é¡¯ç¤ºåœ¨æœ€ä¸Šå±¤
    if (hasObstruction) {
      L.circleMarker([pointLat, pointLng], {
      radius: 4,
      fillColor: '#FF0000',
      color: '#FF0000',
      weight: 2,
      opacity: 1,
      fillOpacity: 1,
      zIndexOffset: 1000,
      pane: 'markerPane'
      }).addTo(routeMapInstance);
    }
    });

  } else {
    // å¦‚æœæ²’æœ‰é«˜åº¦æ•¸æ“šï¼Œç¹ªè£½é è¨­çš„é»ƒè‰²ç·š
    L.polyline([
    [startLat, startLng],
    [endLat, endLng]
    ], {
    color: '#FFFF00',
    weight: 3,
    opacity: 1.0
    }).addTo(routeMapInstance);

    // ğŸ¯ ç¹ªè£½èµ·é»å’Œçµ‚é»çš„åœ“é»
    L.circleMarker([startLat, startLng], {
    radius: 4,
    fillColor: '#FFFF00',
    color: '#FFFFFF',
    weight: 1,
    opacity: 1,
    fillOpacity: 0.9
    }).addTo(routeMapInstance);

    L.circleMarker([endLat, endLng], {
    radius: 4,
    fillColor: '#FFFF00',
    color: '#FFFFFF',
    weight: 1,
    opacity: 1,
    fillOpacity: 0.9
    }).addTo(routeMapInstance);
  }
  const bounds = L.latLngBounds([
    [startLat, startLng],
    [endLat, endLng]
  ]);
  routeMapInstance.fitBounds(bounds, { padding: [50, 50] });

  // æ·»åŠ åœ°åœ–é»æ“Šäº‹ä»¶ï¼Œé¡¯ç¤ºåº§æ¨™å’Œé«˜åº¦
  routeMapInstance.on('click', async function(e) {
    // æª¢æŸ¥æ˜¯å¦æ­£åœ¨æ‹–æ›³å½ˆçª—
    if (isDraggingPopup) {
      return;
    }

    // æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°åœ–å±¤åˆ‡æ›æŒ‰éˆ•æˆ–å…¶ä»–æ§åˆ¶å…ƒä»¶
    if (e.originalEvent && e.originalEvent.target) {
      const target = e.originalEvent.target;
      // å¦‚æœé»æ“Šçš„æ˜¯æŒ‰éˆ•æˆ–å…¶çˆ¶å…ƒç´ åŒ…å«æŒ‰éˆ•ï¼Œå‰‡ä¸è™•ç†
      if (target.tagName === 'BUTTON' || target.closest('button') || target.closest('.leaflet-control')) {
        return;
      }
      // å¦‚æœé»æ“Šçš„æ˜¯å½ˆçª—ï¼Œä¹Ÿä¸è™•ç†
      if (target.closest('.leaflet-popup')) {
        return;
      }
    }

    let lat = e.latlng.lat;
    let lng = e.latlng.lng;

    // ç§»é™¤èˆŠçš„æ¨™è¨˜å’Œå½ˆçª—
    if (clickMarker) {
      routeMapInstance.removeLayer(clickMarker);
    }
    if (clickPopup) {
      routeMapInstance.closePopup(clickPopup);
    }

    // å‰µå»ºæ–°æ¨™è¨˜
    const markerIcon = L.divIcon({
      className: 'click-marker',
      html: '<div style="background:#FFA500; width:20px; height:20px; border-radius:50%; border:2px solid white; box-shadow:0 2px 6px rgba(0,0,0,0.4);"></div>',
      iconSize: [20, 20],
      iconAnchor: [10, 10]
    });

    clickMarker = L.marker([lat, lng], { icon: markerIcon }).addTo(routeMapInstance);

    // é¡¯ç¤ºè¼‰å…¥ä¸­çš„å½ˆçª—ï¼ˆæ”¾å¤§ç‰ˆ,æ”¯æ´æ‹–æ›³ï¼‰
    clickPopup = L.popup({
      maxWidth: 240,
      minWidth: 150,
      className: 'custom-popup-compact',
      autoPan: false,
      offset: [popupRelOffset.x, popupRelOffset.y]
    })
      .setLatLng([lat, lng])
      .setContent('<div class="popup-drag-bar">â ¿ ğŸ“ é»é¸ä½ç½®</div><div class="popup-body" style="color:#555;">æ­£åœ¨æŸ¥è©¢é«˜åº¦<span class="loading-dots">...</span></div>')
      .openOn(routeMapInstance);

    // æŸ¥è©¢é«˜åº¦
    try {
      let elevation = await getElevationFromDSM(lat, lng);

      // æª¢æŸ¥æ˜¯å¦é»æ“Šåœ¨è·¯å¾‘ç·šé™„è¿‘ï¼ˆå®¹å·®ç¯„åœå…§ï¼‰
      let clearanceInfo = '';
      let isNearPath = false;
      let nearestIndex = -1;

      if (elevationData && elevationData.length > 0 && chartInstance && chartInstance.data.datasets[1] && pathData && pathData.length > 1) {
        // æ‰¾åˆ°é›¢é»æ“Šä½ç½®æœ€è¿‘çš„è·¯å¾‘é»
        let minDistance = Infinity;

        for (let i = 0; i < pathData.length; i++) {
          const pointLat = parseFloat(pathData[i].lat);
          const pointLng = parseFloat(pathData[i].lng);
          const distance = Math.sqrt(
            Math.pow(lat - pointLat, 2) + Math.pow(lng - pointLng, 2)
          );
          if (distance < minDistance) {
            minDistance = distance;
            nearestIndex = i;
          }
        }

        // åˆ¤æ–·æ˜¯å¦åœ¨è·¯å¾‘ç·šé™„è¿‘ï¼ˆå®¹å·®ç´„ 0.0002 åº¦ï¼Œç´„ 20mï¼‰
        const tolerance = 0.0002;
        isNearPath = minDistance < tolerance;

        // å¦‚æœé»æ“Šåœ¨è·¯å¾‘ç·šé™„è¿‘ï¼Œä½¿ç”¨åœ–è¡¨ä¸­çš„losLineDataè¨ˆç®—é®è”½è·é›¢
        if (isNearPath && nearestIndex >= 0 && nearestIndex < elevationData.length) {
          const losLineData = chartInstance.data.datasets[1].data;

          // ç›´æ¥ä½¿ç”¨åœ–è¡¨ä¸­çš„è¦–è·ç·šæ•¸æ“šå’Œåœ°å½¢é«˜åº¦æ•¸æ“š
          if (losLineData && losLineData[nearestIndex] !== undefined) {
            const losHeight = losLineData[nearestIndex];
            const terrainHeight = elevationData[nearestIndex];
            const clearance = losHeight - terrainHeight;

            const clearanceColor = clearance >= 0 ? '#4caf50' : '#ff4444';
            let clearanceText = '';
            let obstructionStatus = '';
            if (clearance > 0) {
              clearanceText = `+${clearance.toFixed(2)} m`;
              obstructionStatus = 'ç„¡é®è”½';
            } else if (clearance < 0) {
              clearanceText = `${clearance.toFixed(2)} m`;
              obstructionStatus = 'æœ‰é®è”½';
            } else {
              clearanceText = '0.00 m';
              obstructionStatus = 'ç„¡é®è”½';
            }

            clearanceInfo = `<div style="color: ${clearanceColor}; font-weight: bold; font-size: 14px; margin-top: 3px;">${obstructionStatus}: ${clearanceText}</div>`;

            // ğŸ”— é€£å‹•å‰–é¢åœ–ï¼šæ›´æ–°åœ–è¡¨ä¸Šçš„é¸ä¸­é»
            // ğŸ¯ ä½¿ç”¨ getElevationForIndex å¾åœ–è¡¨å¯¦æ™‚è®€å–é«˜åº¦
            showMap(nearestIndex, getElevationForIndex(nearestIndex));

            // ğŸ¯ æ›´æ–°åœ°åœ–é»æ§åˆ¶å–®å…ƒçš„æ•¸å€¼
            const mapPointInput = document.getElementById('mapPointInput');
            if (mapPointInput) {
              mapPointInput.value = nearestIndex + 1;
            }

            // å°‡åœ°åœ–æ¨™è¨˜ç§»å‹•åˆ°æœ€è¿‘çš„è·¯å¾‘é»ä½ç½®
            const nearestLat = parseFloat(pathData[nearestIndex].lat);
            const nearestLng = parseFloat(pathData[nearestIndex].lng);
            clickMarker.setLatLng([nearestLat, nearestLng]);
            clickPopup.setLatLng([nearestLat, nearestLng]);

            // æ›´æ–°å½ˆçª—å…§å®¹é¡¯ç¤ºé»è™Ÿ
            lat = nearestLat;
            lng = nearestLng;
            elevation = getElevationForIndex(nearestIndex);
          }
        }
      }

      const popupTitle = (isNearPath && nearestIndex >= 0) ? `é» ${nearestIndex + 1}` : 'é»é¸ä½ç½®';
      const popupContent = `
        <div class="popup-drag-bar">â ¿ ğŸ“ ${popupTitle}</div>
        <div class="popup-body">
          <div>
            <span style="color:#555;">ç·¯ï¼š</span><span style="color:#000; font-weight:600;">${lat.toFixed(6)}Â°</span>
          </div>
          <div>
            <span style="color:#555;">ç¶“ï¼š</span><span style="color:#000; font-weight:600;">${lng.toFixed(6)}Â°</span>
          </div>
          <div>
            <span style="color:#555;">é«˜åº¦ï¼š</span><span style="color:#FF6B00; font-weight:700; font-size:15px;">${elevation.toFixed(1)} m</span>
          </div>
          ${clearanceInfo}
        </div>
      `;

      clickPopup.setContent(popupContent);

      // æ‡‰ç”¨ç•¶å‰é¡¯ç¤ºæ¨¡å¼ä¸¦æ·»åŠ æ‹–æ›³åŠŸèƒ½
      setTimeout(() => {
        const popupElement = clickPopup.getElement();

        if (popupElement) {
          if (popupDisplayMode === 'hide') {
            popupElement.style.opacity = '0';
            popupElement.style.pointerEvents = 'none';
          } else {
            popupElement.style.opacity = '1';
            popupElement.style.pointerEvents = 'auto';
          }

          // æ·»åŠ æ‹–æ›³åŠŸèƒ½
          enablePopupDragging(popupElement);
        } else {
        }
      }, 100);
    } catch (error) {
      // å¦‚æœ DSM å¤±æ•—ï¼ˆä¾‹å¦‚è² å€¼æˆ–ç„¡è³‡æ–™ï¼‰ï¼Œå˜—è©¦ä½¿ç”¨ Open Elevation SRTM
      try {
        const elevation = await getElevationFromOpenElevationSimple(lat, lng);
        
        // æª¢æŸ¥æ˜¯å¦é»æ“Šåœ¨è·¯å¾‘ç·šé™„è¿‘ï¼ˆå®¹å·®ç¯„åœå…§ï¼‰
        let clearanceInfo = '';
        let isNearPath = false;
        let nearestIndex = -1;

        if (elevationData && elevationData.length > 0 && chartInstance && chartInstance.data.datasets[1] && pathData && pathData.length > 1) {
          // æ‰¾åˆ°é›¢é»æ“Šä½ç½®æœ€è¿‘çš„è·¯å¾‘é»
          let minDistance = Infinity;

          for (let i = 0; i < pathData.length; i++) {
            const pointLat = parseFloat(pathData[i].lat);
            const pointLng = parseFloat(pathData[i].lng);
            const distance = Math.sqrt(
              Math.pow(lat - pointLat, 2) + Math.pow(lng - pointLng, 2)
            );
            if (distance < minDistance) {
              minDistance = distance;
              nearestIndex = i;
            }
          }

          // åˆ¤æ–·æ˜¯å¦åœ¨è·¯å¾‘ç·šé™„è¿‘ï¼ˆå®¹å·®ç´„ 0.0002 åº¦ï¼Œç´„ 20mï¼‰
          const tolerance = 0.0002;
          if (minDistance < tolerance) {
            isNearPath = true;
            const losLineData = chartInstance.data.datasets[1].data;
            if (losLineData && losLineData[nearestIndex] !== undefined) {
              const losHeight = losLineData[nearestIndex];
              const terrainHeight = elevationData[nearestIndex];
              const clearance = losHeight - terrainHeight;

              const clearanceColor = clearance >= 0 ? '#4caf50' : '#ff4444';
              let clearanceText = '';
              let obstructionStatus = '';
              if (clearance > 0) {
                clearanceText = `+${clearance.toFixed(2)} m`;
                obstructionStatus = 'ç„¡é®è”½';
              } else if (clearance < 0) {
                clearanceText = `${clearance.toFixed(2)} m`;
                obstructionStatus = 'æœ‰é®è”½';
              } else {
                clearanceText = '0.00 m';
                obstructionStatus = 'ç„¡é®è”½';
              }

              clearanceInfo = `<div style="color: ${clearanceColor}; font-weight: bold; font-size: 13px; margin-top: 2px;">${obstructionStatus}: ${clearanceText}</div>`;
            }
          }
        }

        const popupTitle = (isNearPath && nearestIndex >= 0) ? `é» ${nearestIndex + 1}` : 'é»é¸ä½ç½®';
        const popupContent = `
          <div class="popup-drag-bar">â ¿ ğŸ“ ${popupTitle}</div>
          <div class="popup-body">
            <div>
              <span style="color:#555;">ç·¯ï¼š</span><span style="color:#000; font-weight:600;">${lat.toFixed(6)}Â°</span>
            </div>
            <div>
              <span style="color:#555;">ç¶“ï¼š</span><span style="color:#000; font-weight:600;">${lng.toFixed(6)}Â°</span>
            </div>
            <div>
              <span style="color:#555;">é«˜åº¦ï¼š</span><span style="color:#FF6B00; font-weight:700; font-size:15px;">${elevation.toFixed(1)} m</span>
            </div>
            <div style="color:#888; font-size:10px; margin-top:2px;">âš ï¸ ä½¿ç”¨ SRTM å‚™ç”¨è³‡æ–™</div>
            ${clearanceInfo}
          </div>
        `;

        clickPopup.setContent(popupContent);

        // æ‡‰ç”¨ç•¶å‰é¡¯ç¤ºæ¨¡å¼ä¸¦æ·»åŠ æ‹–æ›³åŠŸèƒ½
        setTimeout(() => {
          const popupElement = clickPopup.getElement();

          if (popupElement) {
            if (popupDisplayMode === 'hide') {
              popupElement.style.opacity = '0';
              popupElement.style.pointerEvents = 'none';
            } else {
              popupElement.style.opacity = '1';
              popupElement.style.pointerEvents = 'auto';
            }

            // æ·»åŠ æ‹–æ›³åŠŸèƒ½
            enablePopupDragging(popupElement);
          }
        }, 100);
        
      } catch (openElevError) {
        // å¦‚æœ Open Elevation ä¹Ÿå¤±æ•—ï¼Œé¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
        clickPopup.setContent(`
          <div class="popup-drag-bar">â ¿ ğŸ“ é»é¸ä½ç½®</div>
          <div class="popup-body">
            <div style="font-weight:bold; color:#dc3545; font-size:11px; margin-bottom:2px;">âŒ æŸ¥è©¢å¤±æ•—</div>
            <div>
              <span style="color:#666;">ç·¯:</span> ${lat.toFixed(6)}Â°
            </div>
            <div>
              <span style="color:#666;">ç¶“:</span> ${lng.toFixed(6)}Â°
            </div>
            <div style="color:#dc3545; font-size:10px; margin-top:2px;">${error.message || 'ç„¡æ³•å–å¾—é«˜åº¦è³‡æ–™'}</div>
          </div>
        `);
      }
    }
  });

  // æ·»åŠ å½ˆçª—é¡¯ç¤ºåˆ‡æ›æŒ‰éˆ•ï¼ˆå·¦ä¸‹è§’ï¼‰
  const popupToggleBtn = L.control({ position: 'bottomleft' });
  popupToggleBtn.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'popup-toggle-control');
    div.innerHTML = `
      <button id="popupToggleBtn" title="åˆ‡æ›å½ˆçª—é¡¯ç¤º" style="background:rgba(255, 255, 255, 0.95); border:2px solid rgba(0,0,0,0.2); border-radius:4px; width:36px; height:36px; font-size:18px; cursor:pointer; box-shadow:0 1px 5px rgba(0,0,0,0.4); display:flex; align-items:center; justify-content:center; padding:0;">ğŸ’¬</button>
    `;

    // é˜»æ­¢åœ°åœ–äº‹ä»¶å†’æ³¡
    L.DomEvent.disableClickPropagation(div);

    // æ·»åŠ é»æ“Šäº‹ä»¶
    div.querySelector('#popupToggleBtn').onclick = function() {
      togglePopupDisplay();
    };

    return div;
  };
  popupToggleBtn.addTo(routeMapInstance);

  // æ·»åŠ é»æ§åˆ¶å–®å…ƒï¼ˆå³ä¸‹è§’ï¼‰
  const pointControl = L.control({ position: 'bottomright' });
  pointControl.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'map-point-control');
    const initIdx = (typeof window.currentSelectedPointIndex !== 'undefined' &&
             window.currentSelectedPointIndex !== null &&
             window.currentSelectedPointIndex >= 0)
            ? window.currentSelectedPointIndex : 0;
    const totalPts = pathData ? pathData.length : 1;
    div.innerHTML = `
      <button onclick="mapDecrementPoint()">â—€</button>
      <input type="number" id="mapPointInput" value="${initIdx + 1}" min="1" max="${totalPts}" oninput="mapUpdatePointFromInput()">
      <button onclick="mapIncrementPoint()">â–¶</button>
    `;

    // é˜»æ­¢åœ°åœ–äº‹ä»¶å†’æ³¡
    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);

    return div;
  };
  pointControl.addTo(routeMapInstance);

  // è‹¥å·²æœ‰é¸ä¸­é»ï¼Œè‡ªå‹•è·³åˆ°è©²é»ä¸¦é¡¯ç¤ºæ¨™è¨˜
  const _initIdx = (typeof window.currentSelectedPointIndex !== 'undefined' &&
            window.currentSelectedPointIndex !== null &&
            window.currentSelectedPointIndex >= 0)
           ? window.currentSelectedPointIndex : -1;
  if (_initIdx >= 0) {
    setTimeout(() => { mapJumpToPoint(_initIdx); }, 200);
  }

}

// åœ°åœ–é»æ§åˆ¶å–®å…ƒçš„å‡½æ•¸
function mapUpdatePointFromInput() {
  const input = document.getElementById('mapPointInput');
  let value = parseInt(input.value);

  if (isNaN(value) || !pathData || pathData.length === 0) return;

  // é™åˆ¶ç¯„åœ
  if (value < 1) value = 1;
  if (value > pathData.length) value = pathData.length;

  input.value = value;

  // æ›´æ–°åœ°åœ–æ¨™è¨˜åˆ°æŒ‡å®šé»
  const index = value - 1;
  mapJumpToPoint(index);
}

function mapIncrementPoint() {
  const input = document.getElementById('mapPointInput');
  let currentValue = parseInt(input.value) || 0;

  if (!pathData || pathData.length === 0) return;

  if (currentValue < pathData.length) {
    currentValue++;
    input.value = currentValue;
    mapJumpToPoint(currentValue - 1);
  }
}

function mapDecrementPoint() {
  const input = document.getElementById('mapPointInput');
  let currentValue = parseInt(input.value) || 0;

  if (!pathData || pathData.length === 0) return;

  if (currentValue > 1) {
    currentValue--;
    input.value = currentValue;
    mapJumpToPoint(currentValue - 1);
  }
}

async function mapJumpToPoint(index) {
  if (!pathData || !routeMapInstance || index < 0 || index >= pathData.length) return;

  const pointData = pathData[index];
  const lat = parseFloat(pointData.lat);
  const lng = parseFloat(pointData.lng);

  // ç§»é™¤èˆŠæ¨™è¨˜
  if (clickMarker) {
    routeMapInstance.removeLayer(clickMarker);
  }
  if (clickPopup) {
    routeMapInstance.closePopup(clickPopup);
  }

  // å‰µå»ºæ–°æ¨™è¨˜
  const markerIcon = L.divIcon({
    className: 'click-marker',
    html: '<div style="background:#FFA500; width:20px; height:20px; border-radius:50%; border:2px solid white; box-shadow:0 2px 6px rgba(0,0,0,0.4);"></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10]
  });

  clickMarker = L.marker([lat, lng], { icon: markerIcon }).addTo(routeMapInstance);

  // ç§»å‹•åœ°åœ–è¦–åœ–åˆ°è©²é»
  routeMapInstance.setView([lat, lng], routeMapInstance.getZoom());

  // æŸ¥è©¢é«˜åº¦ä¸¦é¡¯ç¤ºå½ˆçª—
  try {
    let elevation = await getElevationFromDSM(lat, lng);

    // è¨ˆç®—é®è”½è³‡è¨Š
    let clearanceInfo = '';
    if (elevationData && elevationData.length > 0 && chartInstance && chartInstance.data.datasets[1]) {
      const losLineData = chartInstance.data.datasets[1].data;

      if (losLineData && losLineData[index] !== undefined) {
        const losHeight = losLineData[index];
        const terrainHeight = elevationData[index];
        const clearance = losHeight - terrainHeight;

        const clearanceColor = clearance >= 0 ? '#4caf50' : '#ff4444';
        let clearanceText = '';
        let obstructionStatus = '';
        if (clearance > 0) {
          clearanceText = `+${clearance.toFixed(2)} m`;
          obstructionStatus = 'ç„¡é®è”½';
        } else if (clearance < 0) {
          clearanceText = `${clearance.toFixed(2)} m`;
          obstructionStatus = 'æœ‰é®è”½';
        } else {
          clearanceText = '0.00 m';
          obstructionStatus = 'ç„¡é®è”½';
        }

        clearanceInfo = `<div style="color: ${clearanceColor}; font-weight: bold; font-size: 13px; margin-top: 2px;">${obstructionStatus}: ${clearanceText}</div>`;
      }
    }

    // é¡¯ç¤ºå½ˆçª—
    clickPopup = L.popup({
      maxWidth: 240,
      minWidth: 150,
      className: 'custom-popup-compact',
      autoPan: false,
      offset: [popupRelOffset.x, popupRelOffset.y]
    })
      .setLatLng([lat, lng])
      .setContent(`
        <div class="popup-drag-bar">â ¿ ğŸ“ é» ${index + 1}</div>
        <div class="popup-body">
          <div>
            <span style="color:#555;">ç·¯ï¼š</span><span style="color:#000; font-weight:600;">${lat.toFixed(6)}Â°</span>
          </div>
          <div>
            <span style="color:#555;">ç¶“ï¼š</span><span style="color:#000; font-weight:600;">${lng.toFixed(6)}Â°</span>
          </div>
          <div>
            <span style="color:#555;">é«˜åº¦ï¼š</span><span style="color:#FF6B00; font-weight:700; font-size:15px;">${elevation.toFixed(1)} m</span>
          </div>
          ${clearanceInfo}
        </div>
      `)
      .openOn(routeMapInstance);

    // é€£å‹•å‰–é¢åœ– - ä½¿ç”¨ getElevationForIndex å¾åœ–è¡¨å¯¦æ™‚è®€å–
    showMap(index, getElevationForIndex(index));

    // æ‡‰ç”¨å½ˆçª—é¡¯ç¤ºæ¨¡å¼ä¸¦æ·»åŠ æ‹–æ›³åŠŸèƒ½
    setTimeout(() => {
      const popupElement = clickPopup.getElement();
      if (popupElement) {
        if (popupDisplayMode === 'hide') {
          popupElement.style.opacity = '0';
          popupElement.style.pointerEvents = 'none';
        } else {
          popupElement.style.opacity = '1';
          popupElement.style.pointerEvents = 'auto';
        }
        enablePopupDragging(popupElement);
      }
    }, 100);

  } catch (error) {
    // å¦‚æœ DSM å¤±æ•—ï¼Œå˜—è©¦ä½¿ç”¨ Open Elevation SRTM
    try {
      const elevation = await getElevationFromOpenElevationSimple(lat, lng);
      
      // è¨ˆç®—é®è”½è³‡è¨Š
      let clearanceInfo = '';
      if (elevationData && elevationData.length > 0 && chartInstance && chartInstance.data.datasets[1]) {
        const losLineData = chartInstance.data.datasets[1].data;

        if (losLineData && losLineData[index] !== undefined) {
          const losHeight = losLineData[index];
          const terrainHeight = elevationData[index];
          const clearance = losHeight - terrainHeight;

          const clearanceColor = clearance >= 0 ? '#4caf50' : '#ff4444';
          let clearanceText = '';
          let obstructionStatus = '';
          if (clearance > 0) {
            clearanceText = `+${clearance.toFixed(2)} m`;
            obstructionStatus = 'ç„¡é®è”½';
          } else if (clearance < 0) {
            clearanceText = `${clearance.toFixed(2)} m`;
            obstructionStatus = 'æœ‰é®è”½';
          } else {
            clearanceText = '0.00 m';
            obstructionStatus = 'ç„¡é®è”½';
          }

          clearanceInfo = `<div style="color: ${clearanceColor}; font-weight: bold; font-size: 13px; margin-top: 2px;">${obstructionStatus}: ${clearanceText}</div>`;
        }
      }

      // é¡¯ç¤ºå½ˆçª—ï¼ˆå¸¶æœ‰å‚™ç”¨è³‡æ–™æç¤ºï¼‰
      clickPopup = L.popup({
        maxWidth: 240,
        minWidth: 150,
        className: 'custom-popup-compact',
        autoPan: false,
        offset: [popupRelOffset.x, popupRelOffset.y]
      })
        .setLatLng([lat, lng])
        .setContent(`
          <div class="popup-drag-bar">â ¿ ğŸ“ é» ${index + 1}</div>
          <div class="popup-body">
            <div>
              <span style="color:#555;">ç·¯ï¼š</span><span style="color:#000; font-weight:600;">${lat.toFixed(6)}Â°</span>
            </div>
            <div>
              <span style="color:#555;">ç¶“ï¼š</span><span style="color:#000; font-weight:600;">${lng.toFixed(6)}Â°</span>
            </div>
            <div>
              <span style="color:#555;">é«˜åº¦ï¼š</span><span style="color:#FF6B00; font-weight:700; font-size:15px;">${elevation.toFixed(1)} m</span>
            </div>
            <div style="color:#888; font-size:10px; margin-top:2px;">âš ï¸ ä½¿ç”¨ SRTM å‚™ç”¨è³‡æ–™</div>
            ${clearanceInfo}
          </div>
        `)
        .openOn(routeMapInstance);

      // é€£å‹•å‰–é¢åœ– - ä½¿ç”¨ getElevationForIndex å¾åœ–è¡¨å¯¦æ™‚è®€å–
      showMap(index, getElevationForIndex(index));

      // æ‡‰ç”¨å½ˆçª—é¡¯ç¤ºæ¨¡å¼ä¸¦æ·»åŠ æ‹–æ›³åŠŸèƒ½
      setTimeout(() => {
        const popupElement = clickPopup.getElement();
        if (popupElement) {
          if (popupDisplayMode === 'hide') {
            popupElement.style.opacity = '0';
            popupElement.style.pointerEvents = 'none';
          } else {
            popupElement.style.opacity = '1';
            popupElement.style.pointerEvents = 'auto';
          }
          enablePopupDragging(popupElement);
        }
      }, 100);
      
    } catch (openElevError) {
      // å¦‚æœ Open Elevation ä¹Ÿå¤±æ•—ï¼Œä¸é¡¯ç¤ºä»»ä½•å…§å®¹ï¼ˆä¿æŒåŸæœ‰è¡Œç‚ºï¼‰
      console.error('é«˜åº¦æŸ¥è©¢å¤±æ•—:', error, openElevError);
    }
  }
}

// åˆ‡æ›å½ˆçª—é¡¯ç¤ºç‹€æ…‹ï¼ˆåªæœ‰é¡¯ç¤ºå’Œé—œé–‰å…©ç¨®ï¼‰
function togglePopupDisplay() {
  // åˆ‡æ›æ¨¡å¼
  popupDisplayMode = (popupDisplayMode === 'show') ? 'hide' : 'show';

  const btn = document.getElementById('popupToggleBtn');

  if (clickPopup && routeMapInstance) {
    const popupElement = clickPopup.getElement();
    if (popupElement) {
      if (popupDisplayMode === 'hide') {
        popupElement.style.opacity = '0';
        popupElement.style.pointerEvents = 'none';
        if (btn) {
          btn.innerHTML = 'ğŸš«';
          btn.title = 'é¡¯ç¤ºå½ˆçª—';
        }
      } else {
        popupElement.style.opacity = '1';
        popupElement.style.pointerEvents = 'auto';
        if (btn) {
          btn.innerHTML = 'ğŸ’¬';
          btn.title = 'éš±è—å½ˆçª—';
        }
      }
    }
  }
}

// å•Ÿç”¨å½ˆçª—æ‹–æ›³åŠŸèƒ½
// â˜… ç­–ç•¥ï¼šæ‹–æ›³åç§»å…¨å­˜åœ¨å…¨åŸŸ popupRelOffsetï¼Œå‚³çµ¦ L.popup offset é¸é …ã€‚
//   é€™æ¨£é»æ–°é»æ™‚è‡ªå‹•æ²¿ç”¨ç›¸å°ä½ç½®ï¼Œä¸éœ€è¦ DOM transform hackã€‚
function enablePopupDragging(popupElement) {
  if (!popupElement) return;

  if (popupElement._cleanupDragging) {
    popupElement._cleanupDragging();
  }

  const contentWrapper = popupElement.querySelector('.leaflet-popup-content-wrapper');
  if (!contentWrapper) return;

  contentWrapper.style.cursor = 'grab';
  contentWrapper.style.userSelect = 'none';
  contentWrapper.style.webkitUserSelect = 'none';

  // æ¯æ¬¡æ–° popup å…ƒç´ ï¼Œè¦–è¦ºåç§»å¾ 0 é–‹å§‹ï¼ˆLeaflet offset å·²å¸¶å…¥ popupRelOffsetï¼‰
  popupElement._visualX = 0;
  popupElement._visualY = 0;

  function applyVisual(vx, vy) {
    contentWrapper.style.transform = `translate(${vx}px, ${vy}px)`;
    popupElement._visualX = vx;
    popupElement._visualY = vy;
  }
  applyVisual(0, 0);

  let isDragging = false;
  let startClientX = 0, startClientY = 0;
  let baseX = 0, baseY = 0;

  const onStart = (e) => {
    if (e.target.closest && e.target.closest('.leaflet-popup-close-button')) return;
    if (e.button !== undefined && e.button !== 0) return;

    isDragging = true;
    isDraggingPopup = true;

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    startClientX = clientX;
    startClientY = clientY;
    baseX = popupElement._visualX;
    baseY = popupElement._visualY;

    contentWrapper.style.cursor = 'grabbing';
    routeMapInstance.dragging.disable();

    e.preventDefault();
    e.stopPropagation();
  };

  const onMove = (e) => {
    if (!isDragging) return;

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    // â˜… åªå‹• contentWrapper çš„ CSS translate
    //   å®Œå…¨ä¸ç¢° popupElement.style.transformï¼ˆLeaflet å°ˆç”¨ï¼‰
    //   ä¹Ÿä¸å‘¼å« clickPopup.update()ï¼ˆæœƒé‡å»º DOM å°è‡´äº‹ä»¶éˆæ–·æ‰ï¼‰
    applyVisual(baseX + (clientX - startClientX),
          baseY + (clientY - startClientY));

    e.preventDefault();
    e.stopPropagation();
  };

  const onEnd = (e) => {
    if (!isDragging) return;
    isDragging = false;
    contentWrapper.style.cursor = 'grab';
    routeMapInstance.dragging.enable();

    // â˜… æ”¾é–‹å¾Œï¼šæŠŠæœ¬æ¬¡ç§»å‹•é‡ç´¯åŠ é€²å…¨åŸŸ popupRelOffset
    //   ä¸‹æ¬¡é»æ–°é» openOn æ™‚ L.popup offset è‡ªå‹•å¸¶å…¥ï¼Œå¯¦ç¾ã€Œè¨˜æ†¶ç›¸å°ä½ç½®ã€
    popupRelOffset.x += (popupElement._visualX - baseX);
    popupRelOffset.y += (popupElement._visualY - baseY);

    setTimeout(() => { isDraggingPopup = false; }, 150);
    e.stopPropagation();
  };

  contentWrapper.addEventListener('mousedown', onStart, true);
  document.addEventListener('mousemove', onMove, true);
  document.addEventListener('mouseup',   onEnd,  true);
  contentWrapper.addEventListener('touchstart', onStart, { passive: false, capture: true });
  document.addEventListener('touchmove',  onMove, { passive: false, capture: true });
  document.addEventListener('touchend',   onEnd,  { capture: true });

  popupElement.dataset.draggingEnabled = 'true';

  popupElement._cleanupDragging = () => {
    contentWrapper.removeEventListener('mousedown', onStart, true);
    document.removeEventListener('mousemove', onMove, true);
    document.removeEventListener('mouseup',   onEnd,  true);
    contentWrapper.removeEventListener('touchstart', onStart, true);
    document.removeEventListener('touchmove',  onMove, true);
    document.removeEventListener('touchend',   onEnd,  true);
  };
}
// DSM é«˜åº¦æŸ¥è©¢å‡½æ•¸ï¼ˆç”¨æ–¼åœ°åœ–é»æ“Šï¼‰
async function getElevationFromDSM(lat, lng) {
  if (!window.GeoTIFF) {
    await loadGeoTIFFLibrary();
  }

  // å„ªå…ˆä½¿ç”¨æœ¬åœ°ä¸Šå‚³çš„ TIF æª”æ¡ˆ
  if (localTifFileData && localTifFileData.tiff) {
    const image = localTifFileData.image;
    const bbox = image.getBoundingBox();
    const width = image.getWidth();
    const height = image.getHeight();

    const pixelX = Math.floor((lng - bbox[0]) / (bbox[2] - bbox[0]) * width);
    const pixelY = Math.floor((bbox[3] - lat) / (bbox[3] - bbox[1]) * height);

    if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
      const rasters = await image.readRasters({
        window: [pixelX, pixelY, pixelX + 1, pixelY + 1]
      });

      const elevation = rasters[0][0];

      if (elevation === null || elevation === undefined || isNaN(elevation)) {
        throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
      }

      // æª¢æŸ¥å¸¸è¦‹çš„ NoData å€¼å’Œç„¡æ•ˆç¯„åœ
      const commonNoDataValues = [-32768, -32767, -9999, -99999, -12345, 32767, 65535, -3.4028235e+38];
      const isNoData = commonNoDataValues.some(noData => Math.abs(elevation - noData) < 0.01);
      
      if (isNoData || elevation < -500 || elevation > 9000) {
        throw new Error('æª¢æ¸¬åˆ°ç„¡åœ–è³‡å€åŸŸ');
      }

      return elevation;
    } else {
      throw new Error('åº§æ¨™è¶…å‡ºè³‡æ–™ç¯„åœ');
    }
  }

  // ä½¿ç”¨ GitHub ç·šä¸Š DSM è³‡æ–™
  const cogFilename = 'taiwan_dsm_wgs84_cog.tif';
  let tiff = null;

  try {
    tiff = await GeoTIFF.fromUrl(cogFilename);
  } catch (err) {
    const githubUrl = 'https://sulapon.github.io/GPS/taiwan_dsm_wgs84_cog.tif';
    tiff = await GeoTIFF.fromUrl(githubUrl);
  }

  const image = await tiff.getImage();
  const bbox = image.getBoundingBox();
  const width = image.getWidth();
  const height = image.getHeight();

  const pixelX = Math.floor((lng - bbox[0]) / (bbox[2] - bbox[0]) * width);
  const pixelY = Math.floor((bbox[3] - lat) / (bbox[3] - bbox[1]) * height);

  if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
    const rasters = await image.readRasters({
      window: [pixelX, pixelY, pixelX + 1, pixelY + 1]
    });

    const elevation = rasters[0][0];

    if (elevation === null || elevation === undefined || isNaN(elevation)) {
      throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
    }

    // æª¢æŸ¥å¸¸è¦‹çš„ NoData å€¼å’Œç„¡æ•ˆç¯„åœï¼ˆèˆ‡ GPS åˆ†é é‚è¼¯ä¸€è‡´ï¼‰
    const commonNoDataValues = [-32768, -32767, -9999, -99999, -12345, 32767, 65535, -3.4028235e+38];
    const isNoData = commonNoDataValues.some(noData => Math.abs(elevation - noData) < 0.01);
    
    if (isNoData || elevation < -500 || elevation > 9000) {
      throw new Error('æª¢æ¸¬åˆ°ç„¡åœ–è³‡å€åŸŸ');
    }

    return elevation;
  } else {
    throw new Error('åº§æ¨™è¶…å‡º DSM è³‡æ–™ç¯„åœ');
  }
}

// å¾ Open Elevation SRTM ç²å–é«˜åº¦ï¼ˆç”¨æ–¼ AB åœ–çš„å‚™ç”¨æ–¹æ¡ˆï¼‰
async function getElevationFromOpenElevationSimple(lat, lng) {
  const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    body: JSON.stringify({
      locations: [{
        latitude: lat,
        longitude: lng
      }]
    })
  });
  
  if (!response.ok) {
    throw new Error(`HTTP éŒ¯èª¤: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (!data.results || data.results.length === 0) {
    throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
  }
  
  const elevation = data.results[0].elevation;
  
  if (elevation === null || elevation === undefined) {
    throw new Error('è©²ä½ç½®çš„é«˜åº¦æ•¸æ“šä¸å¯ç”¨');
  }
  
  return elevation;
}

let isMapMaximized = false;
let originalMapStyles = {};
let exitFullscreenBtn = null;
function maximizeRouteMap() {
  const container = document.getElementById('route-map-container');
  const mapDiv = document.getElementById('route-map');
  const btn = document.getElementById('maximizeMapBtn');
  const details = document.getElementById('route-map-details');
  if (!container || !mapDiv || !btn) return;
  if (!isMapMaximized) {
    if (container.requestFullscreen) {
      container.requestFullscreen();
    } else if (container.webkitRequestFullscreen) {
      container.webkitRequestFullscreen();
    } else if (container.mozRequestFullScreen) {
      container.mozRequestFullScreen();
    } else if (container.msRequestFullscreen) {
      container.msRequestFullscreen();
    }
    originalMapStyles = {
      containerBackground: container.style.background,
      containerPadding: container.style.padding,
      containerDisplay: container.style.display,
      mapHeight: mapDiv.style.height,
      mapBorder: mapDiv.style.border,
      mapBorderRadius: mapDiv.style.borderRadius
    };
    container.style.background = '#000';
    container.style.padding = '0';
    container.style.display = 'flex';
    container.style.flexDirection = 'column';
    container.style.justifyContent = 'center';
    container.style.alignItems = 'center';
    if (details) details.style.display = 'none';
    btn.style.display = 'none';
    mapDiv.style.width = '100%';
    mapDiv.style.height = '100%';
    mapDiv.style.border = '2px solid #5ff0d5';
    mapDiv.style.borderRadius = '0';
    mapDiv.style.boxSizing = 'border-box';
    exitFullscreenBtn = document.createElement('button');
    exitFullscreenBtn.id = 'exitFullscreenBtn';
    exitFullscreenBtn.innerHTML = 'âœ•';
    exitFullscreenBtn.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      background: rgba(220, 38, 38, 0.95);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      z-index: 999999;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      padding: 0;
      line-height: 1;
    `;
    exitFullscreenBtn.onmouseover = function() {
      this.style.background = 'rgba(185, 28, 28, 0.95)';
      this.style.transform = 'scale(1.1)';
    };
    exitFullscreenBtn.onmouseout = function() {
      this.style.background = 'rgba(220, 38, 38, 0.95)';
      this.style.transform = 'scale(1)';
    };
    exitFullscreenBtn.onclick = function() {
      exitFullscreen();
    };
    container.appendChild(exitFullscreenBtn);
    const layerToggleBtn = document.getElementById('route-layer-toggle');
    const layerToggleContainer = layerToggleBtn?.parentElement;
    if (layerToggleContainer) {
      layerToggleContainer.style.position = 'fixed';
      layerToggleContainer.style.top = '10px';
      layerToggleContainer.style.left = '50%';
      layerToggleContainer.style.right = 'auto';
      layerToggleContainer.style.transform = 'translateX(-50%)';
      layerToggleContainer.style.zIndex = '999998';
    }
    isMapMaximized = true;
    setTimeout(() => {
      if (routeMapInstance) {
        routeMapInstance.invalidateSize();
        const sLat = parseFloat(document.getElementById('sLat')?.value);
        const sLng = parseFloat(document.getElementById('sLng')?.value);
        const eLat = parseFloat(document.getElementById('eLat')?.value);
        const eLng = parseFloat(document.getElementById('eLng')?.value);
        if (!isNaN(sLat) && !isNaN(sLng) && !isNaN(eLat) && !isNaN(eLng)) {
          const bounds = L.latLngBounds([[sLat, sLng], [eLat, eLng]]);
          routeMapInstance.fitBounds(bounds, { padding: [50, 50] });
        }
      }
    }, 150);
  }
}
function exitFullscreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  }
}
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
document.addEventListener('mozfullscreenchange', handleFullscreenChange);
document.addEventListener('MSFullscreenChange', handleFullscreenChange);
function handleFullscreenChange() {
  const container = document.getElementById('route-map-container');
  const mapDiv = document.getElementById('route-map');
  const btn = document.getElementById('maximizeMapBtn');
  const details = document.getElementById('route-map-details');
  if (!document.fullscreenElement && !document.webkitFullscreenElement &&
    !document.mozFullScreenElement && !document.msFullscreenElement) {
    if (container && mapDiv && btn) {
      container.style.background = originalMapStyles.containerBackground || 'transparent';
      container.style.padding = originalMapStyles.containerPadding || '0';
      container.style.display = '';
      container.style.flexDirection = '';
      container.style.justifyContent = '';
      container.style.alignItems = '';
      if (details) details.style.display = 'block';
      btn.style.display = '';
      mapDiv.style.width = '';
      mapDiv.style.height = originalMapStyles.mapHeight || '450px';
      mapDiv.style.border = originalMapStyles.mapBorder || '2px solid #5ff0d5';
      mapDiv.style.borderRadius = originalMapStyles.mapBorderRadius || '8px';
      mapDiv.style.boxSizing = '';
      const layerToggleBtn = document.getElementById('route-layer-toggle');
      const layerToggleContainer = layerToggleBtn?.parentElement;
      if (layerToggleContainer) {
        layerToggleContainer.style.position = 'absolute';
        layerToggleContainer.style.top = '10px';
        layerToggleContainer.style.right = '10px';
        layerToggleContainer.style.left = 'auto';
        layerToggleContainer.style.transform = '';
        layerToggleContainer.style.zIndex = '1000';
      }
      if (exitFullscreenBtn && exitFullscreenBtn.parentNode) {
        exitFullscreenBtn.parentNode.removeChild(exitFullscreenBtn);
        exitFullscreenBtn = null;
      }
      isMapMaximized = false;
      setTimeout(() => {
        if (routeMapInstance) {
          routeMapInstance.invalidateSize();
          const sLat = parseFloat(document.getElementById('sLat')?.value);
          const sLng = parseFloat(document.getElementById('sLng')?.value);
          const eLat = parseFloat(document.getElementById('eLat')?.value);
          const eLng = parseFloat(document.getElementById('eLng')?.value);
          if (!isNaN(sLat) && !isNaN(sLng) && !isNaN(eLat) && !isNaN(eLng)) {
            const bounds = L.latLngBounds([[sLat, sLng], [eLat, eLng]]);
            routeMapInstance.fitBounds(bounds, { padding: [50, 50] });
          }
        }
      }, 150);
    }
  }
}
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape' && isMapMaximized) {
    exitFullscreen();
  }
});
function updatePointFromInput() {
  selectedPointsInCurrentHeight.clear();
  const selectedPointInput = document.getElementById('selectedPointIndex');
  if (!selectedPointInput || !selectedPointInput.value) return;
  let inputValue = parseInt(selectedPointInput.value);
  if (inputValue < 1) {
    inputValue = 1;
    selectedPointInput.value = 1;
  } else if (inputValue > elevationData.length) {
    inputValue = elevationData.length;
    selectedPointInput.value = elevationData.length;
  }
  const index = inputValue - 1;
  const fullscreenInput = document.getElementById('fullscreenPointInput');
  if (fullscreenInput) {
    fullscreenInput.value = inputValue;
  }
  showMap(index, getElevationForIndex(index));
  syncFullscreenChartAfterButtonClick(index);
}
function updatePointFromFullscreenInput() {
  selectedPointsInCurrentHeight.clear();
  const fullscreenInput = document.getElementById('fullscreenPointInput');
  if (!fullscreenInput || !fullscreenInput.value) return;
  let inputValue = parseInt(fullscreenInput.value);
  if (inputValue < 1) {
    inputValue = 1;
    fullscreenInput.value = 1;
  } else if (inputValue > elevationData.length) {
    inputValue = elevationData.length;
    fullscreenInput.value = elevationData.length;
  }
  const index = inputValue - 1;
  const selectedPointInput = document.getElementById('selectedPointIndex');
  if (selectedPointInput) {
    selectedPointInput.value = inputValue;
  }
  showMap(index, getElevationForIndex(index));
  syncFullscreenChartAfterButtonClick(index);
}
function incrementSelectedPoint() {
  selectedPointsInCurrentHeight.clear();
  const selectedPointInput = document.getElementById('selectedPointIndex');
  if (!selectedPointInput || !selectedPointInput.value) return;
  let currentIndex = parseInt(selectedPointInput.value) - 1;
  let newIndex = currentIndex + 1;
  if (newIndex >= elevationData.length) {
    newIndex = 0;
  }
  showMap(newIndex, getElevationForIndex(newIndex));
  syncFullscreenChartAfterButtonClick(newIndex);
}
function decrementSelectedPoint() {
  selectedPointsInCurrentHeight.clear();
  const selectedPointInput = document.getElementById('selectedPointIndex');
  if (!selectedPointInput || !selectedPointInput.value) return;
  let currentIndex = parseInt(selectedPointInput.value) - 1;
  let newIndex = currentIndex - 1;
  if (newIndex < 0) {
    newIndex = elevationData.length - 1;
  }
  showMap(newIndex, getElevationForIndex(newIndex));
  syncFullscreenChartAfterButtonClick(newIndex);
}
function jumpToStartPoint() {
  selectedPointsInCurrentHeight.clear();
  if (!elevationData || elevationData.length === 0) {
    alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  showMap(0, getElevationForIndex(0));
  syncFullscreenChartAfterButtonClick(0);
}
function jumpToEndPoint() {
  selectedPointsInCurrentHeight.clear();
  if (!elevationData || elevationData.length === 0) {
    alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  const endIndex = elevationData.length - 1;
  showMap(endIndex, getElevationForIndex(endIndex));
  syncFullscreenChartAfterButtonClick(endIndex);
}
function jumpToMinPoint() {
  selectedPointsInCurrentHeight.clear();
  if (!elevationData || elevationData.length === 0) {
    alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  let minValue = elevationData[0];
  let minIndex = 0;
  for (let i = 1; i < elevationData.length; i++) {
    if (elevationData[i] < minValue) {
      minValue = elevationData[i];
      minIndex = i;
    }
  }
  showMap(minIndex, getElevationForIndex(minIndex));
  syncFullscreenChartAfterButtonClick(minIndex);
}
function jumpToMaxPoint() {
  selectedPointsInCurrentHeight.clear();
  if (!elevationData || elevationData.length === 0) {
    alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  let maxValue = elevationData[0];
  let maxIndex = 0;
  for (let i = 1; i < elevationData.length; i++) {
    if (elevationData[i] > maxValue) {
      maxValue = elevationData[i];
      maxIndex = i;
    }
  }
  showMap(maxIndex, getElevationForIndex(maxIndex));
  syncFullscreenChartAfterButtonClick(maxIndex);
}
function jumpToMaxObstruction() {
  selectedPointsInCurrentHeight.clear();
  if (!elevationData || elevationData.length === 0) {
    alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  if (!chartInstance || !chartInstance.data.datasets[1]) {
    alert('ç„¡æ³•ç²å–è¦–è·é€£ç·šæ•¸æ“š');
    return;
  }
  const losLineData = chartInstance.data.datasets[1].data;
  let maxObstruction = 0;
  let maxObstructionIndex = -1;
  for (let i = 1; i < elevationData.length - 1; i++) {
    const terrainHeight = elevationData[i];
    const losHeight = losLineData[i];
    const clearance = losHeight - terrainHeight;
    if (clearance < 0 && clearance < maxObstruction) {
      maxObstruction = clearance;
      maxObstructionIndex = i;
    }
  }
  if (maxObstructionIndex === -1) {
    const fullscreenOverlay = document.getElementById('chartFullscreenOverlay');
    const isInFullscreen = fullscreenOverlay && fullscreenOverlay.classList.contains('active');
    if (isInFullscreen) {
      const alertBox = document.createElement('div');
      alertBox.style.position = 'fixed';
      alertBox.style.top = '50%';
      alertBox.style.left = '50%';
      alertBox.style.transform = 'translate(-50%, -50%)';
      alertBox.style.backgroundColor = 'rgba(39, 174, 96, 0.95)';
      alertBox.style.color = 'white';
      alertBox.style.padding = '30px 50px';
      alertBox.style.borderRadius = '12px';
      alertBox.style.fontSize = '24px';
      alertBox.style.fontWeight = 'bold';
      alertBox.style.zIndex = '10003';
      alertBox.style.boxShadow = '0 8px 24px rgba(0,0,0,0.5)';
      alertBox.style.border = '3px solid #27ae60';
      alertBox.textContent = 'âœ“ è·¯å¾‘ä¸Šæ²’æœ‰é®è”½é»';
      fullscreenOverlay.appendChild(alertBox);
      setTimeout(() => {
        if (alertBox.parentNode) {
          alertBox.parentNode.removeChild(alertBox);
        }
      }, 3000);
    } else {
      alert('âœ“ è·¯å¾‘ä¸Šæ²’æœ‰é®è”½é»');
    }
    return;
  }
  showMap(maxObstructionIndex, getElevationForIndex(maxObstructionIndex));
  syncFullscreenChartAfterButtonClick(maxObstructionIndex);
}
function jumpToFirstObstructionFromStart() {
  selectedPointsInCurrentHeight.clear();
  if (!elevationData || elevationData.length === 0) {
    alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  if (!chartInstance || !chartInstance.data.datasets[1]) {
    alert('ç„¡æ³•ç²å–è¦–è·é€£ç·šæ•¸æ“š');
    return;
  }
  const losLineData = chartInstance.data.datasets[1].data;
  for (let i = 1; i < elevationData.length - 1; i++) {
    const terrainHeight = elevationData[i];
    const losHeight = losLineData[i];
    const clearance = losHeight - terrainHeight;
    if (clearance < 0) {
      showMap(i, getElevationForIndex(i));
      syncFullscreenChartAfterButtonClick(i);
      return;
    }
  }
  
  // ä½¿ç”¨è‡ªè¨‚å°è©±æ¡†è€Œä¸æ˜¯ alertï¼Œé¿å…é›¢é–‹å…¨å±
  const fullscreenOverlay = document.getElementById('chartFullscreenOverlay');
  const isFullscreen = fullscreenOverlay && fullscreenOverlay.classList.contains('active');
  
  if (isFullscreen) {
    if (fullscreenOverlay) {
      const alertBox = document.createElement('div');
      alertBox.style.position = 'fixed';
      alertBox.style.top = '50%';
      alertBox.style.left = '50%';
      alertBox.style.transform = 'translate(-50%, -50%)';
      alertBox.style.backgroundColor = 'rgba(39, 174, 96, 0.95)';
      alertBox.style.color = 'white';
      alertBox.style.padding = '30px 50px';
      alertBox.style.borderRadius = '12px';
      alertBox.style.fontSize = '24px';
      alertBox.style.fontWeight = 'bold';
      alertBox.style.zIndex = '10003';
      alertBox.style.boxShadow = '0 8px 24px rgba(0,0,0,0.5)';
      alertBox.style.border = '3px solid #27ae60';
      alertBox.textContent = 'âœ“ å¾èµ·é»é–‹å§‹æ²’æœ‰ç™¼ç¾é®è”½é»';
      fullscreenOverlay.appendChild(alertBox);
      setTimeout(() => {
        if (alertBox.parentNode) {
          alertBox.parentNode.removeChild(alertBox);
        }
      }, 3000);
    } else {
      alert('âœ“ å¾èµ·é»é–‹å§‹æ²’æœ‰ç™¼ç¾é®è”½é»');
    }
  } else {
    alert('âœ“ å¾èµ·é»é–‹å§‹æ²’æœ‰ç™¼ç¾é®è”½é»');
  }
}
function jumpToFirstObstructionFromEnd() {
  selectedPointsInCurrentHeight.clear();
  if (!elevationData || elevationData.length === 0) {
    alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  if (!chartInstance || !chartInstance.data.datasets[1]) {
    alert('ç„¡æ³•ç²å–è¦–è·é€£ç·šæ•¸æ“š');
    return;
  }
  const losLineData = chartInstance.data.datasets[1].data;
  for (let i = elevationData.length - 2; i > 0; i--) {
    const terrainHeight = elevationData[i];
    const losHeight = losLineData[i];
    const clearance = losHeight - terrainHeight;
    if (clearance < 0) {
      showMap(i, getElevationForIndex(i));
      syncFullscreenChartAfterButtonClick(i);
      return;
    }
  }
  
  // ä½¿ç”¨è‡ªè¨‚å°è©±æ¡†è€Œä¸æ˜¯ alertï¼Œé¿å…é›¢é–‹å…¨å±
  const fullscreenOverlay = document.getElementById('chartFullscreenOverlay');
  const isFullscreen = fullscreenOverlay && fullscreenOverlay.classList.contains('active');
  
  if (isFullscreen) {
    if (fullscreenOverlay) {
      const alertBox = document.createElement('div');
      alertBox.style.position = 'fixed';
      alertBox.style.top = '50%';
      alertBox.style.left = '50%';
      alertBox.style.transform = 'translate(-50%, -50%)';
      alertBox.style.backgroundColor = 'rgba(39, 174, 96, 0.95)';
      alertBox.style.color = 'white';
      alertBox.style.padding = '30px 50px';
      alertBox.style.borderRadius = '12px';
      alertBox.style.fontSize = '24px';
      alertBox.style.fontWeight = 'bold';
      alertBox.style.zIndex = '10003';
      alertBox.style.boxShadow = '0 8px 24px rgba(0,0,0,0.5)';
      alertBox.style.border = '3px solid #27ae60';
      alertBox.textContent = 'âœ“ å¾çµ‚é»é–‹å§‹æ²’æœ‰ç™¼ç¾é®è”½é»';
      fullscreenOverlay.appendChild(alertBox);
      setTimeout(() => {
        if (alertBox.parentNode) {
          alertBox.parentNode.removeChild(alertBox);
        }
      }, 3000);
    } else {
      alert('âœ“ å¾çµ‚é»é–‹å§‹æ²’æœ‰ç™¼ç¾é®è”½é»');
    }
  } else {
    alert('âœ“ å¾çµ‚é»é–‹å§‹æ²’æœ‰ç™¼ç¾é®è”½é»');
  }
}
let selectedPointsInCurrentHeight = new Set();
let lastButtonPressed = null;
let previousPointIndex = null;

// ğŸ¯ Helper function: ç›´æ¥å¾å‰–é¢åœ–è®€å–é«˜åº¦ï¼ˆå¯¦æ™‚è®€å–ï¼‰
function getElevationForIndex(index) {
  // å„ªå…ˆå¾åœ–è¡¨å¯¦ä¾‹è®€å–ï¼ˆé€™æ˜¯æœ€æº–ç¢ºçš„ï¼Œå› ç‚ºå‰–é¢åœ–é¡¯ç¤ºæ­£ç¢ºï¼‰
  if (chartInstance && chartInstance.data && chartInstance.data.datasets && chartInstance.data.datasets[0]) {
    const terrainDataset = chartInstance.data.datasets[0]; // åœ°å½¢æµ·æ‹”æ•¸æ“šé›†
    if (terrainDataset.data && terrainDataset.data[index] !== undefined && terrainDataset.data[index] !== null) {
      return terrainDataset.data[index];
    }
  }
  
  // å‚™ç”¨æ–¹æ¡ˆ1ï¼šå¾ pathData è®€å–
  if (pathData && pathData[index] && pathData[index].ele !== null && pathData[index].ele !== undefined) {
    return pathData[index].ele;
  }
  
  // å‚™ç”¨æ–¹æ¡ˆ2ï¼šå¾ elevationData è®€å–
  if (elevationData && elevationData[index] !== null && elevationData[index] !== undefined) {
    return elevationData[index];
  }
  
  // æœ€å¾Œå‚™ç”¨
  return 0;
}

function jumpToHigherPoint() {
  if (!elevationData || elevationData.length === 0) {
    alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  const selectedPointInput = document.getElementById('selectedPointIndex');
  if (!selectedPointInput || !selectedPointInput.value) {
    alert('è«‹å…ˆé¸æ“‡ä¸€å€‹é»');
    return;
  }
  previousPointIndex = parseInt(selectedPointInput.value) - 1;
  if (lastButtonPressed === 'minus') {
    selectedPointsInCurrentHeight.clear();
  }
  lastButtonPressed = 'plus';
  const currentIndex = previousPointIndex;
  const currentHeight = elevationData[currentIndex];
  if (!selectedPointsInCurrentHeight.has(currentIndex)) {
    selectedPointsInCurrentHeight.add(currentIndex);
  }
  let sameHeightPoints = [];
  for (let i = 0; i < elevationData.length; i++) {
    if (Math.abs(elevationData[i] - currentHeight) < 0.01) {
      sameHeightPoints.push(i);
    }
  }
  if (sameHeightPoints.length > 0) {
    for (let idx of sameHeightPoints) {
      if (!selectedPointsInCurrentHeight.has(idx) && idx !== currentIndex) {
        selectedPointsInCurrentHeight.add(idx);
        showMap(idx, getElevationForIndex(idx));
        syncFullscreenChartAfterButtonClick(idx);
        return;
      }
    }
  }
  let higherHeights = new Set();
  for (let i = 0; i < elevationData.length; i++) {
    if (elevationData[i] > currentHeight + 0.001) {
      higherHeights.add(Math.round(elevationData[i] * 100) / 100);
    }
  }
  if (higherHeights.size === 0) {
    return;
  }
  let targetHeight = Math.min(...higherHeights);
  selectedPointsInCurrentHeight.clear();
  let nextIndex = -1;
  for (let i = currentIndex + 1; i < elevationData.length; i++) {
    if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
      nextIndex = i;
      break;
    }
  }
  if (nextIndex === -1) {
    for (let i = 0; i < currentIndex; i++) {
      if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
        nextIndex = i;
        break;
      }
    }
  }
  if (nextIndex === -1) {
    return;
  }
  selectedPointsInCurrentHeight.add(nextIndex);
  showMap(nextIndex, getElevationForIndex(nextIndex));
  syncFullscreenChartAfterButtonClick(nextIndex);
}
function jumpToLowerPoint() {
  if (!elevationData || elevationData.length === 0) {
    alert('è«‹å…ˆç”Ÿæˆè·¯å¾‘å‰–é¢');
    return;
  }
  const selectedPointInput = document.getElementById('selectedPointIndex');
  if (!selectedPointInput || !selectedPointInput.value) {
    alert('è«‹å…ˆé¸æ“‡ä¸€å€‹é»');
    return;
  }
  previousPointIndex = parseInt(selectedPointInput.value) - 1;
  if (lastButtonPressed === 'plus') {
    selectedPointsInCurrentHeight.clear();
  }
  lastButtonPressed = 'minus';
  const currentIndex = previousPointIndex;
  const currentHeight = elevationData[currentIndex];
  if (!selectedPointsInCurrentHeight.has(currentIndex)) {
    selectedPointsInCurrentHeight.add(currentIndex);
  }
  let sameHeightPoints = [];
  for (let i = 0; i < elevationData.length; i++) {
    if (Math.abs(elevationData[i] - currentHeight) < 0.01) {
      sameHeightPoints.push(i);
    }
  }
  if (sameHeightPoints.length > 0) {
    for (let i = sameHeightPoints.length - 1; i >= 0; i--) {
      let idx = sameHeightPoints[i];
      if (!selectedPointsInCurrentHeight.has(idx) && idx !== currentIndex) {
        selectedPointsInCurrentHeight.add(idx);
        showMap(idx, getElevationForIndex(idx));
        syncFullscreenChartAfterButtonClick(idx);
        return;
      }
    }
  }
  let lowerHeights = new Set();
  for (let i = 0; i < elevationData.length; i++) {
    if (elevationData[i] < currentHeight - 0.001) {
      lowerHeights.add(Math.round(elevationData[i] * 100) / 100);
    }
  }
  if (lowerHeights.size === 0) {
    return;
  }
  let targetHeight = Math.max(...lowerHeights);
  selectedPointsInCurrentHeight.clear();
  let nextIndex = -1;
  for (let i = currentIndex - 1; i >= 0; i--) {
    if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
      nextIndex = i;
      break;
    }
  }
  if (nextIndex === -1) {
    for (let i = currentIndex + 1; i < elevationData.length; i++) {
      if (Math.abs(elevationData[i] - targetHeight) < 0.01) {
        nextIndex = i;
        break;
      }
    }
  }
  if (nextIndex === -1) {
    return;
  }
  selectedPointsInCurrentHeight.add(nextIndex);
  showMap(nextIndex, getElevationForIndex(nextIndex));
  syncFullscreenChartAfterButtonClick(nextIndex);
}
let elevationData = [];
let isFirstProfileGeneration = true;
</script>
<script>
(function(){
  function enforceGpsIsolation(){
  var gpsTab = document.getElementById('gps-content');
  var isGpsActive = gpsTab && gpsTab.classList.contains('active');
  var ids = ['gpsCalcBtn','gpsResetBtn','gpsClearBtn','gpsRes','gps-controls-container'];
  ids.forEach(function(id){
    var el = document.getElementById(id);
    if(!el) return;
    if(isGpsActive){
    el.style.display = '';
    el.style.visibility = 'visible';
    }else{
    el.style.display = 'none';
    el.style.visibility = 'hidden';
    }
  });
  }
  var _showTab = window.showTab;
  window.showTab = function(tab){
  if(typeof _showTab === 'function'){
    _showTab(tab);
  }else{
    document.querySelectorAll('.tab-content').forEach(function(c){c.classList.remove('active');});
    var t = document.getElementById(tab+'-content');
    if(t) t.classList.add('active');
  }
  enforceGpsIsolation();
  };
  document.addEventListener('DOMContentLoaded', function(){
  var actives = document.querySelectorAll('.tab-content.active');
  if(actives.length>1){
    actives.forEach(function(c,i){ if(i>0) c.classList.remove('active'); });
  }
  enforceGpsIsolation();
  });
})();
</script>
<script>
(function() {
  function fixGpsPadding() {
  const gpsBoxes = document.querySelectorAll('.gps-ig.orange-border-card');
  gpsBoxes.forEach((box, index) => {
    box.style.padding = '10px 12px';
    box.style.paddingTop = '10px';
    box.style.paddingBottom = '10px';
    box.style.paddingLeft = '12px';
    box.style.paddingRight = '12px';
    box.style.setProperty('padding', '10px 12px', 'important');
  });
  const allGpsBoxes = document.querySelectorAll('.gps-ig');
  allGpsBoxes.forEach((box, index) => {
    box.style.setProperty('padding', '10px 12px', 'important');
  });
  }
  if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', fixGpsPadding);
  } else {
  fixGpsPadding();
  }
  setTimeout(fixGpsPadding, 500);
  setTimeout(fixGpsPadding, 1000);
  setTimeout(fixGpsPadding, 2000);
})();
</script>
<script>
(function() {
  function handleCoordinatePaste(event, point) {
  const pastedText = (event.clipboardData || window.clipboardData).getData('text');
  const coordPattern = /^\s*([-+]?\d+\.?\d*)\s*,\s*([-+]?\d+\.?\d*)\s*$/;
  const match = pastedText.trim().match(coordPattern);
  if (match) {
    event.preventDefault();
    const lat = parseFloat(match[1]);
    const lon = parseFloat(match[2]);
    if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
    document.getElementById(`lat${point}`).value = lat;
    document.getElementById(`lon${point}`).value = lon;

    // ğŸ¯ è§¸ç™¼éŸ¿æ‡‰å¼æ•¸æ“šæ›´æ–°ï¼ˆé€™æœƒåŒæ­¥åˆ°é«˜åº¦åœ–åˆ†é ï¼‰
    updateFromInput(point, 'lat');
    updateFromInput(point, 'lng');

    const resultDiv = document.getElementById('gpsRes');
    if (resultDiv) {
      resultDiv.innerHTML = `âœ“ åº§æ¨™å·²è‡ªå‹•å¡«å…¥åœ°é»${point}ï¼šç·¯åº¦ ${lat}Â°, ç¶“åº¦ ${lon}Â°`;
      resultDiv.style.color = '#ffd43b';
      resultDiv.style.background = 'rgba(255, 212, 59, 0.1)';
      resultDiv.style.padding = '12px';
      resultDiv.style.borderRadius = '6px';
      resultDiv.style.marginTop = '8px';
    }
    } else {
    alert('âŒ åº§æ¨™è¶…å‡ºæœ‰æ•ˆç¯„åœ\nç·¯åº¦: -90 ~ 90\nç¶“åº¦: -180 ~ 180');
    }
  }
  }
  function initCoordinatePaste() {
  const latA = document.getElementById('latA');
  const lonA = document.getElementById('lonA');
  const latB = document.getElementById('latB');
  const lonB = document.getElementById('lonB');
  if (latA) {
    latA.addEventListener('paste', (e) => handleCoordinatePaste(e, 'A'));
  }
  if (lonA) {
    lonA.addEventListener('paste', (e) => handleCoordinatePaste(e, 'A'));
  }
  if (latB) {
    latB.addEventListener('paste', (e) => handleCoordinatePaste(e, 'B'));
  }
  if (lonB) {
    lonB.addEventListener('paste', (e) => handleCoordinatePaste(e, 'B'));
  }
  }
  if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initCoordinatePaste);
  } else {
  initCoordinatePaste();
  }
  setTimeout(initCoordinatePaste, 500);
  setTimeout(initCoordinatePaste, 1000);
})();
</script>
<script>
const LS_KEY="html_saved_configs";
function collectFields(){
  const data={};
  document.querySelectorAll("input,select,textarea").forEach(el=>{
  if(el.id && el.id !== 'ls_save_name' && el.id !== 'ls_import' && el.id !== 'sort_order') {
    data[el.id]=el.value;
  }
  });
  return data;
}
function applyFields(data){
  Object.keys(data).forEach(id=>{
  const el=document.getElementById(id);
  if(el && id !== 'timestamp') el.value=data[id];
  });
  
  // ğŸ”„ è®€å–å­˜æª”å¾Œï¼Œè§¸ç™¼éŸ¿æ‡‰å¼ç³»çµ±æ›´æ–°
  // é€™æœƒè‡ªå‹•åŒæ­¥ GPS â†’ é«˜åº¦åœ– â†’ åœ°åœ–
  if (data.latA !== undefined) coordinateData.A.lat = parseFloat(data.latA) || 0;
  if (data.lonA !== undefined) coordinateData.A.lng = parseFloat(data.lonA) || 0;
  if (data.eleA !== undefined) coordinateData.A.ele = parseFloat(data.eleA) || null;
  if (data.nameA !== undefined) coordinateData.A.name = data.nameA || '';
  
  if (data.latB !== undefined) coordinateData.B.lat = parseFloat(data.latB) || 0;
  if (data.lonB !== undefined) coordinateData.B.lng = parseFloat(data.lonB) || 0;
  if (data.eleB !== undefined) coordinateData.B.ele = parseFloat(data.eleB) || null;
  if (data.nameB !== undefined) coordinateData.B.name = data.nameB || '';
  
  window.scrollTo({top:0,behavior:"smooth"});
  alert("âœ“ åƒæ•¸å·²æˆåŠŸå¡«å…¥");
  setTimeout(() => {
  if (typeof importFromGPS === 'function') {
    importFromGPS();
  }
  }, 100);
}
function lsLoadTable(){
  const tb=document.getElementById("ls_table");
  if(!tb) return;
  tb.innerHTML="";
  const all=JSON.parse(localStorage.getItem(LS_KEY)||"{}");
  let entries = Object.entries(all);

  // å–å¾—æœå°‹é—œéµå­—
  const searchInput = document.getElementById("archive_search");
  const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : "";

  // å¦‚æœæœ‰æœå°‹é—œéµå­—ï¼Œé€²è¡Œéæ¿¾
  if(searchTerm) {
  entries = entries.filter(([name]) => name.toLowerCase().includes(searchTerm));
  }

  if(entries.length === 0){
  const noResultMsg = searchTerm ? "æ‰¾ä¸åˆ°ç¬¦åˆçš„å­˜æª”" : "å°šç„¡å·²ä¿å­˜çš„åƒæ•¸";
  tb.innerHTML=`<tr><td colspan='2' style='text-align:center; padding:16px; color:var(--muted);'>${noResultMsg}</td></tr>`;
  return;
  }
  const sortOrder = document.getElementById("sort_order")?.value || "time-new";
  if(sortOrder === "name-az"){
  entries.sort((a, b) => a[0].localeCompare(b[0], 'zh-Hant'));
  } else if(sortOrder === "name-za"){
  entries.sort((a, b) => b[0].localeCompare(a[0], 'zh-Hant'));
  } else if(sortOrder === "time-new"){
  entries.sort((a, b) => {
    const timeA = a[1].timestamp || 0;
    const timeB = b[1].timestamp || 0;
    return timeB - timeA;
  });
  } else if(sortOrder === "time-old"){
  entries.sort((a, b) => {
    const timeA = a[1].timestamp || 0;
    const timeB = b[1].timestamp || 0;
    return timeA - timeB;
  });
  }
  entries.forEach(([name, data])=>{
  const tr=document.createElement("tr");
  const dataStr = JSON.stringify(data).replace(/'/g, "\\'");
  const losStatus = data.losStatus || '--';
  let nameColor;
  if (losStatus === 'NLOS') {
    nameColor = '#e74c3c';
  } else if (losStatus === 'LOS') {
    nameColor = '#5ff0d5';
  } else {
    nameColor = '#ffffff';
  }
  tr.innerHTML=`
    <td style="padding:8px 8px 8px 4px; color:var(--title); font-weight:600; white-space:nowrap;">
    <span style="cursor:pointer; text-decoration:underline; color:${nameColor};" onclick='fillNameWithDate("${name.replace(/'/g, "\\'")}")'>${name}</span>
    </td>
    <td style="padding:4px 6px; text-align:center; white-space:nowrap;">
    <button style="background:none; border:none; padding:4px 6px; font-size:20px; cursor:pointer; color:#5ff0d5; line-height:1;" onclick='applyFields(${dataStr})' title="å¡«å…¥åƒæ•¸">ğŸ“‚</button>
    <button style="background:none; border:none; padding:4px 6px; font-size:20px; cursor:pointer; color:#ff6b6b; margin-left:4px; line-height:1;" onclick='lsDelete("${name}")' title="åˆªé™¤">ğŸ—‘ï¸</button>
    </td>`;
  tb.appendChild(tr);
  });
}
function updateNamePreview() {
  const input = document.getElementById("ls_save_name");
  const suffix = document.getElementById("ls_name_suffix");
  if (!input || !suffix) return;
  const userInput = input.value;
  const today = new Date();
  const rocYear = today.getFullYear() - 1911;
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  const dateStr = `_${rocYear}${month}${day}`;
  if (userInput) {
  suffix.textContent = dateStr;
  } else {
  suffix.textContent = '';
  }
}
function clearArchiveSearch() {
  const searchInput = document.getElementById("archive_search");
  if (searchInput) {
  searchInput.value = "";
  lsLoadTable();
  }
}
function fillNameWithDate(name) {
  let baseName = name;
  let previousName;
  do {
  previousName = baseName;
  baseName = baseName.replace(/_\d{6,7}/g, '');
  baseName = baseName.replace(/_[a-zA-Z]{1,3}\d{6,7}/g, '');
  baseName = baseName.replace(/\d{8}/g, '');
  baseName = baseName.replace(/\d{6,7}$/g, '');
  baseName = baseName.replace(/\s+/g, ' ').trim();
  baseName = baseName.replace(/_+$/g, '');
  } while (baseName !== previousName);
  const nameInput = document.getElementById("ls_save_name");
  if (nameInput) {
  nameInput.value = baseName;
  updateNamePreview();
  nameInput.focus();
  nameInput.setSelectionRange(baseName.length, baseName.length);
  }
}
let currentLosStatus = '--';
function toggleLosStatus() {
  const btn = document.getElementById('los_toggle_btn');
  const nameContainer = document.getElementById('ls_name_container');
  const nameInput = document.getElementById('ls_save_name');
  if (currentLosStatus === '--') {
  currentLosStatus = 'LOS';
  btn.innerHTML = 'LOS';
  btn.style.background = 'linear-gradient(90deg, #3498db, #2980b9)';
  nameContainer.style.borderColor = '#3498db';
  nameInput.style.color = '#5ff0d5';
  } else if (currentLosStatus === 'LOS') {
  currentLosStatus = 'NLOS';
  btn.innerHTML = 'NLOS';
  btn.style.background = 'linear-gradient(90deg, #e74c3c, #c0392b)';
  nameContainer.style.borderColor = '#e74c3c';
  nameInput.style.color = '#e74c3c';
  } else {
  currentLosStatus = '--';
  btn.innerHTML = 'N/A';
  btn.style.background = 'linear-gradient(90deg, #95a5a6, #7f8c8d)';
  nameContainer.style.borderColor = '#ffffff';
  nameInput.style.color = '#ffffff';
  }
}
function loadGpsNamesToArchive() {
  const nameA = document.getElementById('nameA').value.trim();
  const nameB = document.getElementById('nameB').value.trim();
  const inputElement = document.getElementById('ls_save_name');
  if (!nameA && !nameB) {
  alert('âŒ GPSåˆ†é çš„Aé»å’ŒBé»åœ°åéƒ½æ˜¯ç©ºçš„ï¼Œè«‹å…ˆå¡«å¯«åœ°å');
  return;
  }
  if (!nameA || !nameB) {
  alert('âš ï¸ åªæœ‰ä¸€å€‹åœ°åæœ‰å€¼ï¼Œå»ºè­°å¡«å¯«å®Œæ•´çš„Aé»å’ŒBé»åœ°å');
  }
  const combinedName = nameA && nameB ? `${nameA}â†”${nameB}` : (nameA || nameB);
  inputElement.value = combinedName;
  updateNamePreview();
}
function lsSave(){
  const inputElement = document.getElementById("ls_save_name");
  const userInput = inputElement.value.trim();
  if(!userInput){
  alert("âŒ è«‹è¼¸å…¥åç¨±");
  return;
  }
  const today = new Date();
  const rocYear = today.getFullYear() - 1911;
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  const dateStr = `_${rocYear}${month}${day}`;
  const fullName = userInput + dateStr;
  const all=JSON.parse(localStorage.getItem(LS_KEY)||"{}");
  const existingNames = Object.keys(all);
  let hasDuplicateBaseName = false;
  let duplicateFullName = '';
  for (let existingName of existingNames) {
  const baseName = existingName.replace(/_\d{6,7}$/g, '');
  if (baseName === userInput) {
    hasDuplicateBaseName = true;
    duplicateFullName = existingName;
    break;
  }
  }
  if (hasDuplicateBaseName) {
  const confirmMsg = `âš ï¸ å·²å­˜åœ¨ç›¸åŒåç¨±çš„æª”æ¡ˆï¼š\n\nã€Œ${duplicateFullName}ã€\n\næ˜¯å¦è¦è¦†è“‹æ­¤æª”æ¡ˆï¼Ÿ`;
  if (!confirm(confirmMsg)) {
    return;
  }
  delete all[duplicateFullName];
  }
  const saveData = collectFields();
  saveData.timestamp = Date.now();
  saveData.losStatus = currentLosStatus;
  all[fullName]=saveData;
  localStorage.setItem(LS_KEY,JSON.stringify(all));
  inputElement.value = "";
  updateNamePreview();
  currentLosStatus = '--';
  const btn = document.getElementById('los_toggle_btn');
  const nameContainer = document.getElementById('ls_name_container');
  btn.innerHTML = 'N/A';
  btn.style.background = 'linear-gradient(90deg, #95a5a6, #7f8c8d)';
  nameContainer.style.borderColor = '#ffffff';
  inputElement.style.color = '#ffffff';
  lsLoadTable();
  if (hasDuplicateBaseName) {
  alert("âœ“ åƒæ•¸å·²è¦†è“‹ä¿å­˜ï¼š" + fullName);
  } else {
  alert("âœ“ åƒæ•¸å·²ä¿å­˜ï¼š" + fullName);
  }
}
function lsDelete(name){
  if(!confirm("ç¢ºå®šè¦åˆªé™¤ã€Œ" + name + "ã€å—ï¼Ÿ")){
  return;
  }
  const all=JSON.parse(localStorage.getItem(LS_KEY)||"{}");
  delete all[name];
  localStorage.setItem(LS_KEY,JSON.stringify(all));
  lsLoadTable();
  alert("âœ“ å·²åˆªé™¤ï¼š" + name);
}
function lsExport(){
  const data = localStorage.getItem(LS_KEY)||"{}";
  const blob=new Blob([data],{type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  const date = new Date().toISOString().slice(0,10);
  a.download=`RFå·¥å…·ç®±backup_${date}.json`;
  a.click();
  alert("âœ“ JSON æª”æ¡ˆå·²åŒ¯å‡º");
}
function lsImport(e){
  const f=e.target.files[0];
  if(!f) return;
  const r=new FileReader();
  r.onload=()=>{
  try{
    JSON.parse(r.result);
    localStorage.setItem(LS_KEY,r.result);
    lsLoadTable();
    alert("âœ“ JSON æª”æ¡ˆå·²æˆåŠŸè®€å–");
  } catch(err){
    alert("âŒ æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹é¸æ“‡æœ‰æ•ˆçš„JSONæª”æ¡ˆ");
  }
  };
  r.readAsText(f);
  e.target.value = '';
}
document.addEventListener("DOMContentLoaded", () => {
  lsLoadTable();
  updateNamePreview();
});
</script>
<script>
(function(){
  window.__LOS_REFRACTION = false;
  function updateBtn(){
  const btn = document.getElementById('refBtn');
  if(!btn) return;
  btn.textContent = window.__LOS_REFRACTION ? 'ç›®å‰ï¼šå«å¤§æ°£æŠ˜å°„' : 'ç›®å‰ï¼šä¸å«å¤§æ°£æŠ˜å°„';
  btn.style.color = '#bb66ff';
  }
  window.toggleRefraction = function(){
  window.__LOS_REFRACTION = !window.__LOS_REFRACTION;
  updateBtn();
  window.calculateMaxLOS();
  };
  window.calculateMaxLOS = function(){
  const g1 = parseFloat(document.getElementById('los_g1')?.value) || 0;
  const h1 = parseFloat(document.getElementById('los_h1')?.value) || 0;
  const g2 = parseFloat(document.getElementById('los_g2')?.value) || 0;
  const h2 = parseFloat(document.getElementById('los_h2')?.value) || 0;
  let R = 6371000;
  if(window.__LOS_REFRACTION){
    R = R * 4 / 3;
  }
  const d1 = Math.sqrt(2 * R * (g1 + h1));
  const d2 = Math.sqrt(2 * R * (g2 + h2));
  const totalKm = (d1 + d2) / 1000;
  const out = document.getElementById('los_output');
  if(out){
    out.innerHTML =
    'æœ€å¤§é€šè¦–è·é›¢ï¼š<span class="result-value">' + totalKm.toFixed(2) + '</span> km<br>' +
    '(A:' + (d1/1000).toFixed(2) + ' km, B:' + (d2/1000).toFixed(2) + ' km)';
  }
  };
  document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('refBtn');
  if(btn){
    btn.onclick = window.toggleRefraction;
  }
  updateBtn();
  window.calculateMaxLOS();
  });
})();
</script>
<div id="chartFullscreenOverlay" class="chart-fullscreen-overlay">
    <div class="chart-fullscreen-container">
        <button class="chart-fullscreen-close" onclick="closeChartFullscreen()">âœ•</button>
        <button class="chart-fullscreen-screenshot" onclick="generateChartImage()" title="ç”Ÿæˆå‰–é¢åœ–åœ–ç‰‡">ğŸ“·</button>
        <button class="chart-fullscreen-rotate-toggle" onclick="toggleLandscapeFullscreen()" title="å¼·åˆ¶æ©«å±å…¨ç•«é¢">â›¶</button>
        <button class="chart-fullscreen-info-toggle" onclick="toggleFullscreenInfo()" title="é–‹é—œè¨Šæ¯æ¡†èˆ‡é»ƒé»">â„¹ï¸</button>
        <button class="chart-fullscreen-obstruction-toggle" onclick="toggleObstructionColor()" title="åˆ‡æ›é®è”½ç·šé¡è‰²">ğŸš§</button>
        <button class="chart-fullscreen-map-toggle" onclick="openABMapFromFullscreen()" title="é¡¯ç¤ºABé»åœ°åœ–">ğŸ—ºï¸</button>
        <button class="chart-fullscreen-end-obstruction" onclick="jumpToFirstObstructionFromStart()" title="è·³åˆ°è·é›¢èµ·é»æœ€è¿‘çš„é®è”½é»">â®</button>
        <button class="chart-fullscreen-max-obstruction" onclick="jumpToMaxObstruction()" title="è·³åˆ°æœ€å¤§é®è”½é»">â›°ï¸</button>
        <button class="chart-fullscreen-start-obstruction" onclick="jumpToFirstObstructionFromEnd()" title="è·³åˆ°è·é›¢çµ‚é»æœ€è¿‘çš„é®è”½é»">â­</button>
        <div class="chart-fullscreen-point-control">
            <button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:4px 10px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:26px; min-width:40px;" onclick="decrementSelectedPoint()">â—€</button>
            <input type="number" id="fullscreenPointInput" placeholder="é»" style="width:80px; padding:4px 6px; font-size:14px; color:#5ff0d5; background:rgba(0, 0, 0, 0.5); border-radius:4px; border:2px solid rgba(95, 240, 213, 0.3); text-align:center; height:26px; font-weight:bold;" oninput="updatePointFromFullscreenInput()">
            <button class="btn" style="background:linear-gradient(90deg, #79a8ff, #5ff0d5); border:0; padding:4px 10px; border-radius:4px; font-weight:700; font-size:14px; color:#022; cursor:pointer; white-space:nowrap; flex-shrink:0; height:26px; min-width:40px;" onclick="incrementSelectedPoint()">â–¶</button>
        </div>
        <div class="chart-fullscreen-canvas-wrapper">
            <canvas id="elevationChartFullscreen"></canvas>
        </div>
    </div>
</div>
<script>
let useRefraction = false;
function toggleRefraction(){
  useRefraction = !useRefraction;
  const btn = document.getElementById('refBtn');
  btn.innerText = useRefraction ? 'ç›®å‰ï¼šå«å¤§æ°£æŠ˜å°„' : 'ç›®å‰ï¼šä¸å«å¤§æ°£æŠ˜å°„';
  btn.style.color = '#bb66ff';
  calculateMaxLOS();
}
function calculateMaxLOS(){
  const g1 = parseFloat(document.getElementById('los_g1').value) || 0;
  const h1 = parseFloat(document.getElementById('los_h1').value) || 0;
  const g2 = parseFloat(document.getElementById('los_g2').value) || 0;
  const h2 = parseFloat(document.getElementById('los_h2').value) || 0;
  let R = 6371000;
  if(useRefraction){
  R = R * 4 / 3;
  }
  const d1 = Math.sqrt(2 * R * (g1 + h1));
  const d2 = Math.sqrt(2 * R * (g2 + h2));
  const dTotal = (d1 + d2) / 1000;
  document.getElementById('los_output').innerHTML =
  'æœ€å¤§é€šè¦–è·é›¢ï¼š<span class="result-value">' + dTotal.toFixed(2) + '</span> km<br>' +
  '(A:' + (d1/1000).toFixed(2) + ' km, B:' + (d2/1000).toFixed(2) + ' km)';
}
let elevationChart = null;
let elevationDataProvider = 'taiwan-dsm';
function initElevationTab() {
  const apiSelector = document.getElementById('elevationApiSelector');
  const nodataHandlingDiv = document.getElementById('nodataHandlingDiv');
  if (apiSelector) {
  if (apiSelector.value === 'taiwan-dsm' && nodataHandlingDiv) {
    nodataHandlingDiv.style.display = 'block';
  }
  apiSelector.addEventListener('change', (e) => {
    elevationDataProvider = e.target.value;
    if (nodataHandlingDiv) {
    if (e.target.value === 'taiwan-dsm') {
      nodataHandlingDiv.style.display = 'block';
    } else {
      nodataHandlingDiv.style.display = 'none';
    }
    }
  });
  }
}
async function fetchElevationData() {
  const sLat = parseFloat(document.getElementById('sLat')?.value);
  const sLng = parseFloat(document.getElementById('sLng')?.value);
  const eLat = parseFloat(document.getElementById('eLat')?.value);
  const eLng = parseFloat(document.getElementById('eLng')?.value);
  if (!sLat || !sLng || !eLat || !eLng) {
  showElevationStatus('âŒ è«‹å…ˆè¼¸å…¥Aé»å’ŒBé»åº§æ¨™', 'error');
  return;
  }
  showElevationStatus('â³ æ­£åœ¨è¼‰å…¥é«˜åº¦æ•¸æ“š...', 'loading');
  try {
  let elevationData = [];
  if (elevationDataProvider === 'openmeteo') {
    elevationData = await fetchElevationFromOpenMeteo(sLat, sLng, eLat, eLng);
  } else if (elevationDataProvider === 'astergdem') {
    elevationData = await fetchElevationFromAsterGdem(sLat, sLng, eLat, eLng);
  } else if (elevationDataProvider === 'usgs') {
    elevationData = await fetchElevationFromUSGS(sLat, sLng, eLat, eLng);
  }
  if (elevationData.length > 0) {
    drawElevationChart(elevationData);
    showElevationStatus('âœ“ é«˜åº¦æ•¸æ“šè¼‰å…¥æˆåŠŸ', 'success');
  } else {
    showElevationStatus('âŒ ç„¡æ³•ç²å–é«˜åº¦æ•¸æ“š', 'error');
  }
  } catch (error) {
  showElevationStatus('âŒ æ•¸æ“šç²å–å¤±æ•—: ' + error.message, 'error');
  }
}
async function fetchElevationFromOpenMeteo(sLat, sLng, eLat, eLng) {
  try {
  const points = generatePathPoints(sLat, sLng, eLat, eLng, 100);
  const lats = points.map(p => p.lat).join(',');
  const lons = points.map(p => p.lng).join(',');
  const url = `https://open-meteo.com/api/v1/elevation?latitude=${lats}&longitude=${lons}`;
  const response = await fetch(url);
  if (!response.ok) throw new Error('Open-Meteo API è«‹æ±‚å¤±æ•—');
  const data = await response.json();
  return data.elevation.map((elev, idx) => ({
    distance: (idx / (data.elevation.length - 1)) * getDistance(sLat, sLng, eLat, eLng),
    elevation: elev || 0
  }));
  } catch (error) {
  throw error;
  }
}
async function fetchElevationFromAsterGdem(sLat, sLng, eLat, eLng) {
  try {
  const points = generatePathPoints(sLat, sLng, eLat, eLng, 100);
  const elevations = [];
  for (let point of points) {
    try {
    const fallbackUrl = `https://api.open-elevation.com/api/v1/lookup?locations=${point.lat},${point.lng}`;
    const response = await fetch(fallbackUrl);
    if (response.ok) {
      const data = await response.json();
      if (data.results && data.results.length > 0) {
      elevations.push(data.results[0].elevation || 0);
      } else {
      elevations.push(0);
      }
    }
    await new Promise(resolve => setTimeout(resolve, 50));
    } catch (error) {
    elevations.push(0);
    }
  }
  const distance = getDistance(sLat, sLng, eLat, eLng);
  return elevations.map((elev, idx) => ({
    distance: (idx / (elevations.length - 1)) * distance,
    elevation: elev || 0
  }));
  } catch (error) {
  throw error;
  }
}
async function fetchElevationFromUSGS(sLat, sLng, eLat, eLng) {
  try {
  const points = generatePathPoints(sLat, sLng, eLat, eLng, 50);
  const elevations = [];
  for (let point of points) {
    const url = `https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/getSamples?locations=[{"x":${point.lng},"y":${point.lat}}]&outSR=4326&f=json`;
    const response = await fetch(url);
    if (response.ok) {
    const data = await response.json();
    if (data.samples && data.samples.length > 0) {
      elevations.push(data.samples[0].value || 0);
    } else {
      elevations.push(0);
    }
    } else {
    elevations.push(0);
    }
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  return elevations.map((elev, idx) => ({
    distance: (idx / (elevations.length - 1)) * getDistance(sLat, sLng, eLat, eLng),
    elevation: elev
  }));
  } catch (error) {
  throw error;
  }
}
function generatePathPoints(sLat, sLng, eLat, eLng, pointCount) {
  const points = [];
  for (let i = 0; i < pointCount; i++) {
  const fraction = i / (pointCount - 1);
  const lat = sLat + (eLat - sLat) * fraction;
  const lng = sLng + (eLng - sLng) * fraction;
  points.push({ lat, lng });
  }
  return points;
}
function drawElevationChart(data) {
  const ctx = document.getElementById('elevationCanvas');
  if (!ctx) {
  return;
  }
  const labels = data.map(d => Math.round(d.distance).toString());
  const elevations = data.map(d => d.elevation);
  if (elevationChart) {
  elevationChart.destroy();
  }
  elevationChart = new Chart(ctx, {
  type: 'line',
  data: {
    labels: labels,
    datasets: [{
    label: 'é«˜åº¦ (m)',
    data: elevations,
    borderColor: '#059669',
    backgroundColor: 'rgba(5, 150, 105, 0.2)',
    tension: 0.4,
    fill: true,
    borderWidth: 2,
    pointRadius: 3,
    pointBackgroundColor: 'transparent',
    pointBorderColor: 'transparent',
    pointHoverRadius: 6,
    pointHoverBackgroundColor: '#059669',
    pointHoverBorderColor: '#fff',
    pointHoverBorderWidth: 2
    }]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
    legend: {
      labels: { color: '#e8eef5', font: { size: 14 } }
    }
    },
    scales: {
    y: {
      ticks: { color: '#a8b3c3', font: { size: 12 } },
      grid: { color: 'rgba(255,255,255,0.05)' },
      title: { display: true, text: 'æµ·æ‹”é«˜åº¦ (m)', color: '#85c9ff' }
    },
    x: {
      ticks: { color: '#a8b3c3', font: { size: 12 }, maxRotation: 0, minRotation: 0 },
      grid: { color: 'rgba(255,255,255,0.05)' },
      title: { display: true, text: 'è·é›¢ (km)', color: '#85c9ff' }
    }
    }
  }
  });
}
function showElevationStatus(message, type) {
  const statusDiv = document.getElementById('elevationStatus');
  if (statusDiv) {
  statusDiv.textContent = message;
  statusDiv.className = 'elevation-status ' + type;
  }
}
document.addEventListener('DOMContentLoaded', () => {
  initElevationTab();
});

// ===== è—è‰²è¨Šæ¯æ¡†é»æ“Šäº‹ä»¶æ””æˆª =====
(function() {
  'use strict';

  // æ””æˆªtooltipçš„é»æ“Šäº‹ä»¶ï¼Œé˜²æ­¢å…¶å†’æ³¡åˆ°canvasè§¸ç™¼å°é»ƒé»æ›´æ–°
  document.addEventListener('click', function(e) {
  const tooltipEl = document.getElementById('chartjs-tooltip-fullscreen');
  if (!tooltipEl) return;

  // æª¢æŸ¥é»æ“Šæ˜¯å¦åœ¨tooltipå…§
  if (tooltipEl.contains(e.target) || tooltipEl === e.target) {
    e.stopPropagation();
    e.preventDefault();
  }
  }, true);
})();

// ===== æœ¬åœ° TIF æª”æ¡ˆè™•ç† =====
function toggleLocalFileUpload() {
  const apiSelector = document.getElementById('elevationApiSelector');
  const localFileDiv = document.getElementById('localFileUploadDiv');

  if (apiSelector && localFileDiv) {
  if (apiSelector.value === 'taiwan-dsm') {
    localFileDiv.style.display = 'block';
  } else {
    localFileDiv.style.display = 'none';
  }
  }
}

async function handleLocalTifFile(event) {
  const file = event.target.files[0];
  if (!file) return;

  const fileInfo = document.getElementById('localFileInfo');
  const clearBtn = document.getElementById('clearLocalTifBtn');
  const currentSourceText = document.getElementById('currentSourceText');

  fileInfo.textContent = 'ğŸ“‚ è¼‰å…¥ä¸­...';
  fileInfo.style.color = '#fbbf24';

  try {
  // æª¢æŸ¥æª”æ¡ˆé¡å‹
  if (!file.name.match(/\.(tif|tiff)$/i)) {
    throw new Error('è«‹é¸æ“‡ TIF æˆ– TIFF æ ¼å¼çš„æª”æ¡ˆ');
  }

  // è®€å–æª”æ¡ˆ
  const arrayBuffer = await file.arrayBuffer();

  // è¼‰å…¥ GeoTIFF å‡½å¼åº«ï¼ˆå¦‚æœå°šæœªè¼‰å…¥ï¼‰
  if (!window.GeoTIFF) {
    fileInfo.textContent = 'ğŸ“‚ è¼‰å…¥ GeoTIFF å‡½å¼åº«...';
    await loadGeoTIFFLibrary();
  }

  fileInfo.textContent = 'ğŸ“‚ è§£æ TIF æª”æ¡ˆ...';

  // è§£æ TIF æª”æ¡ˆ
  const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
  const image = await tiff.getImage();

  // å„²å­˜æª”æ¡ˆè³‡æ–™
  localTifFileData = {
    file: file,
    tiff: tiff,
    image: image,
    fileName: file.name,
    fileSize: (file.size / 1024 / 1024).toFixed(2) + ' MB'
  };

  // ğŸš€ å„ªåŒ–: åŒæ™‚å¿«å–åˆ°è¨˜æ†¶é«”
  cachedTiffData.local = tiff;
  cachedImageData.local = image;

  // é¡¯ç¤ºæª”æ¡ˆè³‡è¨Š
  fileInfo.textContent = `âœ… å·²è¼‰å…¥: ${file.name} (${localTifFileData.fileSize})`;
  fileInfo.style.color = '#36c74d';
  clearBtn.style.display = 'inline-block';

  // æ›´æ–°ç•¶å‰ä½¿ç”¨ç‹€æ…‹
  if (currentSourceText) {
    currentSourceText.textContent = `âœ… æœ¬æ©Ÿæª”æ¡ˆ: ${file.name}`;
    currentSourceText.style.color = '#5ff0d5';
  }

  } catch (error) {
  fileInfo.textContent = 'âŒ è¼‰å…¥å¤±æ•—: ' + error.message;
  fileInfo.style.color = '#dc3545';
  localTifFileData = null;
  clearBtn.style.display = 'none';

  // æ¢å¾©é¡¯ç¤ºGitHubç‹€æ…‹
  if (currentSourceText) {
    currentSourceText.textContent = 'ğŸŒ GitHub ç·šä¸Šåœ–è³‡';
    currentSourceText.style.color = '#5ff0d5';
  }
  }
}

function clearLocalTifFile() {
  localTifFileData = null;

  // ğŸš€ å„ªåŒ–: æ¸…é™¤æœ¬åœ°æª”æ¡ˆå¿«å–
  clearTiffCache('local');

  document.getElementById('localTifFile').value = '';
  const fileInfo = document.getElementById('localFileInfo');
  fileInfo.textContent = '';
  document.getElementById('clearLocalTifBtn').style.display = 'none';

  // æ›´æ–°ç•¶å‰ä½¿ç”¨ç‹€æ…‹
  const currentSourceText = document.getElementById('currentSourceText');
  if (currentSourceText) {
  currentSourceText.textContent = 'âš ï¸ å°šæœªé¸æ“‡æœ¬æ©Ÿæª”æ¡ˆï¼ˆæœªé€£ç¶²å°‡å¤±æ•—ï¼‰';
  currentSourceText.style.color = '#ffd43b';
  }

}

function useGithubTifFile() {
  // æ¸…é™¤æœ¬åœ°æª”æ¡ˆ
  clearLocalTifFile();

  const fileInfo = document.getElementById('localFileInfo');
  fileInfo.textContent = '';

  // æ›´æ–°ç•¶å‰ä½¿ç”¨ç‹€æ…‹
  const currentSourceText = document.getElementById('currentSourceText');
  if (currentSourceText) {
  currentSourceText.textContent = 'âš ï¸ å°šæœªé¸æ“‡æœ¬æ©Ÿæª”æ¡ˆï¼ˆæœªé€£ç¶²å°‡å¤±æ•—ï¼‰';
  currentSourceText.style.color = '#ffd43b';
  }

}

// åˆå§‹åŒ–æ™‚è¨­å®šé¡¯ç¤ºç‹€æ…‹
document.addEventListener('DOMContentLoaded', () => {
  toggleLocalFileUpload();
});

// å•Ÿç”¨å½ˆçª—æ‹–æ›³åŠŸèƒ½
// â˜… ç­–ç•¥ï¼š
//   æ‹–æ›³ä¸­ï¼šåªå‹• contentWrapper.style.translateï¼ˆç´” CSSï¼Œä¸ç¢° Leafletï¼Œä¸å‘¼å« update()ï¼‰
//   æ”¾é–‹å¾Œï¼šè¨ˆç®—ç§»å‹•é‡åŠ é€²å…¨åŸŸ popupRelOffsetï¼Œä¾›ä¸‹æ¬¡æ–°é»å»ºç«‹ popup æ™‚æ²¿ç”¨
function enablePopupDragging(popupElement) {
  if (!popupElement) return;

  if (popupElement._cleanupDragging) {
    popupElement._cleanupDragging();
  }

  const contentWrapper = popupElement.querySelector('.leaflet-popup-content-wrapper');
  if (!contentWrapper) return;

  contentWrapper.style.cursor = 'grab';
  contentWrapper.style.userSelect = 'none';
  contentWrapper.style.webkitUserSelect = 'none';

  // æœ¬æ¬¡ popup å¯¦ä¾‹çš„è¦–è¦ºåç§»ï¼ˆç´” CSSï¼Œä¸å‘¼å« Leafletï¼‰
  // æ¯æ¬¡ enablePopupDragging è¢«å‘¼å«ä»£è¡¨æ˜¯æ–° popup å…ƒç´ ï¼Œå¾ 0 é–‹å§‹
  popupElement._visualX = 0;
  popupElement._visualY = 0;

  function applyVisual(vx, vy) {
    contentWrapper.style.transform = `translate(${vx}px, ${vy}px)`;
    popupElement._visualX = vx;
    popupElement._visualY = vy;
  }
  applyVisual(0, 0);

  let isDragging = false;
  let startClientX = 0, startClientY = 0;
  let baseX = 0, baseY = 0;

  const onStart = (e) => {
    if (e.target.closest && e.target.closest('.leaflet-popup-close-button')) return;
    if (e.button !== undefined && e.button !== 0) return;

    isDragging = true;
    isDraggingPopup = true;

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    startClientX = clientX;
    startClientY = clientY;
    baseX = popupElement._visualX || 0;
    baseY = popupElement._visualY || 0;

    contentWrapper.style.cursor = 'grabbing';
    routeMapInstance.dragging.disable();

    e.preventDefault();
    e.stopPropagation();
  };

  const onMove = (e) => {
    if (!isDragging) return;

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    // â˜… åªå‹• CSS translateï¼Œä¸å‘¼å«ä»»ä½• Leaflet API
    applyVisual(baseX + (clientX - startClientX),
          baseY + (clientY - startClientY));

    e.preventDefault();
    e.stopPropagation();
  };

  const onEnd = (e) => {
    if (!isDragging) return;
    isDragging = false;
    contentWrapper.style.cursor = 'grab';
    routeMapInstance.dragging.enable();

    // â˜… æ”¾é–‹å¾Œï¼šæŠŠæœ¬æ¬¡ç§»å‹•é‡ç´¯åŠ é€²å…¨åŸŸ popupRelOffset
    //   ç”¨ã€Œæœ¬æ¬¡çµ‚é» - æœ¬æ¬¡èµ·é»ã€ï¼Œé¿å…é‡è¤‡ç–ŠåŠ 
    const movedX = popupElement._visualX - baseX;
    const movedY = popupElement._visualY - baseY;
    popupRelOffset.x += movedX;
    popupRelOffset.y += movedY;

    setTimeout(() => { isDraggingPopup = false; }, 150);
    e.stopPropagation();
  };

  contentWrapper.addEventListener('mousedown', onStart, true);
  document.addEventListener('mousemove', onMove, true);
  document.addEventListener('mouseup',   onEnd,  true);
  contentWrapper.addEventListener('touchstart', onStart, { passive: false, capture: true });
  document.addEventListener('touchmove',  onMove, { passive: false, capture: true });
  document.addEventListener('touchend',   onEnd,  { capture: true });

  popupElement.dataset.draggingEnabled = 'true';

  popupElement._cleanupDragging = () => {
    contentWrapper.removeEventListener('mousedown', onStart, true);
    document.removeEventListener('mousemove', onMove, true);
    document.removeEventListener('mouseup',   onEnd,  true);
    contentWrapper.removeEventListener('touchstart', onStart, true);
    document.removeEventListener('touchmove',  onMove, true);
    document.removeEventListener('touchend',   onEnd,  true);
  };
}
</script>
</body></html>
