<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>DSM å‰–é¢åˆ†æ - é›²ç«¯è¨ºæ–·ç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: sans-serif; max-width: 1100px; margin: auto; padding: 20px; background: #f8f9fa; }
        .card { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .input-group { display: flex; gap: 10px; margin-bottom: 15px; align-items: flex-end; }
        input { flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 4px; }
        button { padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        #log { background: #1e1e1e; color: #00ff00; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 13px; margin-top: 15px; white-space: pre-wrap; height: 200px; overflow-y: auto; }
        .status-badge { display: inline-block; padding: 3px 8px; border-radius: 4px; font-size: 12px; font-weight: bold; margin-bottom: 10px; }
        .online { background: #d4edda; color: #155724; }
    </style>
</head>
<body>

<div class="card">
    <h2>â›°ï¸ DSM å‰–é¢åˆ†æå„€ (é›²ç«¯è¨ºæ–·ç‰ˆ)</h2>
    <div class="status-badge online">ğŸ”— ç›®å‰æ¨¡å¼ï¼šGitHub é›²ç«¯è®€å–</div>
    
    <div class="input-group">
        <div><label>A (Lat, Lon)</label><input type="text" id="posA" value="25.214458, 121.563209"></div>
        <div><label>B (Lat, Lon)</label><input type="text" id="posB" value="24.499911, 121.087641"></div>
        <button onclick="startProcess()">åŸ·è¡Œåˆ†æ</button>
    </div>

    <div id="log">ç­‰å¾…æ“ä½œ...</div>
</div>

<div style="height:450px; margin-top:20px; background:white; padding:15px; border-radius:12px;">
    <canvas id="profileChart"></canvas>
</div>

<script>
async function startProcess() {
    const log = document.getElementById('log');
    const tifName = "taiwan_dsm_wgs84_cog.tif";
    log.innerHTML = `[${new Date().toLocaleTimeString()}] å•Ÿå‹•è¨ºæ–·...\n`;

    // 1. æª¢æŸ¥åŸ·è¡Œç’°å¢ƒ
    if (window.location.protocol === 'file:') {
        log.innerHTML += `âŒ éŒ¯èª¤ï¼šæª¢æ¸¬åˆ° file:// å”å®šã€‚è«‹å‹¿ç›´æ¥é›™æ“Šæ‰“é–‹ HTMLï¼Œè«‹é€é GitHub Pages æˆ–æœ¬åœ°ä¼ºæœå™¨é‹è¡Œã€‚\n`;
        return;
    }

    try {
        log.innerHTML += `ğŸ“¡ æ­£åœ¨å˜—è©¦é€£æ¥ï¼š${tifName}\n`;
        
        // 2. å…ˆé€²è¡Œ Head æ¸¬è©¦ï¼Œæª¢æŸ¥ä¼ºæœå™¨æ˜¯å¦æ”¯æ´ Range Requests
        const headCheck = await fetch(tifName, { method: 'HEAD' });
        if (!headCheck.ok) throw new Error(`æ‰¾ä¸åˆ°æª”æ¡ˆ (HTTP ${headCheck.status})`);
        
        const acceptRanges = headCheck.headers.get('Accept-Ranges');
        log.innerHTML += `âœ… ä¼ºæœå™¨éŸ¿æ‡‰æ­£å¸¸ (HTTP 200)\n`;
        log.innerHTML += `âœ… ç¯„åœè®€å–æ”¯æ´ï¼š${acceptRanges === 'bytes' ? 'æ”¯æ´' : 'ä¸æ”¯æ´ (å¯èƒ½æ˜¯ COG è®€å–ç·©æ…¢çš„åŸå› )'}\n`;

        // 3. é–‹å§‹è®€å– GeoTIFF
        const tiff = await GeoTIFF.fromUrl(tifName);
        const image = await tiff.getImage();
        const bbox = image.getBoundingBox();
        const [w, h] = [image.getWidth(), image.getHeight()];

        log.innerHTML += `ğŸ—ºï¸ å½±åƒè¼‰å…¥æˆåŠŸï¼è§£æåº¦ï¼š${w} x ${h}\n`;
        log.innerHTML += `ğŸ“ é‚Šç•Œï¼šLon(${bbox[0].toFixed(3)}~${bbox[2].toFixed(3)}), Lat(${bbox[1].toFixed(3)}~${bbox[3].toFixed(3)})\n`;

        // 4. è¨ˆç®—å‰–é¢
        const pA = document.getElementById('posA').value.split(',').map(v => parseFloat(v.trim()));
        const pB = document.getElementById('posB').value.split(',').map(v => parseFloat(v.trim()));
        const samples = 300;
        let elevData = [];

        for (let i = 0; i <= samples; i++) {
            const r = i / samples;
            const lat = pA[0] + (pB[0] - pA[0]) * r;
            const lon = pA[1] + (pB[1] - pA[1]) * r;

            const x = Math.max(0, Math.min(w - 1, ((lon - bbox[0]) / (bbox[2] - bbox[0])) * w));
            const y = Math.max(0, Math.min(h - 1, ((bbox[3] - lat) / (bbox[3] - bbox[1])) * h));

            const raster = await image.readRasters({ window: [Math.floor(x), Math.floor(y), Math.floor(x) + 1, Math.floor(y) + 1] });
            elevData.push(raster[0][0] > -1000 ? raster[0][0] : 0);
        }

        renderChart(elevData);
        log.innerHTML += `âœ¨ åˆ†æå®Œæˆã€‚B é»é«˜åº¦ï¼š${elevData[samples].toFixed(1)}m\n`;

    } catch (err) {
        log.innerHTML += `âŒ ç™¼ç”Ÿå•é¡Œï¼š${err.message}\n`;
        log.innerHTML += `ğŸ’¡ å»ºè­°ï¼šè«‹æª¢æŸ¥ GitHub Repo ä¸­æ˜¯å¦æœ‰ "${tifName}"ï¼Œä¸”å¤§å°å¯«å®Œå…¨ä¸€è‡´ã€‚\n`;
    }
}

function renderChart(data) {
    const ctx = document.getElementById('profileChart').getContext('2d');
    if (window.myChart) window.myChart.destroy();
    window.myChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: data.map(() => ""),
            datasets: [{
                label: 'åœ°å½¢é«˜åº¦ (m)',
                data: data,
                borderColor: '#2c3e50',
                backgroundColor: 'rgba(44, 62, 80, 0.2)',
                fill: true,
                pointRadius: 0
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: { y: { beginAtZero: false } }
        }
    });
}
</script>
</body>
</html>